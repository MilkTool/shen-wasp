"Copyright (c) 2010-2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"

(defun shen.<defprolog> (V1970) (let Parse_shen.<predicate*> (shen.<predicate*> V1970) (if (not (= (fail) Parse_shen.<predicate*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<predicate*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (hd (shen.prolog->shen (map (lambda Parse_X (shen.insert-predicate (shen.hdtl Parse_shen.<predicate*>) Parse_X)) (shen.hdtl Parse_shen.<clauses*>))))) (fail))) (fail))))

(defun shen.prolog-error (V1979 V1980) (cond ((and (cons? V1980) (and (cons? (tl V1980)) (= () (tl (tl V1980))))) (simple-error (cn "prolog syntax error in " (shen.app V1979 (cn " here:

 " (shen.app (shen.next-50 50 (hd V1980)) "
" shen.a)) shen.a)))) (true (simple-error (cn "prolog syntax error in " (shen.app V1979 "
" shen.a))))))

(defun shen.next-50 (V1987 V1988) (cond ((= () V1988) "") ((= 0 V1987) "") ((cons? V1988) (cn (shen.decons-string (hd V1988)) (shen.next-50 (- V1987 1) (tl V1988)))) (true (shen.f_error shen.next-50))))

(defun shen.decons-string (V1990) (cond ((and (cons? V1990) (and (= cons (hd V1990)) (and (cons? (tl V1990)) (and (cons? (tl (tl V1990))) (= () (tl (tl (tl V1990)))))))) (shen.app (shen.eval-cons V1990) " " shen.s)) (true (shen.app V1990 " " shen.r))))

(defun shen.insert-predicate (V1993 V1994) (cond ((and (cons? V1994) (and (cons? (tl V1994)) (= () (tl (tl V1994))))) (cons (cons V1993 (hd V1994)) (cons :- (tl V1994)))) (true (shen.f_error shen.insert-predicate))))

(defun shen.<predicate*> (V1996) (if (cons? (hd V1996)) (let Parse_X (shen.hdhd V1996) (shen.pair (hd (shen.pair (shen.tlhd V1996) (shen.hdtl V1996))) Parse_X)) (fail)))

(defun shen.<clauses*> (V1998) (let YaccParse (let Parse_shen.<clause*> (shen.<clause*> V1998) (if (not (= (fail) Parse_shen.<clause*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<clause*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (cons (shen.hdtl Parse_shen.<clause*>) (shen.hdtl Parse_shen.<clauses*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1998) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<clause*> (V2001) (let Parse_shen.<head*> (shen.<head*> V2001) (if (not (= (fail) Parse_shen.<head*>)) (if (and (cons? (hd Parse_shen.<head*>)) (= <-- (shen.hdhd Parse_shen.<head*>))) (let NewStream1999 (shen.pair (shen.tlhd Parse_shen.<head*>) (shen.hdtl Parse_shen.<head*>)) (let Parse_shen.<body*> (shen.<body*> NewStream1999) (if (not (= (fail) Parse_shen.<body*>)) (let Parse_shen.<end*> (shen.<end*> Parse_shen.<body*>) (if (not (= (fail) Parse_shen.<end*>)) (shen.pair (hd Parse_shen.<end*>) (cons (shen.hdtl Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<body*>) ()))) (fail))) (fail)))) (fail)) (fail))))

(defun shen.<head*> (V2003) (let YaccParse (let Parse_shen.<term*> (shen.<term*> V2003) (if (not (= (fail) Parse_shen.<term*>)) (let Parse_shen.<head*> (shen.<head*> Parse_shen.<term*>) (if (not (= (fail) Parse_shen.<head*>)) (shen.pair (hd Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<term*>) (shen.hdtl Parse_shen.<head*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2003) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<term*> (V2005) (if (cons? (hd V2005)) (let Parse_X (shen.hdhd V2005) (if (and (not (= <-- Parse_X)) (shen.legitimate-term? Parse_X)) (shen.pair (hd (shen.pair (shen.tlhd V2005) (shen.hdtl V2005))) (shen.eval-cons Parse_X)) (fail))) (fail)))

(defun shen.legitimate-term? (V2011) (cond ((and (cons? V2011) (and (= cons (hd V2011)) (and (cons? (tl V2011)) (and (cons? (tl (tl V2011))) (= () (tl (tl (tl V2011)))))))) (and (shen.legitimate-term? (hd (tl V2011))) (shen.legitimate-term? (hd (tl (tl V2011)))))) ((and (cons? V2011) (and (= mode (hd V2011)) (and (cons? (tl V2011)) (and (cons? (tl (tl V2011))) (and (= + (hd (tl (tl V2011)))) (= () (tl (tl (tl V2011))))))))) (shen.legitimate-term? (hd (tl V2011)))) ((and (cons? V2011) (and (= mode (hd V2011)) (and (cons? (tl V2011)) (and (cons? (tl (tl V2011))) (and (= - (hd (tl (tl V2011)))) (= () (tl (tl (tl V2011))))))))) (shen.legitimate-term? (hd (tl V2011)))) ((cons? V2011) false) (true true)))

(defun shen.eval-cons (V2013) (cond ((and (cons? V2013) (and (= cons (hd V2013)) (and (cons? (tl V2013)) (and (cons? (tl (tl V2013))) (= () (tl (tl (tl V2013)))))))) (cons (shen.eval-cons (hd (tl V2013))) (shen.eval-cons (hd (tl (tl V2013)))))) ((and (cons? V2013) (and (= mode (hd V2013)) (and (cons? (tl V2013)) (and (cons? (tl (tl V2013))) (= () (tl (tl (tl V2013)))))))) (cons mode (cons (shen.eval-cons (hd (tl V2013))) (tl (tl V2013))))) (true V2013)))

(defun shen.<body*> (V2015) (let YaccParse (let Parse_shen.<literal*> (shen.<literal*> V2015) (if (not (= (fail) Parse_shen.<literal*>)) (let Parse_shen.<body*> (shen.<body*> Parse_shen.<literal*>) (if (not (= (fail) Parse_shen.<body*>)) (shen.pair (hd Parse_shen.<body*>) (cons (shen.hdtl Parse_shen.<literal*>) (shen.hdtl Parse_shen.<body*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2015) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<literal*> (V2018) (let YaccParse (if (and (cons? (hd V2018)) (= ! (shen.hdhd V2018))) (let NewStream2016 (shen.pair (shen.tlhd V2018) (shen.hdtl V2018)) (shen.pair (hd NewStream2016) (cons cut (cons (intern "Throwcontrol") ())))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V2018)) (let Parse_X (shen.hdhd V2018) (if (cons? Parse_X) (shen.pair (hd (shen.pair (shen.tlhd V2018) (shen.hdtl V2018))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<end*> (V2020) (if (cons? (hd V2020)) (let Parse_X (shen.hdhd V2020) (if (= Parse_X ;) (shen.pair (hd (shen.pair (shen.tlhd V2020) (shen.hdtl V2020))) Parse_X) (fail))) (fail)))

(defun cut (V2024 V2025 V2026) (let Result (thaw V2026) (if (= Result false) V2024 Result)))

(defun shen.insert_modes (V2028) (cond ((and (cons? V2028) (and (= mode (hd V2028)) (and (cons? (tl V2028)) (and (cons? (tl (tl V2028))) (= () (tl (tl (tl V2028)))))))) V2028) ((= () V2028) ()) ((cons? V2028) (cons (cons mode (cons (hd V2028) (cons + ()))) (cons mode (cons (shen.insert_modes (tl V2028)) (cons - ()))))) (true V2028)))

(defun shen.s-prolog (V2030) (map (lambda X (eval X)) (shen.prolog->shen V2030)))

(defun shen.prolog->shen (V2032) (map (lambda X (shen.compile_prolog_procedure X)) (shen.group_clauses (map (lambda X (shen.s-prolog_clause X)) (mapcan (lambda X (shen.head_abstraction X)) V2032)))))

(defun shen.s-prolog_clause (V2034) (cond ((and (cons? V2034) (and (cons? (tl V2034)) (and (= :- (hd (tl V2034))) (and (cons? (tl (tl V2034))) (= () (tl (tl (tl V2034)))))))) (cons (hd V2034) (cons :- (cons (map (lambda X (shen.s-prolog_literal X)) (hd (tl (tl V2034)))) ())))) (true (shen.f_error shen.s-prolog_clause))))

(defun shen.head_abstraction (V2036) (cond ((and (cons? V2036) (and (cons? (tl V2036)) (and (= :- (hd (tl V2036))) (and (cons? (tl (tl V2036))) (and (= () (tl (tl (tl V2036)))) (trap-error (< (shen.complexity_head (hd V2036)) (value shen.*maxcomplexity*)) (lambda _ false))))))) (cons V2036 ())) ((and (cons? V2036) (and (cons? (hd V2036)) (and (cons? (tl V2036)) (and (= :- (hd (tl V2036))) (and (cons? (tl (tl V2036))) (= () (tl (tl (tl V2036))))))))) (let Terms (map (lambda Y (gensym V)) (tl (hd V2036))) (let XTerms (shen.rcons_form (shen.remove_modes (tl (hd V2036)))) (let Literal (cons unify (cons (shen.cons_form Terms) (cons XTerms ()))) (let Clause (cons (cons (hd (hd V2036)) Terms) (cons :- (cons (cons Literal (hd (tl (tl V2036)))) ()))) (cons Clause ())))))) (true (shen.f_error shen.head_abstraction))))

(defun shen.complexity_head (V2042) (cond ((cons? V2042) (shen.safe-product (map (lambda X (shen.complexity X)) (tl V2042)))) (true (shen.f_error shen.complexity_head))))

(defun shen.safe-multiply (V2045 V2046) (* V2045 V2046))

(defun shen.complexity (V2055) (cond ((and (cons? V2055) (and (= mode (hd V2055)) (and (cons? (tl V2055)) (and (cons? (hd (tl V2055))) (and (= mode (hd (hd (tl V2055)))) (and (cons? (tl (hd (tl V2055)))) (and (cons? (tl (tl (hd (tl V2055))))) (and (= () (tl (tl (tl (hd (tl V2055)))))) (and (cons? (tl (tl V2055))) (= () (tl (tl (tl V2055))))))))))))) (shen.complexity (hd (tl V2055)))) ((and (cons? V2055) (and (= mode (hd V2055)) (and (cons? (tl V2055)) (and (cons? (hd (tl V2055))) (and (cons? (tl (tl V2055))) (and (= + (hd (tl (tl V2055)))) (= () (tl (tl (tl V2055)))))))))) (shen.safe-multiply 2 (shen.safe-multiply (shen.complexity (cons mode (cons (hd (hd (tl V2055))) (tl (tl V2055))))) (shen.complexity (cons mode (cons (tl (hd (tl V2055))) (tl (tl V2055)))))))) ((and (cons? V2055) (and (= mode (hd V2055)) (and (cons? (tl V2055)) (and (cons? (hd (tl V2055))) (and (cons? (tl (tl V2055))) (and (= - (hd (tl (tl V2055)))) (= () (tl (tl (tl V2055)))))))))) (shen.safe-multiply (shen.complexity (cons mode (cons (hd (hd (tl V2055))) (tl (tl V2055))))) (shen.complexity (cons mode (cons (tl (hd (tl V2055))) (tl (tl V2055))))))) ((and (cons? V2055) (and (= mode (hd V2055)) (and (cons? (tl V2055)) (and (cons? (tl (tl V2055))) (and (= () (tl (tl (tl V2055)))) (variable? (hd (tl V2055)))))))) 1) ((and (cons? V2055) (and (= mode (hd V2055)) (and (cons? (tl V2055)) (and (cons? (tl (tl V2055))) (and (= + (hd (tl (tl V2055)))) (= () (tl (tl (tl V2055))))))))) 2) ((and (cons? V2055) (and (= mode (hd V2055)) (and (cons? (tl V2055)) (and (cons? (tl (tl V2055))) (and (= - (hd (tl (tl V2055)))) (= () (tl (tl (tl V2055))))))))) 1) (true (shen.complexity (cons mode (cons V2055 (cons + ())))))))

(defun shen.safe-product (V2057) (cond ((= () V2057) 1) ((cons? V2057) (shen.safe-multiply (hd V2057) (shen.safe-product (tl V2057)))) (true (shen.f_error shen.safe-product))))

(defun shen.s-prolog_literal (V2059) (cond ((and (cons? V2059) (and (= is (hd V2059)) (and (cons? (tl V2059)) (and (cons? (tl (tl V2059))) (= () (tl (tl (tl V2059)))))))) (cons bind (cons (hd (tl V2059)) (cons (shen.insert-deref (hd (tl (tl V2059))) ProcessN) ())))) ((and (cons? V2059) (and (= when (hd V2059)) (and (cons? (tl V2059)) (= () (tl (tl V2059)))))) (cons fwhen (cons (shen.insert-deref (hd (tl V2059)) ProcessN) ()))) ((and (cons? V2059) (and (= bind (hd V2059)) (and (cons? (tl V2059)) (and (cons? (tl (tl V2059))) (= () (tl (tl (tl V2059)))))))) (cons bind (cons (hd (tl V2059)) (cons (shen.insert-lazyderef (hd (tl (tl V2059))) ProcessN) ())))) ((and (cons? V2059) (and (= fwhen (hd V2059)) (and (cons? (tl V2059)) (= () (tl (tl V2059)))))) (cons fwhen (cons (shen.insert-lazyderef (hd (tl V2059)) ProcessN) ()))) ((cons? V2059) V2059) (true (shen.f_error shen.s-prolog_literal))))

(defun shen.insert-deref (V2066 V2067) (cond ((variable? V2066) (cons shen.deref (cons V2066 (cons V2067 ())))) ((and (cons? V2066) (and (= lambda (hd V2066)) (and (cons? (tl V2066)) (and (cons? (tl (tl V2066))) (= () (tl (tl (tl V2066)))))))) (cons lambda (cons (hd (tl V2066)) (cons (shen.insert-deref (hd (tl (tl V2066))) V2067) ())))) ((and (cons? V2066) (and (= let (hd V2066)) (and (cons? (tl V2066)) (and (cons? (tl (tl V2066))) (and (cons? (tl (tl (tl V2066)))) (= () (tl (tl (tl (tl V2066)))))))))) (cons let (cons (hd (tl V2066)) (cons (shen.insert-deref (hd (tl (tl V2066))) V2067) (cons (shen.insert-deref (hd (tl (tl (tl V2066)))) V2067) ()))))) ((cons? V2066) (cons (shen.insert-deref (hd V2066) V2067) (shen.insert-deref (tl V2066) V2067))) (true V2066)))

(defun shen.insert-lazyderef (V2074 V2075) (cond ((variable? V2074) (cons shen.lazyderef (cons V2074 (cons V2075 ())))) ((and (cons? V2074) (and (= lambda (hd V2074)) (and (cons? (tl V2074)) (and (cons? (tl (tl V2074))) (= () (tl (tl (tl V2074)))))))) (cons lambda (cons (hd (tl V2074)) (cons (shen.insert-lazyderef (hd (tl (tl V2074))) V2075) ())))) ((and (cons? V2074) (and (= let (hd V2074)) (and (cons? (tl V2074)) (and (cons? (tl (tl V2074))) (and (cons? (tl (tl (tl V2074)))) (= () (tl (tl (tl (tl V2074)))))))))) (cons let (cons (hd (tl V2074)) (cons (shen.insert-lazyderef (hd (tl (tl V2074))) V2075) (cons (shen.insert-lazyderef (hd (tl (tl (tl V2074)))) V2075) ()))))) ((cons? V2074) (cons (shen.insert-lazyderef (hd V2074) V2075) (shen.insert-lazyderef (tl V2074) V2075))) (true V2074)))

(defun shen.group_clauses (V2077) (cond ((= () V2077) ()) ((cons? V2077) (let Group (shen.collect (lambda X (shen.same_predicate? (hd V2077) X)) V2077) (let Rest (difference V2077 Group) (cons Group (shen.group_clauses Rest))))) (true (shen.f_error shen.group_clauses))))

(defun shen.collect (V2082 V2083) (cond ((= () V2083) ()) ((cons? V2083) (if (V2082 (hd V2083)) (cons (hd V2083) (shen.collect V2082 (tl V2083))) (shen.collect V2082 (tl V2083)))) (true (shen.f_error shen.collect))))

(defun shen.same_predicate? (V2102 V2103) (cond ((and (cons? V2102) (and (cons? (hd V2102)) (and (cons? V2103) (cons? (hd V2103))))) (= (hd (hd V2102)) (hd (hd V2103)))) (true (shen.f_error shen.same_predicate?))))

(defun shen.compile_prolog_procedure (V2105) (let F (shen.procedure_name V2105) (let Shen (shen.clauses-to-shen F V2105) Shen)))

(defun shen.procedure_name (V2119) (cond ((and (cons? V2119) (and (cons? (hd V2119)) (cons? (hd (hd V2119))))) (hd (hd (hd V2119)))) (true (shen.f_error shen.procedure_name))))

(defun shen.clauses-to-shen (V2122 V2123) (let Linear (map (lambda X (shen.linearise-clause X)) V2123) (let Arity (shen.prolog-aritycheck V2122 (map (lambda X (head X)) V2123)) (let Parameters (shen.parameters Arity) (let AUM_instructions (map (lambda X (shen.aum X Parameters)) Linear) (let Code (shen.catch-cut (shen.nest-disjunct (map (lambda X (shen.aum_to_shen X)) AUM_instructions))) (let ShenDef (cons define (cons V2122 (append Parameters (append (cons ProcessN (cons Continuation ())) (cons -> (cons Code ())))))) ShenDef)))))))

(defun shen.catch-cut (V2125) (cond ((not (shen.occurs? cut V2125)) V2125) (true (cons let (cons Throwcontrol (cons (cons shen.catchpoint ()) (cons (cons shen.cutpoint (cons Throwcontrol (cons V2125 ()))) ())))))))

(defun shen.catchpoint () (set shen.*catch* (+ 1 (value shen.*catch*))))

(defun shen.cutpoint (V2133 V2134) (cond ((= V2134 V2133) false) (true V2134)))

(defun shen.nest-disjunct (V2136) (cond ((and (cons? V2136) (= () (tl V2136))) (hd V2136)) ((cons? V2136) (shen.lisp-or (hd V2136) (shen.nest-disjunct (tl V2136)))) (true (shen.f_error shen.nest-disjunct))))

(defun shen.lisp-or (V2139 V2140) (cons let (cons Case (cons V2139 (cons (cons if (cons (cons = (cons Case (cons false ()))) (cons V2140 (cons Case ())))) ())))))

(defun shen.prolog-aritycheck (V2145 V2146) (cond ((and (cons? V2146) (= () (tl V2146))) (- (length (hd V2146)) 1)) ((and (cons? V2146) (cons? (tl V2146))) (if (= (length (hd V2146)) (length (hd (tl V2146)))) (shen.prolog-aritycheck V2145 (tl V2146)) (simple-error (cn "arity error in prolog procedure " (shen.app (cons V2145 ()) "
" shen.a))))) (true (shen.f_error shen.prolog-aritycheck))))

(defun shen.linearise-clause (V2148) (cond ((and (cons? V2148) (and (cons? (tl V2148)) (and (= :- (hd (tl V2148))) (and (cons? (tl (tl V2148))) (= () (tl (tl (tl V2148)))))))) (let Linear (shen.linearise (cons (hd V2148) (tl (tl V2148)))) (shen.clause_form Linear))) (true (shen.f_error shen.linearise-clause))))

(defun shen.clause_form (V2150) (cond ((and (cons? V2150) (and (cons? (tl V2150)) (= () (tl (tl V2150))))) (cons (shen.explicit_modes (hd V2150)) (cons :- (cons (shen.cf_help (hd (tl V2150))) ())))) (true (shen.f_error shen.clause_form))))

(defun shen.explicit_modes (V2152) (cond ((cons? V2152) (cons (hd V2152) (map (lambda X (shen.em_help X)) (tl V2152)))) (true (shen.f_error shen.explicit_modes))))

(defun shen.em_help (V2154) (cond ((and (cons? V2154) (and (= mode (hd V2154)) (and (cons? (tl V2154)) (and (cons? (tl (tl V2154))) (= () (tl (tl (tl V2154)))))))) V2154) (true (cons mode (cons V2154 (cons + ()))))))

(defun shen.cf_help (V2156) (cond ((and (cons? V2156) (and (= where (hd V2156)) (and (cons? (tl V2156)) (and (cons? (hd (tl V2156))) (and (= = (hd (hd (tl V2156)))) (and (cons? (tl (hd (tl V2156)))) (and (cons? (tl (tl (hd (tl V2156))))) (and (= () (tl (tl (tl (hd (tl V2156)))))) (and (cons? (tl (tl V2156))) (= () (tl (tl (tl V2156))))))))))))) (cons (cons (if (value shen.*occurs*) unify! unify) (tl (hd (tl V2156)))) (shen.cf_help (hd (tl (tl V2156)))))) (true V2156)))

(defun occurs-check (V2162) (cond ((= + V2162) (set shen.*occurs* true)) ((= - V2162) (set shen.*occurs* false)) (true (simple-error "occurs-check expects + or -
"))))

(defun shen.aum (V2165 V2166) (cond ((and (cons? V2165) (and (cons? (hd V2165)) (and (cons? (tl V2165)) (and (= :- (hd (tl V2165))) (and (cons? (tl (tl V2165))) (= () (tl (tl (tl V2165))))))))) (let MuApplication (shen.make_mu_application (cons shen.mu (cons (tl (hd V2165)) (cons (shen.continuation_call (tl (hd V2165)) (hd (tl (tl V2165)))) ()))) V2166) (shen.mu_reduction MuApplication +))) (true (shen.f_error shen.aum))))

(defun shen.continuation_call (V2169 V2170) (let VTerms (cons ProcessN (shen.extract_vars V2169)) (let VBody (shen.extract_vars V2170) (let Free (remove Throwcontrol (difference VBody VTerms)) (shen.cc_help Free V2170)))))

(defun remove (V2173 V2174) (shen.remove-h V2173 V2174 ()))

(defun shen.remove-h (V2181 V2182 V2183) (cond ((= () V2182) (reverse V2183)) ((and (cons? V2182) (= (hd V2182) V2181)) (shen.remove-h (hd V2182) (tl V2182) V2183)) ((cons? V2182) (shen.remove-h V2181 (tl V2182) (cons (hd V2182) V2183))) (true (shen.f_error shen.remove-h))))

(defun shen.cc_help (V2186 V2187) (cond ((and (= () V2186) (= () V2187)) (cons shen.pop (cons shen.the (cons shen.stack ())))) ((= () V2187) (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V2186 (cons and (cons shen.then (cons (cons shen.pop (cons shen.the (cons shen.stack ()))) ()))))))))) ((= () V2186) (cons call (cons shen.the (cons shen.continuation (cons V2187 ()))))) (true (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V2186 (cons and (cons shen.then (cons (cons call (cons shen.the (cons shen.continuation (cons V2187 ())))) ())))))))))))

(defun shen.make_mu_application (V2190 V2191) (cond ((and (cons? V2190) (and (= shen.mu (hd V2190)) (and (cons? (tl V2190)) (and (= () (hd (tl V2190))) (and (cons? (tl (tl V2190))) (and (= () (tl (tl (tl V2190)))) (= () V2191))))))) (hd (tl (tl V2190)))) ((and (cons? V2190) (and (= shen.mu (hd V2190)) (and (cons? (tl V2190)) (and (cons? (hd (tl V2190))) (and (cons? (tl (tl V2190))) (and (= () (tl (tl (tl V2190)))) (cons? V2191))))))) (cons (cons shen.mu (cons (hd (hd (tl V2190))) (cons (shen.make_mu_application (cons shen.mu (cons (tl (hd (tl V2190))) (tl (tl V2190)))) (tl V2191)) ()))) (cons (hd V2191) ()))) (true (shen.f_error shen.make_mu_application))))

(defun shen.mu_reduction (V2200 V2201) (cond ((and (cons? V2200) (and (cons? (hd V2200)) (and (= shen.mu (hd (hd V2200))) (and (cons? (tl (hd V2200))) (and (cons? (hd (tl (hd V2200)))) (and (= mode (hd (hd (tl (hd V2200))))) (and (cons? (tl (hd (tl (hd V2200))))) (and (cons? (tl (tl (hd (tl (hd V2200)))))) (and (= () (tl (tl (tl (hd (tl (hd V2200))))))) (and (cons? (tl (tl (hd V2200)))) (and (= () (tl (tl (tl (hd V2200))))) (and (cons? (tl V2200)) (= () (tl (tl V2200))))))))))))))) (shen.mu_reduction (cons (cons shen.mu (cons (hd (tl (hd (tl (hd V2200))))) (tl (tl (hd V2200))))) (tl V2200)) (hd (tl (tl (hd (tl (hd V2200)))))))) ((and (cons? V2200) (and (cons? (hd V2200)) (and (= shen.mu (hd (hd V2200))) (and (cons? (tl (hd V2200))) (and (cons? (tl (tl (hd V2200)))) (and (= () (tl (tl (tl (hd V2200))))) (and (cons? (tl V2200)) (and (= () (tl (tl V2200))) (= _ (hd (tl (hd V2200)))))))))))) (shen.mu_reduction (hd (tl (tl (hd V2200)))) V2201)) ((and (cons? V2200) (and (cons? (hd V2200)) (and (= shen.mu (hd (hd V2200))) (and (cons? (tl (hd V2200))) (and (cons? (tl (tl (hd V2200)))) (and (= () (tl (tl (tl (hd V2200))))) (and (cons? (tl V2200)) (and (= () (tl (tl V2200))) (shen.ephemeral_variable? (hd (tl (hd V2200))) (hd (tl V2200))))))))))) (subst (hd (tl V2200)) (hd (tl (hd V2200))) (shen.mu_reduction (hd (tl (tl (hd V2200)))) V2201))) ((and (cons? V2200) (and (cons? (hd V2200)) (and (= shen.mu (hd (hd V2200))) (and (cons? (tl (hd V2200))) (and (cons? (tl (tl (hd V2200)))) (and (= () (tl (tl (tl (hd V2200))))) (and (cons? (tl V2200)) (and (= () (tl (tl V2200))) (variable? (hd (tl (hd V2200)))))))))))) (cons let (cons (hd (tl (hd V2200))) (cons shen.be (cons (hd (tl V2200)) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V2200)))) V2201) ()))))))) ((and (cons? V2200) (and (cons? (hd V2200)) (and (= shen.mu (hd (hd V2200))) (and (cons? (tl (hd V2200))) (and (cons? (tl (tl (hd V2200)))) (and (= () (tl (tl (tl (hd V2200))))) (and (cons? (tl V2200)) (and (= () (tl (tl V2200))) (and (= - V2201) (shen.prolog_constant? (hd (tl (hd V2200))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V2200))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V2200))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V2200)))) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V2200) (and (cons? (hd V2200)) (and (= shen.mu (hd (hd V2200))) (and (cons? (tl (hd V2200))) (and (cons? (tl (tl (hd V2200)))) (and (= () (tl (tl (tl (hd V2200))))) (and (cons? (tl V2200)) (and (= () (tl (tl V2200))) (and (= + V2201) (shen.prolog_constant? (hd (tl (hd V2200))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V2200))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V2200))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V2200)))) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (hd (tl (hd V2200))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V2200)))) +) ())))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) ((and (cons? V2200) (and (cons? (hd V2200)) (and (= shen.mu (hd (hd V2200))) (and (cons? (tl (hd V2200))) (and (cons? (hd (tl (hd V2200)))) (and (cons? (tl (tl (hd V2200)))) (and (= () (tl (tl (tl (hd V2200))))) (and (cons? (tl V2200)) (and (= () (tl (tl V2200))) (= - V2201)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V2200))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V2200)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V2200)))) (tl (tl (hd V2200))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V2200) (and (cons? (hd V2200)) (and (= shen.mu (hd (hd V2200))) (and (cons? (tl (hd V2200))) (and (cons? (hd (tl (hd V2200)))) (and (cons? (tl (tl (hd V2200)))) (and (= () (tl (tl (tl (hd V2200))))) (and (cons? (tl V2200)) (and (= () (tl (tl V2200))) (= + V2201)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V2200))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V2200)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V2200)))) (tl (tl (hd V2200))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (shen.extract_vars (hd (tl (hd V2200)))) (cons and (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (shen.rcons_form (shen.remove_modes (hd (tl (hd V2200))))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V2200)))) +) ())))))) ())))))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) (true V2200)))

(defun shen.rcons_form (V2203) (cond ((cons? V2203) (cons cons (cons (shen.rcons_form (hd V2203)) (cons (shen.rcons_form (tl V2203)) ())))) (true V2203)))

(defun shen.remove_modes (V2205) (cond ((and (cons? V2205) (and (= mode (hd V2205)) (and (cons? (tl V2205)) (and (cons? (tl (tl V2205))) (and (= + (hd (tl (tl V2205)))) (= () (tl (tl (tl V2205))))))))) (shen.remove_modes (hd (tl V2205)))) ((and (cons? V2205) (and (= mode (hd V2205)) (and (cons? (tl V2205)) (and (cons? (tl (tl V2205))) (and (= - (hd (tl (tl V2205)))) (= () (tl (tl (tl V2205))))))))) (shen.remove_modes (hd (tl V2205)))) ((cons? V2205) (cons (shen.remove_modes (hd V2205)) (shen.remove_modes (tl V2205)))) (true V2205)))

(defun shen.ephemeral_variable? (V2208 V2209) (and (variable? V2208) (variable? V2209)))

(defun shen.prolog_constant? (V2219) (cond ((cons? V2219) false) (true true)))

(defun shen.aum_to_shen (V2221) (cond ((and (cons? V2221) (and (= let (hd V2221)) (and (cons? (tl V2221)) (and (cons? (tl (tl V2221))) (and (= shen.be (hd (tl (tl V2221)))) (and (cons? (tl (tl (tl V2221)))) (and (cons? (tl (tl (tl (tl V2221))))) (and (= in (hd (tl (tl (tl (tl V2221)))))) (and (cons? (tl (tl (tl (tl (tl V2221)))))) (= () (tl (tl (tl (tl (tl (tl V2221)))))))))))))))) (cons let (cons (hd (tl V2221)) (cons (shen.aum_to_shen (hd (tl (tl (tl V2221))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V2221))))))) ()))))) ((and (cons? V2221) (and (= shen.the (hd V2221)) (and (cons? (tl V2221)) (and (= shen.result (hd (tl V2221))) (and (cons? (tl (tl V2221))) (and (= shen.of (hd (tl (tl V2221)))) (and (cons? (tl (tl (tl V2221)))) (and (= shen.dereferencing (hd (tl (tl (tl V2221))))) (and (cons? (tl (tl (tl (tl V2221))))) (= () (tl (tl (tl (tl (tl V2221))))))))))))))) (cons shen.lazyderef (cons (shen.aum_to_shen (hd (tl (tl (tl (tl V2221)))))) (cons ProcessN ())))) ((and (cons? V2221) (and (= if (hd V2221)) (and (cons? (tl V2221)) (and (cons? (tl (tl V2221))) (and (= shen.then (hd (tl (tl V2221)))) (and (cons? (tl (tl (tl V2221)))) (and (cons? (tl (tl (tl (tl V2221))))) (and (= shen.else (hd (tl (tl (tl (tl V2221)))))) (and (cons? (tl (tl (tl (tl (tl V2221)))))) (= () (tl (tl (tl (tl (tl (tl V2221)))))))))))))))) (cons if (cons (shen.aum_to_shen (hd (tl V2221))) (cons (shen.aum_to_shen (hd (tl (tl (tl V2221))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V2221))))))) ()))))) ((and (cons? V2221) (and (cons? (tl V2221)) (and (= is (hd (tl V2221))) (and (cons? (tl (tl V2221))) (and (= shen.a (hd (tl (tl V2221)))) (and (cons? (tl (tl (tl V2221)))) (and (= shen.variable (hd (tl (tl (tl V2221))))) (= () (tl (tl (tl (tl V2221)))))))))))) (cons shen.pvar? (cons (hd V2221) ()))) ((and (cons? V2221) (and (cons? (tl V2221)) (and (= is (hd (tl V2221))) (and (cons? (tl (tl V2221))) (and (= shen.a (hd (tl (tl V2221)))) (and (cons? (tl (tl (tl V2221)))) (and (= shen.non-empty (hd (tl (tl (tl V2221))))) (and (cons? (tl (tl (tl (tl V2221))))) (and (= list (hd (tl (tl (tl (tl V2221)))))) (= () (tl (tl (tl (tl (tl V2221))))))))))))))) (cons cons? (cons (hd V2221) ()))) ((and (cons? V2221) (and (= shen.rename (hd V2221)) (and (cons? (tl V2221)) (and (= shen.the (hd (tl V2221))) (and (cons? (tl (tl V2221))) (and (= shen.variables (hd (tl (tl V2221)))) (and (cons? (tl (tl (tl V2221)))) (and (= in (hd (tl (tl (tl V2221))))) (and (cons? (tl (tl (tl (tl V2221))))) (and (= () (hd (tl (tl (tl (tl V2221)))))) (and (cons? (tl (tl (tl (tl (tl V2221)))))) (and (= and (hd (tl (tl (tl (tl (tl V2221))))))) (and (cons? (tl (tl (tl (tl (tl (tl V2221))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V2221)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V2221)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V2221)))))))))))))))))))))))) (shen.aum_to_shen (hd (tl (tl (tl (tl (tl (tl (tl V2221)))))))))) ((and (cons? V2221) (and (= shen.rename (hd V2221)) (and (cons? (tl V2221)) (and (= shen.the (hd (tl V2221))) (and (cons? (tl (tl V2221))) (and (= shen.variables (hd (tl (tl V2221)))) (and (cons? (tl (tl (tl V2221)))) (and (= in (hd (tl (tl (tl V2221))))) (and (cons? (tl (tl (tl (tl V2221))))) (and (cons? (hd (tl (tl (tl (tl V2221)))))) (and (cons? (tl (tl (tl (tl (tl V2221)))))) (and (= and (hd (tl (tl (tl (tl (tl V2221))))))) (and (cons? (tl (tl (tl (tl (tl (tl V2221))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V2221)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V2221)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V2221)))))))))))))))))))))))) (cons let (cons (hd (hd (tl (tl (tl (tl V2221)))))) (cons (cons shen.newpv (cons ProcessN ())) (cons (shen.aum_to_shen (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (tl (hd (tl (tl (tl (tl V2221)))))) (tl (tl (tl (tl (tl V2221))))))))))) ()))))) ((and (cons? V2221) (and (= bind (hd V2221)) (and (cons? (tl V2221)) (and (cons? (tl (tl V2221))) (and (= shen.to (hd (tl (tl V2221)))) (and (cons? (tl (tl (tl V2221)))) (and (cons? (tl (tl (tl (tl V2221))))) (and (= in (hd (tl (tl (tl (tl V2221)))))) (and (cons? (tl (tl (tl (tl (tl V2221)))))) (= () (tl (tl (tl (tl (tl (tl V2221)))))))))))))))) (cons do (cons (cons shen.bindv (cons (hd (tl V2221)) (cons (shen.chwild (hd (tl (tl (tl V2221))))) (cons ProcessN ())))) (cons (cons let (cons Result (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V2221))))))) (cons (cons do (cons (cons shen.unbindv (cons (hd (tl V2221)) (cons ProcessN ()))) (cons Result ()))) ())))) ())))) ((and (cons? V2221) (and (cons? (tl V2221)) (and (= is (hd (tl V2221))) (and (cons? (tl (tl V2221))) (and (= identical (hd (tl (tl V2221)))) (and (cons? (tl (tl (tl V2221)))) (and (= shen.to (hd (tl (tl (tl V2221))))) (and (cons? (tl (tl (tl (tl V2221))))) (= () (tl (tl (tl (tl (tl V2221)))))))))))))) (cons = (cons (hd (tl (tl (tl (tl V2221))))) (cons (hd V2221) ())))) ((= shen.failed! V2221) false) ((and (cons? V2221) (and (= shen.the (hd V2221)) (and (cons? (tl V2221)) (and (= head (hd (tl V2221))) (and (cons? (tl (tl V2221))) (and (= shen.of (hd (tl (tl V2221)))) (and (cons? (tl (tl (tl V2221)))) (= () (tl (tl (tl (tl V2221)))))))))))) (cons hd (tl (tl (tl V2221))))) ((and (cons? V2221) (and (= shen.the (hd V2221)) (and (cons? (tl V2221)) (and (= tail (hd (tl V2221))) (and (cons? (tl (tl V2221))) (and (= shen.of (hd (tl (tl V2221)))) (and (cons? (tl (tl (tl V2221)))) (= () (tl (tl (tl (tl V2221)))))))))))) (cons tl (tl (tl (tl V2221))))) ((and (cons? V2221) (and (= shen.pop (hd V2221)) (and (cons? (tl V2221)) (and (= shen.the (hd (tl V2221))) (and (cons? (tl (tl V2221))) (and (= shen.stack (hd (tl (tl V2221)))) (= () (tl (tl (tl V2221)))))))))) (cons do (cons (cons shen.incinfs ()) (cons (cons thaw (cons Continuation ())) ())))) ((and (cons? V2221) (and (= call (hd V2221)) (and (cons? (tl V2221)) (and (= shen.the (hd (tl V2221))) (and (cons? (tl (tl V2221))) (and (= shen.continuation (hd (tl (tl V2221)))) (and (cons? (tl (tl (tl V2221)))) (= () (tl (tl (tl (tl V2221)))))))))))) (cons do (cons (cons shen.incinfs ()) (cons (shen.call_the_continuation (shen.chwild (hd (tl (tl (tl V2221))))) ProcessN Continuation) ())))) (true V2221)))

(defun shen.chwild (V2223) (cond ((= V2223 _) (cons shen.newpv (cons ProcessN ()))) ((cons? V2223) (map (lambda Z (shen.chwild Z)) V2223)) (true V2223)))

(defun shen.newpv (V2225) (let Count+1 (+ (<-address (value shen.*varcounter*) V2225) 1) (let IncVar (address-> (value shen.*varcounter*) V2225 Count+1) (let Vector (<-address (value shen.*prologvectors*) V2225) (let ResizeVectorIfNeeded (if (= Count+1 (limit Vector)) (shen.resizeprocessvector V2225 Count+1) shen.skip) (shen.mk-pvar Count+1))))))

(defun shen.resizeprocessvector (V2228 V2229) (let Vector (<-address (value shen.*prologvectors*) V2228) (let BigVector (shen.resize-vector Vector (+ V2229 V2229) shen.-null-) (address-> (value shen.*prologvectors*) V2228 BigVector))))

(defun shen.resize-vector (V2233 V2234 V2235) (let BigVector (address-> (absvector (+ 1 V2234)) 0 V2234) (shen.copy-vector V2233 BigVector (limit V2233) V2234 V2235)))

(defun shen.copy-vector (V2241 V2242 V2243 V2244 V2245) (shen.copy-vector-stage-2 (+ 1 V2243) (+ V2244 1) V2245 (shen.copy-vector-stage-1 1 V2241 V2242 (+ 1 V2243))))

(defun shen.copy-vector-stage-1 (V2253 V2254 V2255 V2256) (cond ((= V2256 V2253) V2255) (true (shen.copy-vector-stage-1 (+ 1 V2253) V2254 (address-> V2255 V2253 (<-address V2254 V2253)) V2256))))

(defun shen.copy-vector-stage-2 (V2264 V2265 V2266 V2267) (cond ((= V2265 V2264) V2267) (true (shen.copy-vector-stage-2 (+ V2264 1) V2265 V2266 (address-> V2267 V2264 V2266)))))

(defun shen.mk-pvar (V2269) (address-> (address-> (absvector 2) 0 shen.pvar) 1 V2269))

(defun shen.pvar? (V2271) (and (absvector? V2271) (= (trap-error (<-address V2271 0) (lambda E shen.not-pvar)) shen.pvar)))

(defun shen.bindv (V2275 V2276 V2277) (let Vector (<-address (value shen.*prologvectors*) V2277) (address-> Vector (<-address V2275 1) V2276)))

(defun shen.unbindv (V2280 V2281) (let Vector (<-address (value shen.*prologvectors*) V2281) (address-> Vector (<-address V2280 1) shen.-null-)))

(defun shen.incinfs () (set shen.*infs* (+ 1 (value shen.*infs*))))

(defun shen.call_the_continuation (V2285 V2286 V2287) (cond ((and (cons? V2285) (and (cons? (hd V2285)) (= () (tl V2285)))) (cons (hd (hd V2285)) (append (tl (hd V2285)) (cons V2286 (cons V2287 ()))))) ((and (cons? V2285) (cons? (hd V2285))) (let NewContinuation (shen.newcontinuation (tl V2285) V2286 V2287) (cons (hd (hd V2285)) (append (tl (hd V2285)) (cons V2286 (cons NewContinuation ())))))) (true (shen.f_error shen.call_the_continuation))))

(defun shen.newcontinuation (V2291 V2292 V2293) (cond ((= () V2291) V2293) ((and (cons? V2291) (cons? (hd V2291))) (cons freeze (cons (cons (hd (hd V2291)) (append (tl (hd V2291)) (cons V2292 (cons (shen.newcontinuation (tl V2291) V2292 V2293) ())))) ()))) (true (shen.f_error shen.newcontinuation))))

(defun return (V2301 V2302 V2303) (shen.deref V2301 V2302))

(defun shen.measure&return (V2311 V2312 V2313) (do (shen.prhush (shen.app (value shen.*infs*) " inferences
" shen.a) (stoutput)) (shen.deref V2311 V2312)))

(defun unify (V2318 V2319 V2320 V2321) (shen.lzy= (shen.lazyderef V2318 V2320) (shen.lazyderef V2319 V2320) V2320 V2321))

(defun shen.lzy= (V2343 V2344 V2345 V2346) (cond ((= V2344 V2343) (thaw V2346)) ((shen.pvar? V2343) (bind V2343 V2344 V2345 V2346)) ((shen.pvar? V2344) (bind V2344 V2343 V2345 V2346)) ((and (cons? V2343) (cons? V2344)) (shen.lzy= (shen.lazyderef (hd V2343) V2345) (shen.lazyderef (hd V2344) V2345) V2345 (freeze (shen.lzy= (shen.lazyderef (tl V2343) V2345) (shen.lazyderef (tl V2344) V2345) V2345 V2346)))) (true false)))

(defun shen.deref (V2349 V2350) (cond ((cons? V2349) (cons (shen.deref (hd V2349) V2350) (shen.deref (tl V2349) V2350))) (true (if (shen.pvar? V2349) (let Value (shen.valvector V2349 V2350) (if (= Value shen.-null-) V2349 (shen.deref Value V2350))) V2349))))

(defun shen.lazyderef (V2353 V2354) (if (shen.pvar? V2353) (let Value (shen.valvector V2353 V2354) (if (= Value shen.-null-) V2353 (shen.lazyderef Value V2354))) V2353))

(defun shen.valvector (V2357 V2358) (<-address (<-address (value shen.*prologvectors*) V2358) (<-address V2357 1)))

(defun unify! (V2363 V2364 V2365 V2366) (shen.lzy=! (shen.lazyderef V2363 V2365) (shen.lazyderef V2364 V2365) V2365 V2366))

(defun shen.lzy=! (V2388 V2389 V2390 V2391) (cond ((= V2389 V2388) (thaw V2391)) ((and (shen.pvar? V2388) (not (shen.occurs? V2388 (shen.deref V2389 V2390)))) (bind V2388 V2389 V2390 V2391)) ((and (shen.pvar? V2389) (not (shen.occurs? V2389 (shen.deref V2388 V2390)))) (bind V2389 V2388 V2390 V2391)) ((and (cons? V2388) (cons? V2389)) (shen.lzy=! (shen.lazyderef (hd V2388) V2390) (shen.lazyderef (hd V2389) V2390) V2390 (freeze (shen.lzy=! (shen.lazyderef (tl V2388) V2390) (shen.lazyderef (tl V2389) V2390) V2390 V2391)))) (true false)))

(defun shen.occurs? (V2403 V2404) (cond ((= V2404 V2403) true) ((cons? V2404) (or (shen.occurs? V2403 (hd V2404)) (shen.occurs? V2403 (tl V2404)))) (true false)))

(defun identical (V2409 V2410 V2411 V2412) (shen.lzy== (shen.lazyderef V2409 V2411) (shen.lazyderef V2410 V2411) V2411 V2412))

(defun shen.lzy== (V2434 V2435 V2436 V2437) (cond ((= V2435 V2434) (thaw V2437)) ((and (cons? V2434) (cons? V2435)) (shen.lzy== (shen.lazyderef (hd V2434) V2436) (shen.lazyderef (hd V2435) V2436) V2436 (freeze (shen.lzy== (tl V2434) (tl V2435) V2436 V2437)))) (true false)))

(defun shen.pvar (V2439) (cn "Var" (shen.app (<-address V2439 1) "" shen.a)))

(defun bind (V2444 V2445 V2446 V2447) (do (shen.bindv V2444 V2445 V2446) (let Result (thaw V2447) (do (shen.unbindv V2444 V2446) Result))))

(defun fwhen (V2465 V2466 V2467) (cond ((= true V2465) (thaw V2467)) ((= false V2465) false) (true (simple-error (cn "fwhen expects a boolean: not " (shen.app V2465 "%" shen.s))))))

(defun call (V2483 V2484 V2485) (cond ((cons? V2483) (shen.call-help (function (shen.lazyderef (hd V2483) V2484)) (tl V2483) V2484 V2485)) ((shen.pvar? V2483) (call (shen.lazyderef V2483 V2484) V2484 V2485)) (true false)))

(defun shen.call-help (V2490 V2491 V2492 V2493) (cond ((= () V2491) (V2490 V2492 V2493)) ((cons? V2491) (shen.call-help (V2490 (hd V2491)) (tl V2491) V2492 V2493)) (true (shen.f_error shen.call-help))))

(defun shen.intprolog (V2495) (cond ((and (cons? V2495) (cons? (hd V2495))) (let ProcessN (shen.start-new-prolog-process) (shen.intprolog-help (hd (hd V2495)) (shen.insert-prolog-variables (cons (tl (hd V2495)) (cons (tl V2495) ())) ProcessN) ProcessN))) (true (shen.f_error shen.intprolog))))

(defun shen.intprolog-help (V2499 V2500 V2501) (cond ((and (cons? V2500) (and (cons? (tl V2500)) (= () (tl (tl V2500))))) (shen.intprolog-help-help V2499 (hd V2500) (hd (tl V2500)) V2501)) (true (shen.f_error shen.intprolog-help))))

(defun shen.intprolog-help-help (V2506 V2507 V2508 V2509) (cond ((= () V2507) (V2506 V2509 (freeze (shen.call-rest V2508 V2509)))) ((cons? V2507) (shen.intprolog-help-help (V2506 (hd V2507)) (tl V2507) V2508 V2509)) (true (shen.f_error shen.intprolog-help-help))))

(defun shen.call-rest (V2514 V2515) (cond ((= () V2514) true) ((and (cons? V2514) (and (cons? (hd V2514)) (cons? (tl (hd V2514))))) (shen.call-rest (cons (cons ((hd (hd V2514)) (hd (tl (hd V2514)))) (tl (tl (hd V2514)))) (tl V2514)) V2515)) ((and (cons? V2514) (and (cons? (hd V2514)) (= () (tl (hd V2514))))) ((hd (hd V2514)) V2515 (freeze (shen.call-rest (tl V2514) V2515)))) (true (shen.f_error shen.call-rest))))

(defun shen.start-new-prolog-process () (let IncrementProcessCounter (set shen.*process-counter* (+ 1 (value shen.*process-counter*))) (shen.initialise-prolog IncrementProcessCounter)))

(defun shen.insert-prolog-variables (V2518 V2519) (shen.insert-prolog-variables-help V2518 (shen.flatten V2518) V2519))

(defun shen.insert-prolog-variables-help (V2527 V2528 V2529) (cond ((= () V2528) V2527) ((and (cons? V2528) (variable? (hd V2528))) (let V (shen.newpv V2529) (let XV/Y (subst V (hd V2528) V2527) (let Z-Y (remove (hd V2528) (tl V2528)) (shen.insert-prolog-variables-help XV/Y Z-Y V2529))))) ((cons? V2528) (shen.insert-prolog-variables-help V2527 (tl V2528) V2529)) (true (shen.f_error shen.insert-prolog-variables-help))))

(defun shen.initialise-prolog (V2531) (let Vector (address-> (value shen.*prologvectors*) V2531 (shen.fillvector (vector 10) 1 10 shen.-null-)) (let Counter (address-> (value shen.*varcounter*) V2531 1) V2531)))



