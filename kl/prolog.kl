"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.<defprolog> (V1630) (let Parse_shen.<predicate*> (shen.<predicate*> V1630) (if (not (= (fail) Parse_shen.<predicate*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<predicate*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (hd (shen.prolog->shen (map (lambda Parse_X (shen.insert-predicate (shen.hdtl Parse_shen.<predicate*>) Parse_X)) (shen.hdtl Parse_shen.<clauses*>))))) (fail))) (fail))))

(defun shen.prolog-error (V1639 V1640) (cond ((and (cons? V1640) (and (cons? (tl V1640)) (= () (tl (tl V1640))))) (simple-error (cn "prolog syntax error in " (shen.app V1639 (cn " here:

 " (shen.app (shen.next-50 50 (hd V1640)) "
" shen.a)) shen.a)))) (true (simple-error (cn "prolog syntax error in " (shen.app V1639 "
" shen.a))))))

(defun shen.next-50 (V1647 V1648) (cond ((= () V1648) "") ((= 0 V1647) "") ((cons? V1648) (cn (shen.decons-string (hd V1648)) (shen.next-50 (- V1647 1) (tl V1648)))) (true (shen.f_error shen.next-50))))

(defun shen.decons-string (V1650) (cond ((and (cons? V1650) (and (= cons (hd V1650)) (and (cons? (tl V1650)) (and (cons? (tl (tl V1650))) (= () (tl (tl (tl V1650)))))))) (shen.app (shen.eval-cons V1650) " " shen.s)) (true (shen.app V1650 " " shen.r))))

(defun shen.insert-predicate (V1653 V1654) (cond ((and (cons? V1654) (and (cons? (tl V1654)) (= () (tl (tl V1654))))) (cons (cons V1653 (hd V1654)) (cons :- (tl V1654)))) (true (shen.f_error shen.insert-predicate))))

(defun shen.<predicate*> (V1656) (if (cons? (hd V1656)) (let Parse_X (shen.hdhd V1656) (shen.pair (hd (shen.pair (shen.tlhd V1656) (shen.hdtl V1656))) Parse_X)) (fail)))

(defun shen.<clauses*> (V1658) (let YaccParse (let Parse_shen.<clause*> (shen.<clause*> V1658) (if (not (= (fail) Parse_shen.<clause*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<clause*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (cons (shen.hdtl Parse_shen.<clause*>) (shen.hdtl Parse_shen.<clauses*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1658) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<clause*> (V1661) (let Parse_shen.<head*> (shen.<head*> V1661) (if (not (= (fail) Parse_shen.<head*>)) (if (and (cons? (hd Parse_shen.<head*>)) (= <-- (shen.hdhd Parse_shen.<head*>))) (let NewStream1659 (shen.pair (shen.tlhd Parse_shen.<head*>) (shen.hdtl Parse_shen.<head*>)) (let Parse_shen.<body*> (shen.<body*> NewStream1659) (if (not (= (fail) Parse_shen.<body*>)) (let Parse_shen.<end*> (shen.<end*> Parse_shen.<body*>) (if (not (= (fail) Parse_shen.<end*>)) (shen.pair (hd Parse_shen.<end*>) (cons (shen.hdtl Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<body*>) ()))) (fail))) (fail)))) (fail)) (fail))))

(defun shen.<head*> (V1663) (let YaccParse (let Parse_shen.<term*> (shen.<term*> V1663) (if (not (= (fail) Parse_shen.<term*>)) (let Parse_shen.<head*> (shen.<head*> Parse_shen.<term*>) (if (not (= (fail) Parse_shen.<head*>)) (shen.pair (hd Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<term*>) (shen.hdtl Parse_shen.<head*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1663) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<term*> (V1665) (if (cons? (hd V1665)) (let Parse_X (shen.hdhd V1665) (if (and (not (= <-- Parse_X)) (shen.legitimate-term? Parse_X)) (shen.pair (hd (shen.pair (shen.tlhd V1665) (shen.hdtl V1665))) (shen.eval-cons Parse_X)) (fail))) (fail)))

(defun shen.legitimate-term? (V1671) (cond ((and (cons? V1671) (and (= cons (hd V1671)) (and (cons? (tl V1671)) (and (cons? (tl (tl V1671))) (= () (tl (tl (tl V1671)))))))) (and (shen.legitimate-term? (hd (tl V1671))) (shen.legitimate-term? (hd (tl (tl V1671)))))) ((and (cons? V1671) (and (= mode (hd V1671)) (and (cons? (tl V1671)) (and (cons? (tl (tl V1671))) (and (= + (hd (tl (tl V1671)))) (= () (tl (tl (tl V1671))))))))) (shen.legitimate-term? (hd (tl V1671)))) ((and (cons? V1671) (and (= mode (hd V1671)) (and (cons? (tl V1671)) (and (cons? (tl (tl V1671))) (and (= - (hd (tl (tl V1671)))) (= () (tl (tl (tl V1671))))))))) (shen.legitimate-term? (hd (tl V1671)))) ((cons? V1671) false) (true true)))

(defun shen.eval-cons (V1673) (cond ((and (cons? V1673) (and (= cons (hd V1673)) (and (cons? (tl V1673)) (and (cons? (tl (tl V1673))) (= () (tl (tl (tl V1673)))))))) (cons (shen.eval-cons (hd (tl V1673))) (shen.eval-cons (hd (tl (tl V1673)))))) ((and (cons? V1673) (and (= mode (hd V1673)) (and (cons? (tl V1673)) (and (cons? (tl (tl V1673))) (= () (tl (tl (tl V1673)))))))) (cons mode (cons (shen.eval-cons (hd (tl V1673))) (tl (tl V1673))))) (true V1673)))

(defun shen.<body*> (V1675) (let YaccParse (let Parse_shen.<literal*> (shen.<literal*> V1675) (if (not (= (fail) Parse_shen.<literal*>)) (let Parse_shen.<body*> (shen.<body*> Parse_shen.<literal*>) (if (not (= (fail) Parse_shen.<body*>)) (shen.pair (hd Parse_shen.<body*>) (cons (shen.hdtl Parse_shen.<literal*>) (shen.hdtl Parse_shen.<body*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1675) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<literal*> (V1678) (let YaccParse (if (and (cons? (hd V1678)) (= ! (shen.hdhd V1678))) (let NewStream1676 (shen.pair (shen.tlhd V1678) (shen.hdtl V1678)) (shen.pair (hd NewStream1676) (cons cut (cons (intern "Throwcontrol") ())))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V1678)) (let Parse_X (shen.hdhd V1678) (if (cons? Parse_X) (shen.pair (hd (shen.pair (shen.tlhd V1678) (shen.hdtl V1678))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<end*> (V1680) (if (cons? (hd V1680)) (let Parse_X (shen.hdhd V1680) (if (= Parse_X ;) (shen.pair (hd (shen.pair (shen.tlhd V1680) (shen.hdtl V1680))) Parse_X) (fail))) (fail)))

(defun cut (V1684 V1685 V1686) (let Result (thaw V1686) (if (= Result false) V1684 Result)))

(defun shen.insert_modes (V1688) (cond ((and (cons? V1688) (and (= mode (hd V1688)) (and (cons? (tl V1688)) (and (cons? (tl (tl V1688))) (= () (tl (tl (tl V1688)))))))) V1688) ((= () V1688) ()) ((cons? V1688) (cons (cons mode (cons (hd V1688) (cons + ()))) (cons mode (cons (shen.insert_modes (tl V1688)) (cons - ()))))) (true V1688)))

(defun shen.s-prolog (V1690) (map (lambda X (eval X)) (shen.prolog->shen V1690)))

(defun shen.prolog->shen (V1692) (map (lambda X (shen.compile_prolog_procedure X)) (shen.group_clauses (map (lambda X (shen.s-prolog_clause X)) (mapcan (lambda X (shen.head_abstraction X)) V1692)))))

(defun shen.s-prolog_clause (V1694) (cond ((and (cons? V1694) (and (cons? (tl V1694)) (and (= :- (hd (tl V1694))) (and (cons? (tl (tl V1694))) (= () (tl (tl (tl V1694)))))))) (cons (hd V1694) (cons :- (cons (map (lambda X (shen.s-prolog_literal X)) (hd (tl (tl V1694)))) ())))) (true (shen.f_error shen.s-prolog_clause))))

(defun shen.head_abstraction (V1696) (cond ((and (cons? V1696) (and (cons? (tl V1696)) (and (= :- (hd (tl V1696))) (and (cons? (tl (tl V1696))) (and (= () (tl (tl (tl V1696)))) (trap-error (< (shen.complexity_head (hd V1696)) (value shen.*maxcomplexity*)) (lambda _ false))))))) (cons V1696 ())) ((and (cons? V1696) (and (cons? (hd V1696)) (and (cons? (tl V1696)) (and (= :- (hd (tl V1696))) (and (cons? (tl (tl V1696))) (= () (tl (tl (tl V1696))))))))) (let Terms (map (lambda Y (gensym V)) (tl (hd V1696))) (let XTerms (shen.rcons_form (shen.remove_modes (tl (hd V1696)))) (let Literal (cons unify (cons (shen.cons_form Terms) (cons XTerms ()))) (let Clause (cons (cons (hd (hd V1696)) Terms) (cons :- (cons (cons Literal (hd (tl (tl V1696)))) ()))) (cons Clause ())))))) (true (shen.f_error shen.head_abstraction))))

(defun shen.complexity_head (V1702) (cond ((cons? V1702) (shen.safe-product (map (lambda X (shen.complexity X)) (tl V1702)))) (true (shen.f_error shen.complexity_head))))

(defun shen.safe-multiply (V1705 V1706) (* V1705 V1706))

(defun shen.complexity (V1715) (cond ((and (cons? V1715) (and (= mode (hd V1715)) (and (cons? (tl V1715)) (and (cons? (hd (tl V1715))) (and (= mode (hd (hd (tl V1715)))) (and (cons? (tl (hd (tl V1715)))) (and (cons? (tl (tl (hd (tl V1715))))) (and (= () (tl (tl (tl (hd (tl V1715)))))) (and (cons? (tl (tl V1715))) (= () (tl (tl (tl V1715))))))))))))) (shen.complexity (hd (tl V1715)))) ((and (cons? V1715) (and (= mode (hd V1715)) (and (cons? (tl V1715)) (and (cons? (hd (tl V1715))) (and (cons? (tl (tl V1715))) (and (= + (hd (tl (tl V1715)))) (= () (tl (tl (tl V1715)))))))))) (shen.safe-multiply 2 (shen.safe-multiply (shen.complexity (cons mode (cons (hd (hd (tl V1715))) (tl (tl V1715))))) (shen.complexity (cons mode (cons (tl (hd (tl V1715))) (tl (tl V1715)))))))) ((and (cons? V1715) (and (= mode (hd V1715)) (and (cons? (tl V1715)) (and (cons? (hd (tl V1715))) (and (cons? (tl (tl V1715))) (and (= - (hd (tl (tl V1715)))) (= () (tl (tl (tl V1715)))))))))) (shen.safe-multiply (shen.complexity (cons mode (cons (hd (hd (tl V1715))) (tl (tl V1715))))) (shen.complexity (cons mode (cons (tl (hd (tl V1715))) (tl (tl V1715))))))) ((and (cons? V1715) (and (= mode (hd V1715)) (and (cons? (tl V1715)) (and (cons? (tl (tl V1715))) (and (= () (tl (tl (tl V1715)))) (variable? (hd (tl V1715)))))))) 1) ((and (cons? V1715) (and (= mode (hd V1715)) (and (cons? (tl V1715)) (and (cons? (tl (tl V1715))) (and (= + (hd (tl (tl V1715)))) (= () (tl (tl (tl V1715))))))))) 2) ((and (cons? V1715) (and (= mode (hd V1715)) (and (cons? (tl V1715)) (and (cons? (tl (tl V1715))) (and (= - (hd (tl (tl V1715)))) (= () (tl (tl (tl V1715))))))))) 1) (true (shen.complexity (cons mode (cons V1715 (cons + ())))))))

(defun shen.safe-product (V1717) (cond ((= () V1717) 1) ((cons? V1717) (shen.safe-multiply (hd V1717) (shen.safe-product (tl V1717)))) (true (shen.f_error shen.safe-product))))

(defun shen.s-prolog_literal (V1719) (cond ((and (cons? V1719) (and (= is (hd V1719)) (and (cons? (tl V1719)) (and (cons? (tl (tl V1719))) (= () (tl (tl (tl V1719)))))))) (cons bind (cons (hd (tl V1719)) (cons (shen.insert_deref (hd (tl (tl V1719)))) ())))) ((and (cons? V1719) (and (= when (hd V1719)) (and (cons? (tl V1719)) (= () (tl (tl V1719)))))) (cons fwhen (cons (shen.insert_deref (hd (tl V1719))) ()))) ((and (cons? V1719) (and (= bind (hd V1719)) (and (cons? (tl V1719)) (and (cons? (tl (tl V1719))) (= () (tl (tl (tl V1719)))))))) (cons bind (cons (hd (tl V1719)) (cons (shen.insert_lazyderef (hd (tl (tl V1719)))) ())))) ((and (cons? V1719) (and (= fwhen (hd V1719)) (and (cons? (tl V1719)) (= () (tl (tl V1719)))))) (cons fwhen (cons (shen.insert_lazyderef (hd (tl V1719))) ()))) ((cons? V1719) V1719) (true (shen.f_error shen.s-prolog_literal))))

(defun shen.insert_deref (V1721) (cond ((variable? V1721) (cons shen.deref (cons V1721 (cons ProcessN ())))) ((cons? V1721) (cons (shen.insert_deref (hd V1721)) (shen.insert_deref (tl V1721)))) (true V1721)))

(defun shen.insert_lazyderef (V1723) (cond ((variable? V1723) (cons shen.lazyderef (cons V1723 (cons ProcessN ())))) ((cons? V1723) (cons (shen.insert_lazyderef (hd V1723)) (shen.insert_lazyderef (tl V1723)))) (true V1723)))

(defun shen.group_clauses (V1725) (cond ((= () V1725) ()) ((cons? V1725) (let Group (shen.collect (lambda X (shen.same_predicate? (hd V1725) X)) V1725) (let Rest (difference V1725 Group) (cons Group (shen.group_clauses Rest))))) (true (shen.f_error shen.group_clauses))))

(defun shen.collect (V1730 V1731) (cond ((= () V1731) ()) ((cons? V1731) (if (V1730 (hd V1731)) (cons (hd V1731) (shen.collect V1730 (tl V1731))) (shen.collect V1730 (tl V1731)))) (true (shen.f_error shen.collect))))

(defun shen.same_predicate? (V1750 V1751) (cond ((and (cons? V1750) (and (cons? (hd V1750)) (and (cons? V1751) (cons? (hd V1751))))) (= (hd (hd V1750)) (hd (hd V1751)))) (true (shen.f_error shen.same_predicate?))))

(defun shen.compile_prolog_procedure (V1753) (let F (shen.procedure_name V1753) (let Shen (shen.clauses-to-shen F V1753) Shen)))

(defun shen.procedure_name (V1767) (cond ((and (cons? V1767) (and (cons? (hd V1767)) (cons? (hd (hd V1767))))) (hd (hd (hd V1767)))) (true (shen.f_error shen.procedure_name))))

(defun shen.clauses-to-shen (V1770 V1771) (let Linear (map (lambda X (shen.linearise-clause X)) V1771) (let Arity (shen.prolog-aritycheck V1770 (map (lambda X (head X)) V1771)) (let Parameters (shen.parameters Arity) (let AUM_instructions (map (lambda X (shen.aum X Parameters)) Linear) (let Code (shen.catch-cut (shen.nest-disjunct (map (lambda X (shen.aum_to_shen X)) AUM_instructions))) (let ShenDef (cons define (cons V1770 (append Parameters (append (cons ProcessN (cons Continuation ())) (cons -> (cons Code ())))))) ShenDef)))))))

(defun shen.catch-cut (V1773) (cond ((not (shen.occurs? cut V1773)) V1773) (true (cons let (cons Throwcontrol (cons (cons shen.catchpoint ()) (cons (cons shen.cutpoint (cons Throwcontrol (cons V1773 ()))) ())))))))

(defun shen.catchpoint () (set shen.*catch* (+ 1 (value shen.*catch*))))

(defun shen.cutpoint (V1781 V1782) (cond ((= V1782 V1781) false) (true V1782)))

(defun shen.nest-disjunct (V1784) (cond ((and (cons? V1784) (= () (tl V1784))) (hd V1784)) ((cons? V1784) (shen.lisp-or (hd V1784) (shen.nest-disjunct (tl V1784)))) (true (shen.f_error shen.nest-disjunct))))

(defun shen.lisp-or (V1787 V1788) (cons let (cons Case (cons V1787 (cons (cons if (cons (cons = (cons Case (cons false ()))) (cons V1788 (cons Case ())))) ())))))

(defun shen.prolog-aritycheck (V1793 V1794) (cond ((and (cons? V1794) (= () (tl V1794))) (- (length (hd V1794)) 1)) ((and (cons? V1794) (cons? (tl V1794))) (if (= (length (hd V1794)) (length (hd (tl V1794)))) (shen.prolog-aritycheck V1793 (tl V1794)) (simple-error (cn "arity error in prolog procedure " (shen.app (cons V1793 ()) "
" shen.a))))) (true (shen.f_error shen.prolog-aritycheck))))

(defun shen.linearise-clause (V1796) (cond ((and (cons? V1796) (and (cons? (tl V1796)) (and (= :- (hd (tl V1796))) (and (cons? (tl (tl V1796))) (= () (tl (tl (tl V1796)))))))) (let Linear (shen.linearise (cons (hd V1796) (tl (tl V1796)))) (shen.clause_form Linear))) (true (shen.f_error shen.linearise-clause))))

(defun shen.clause_form (V1798) (cond ((and (cons? V1798) (and (cons? (tl V1798)) (= () (tl (tl V1798))))) (cons (shen.explicit_modes (hd V1798)) (cons :- (cons (shen.cf_help (hd (tl V1798))) ())))) (true (shen.f_error shen.clause_form))))

(defun shen.explicit_modes (V1800) (cond ((cons? V1800) (cons (hd V1800) (map (lambda X (shen.em_help X)) (tl V1800)))) (true (shen.f_error shen.explicit_modes))))

(defun shen.em_help (V1802) (cond ((and (cons? V1802) (and (= mode (hd V1802)) (and (cons? (tl V1802)) (and (cons? (tl (tl V1802))) (= () (tl (tl (tl V1802)))))))) V1802) (true (cons mode (cons V1802 (cons + ()))))))

(defun shen.cf_help (V1804) (cond ((and (cons? V1804) (and (= where (hd V1804)) (and (cons? (tl V1804)) (and (cons? (hd (tl V1804))) (and (= = (hd (hd (tl V1804)))) (and (cons? (tl (hd (tl V1804)))) (and (cons? (tl (tl (hd (tl V1804))))) (and (= () (tl (tl (tl (hd (tl V1804)))))) (and (cons? (tl (tl V1804))) (= () (tl (tl (tl V1804))))))))))))) (cons (cons (if (value shen.*occurs*) unify! unify) (tl (hd (tl V1804)))) (shen.cf_help (hd (tl (tl V1804)))))) (true V1804)))

(defun occurs-check (V1810) (cond ((= + V1810) (set shen.*occurs* true)) ((= - V1810) (set shen.*occurs* false)) (true (simple-error "occurs-check expects + or -
"))))

(defun shen.aum (V1813 V1814) (cond ((and (cons? V1813) (and (cons? (hd V1813)) (and (cons? (tl V1813)) (and (= :- (hd (tl V1813))) (and (cons? (tl (tl V1813))) (= () (tl (tl (tl V1813))))))))) (let MuApplication (shen.make_mu_application (cons shen.mu (cons (tl (hd V1813)) (cons (shen.continuation_call (tl (hd V1813)) (hd (tl (tl V1813)))) ()))) V1814) (shen.mu_reduction MuApplication +))) (true (shen.f_error shen.aum))))

(defun shen.continuation_call (V1817 V1818) (let VTerms (cons ProcessN (shen.extract_vars V1817)) (let VBody (shen.extract_vars V1818) (let Free (remove Throwcontrol (difference VBody VTerms)) (shen.cc_help Free V1818)))))

(defun remove (V1821 V1822) (shen.remove-h V1821 V1822 ()))

(defun shen.remove-h (V1829 V1830 V1831) (cond ((= () V1830) (reverse V1831)) ((and (cons? V1830) (= (hd V1830) V1829)) (shen.remove-h (hd V1830) (tl V1830) V1831)) ((cons? V1830) (shen.remove-h V1829 (tl V1830) (cons (hd V1830) V1831))) (true (shen.f_error shen.remove-h))))

(defun shen.cc_help (V1834 V1835) (cond ((and (= () V1834) (= () V1835)) (cons shen.pop (cons shen.the (cons shen.stack ())))) ((= () V1835) (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V1834 (cons and (cons shen.then (cons (cons shen.pop (cons shen.the (cons shen.stack ()))) ()))))))))) ((= () V1834) (cons call (cons shen.the (cons shen.continuation (cons V1835 ()))))) (true (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V1834 (cons and (cons shen.then (cons (cons call (cons shen.the (cons shen.continuation (cons V1835 ())))) ())))))))))))

(defun shen.make_mu_application (V1838 V1839) (cond ((and (cons? V1838) (and (= shen.mu (hd V1838)) (and (cons? (tl V1838)) (and (= () (hd (tl V1838))) (and (cons? (tl (tl V1838))) (and (= () (tl (tl (tl V1838)))) (= () V1839))))))) (hd (tl (tl V1838)))) ((and (cons? V1838) (and (= shen.mu (hd V1838)) (and (cons? (tl V1838)) (and (cons? (hd (tl V1838))) (and (cons? (tl (tl V1838))) (and (= () (tl (tl (tl V1838)))) (cons? V1839))))))) (cons (cons shen.mu (cons (hd (hd (tl V1838))) (cons (shen.make_mu_application (cons shen.mu (cons (tl (hd (tl V1838))) (tl (tl V1838)))) (tl V1839)) ()))) (cons (hd V1839) ()))) (true (shen.f_error shen.make_mu_application))))

(defun shen.mu_reduction (V1848 V1849) (cond ((and (cons? V1848) (and (cons? (hd V1848)) (and (= shen.mu (hd (hd V1848))) (and (cons? (tl (hd V1848))) (and (cons? (hd (tl (hd V1848)))) (and (= mode (hd (hd (tl (hd V1848))))) (and (cons? (tl (hd (tl (hd V1848))))) (and (cons? (tl (tl (hd (tl (hd V1848)))))) (and (= () (tl (tl (tl (hd (tl (hd V1848))))))) (and (cons? (tl (tl (hd V1848)))) (and (= () (tl (tl (tl (hd V1848))))) (and (cons? (tl V1848)) (= () (tl (tl V1848))))))))))))))) (shen.mu_reduction (cons (cons shen.mu (cons (hd (tl (hd (tl (hd V1848))))) (tl (tl (hd V1848))))) (tl V1848)) (hd (tl (tl (hd (tl (hd V1848)))))))) ((and (cons? V1848) (and (cons? (hd V1848)) (and (= shen.mu (hd (hd V1848))) (and (cons? (tl (hd V1848))) (and (cons? (tl (tl (hd V1848)))) (and (= () (tl (tl (tl (hd V1848))))) (and (cons? (tl V1848)) (and (= () (tl (tl V1848))) (= _ (hd (tl (hd V1848)))))))))))) (shen.mu_reduction (hd (tl (tl (hd V1848)))) V1849)) ((and (cons? V1848) (and (cons? (hd V1848)) (and (= shen.mu (hd (hd V1848))) (and (cons? (tl (hd V1848))) (and (cons? (tl (tl (hd V1848)))) (and (= () (tl (tl (tl (hd V1848))))) (and (cons? (tl V1848)) (and (= () (tl (tl V1848))) (shen.ephemeral_variable? (hd (tl (hd V1848))) (hd (tl V1848))))))))))) (subst (hd (tl V1848)) (hd (tl (hd V1848))) (shen.mu_reduction (hd (tl (tl (hd V1848)))) V1849))) ((and (cons? V1848) (and (cons? (hd V1848)) (and (= shen.mu (hd (hd V1848))) (and (cons? (tl (hd V1848))) (and (cons? (tl (tl (hd V1848)))) (and (= () (tl (tl (tl (hd V1848))))) (and (cons? (tl V1848)) (and (= () (tl (tl V1848))) (variable? (hd (tl (hd V1848)))))))))))) (cons let (cons (hd (tl (hd V1848))) (cons shen.be (cons (hd (tl V1848)) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1848)))) V1849) ()))))))) ((and (cons? V1848) (and (cons? (hd V1848)) (and (= shen.mu (hd (hd V1848))) (and (cons? (tl (hd V1848))) (and (cons? (tl (tl (hd V1848)))) (and (= () (tl (tl (tl (hd V1848))))) (and (cons? (tl V1848)) (and (= () (tl (tl V1848))) (and (= - V1849) (shen.prolog_constant? (hd (tl (hd V1848))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1848))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V1848))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V1848)))) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V1848) (and (cons? (hd V1848)) (and (= shen.mu (hd (hd V1848))) (and (cons? (tl (hd V1848))) (and (cons? (tl (tl (hd V1848)))) (and (= () (tl (tl (tl (hd V1848))))) (and (cons? (tl V1848)) (and (= () (tl (tl V1848))) (and (= + V1849) (shen.prolog_constant? (hd (tl (hd V1848))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1848))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V1848))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V1848)))) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (hd (tl (hd V1848))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1848)))) +) ())))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) ((and (cons? V1848) (and (cons? (hd V1848)) (and (= shen.mu (hd (hd V1848))) (and (cons? (tl (hd V1848))) (and (cons? (hd (tl (hd V1848)))) (and (cons? (tl (tl (hd V1848)))) (and (= () (tl (tl (tl (hd V1848))))) (and (cons? (tl V1848)) (and (= () (tl (tl V1848))) (= - V1849)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1848))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V1848)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V1848)))) (tl (tl (hd V1848))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V1848) (and (cons? (hd V1848)) (and (= shen.mu (hd (hd V1848))) (and (cons? (tl (hd V1848))) (and (cons? (hd (tl (hd V1848)))) (and (cons? (tl (tl (hd V1848)))) (and (= () (tl (tl (tl (hd V1848))))) (and (cons? (tl V1848)) (and (= () (tl (tl V1848))) (= + V1849)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1848))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V1848)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V1848)))) (tl (tl (hd V1848))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (shen.extract_vars (hd (tl (hd V1848)))) (cons and (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (shen.rcons_form (shen.remove_modes (hd (tl (hd V1848))))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1848)))) +) ())))))) ())))))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) (true V1848)))

(defun shen.rcons_form (V1851) (cond ((cons? V1851) (cons cons (cons (shen.rcons_form (hd V1851)) (cons (shen.rcons_form (tl V1851)) ())))) (true V1851)))

(defun shen.remove_modes (V1853) (cond ((and (cons? V1853) (and (= mode (hd V1853)) (and (cons? (tl V1853)) (and (cons? (tl (tl V1853))) (and (= + (hd (tl (tl V1853)))) (= () (tl (tl (tl V1853))))))))) (shen.remove_modes (hd (tl V1853)))) ((and (cons? V1853) (and (= mode (hd V1853)) (and (cons? (tl V1853)) (and (cons? (tl (tl V1853))) (and (= - (hd (tl (tl V1853)))) (= () (tl (tl (tl V1853))))))))) (shen.remove_modes (hd (tl V1853)))) ((cons? V1853) (cons (shen.remove_modes (hd V1853)) (shen.remove_modes (tl V1853)))) (true V1853)))

(defun shen.ephemeral_variable? (V1856 V1857) (and (variable? V1856) (variable? V1857)))

(defun shen.prolog_constant? (V1867) (cond ((cons? V1867) false) (true true)))

(defun shen.aum_to_shen (V1869) (cond ((and (cons? V1869) (and (= let (hd V1869)) (and (cons? (tl V1869)) (and (cons? (tl (tl V1869))) (and (= shen.be (hd (tl (tl V1869)))) (and (cons? (tl (tl (tl V1869)))) (and (cons? (tl (tl (tl (tl V1869))))) (and (= in (hd (tl (tl (tl (tl V1869)))))) (and (cons? (tl (tl (tl (tl (tl V1869)))))) (= () (tl (tl (tl (tl (tl (tl V1869)))))))))))))))) (cons let (cons (hd (tl V1869)) (cons (shen.aum_to_shen (hd (tl (tl (tl V1869))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1869))))))) ()))))) ((and (cons? V1869) (and (= shen.the (hd V1869)) (and (cons? (tl V1869)) (and (= shen.result (hd (tl V1869))) (and (cons? (tl (tl V1869))) (and (= shen.of (hd (tl (tl V1869)))) (and (cons? (tl (tl (tl V1869)))) (and (= shen.dereferencing (hd (tl (tl (tl V1869))))) (and (cons? (tl (tl (tl (tl V1869))))) (= () (tl (tl (tl (tl (tl V1869))))))))))))))) (cons shen.lazyderef (cons (shen.aum_to_shen (hd (tl (tl (tl (tl V1869)))))) (cons ProcessN ())))) ((and (cons? V1869) (and (= if (hd V1869)) (and (cons? (tl V1869)) (and (cons? (tl (tl V1869))) (and (= shen.then (hd (tl (tl V1869)))) (and (cons? (tl (tl (tl V1869)))) (and (cons? (tl (tl (tl (tl V1869))))) (and (= shen.else (hd (tl (tl (tl (tl V1869)))))) (and (cons? (tl (tl (tl (tl (tl V1869)))))) (= () (tl (tl (tl (tl (tl (tl V1869)))))))))))))))) (cons if (cons (shen.aum_to_shen (hd (tl V1869))) (cons (shen.aum_to_shen (hd (tl (tl (tl V1869))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1869))))))) ()))))) ((and (cons? V1869) (and (cons? (tl V1869)) (and (= is (hd (tl V1869))) (and (cons? (tl (tl V1869))) (and (= shen.a (hd (tl (tl V1869)))) (and (cons? (tl (tl (tl V1869)))) (and (= shen.variable (hd (tl (tl (tl V1869))))) (= () (tl (tl (tl (tl V1869)))))))))))) (cons shen.pvar? (cons (hd V1869) ()))) ((and (cons? V1869) (and (cons? (tl V1869)) (and (= is (hd (tl V1869))) (and (cons? (tl (tl V1869))) (and (= shen.a (hd (tl (tl V1869)))) (and (cons? (tl (tl (tl V1869)))) (and (= shen.non-empty (hd (tl (tl (tl V1869))))) (and (cons? (tl (tl (tl (tl V1869))))) (and (= list (hd (tl (tl (tl (tl V1869)))))) (= () (tl (tl (tl (tl (tl V1869))))))))))))))) (cons cons? (cons (hd V1869) ()))) ((and (cons? V1869) (and (= shen.rename (hd V1869)) (and (cons? (tl V1869)) (and (= shen.the (hd (tl V1869))) (and (cons? (tl (tl V1869))) (and (= shen.variables (hd (tl (tl V1869)))) (and (cons? (tl (tl (tl V1869)))) (and (= in (hd (tl (tl (tl V1869))))) (and (cons? (tl (tl (tl (tl V1869))))) (and (= () (hd (tl (tl (tl (tl V1869)))))) (and (cons? (tl (tl (tl (tl (tl V1869)))))) (and (= and (hd (tl (tl (tl (tl (tl V1869))))))) (and (cons? (tl (tl (tl (tl (tl (tl V1869))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V1869)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V1869)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V1869)))))))))))))))))))))))) (shen.aum_to_shen (hd (tl (tl (tl (tl (tl (tl (tl V1869)))))))))) ((and (cons? V1869) (and (= shen.rename (hd V1869)) (and (cons? (tl V1869)) (and (= shen.the (hd (tl V1869))) (and (cons? (tl (tl V1869))) (and (= shen.variables (hd (tl (tl V1869)))) (and (cons? (tl (tl (tl V1869)))) (and (= in (hd (tl (tl (tl V1869))))) (and (cons? (tl (tl (tl (tl V1869))))) (and (cons? (hd (tl (tl (tl (tl V1869)))))) (and (cons? (tl (tl (tl (tl (tl V1869)))))) (and (= and (hd (tl (tl (tl (tl (tl V1869))))))) (and (cons? (tl (tl (tl (tl (tl (tl V1869))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V1869)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V1869)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V1869)))))))))))))))))))))))) (cons let (cons (hd (hd (tl (tl (tl (tl V1869)))))) (cons (cons shen.newpv (cons ProcessN ())) (cons (shen.aum_to_shen (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (tl (hd (tl (tl (tl (tl V1869)))))) (tl (tl (tl (tl (tl V1869))))))))))) ()))))) ((and (cons? V1869) (and (= bind (hd V1869)) (and (cons? (tl V1869)) (and (cons? (tl (tl V1869))) (and (= shen.to (hd (tl (tl V1869)))) (and (cons? (tl (tl (tl V1869)))) (and (cons? (tl (tl (tl (tl V1869))))) (and (= in (hd (tl (tl (tl (tl V1869)))))) (and (cons? (tl (tl (tl (tl (tl V1869)))))) (= () (tl (tl (tl (tl (tl (tl V1869)))))))))))))))) (cons do (cons (cons shen.bindv (cons (hd (tl V1869)) (cons (shen.chwild (hd (tl (tl (tl V1869))))) (cons ProcessN ())))) (cons (cons let (cons Result (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1869))))))) (cons (cons do (cons (cons shen.unbindv (cons (hd (tl V1869)) (cons ProcessN ()))) (cons Result ()))) ())))) ())))) ((and (cons? V1869) (and (cons? (tl V1869)) (and (= is (hd (tl V1869))) (and (cons? (tl (tl V1869))) (and (= identical (hd (tl (tl V1869)))) (and (cons? (tl (tl (tl V1869)))) (and (= shen.to (hd (tl (tl (tl V1869))))) (and (cons? (tl (tl (tl (tl V1869))))) (= () (tl (tl (tl (tl (tl V1869)))))))))))))) (cons = (cons (hd (tl (tl (tl (tl V1869))))) (cons (hd V1869) ())))) ((= shen.failed! V1869) false) ((and (cons? V1869) (and (= shen.the (hd V1869)) (and (cons? (tl V1869)) (and (= head (hd (tl V1869))) (and (cons? (tl (tl V1869))) (and (= shen.of (hd (tl (tl V1869)))) (and (cons? (tl (tl (tl V1869)))) (= () (tl (tl (tl (tl V1869)))))))))))) (cons hd (tl (tl (tl V1869))))) ((and (cons? V1869) (and (= shen.the (hd V1869)) (and (cons? (tl V1869)) (and (= tail (hd (tl V1869))) (and (cons? (tl (tl V1869))) (and (= shen.of (hd (tl (tl V1869)))) (and (cons? (tl (tl (tl V1869)))) (= () (tl (tl (tl (tl V1869)))))))))))) (cons tl (tl (tl (tl V1869))))) ((and (cons? V1869) (and (= shen.pop (hd V1869)) (and (cons? (tl V1869)) (and (= shen.the (hd (tl V1869))) (and (cons? (tl (tl V1869))) (and (= shen.stack (hd (tl (tl V1869)))) (= () (tl (tl (tl V1869)))))))))) (cons do (cons (cons shen.incinfs ()) (cons (cons thaw (cons Continuation ())) ())))) ((and (cons? V1869) (and (= call (hd V1869)) (and (cons? (tl V1869)) (and (= shen.the (hd (tl V1869))) (and (cons? (tl (tl V1869))) (and (= shen.continuation (hd (tl (tl V1869)))) (and (cons? (tl (tl (tl V1869)))) (= () (tl (tl (tl (tl V1869)))))))))))) (cons do (cons (cons shen.incinfs ()) (cons (shen.call_the_continuation (shen.chwild (hd (tl (tl (tl V1869))))) ProcessN Continuation) ())))) (true V1869)))

(defun shen.chwild (V1871) (cond ((= V1871 _) (cons shen.newpv (cons ProcessN ()))) ((cons? V1871) (map (lambda Z (shen.chwild Z)) V1871)) (true V1871)))

(defun shen.newpv (V1873) (let Count+1 (+ (<-address (value shen.*varcounter*) V1873) 1) (let IncVar (address-> (value shen.*varcounter*) V1873 Count+1) (let Vector (<-address (value shen.*prologvectors*) V1873) (let ResizeVectorIfNeeded (if (= Count+1 (limit Vector)) (shen.resizeprocessvector V1873 Count+1) shen.skip) (shen.mk-pvar Count+1))))))

(defun shen.resizeprocessvector (V1876 V1877) (let Vector (<-address (value shen.*prologvectors*) V1876) (let BigVector (shen.resize-vector Vector (+ V1877 V1877) shen.-null-) (address-> (value shen.*prologvectors*) V1876 BigVector))))

(defun shen.resize-vector (V1881 V1882 V1883) (let BigVector (address-> (absvector (+ 1 V1882)) 0 V1882) (shen.copy-vector V1881 BigVector (limit V1881) V1882 V1883)))

(defun shen.copy-vector (V1889 V1890 V1891 V1892 V1893) (shen.copy-vector-stage-2 (+ 1 V1891) (+ V1892 1) V1893 (shen.copy-vector-stage-1 1 V1889 V1890 (+ 1 V1891))))

(defun shen.copy-vector-stage-1 (V1901 V1902 V1903 V1904) (cond ((= V1904 V1901) V1903) (true (shen.copy-vector-stage-1 (+ 1 V1901) V1902 (address-> V1903 V1901 (<-address V1902 V1901)) V1904))))

(defun shen.copy-vector-stage-2 (V1912 V1913 V1914 V1915) (cond ((= V1913 V1912) V1915) (true (shen.copy-vector-stage-2 (+ V1912 1) V1913 V1914 (address-> V1915 V1912 V1914)))))

(defun shen.mk-pvar (V1917) (address-> (address-> (absvector 2) 0 shen.pvar) 1 V1917))

(defun shen.pvar? (V1919) (and (absvector? V1919) (= (trap-error (<-address V1919 0) (lambda E shen.not-pvar)) shen.pvar)))

(defun shen.bindv (V1923 V1924 V1925) (let Vector (<-address (value shen.*prologvectors*) V1925) (address-> Vector (<-address V1923 1) V1924)))

(defun shen.unbindv (V1928 V1929) (let Vector (<-address (value shen.*prologvectors*) V1929) (address-> Vector (<-address V1928 1) shen.-null-)))

(defun shen.incinfs () (set shen.*infs* (+ 1 (value shen.*infs*))))

(defun shen.call_the_continuation (V1933 V1934 V1935) (cond ((and (cons? V1933) (and (cons? (hd V1933)) (= () (tl V1933)))) (cons (hd (hd V1933)) (append (tl (hd V1933)) (cons V1934 (cons V1935 ()))))) ((and (cons? V1933) (cons? (hd V1933))) (let NewContinuation (shen.newcontinuation (tl V1933) V1934 V1935) (cons (hd (hd V1933)) (append (tl (hd V1933)) (cons V1934 (cons NewContinuation ())))))) (true (shen.f_error shen.call_the_continuation))))

(defun shen.newcontinuation (V1939 V1940 V1941) (cond ((= () V1939) V1941) ((and (cons? V1939) (cons? (hd V1939))) (cons freeze (cons (cons (hd (hd V1939)) (append (tl (hd V1939)) (cons V1940 (cons (shen.newcontinuation (tl V1939) V1940 V1941) ())))) ()))) (true (shen.f_error shen.newcontinuation))))

(defun return (V1949 V1950 V1951) (shen.deref V1949 V1950))

(defun shen.measure&return (V1959 V1960 V1961) (do (shen.prhush (shen.app (value shen.*infs*) " inferences
" shen.a) (stoutput)) (shen.deref V1959 V1960)))

(defun unify (V1966 V1967 V1968 V1969) (shen.lzy= (shen.lazyderef V1966 V1968) (shen.lazyderef V1967 V1968) V1968 V1969))

(defun shen.lzy= (V1991 V1992 V1993 V1994) (cond ((= V1992 V1991) (thaw V1994)) ((shen.pvar? V1991) (bind V1991 V1992 V1993 V1994)) ((shen.pvar? V1992) (bind V1992 V1991 V1993 V1994)) ((and (cons? V1991) (cons? V1992)) (shen.lzy= (shen.lazyderef (hd V1991) V1993) (shen.lazyderef (hd V1992) V1993) V1993 (freeze (shen.lzy= (shen.lazyderef (tl V1991) V1993) (shen.lazyderef (tl V1992) V1993) V1993 V1994)))) (true false)))

(defun shen.deref (V1997 V1998) (cond ((cons? V1997) (cons (shen.deref (hd V1997) V1998) (shen.deref (tl V1997) V1998))) (true (if (shen.pvar? V1997) (let Value (shen.valvector V1997 V1998) (if (= Value shen.-null-) V1997 (shen.deref Value V1998))) V1997))))

(defun shen.lazyderef (V2001 V2002) (if (shen.pvar? V2001) (let Value (shen.valvector V2001 V2002) (if (= Value shen.-null-) V2001 (shen.lazyderef Value V2002))) V2001))

(defun shen.valvector (V2005 V2006) (<-address (<-address (value shen.*prologvectors*) V2006) (<-address V2005 1)))

(defun unify! (V2011 V2012 V2013 V2014) (shen.lzy=! (shen.lazyderef V2011 V2013) (shen.lazyderef V2012 V2013) V2013 V2014))

(defun shen.lzy=! (V2036 V2037 V2038 V2039) (cond ((= V2037 V2036) (thaw V2039)) ((and (shen.pvar? V2036) (not (shen.occurs? V2036 (shen.deref V2037 V2038)))) (bind V2036 V2037 V2038 V2039)) ((and (shen.pvar? V2037) (not (shen.occurs? V2037 (shen.deref V2036 V2038)))) (bind V2037 V2036 V2038 V2039)) ((and (cons? V2036) (cons? V2037)) (shen.lzy=! (shen.lazyderef (hd V2036) V2038) (shen.lazyderef (hd V2037) V2038) V2038 (freeze (shen.lzy=! (shen.lazyderef (tl V2036) V2038) (shen.lazyderef (tl V2037) V2038) V2038 V2039)))) (true false)))

(defun shen.occurs? (V2051 V2052) (cond ((= V2052 V2051) true) ((cons? V2052) (or (shen.occurs? V2051 (hd V2052)) (shen.occurs? V2051 (tl V2052)))) (true false)))

(defun identical (V2057 V2058 V2059 V2060) (shen.lzy== (shen.lazyderef V2057 V2059) (shen.lazyderef V2058 V2059) V2059 V2060))

(defun shen.lzy== (V2082 V2083 V2084 V2085) (cond ((= V2083 V2082) (thaw V2085)) ((and (cons? V2082) (cons? V2083)) (shen.lzy== (shen.lazyderef (hd V2082) V2084) (shen.lazyderef (hd V2083) V2084) V2084 (freeze (shen.lzy== (tl V2082) (tl V2083) V2084 V2085)))) (true false)))

(defun shen.pvar (V2087) (cn "Var" (shen.app (<-address V2087 1) "" shen.a)))

(defun bind (V2092 V2093 V2094 V2095) (do (shen.bindv V2092 V2093 V2094) (let Result (thaw V2095) (do (shen.unbindv V2092 V2094) Result))))

(defun fwhen (V2113 V2114 V2115) (cond ((= true V2113) (thaw V2115)) ((= false V2113) false) (true (simple-error (cn "fwhen expects a boolean: not " (shen.app V2113 "%" shen.s))))))

(defun call (V2131 V2132 V2133) (cond ((cons? V2131) (shen.call-help (function (shen.lazyderef (hd V2131) V2132)) (tl V2131) V2132 V2133)) (true false)))

(defun shen.call-help (V2138 V2139 V2140 V2141) (cond ((= () V2139) (V2138 V2140 V2141)) ((cons? V2139) (shen.call-help (V2138 (hd V2139)) (tl V2139) V2140 V2141)) (true (shen.f_error shen.call-help))))

(defun shen.intprolog (V2143) (cond ((and (cons? V2143) (cons? (hd V2143))) (let ProcessN (shen.start-new-prolog-process) (shen.intprolog-help (hd (hd V2143)) (shen.insert-prolog-variables (cons (tl (hd V2143)) (cons (tl V2143) ())) ProcessN) ProcessN))) (true (shen.f_error shen.intprolog))))

(defun shen.intprolog-help (V2147 V2148 V2149) (cond ((and (cons? V2148) (and (cons? (tl V2148)) (= () (tl (tl V2148))))) (shen.intprolog-help-help V2147 (hd V2148) (hd (tl V2148)) V2149)) (true (shen.f_error shen.intprolog-help))))

(defun shen.intprolog-help-help (V2154 V2155 V2156 V2157) (cond ((= () V2155) (V2154 V2157 (freeze (shen.call-rest V2156 V2157)))) ((cons? V2155) (shen.intprolog-help-help (V2154 (hd V2155)) (tl V2155) V2156 V2157)) (true (shen.f_error shen.intprolog-help-help))))

(defun shen.call-rest (V2162 V2163) (cond ((= () V2162) true) ((and (cons? V2162) (and (cons? (hd V2162)) (cons? (tl (hd V2162))))) (shen.call-rest (cons (cons ((hd (hd V2162)) (hd (tl (hd V2162)))) (tl (tl (hd V2162)))) (tl V2162)) V2163)) ((and (cons? V2162) (and (cons? (hd V2162)) (= () (tl (hd V2162))))) ((hd (hd V2162)) V2163 (freeze (shen.call-rest (tl V2162) V2163)))) (true (shen.f_error shen.call-rest))))

(defun shen.start-new-prolog-process () (let IncrementProcessCounter (set shen.*process-counter* (+ 1 (value shen.*process-counter*))) (shen.initialise-prolog IncrementProcessCounter)))

(defun shen.insert-prolog-variables (V2166 V2167) (shen.insert-prolog-variables-help V2166 (shen.flatten V2166) V2167))

(defun shen.insert-prolog-variables-help (V2175 V2176 V2177) (cond ((= () V2176) V2175) ((and (cons? V2176) (variable? (hd V2176))) (let V (shen.newpv V2177) (let XV/Y (subst V (hd V2176) V2175) (let Z-Y (remove (hd V2176) (tl V2176)) (shen.insert-prolog-variables-help XV/Y Z-Y V2177))))) ((cons? V2176) (shen.insert-prolog-variables-help V2175 (tl V2176) V2177)) (true (shen.f_error shen.insert-prolog-variables-help))))

(defun shen.initialise-prolog (V2179) (let Vector (address-> (value shen.*prologvectors*) V2179 (shen.fillvector (vector 10) 1 10 shen.-null-)) (let Counter (address-> (value shen.*varcounter*) V2179 1) V2179)))



