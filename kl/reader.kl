"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.read-char-code (V2181) (read-byte V2181))

(defun read-file-as-bytelist (V2183) (shen.read-file-as-Xlist V2183 (lambda S (read-byte S))))

(defun shen.read-file-as-charlist (V2185) (shen.read-file-as-Xlist V2185 (lambda S (shen.read-char-code S))))

(defun shen.read-file-as-Xlist (V2188 V2189) (let Stream (open V2188 in) (let X (V2189 Stream) (let Xs (shen.read-file-as-Xlist-help Stream V2189 X ()) (let Close (close Stream) (reverse Xs))))))

(defun shen.read-file-as-Xlist-help (V2194 V2195 V2196 V2197) (cond ((= -1 V2196) V2197) (true (shen.read-file-as-Xlist-help V2194 V2195 (V2195 V2194) (cons V2196 V2197)))))

(defun read-file-as-string (V2199) (let Stream (open V2199 in) (shen.rfas-h Stream (shen.read-char-code Stream) "")))

(defun shen.rfas-h (V2203 V2204 V2205) (cond ((= -1 V2204) (do (close V2203) V2205)) (true (shen.rfas-h V2203 (shen.read-char-code V2203) (cn V2205 (n->string V2204))))))

(defun input (V2207) (eval-kl (read V2207)))

(defun input+ (V2210 V2211) (let Mono? (shen.monotype V2210) (let Input (read V2211) (if (= false (shen.typecheck Input (shen.demodulate V2210))) (simple-error (cn "type error: " (shen.app Input (cn " is not of type " (shen.app V2210 "
" shen.r)) shen.r))) (eval-kl Input)))))

(defun shen.monotype (V2213) (cond ((cons? V2213) (map (lambda Z (shen.monotype Z)) V2213)) (true (if (variable? V2213) (simple-error (cn "input+ expects a monotype: not " (shen.app V2213 "
" shen.a))) V2213))))

(defun read (V2215) (hd (shen.read-loop V2215 (shen.read-char-code V2215) ())))

(defun it () (value shen.*it*))

(defun shen.read-loop (V2223 V2224 V2225) (cond ((= 94 V2224) (simple-error "read aborted")) ((= -1 V2224) (if (empty? V2225) (simple-error "error: empty stream") (compile (lambda X (shen.<st_input> X)) V2225 (lambda E E)))) ((shen.terminator? V2224) (let AllChars (append V2225 (cons V2224 ())) (let It (shen.record-it AllChars) (let Read (compile (lambda X (shen.<st_input> X)) AllChars (lambda E shen.nextbyte)) (if (or (= Read shen.nextbyte) (empty? Read)) (shen.read-loop V2223 (shen.read-char-code V2223) AllChars) Read))))) (true (shen.read-loop V2223 (shen.read-char-code V2223) (append V2225 (cons V2224 ()))))))

(defun shen.terminator? (V2227) (element? V2227 (cons 9 (cons 10 (cons 13 (cons 32 (cons 34 (cons 41 (cons 93 ())))))))))

(defun lineread (V2229) (shen.lineread-loop (shen.read-char-code V2229) () V2229))

(defun shen.lineread-loop (V2234 V2235 V2236) (cond ((= -1 V2234) (if (empty? V2235) (simple-error "empty stream") (compile (lambda X (shen.<st_input> X)) V2235 (lambda E E)))) ((= V2234 (shen.hat)) (simple-error "line read aborted")) ((element? V2234 (cons (shen.newline) (cons (shen.carriage-return) ()))) (let Line (compile (lambda X (shen.<st_input> X)) V2235 (lambda E shen.nextline)) (let It (shen.record-it V2235) (if (or (= Line shen.nextline) (empty? Line)) (shen.lineread-loop (shen.read-char-code V2236) (append V2235 (cons V2234 ())) V2236) Line)))) (true (shen.lineread-loop (shen.read-char-code V2236) (append V2235 (cons V2234 ())) V2236))))

(defun shen.record-it (V2238) (let TrimLeft (shen.trim-whitespace V2238) (let TrimRight (shen.trim-whitespace (reverse TrimLeft)) (let Trimmed (reverse TrimRight) (shen.record-it-h Trimmed)))))

(defun shen.trim-whitespace (V2240) (cond ((and (cons? V2240) (element? (hd V2240) (cons 9 (cons 10 (cons 13 (cons 32 ())))))) (shen.trim-whitespace (tl V2240))) (true V2240)))

(defun shen.record-it-h (V2242) (do (set shen.*it* (shen.cn-all (map (lambda X (n->string X)) V2242))) V2242))

(defun shen.cn-all (V2244) (cond ((= () V2244) "") ((cons? V2244) (cn (hd V2244) (shen.cn-all (tl V2244)))) (true (shen.f_error shen.cn-all))))

(defun read-file (V2246) (let Charlist (shen.read-file-as-charlist V2246) (compile (lambda X (shen.<st_input> X)) Charlist (lambda X (shen.read-error X)))))

(defun read-from-string (V2248) (let Ns (map (lambda X (string->n X)) (explode V2248)) (compile (lambda X (shen.<st_input> X)) Ns (lambda X (shen.read-error X)))))

(defun shen.read-error (V2256) (cond ((and (cons? V2256) (and (cons? (hd V2256)) (and (cons? (tl V2256)) (= () (tl (tl V2256)))))) (simple-error (cn "read error here:

 " (shen.app (shen.compress-50 50 (hd V2256)) "
" shen.a)))) (true (simple-error "read error
"))))

(defun shen.compress-50 (V2263 V2264) (cond ((= () V2264) "") ((= 0 V2263) "") ((cons? V2264) (cn (n->string (hd V2264)) (shen.compress-50 (- V2263 1) (tl V2264)))) (true (shen.f_error shen.compress-50))))

(defun shen.<st_input> (V2266) (let YaccParse (let Parse_shen.<lsb> (shen.<lsb> V2266) (if (not (= (fail) Parse_shen.<lsb>)) (let Parse_shen.<st_input1> (shen.<st_input1> Parse_shen.<lsb>) (if (not (= (fail) Parse_shen.<st_input1>)) (let Parse_shen.<rsb> (shen.<rsb> Parse_shen.<st_input1>) (if (not (= (fail) Parse_shen.<rsb>)) (let Parse_shen.<st_input2> (shen.<st_input2> Parse_shen.<rsb>) (if (not (= (fail) Parse_shen.<st_input2>)) (shen.pair (hd Parse_shen.<st_input2>) (cons (macroexpand (shen.cons_form (shen.hdtl Parse_shen.<st_input1>))) (shen.hdtl Parse_shen.<st_input2>))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<lrb> (shen.<lrb> V2266) (if (not (= (fail) Parse_shen.<lrb>)) (let Parse_shen.<st_input1> (shen.<st_input1> Parse_shen.<lrb>) (if (not (= (fail) Parse_shen.<st_input1>)) (let Parse_shen.<rrb> (shen.<rrb> Parse_shen.<st_input1>) (if (not (= (fail) Parse_shen.<rrb>)) (let Parse_shen.<st_input2> (shen.<st_input2> Parse_shen.<rrb>) (if (not (= (fail) Parse_shen.<st_input2>)) (shen.pair (hd Parse_shen.<st_input2>) (shen.package-macro (macroexpand (shen.hdtl Parse_shen.<st_input1>)) (shen.hdtl Parse_shen.<st_input2>))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<lcurly> (shen.<lcurly> V2266) (if (not (= (fail) Parse_shen.<lcurly>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<lcurly>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons { (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<rcurly> (shen.<rcurly> V2266) (if (not (= (fail) Parse_shen.<rcurly>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<rcurly>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons } (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<bar> (shen.<bar> V2266) (if (not (= (fail) Parse_shen.<bar>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<bar>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons bar! (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<semicolon> (shen.<semicolon> V2266) (if (not (= (fail) Parse_shen.<semicolon>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<semicolon>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons ; (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V2266) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<equal> (shen.<equal> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<equal>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<equal>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons := (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V2266) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<minus> (shen.<minus> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons :- (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V2266) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons : (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<comma> (shen.<comma> V2266) (if (not (= (fail) Parse_shen.<comma>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<comma>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons (intern ",") (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<comment> (shen.<comment> V2266) (if (not (= (fail) Parse_shen.<comment>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<comment>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<atom> (shen.<atom> V2266) (if (not (= (fail) Parse_shen.<atom>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<atom>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons (macroexpand (shen.hdtl Parse_shen.<atom>)) (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<whitespaces> (shen.<whitespaces> V2266) (if (not (= (fail) Parse_shen.<whitespaces>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<whitespaces>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2266) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.<lsb> (V2269) (if (and (cons? (hd V2269)) (= 91 (shen.hdhd V2269))) (let NewStream2267 (shen.pair (shen.tlhd V2269) (shen.hdtl V2269)) (shen.pair (hd NewStream2267) shen.skip)) (fail)))

(defun shen.<rsb> (V2272) (if (and (cons? (hd V2272)) (= 93 (shen.hdhd V2272))) (let NewStream2270 (shen.pair (shen.tlhd V2272) (shen.hdtl V2272)) (shen.pair (hd NewStream2270) shen.skip)) (fail)))

(defun shen.<lcurly> (V2275) (if (and (cons? (hd V2275)) (= 123 (shen.hdhd V2275))) (let NewStream2273 (shen.pair (shen.tlhd V2275) (shen.hdtl V2275)) (shen.pair (hd NewStream2273) shen.skip)) (fail)))

(defun shen.<rcurly> (V2278) (if (and (cons? (hd V2278)) (= 125 (shen.hdhd V2278))) (let NewStream2276 (shen.pair (shen.tlhd V2278) (shen.hdtl V2278)) (shen.pair (hd NewStream2276) shen.skip)) (fail)))

(defun shen.<bar> (V2281) (if (and (cons? (hd V2281)) (= 124 (shen.hdhd V2281))) (let NewStream2279 (shen.pair (shen.tlhd V2281) (shen.hdtl V2281)) (shen.pair (hd NewStream2279) shen.skip)) (fail)))

(defun shen.<semicolon> (V2284) (if (and (cons? (hd V2284)) (= 59 (shen.hdhd V2284))) (let NewStream2282 (shen.pair (shen.tlhd V2284) (shen.hdtl V2284)) (shen.pair (hd NewStream2282) shen.skip)) (fail)))

(defun shen.<colon> (V2287) (if (and (cons? (hd V2287)) (= 58 (shen.hdhd V2287))) (let NewStream2285 (shen.pair (shen.tlhd V2287) (shen.hdtl V2287)) (shen.pair (hd NewStream2285) shen.skip)) (fail)))

(defun shen.<comma> (V2290) (if (and (cons? (hd V2290)) (= 44 (shen.hdhd V2290))) (let NewStream2288 (shen.pair (shen.tlhd V2290) (shen.hdtl V2290)) (shen.pair (hd NewStream2288) shen.skip)) (fail)))

(defun shen.<equal> (V2293) (if (and (cons? (hd V2293)) (= 61 (shen.hdhd V2293))) (let NewStream2291 (shen.pair (shen.tlhd V2293) (shen.hdtl V2293)) (shen.pair (hd NewStream2291) shen.skip)) (fail)))

(defun shen.<minus> (V2296) (if (and (cons? (hd V2296)) (= 45 (shen.hdhd V2296))) (let NewStream2294 (shen.pair (shen.tlhd V2296) (shen.hdtl V2296)) (shen.pair (hd NewStream2294) shen.skip)) (fail)))

(defun shen.<lrb> (V2299) (if (and (cons? (hd V2299)) (= 40 (shen.hdhd V2299))) (let NewStream2297 (shen.pair (shen.tlhd V2299) (shen.hdtl V2299)) (shen.pair (hd NewStream2297) shen.skip)) (fail)))

(defun shen.<rrb> (V2302) (if (and (cons? (hd V2302)) (= 41 (shen.hdhd V2302))) (let NewStream2300 (shen.pair (shen.tlhd V2302) (shen.hdtl V2302)) (shen.pair (hd NewStream2300) shen.skip)) (fail)))

(defun shen.<atom> (V2304) (let YaccParse (let Parse_shen.<str> (shen.<str> V2304) (if (not (= (fail) Parse_shen.<str>)) (shen.pair (hd Parse_shen.<str>) (shen.control-chars (shen.hdtl Parse_shen.<str>))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<number> (shen.<number> V2304) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (shen.hdtl Parse_shen.<number>)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<sym> (shen.<sym> V2304) (if (not (= (fail) Parse_shen.<sym>)) (shen.pair (hd Parse_shen.<sym>) (if (= (shen.hdtl Parse_shen.<sym>) "<>") (cons vector (cons 0 ())) (intern (shen.hdtl Parse_shen.<sym>)))) (fail))) YaccParse)) YaccParse)))

(defun shen.control-chars (V2306) (cond ((= () V2306) "") ((and (cons? V2306) (and (= "c" (hd V2306)) (and (cons? (tl V2306)) (= "#" (hd (tl V2306)))))) (let CodePoint (shen.code-point (tl (tl V2306))) (let AfterCodePoint (shen.after-codepoint (tl (tl V2306))) (@s (n->string (shen.decimalise CodePoint)) (shen.control-chars AfterCodePoint))))) ((cons? V2306) (@s (hd V2306) (shen.control-chars (tl V2306)))) (true (shen.f_error shen.control-chars))))

(defun shen.code-point (V2310) (cond ((and (cons? V2310) (= ";" (hd V2310))) "") ((and (cons? V2310) (element? (hd V2310) (cons "0" (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ()))))))))))))) (cons (hd V2310) (shen.code-point (tl V2310)))) (true (simple-error (cn "code point parse error " (shen.app V2310 "
" shen.a))))))

(defun shen.after-codepoint (V2316) (cond ((= () V2316) ()) ((and (cons? V2316) (= ";" (hd V2316))) (tl V2316)) ((cons? V2316) (shen.after-codepoint (tl V2316))) (true (shen.f_error shen.after-codepoint))))

(defun shen.decimalise (V2318) (shen.pre (reverse (shen.digits->integers V2318)) 0))

(defun shen.digits->integers (V2324) (cond ((and (cons? V2324) (= "0" (hd V2324))) (cons 0 (shen.digits->integers (tl V2324)))) ((and (cons? V2324) (= "1" (hd V2324))) (cons 1 (shen.digits->integers (tl V2324)))) ((and (cons? V2324) (= "2" (hd V2324))) (cons 2 (shen.digits->integers (tl V2324)))) ((and (cons? V2324) (= "3" (hd V2324))) (cons 3 (shen.digits->integers (tl V2324)))) ((and (cons? V2324) (= "4" (hd V2324))) (cons 4 (shen.digits->integers (tl V2324)))) ((and (cons? V2324) (= "5" (hd V2324))) (cons 5 (shen.digits->integers (tl V2324)))) ((and (cons? V2324) (= "6" (hd V2324))) (cons 6 (shen.digits->integers (tl V2324)))) ((and (cons? V2324) (= "7" (hd V2324))) (cons 7 (shen.digits->integers (tl V2324)))) ((and (cons? V2324) (= "8" (hd V2324))) (cons 8 (shen.digits->integers (tl V2324)))) ((and (cons? V2324) (= "9" (hd V2324))) (cons 9 (shen.digits->integers (tl V2324)))) (true ())))

(defun shen.<sym> (V2326) (let Parse_shen.<alpha> (shen.<alpha> V2326) (if (not (= (fail) Parse_shen.<alpha>)) (let Parse_shen.<alphanums> (shen.<alphanums> Parse_shen.<alpha>) (if (not (= (fail) Parse_shen.<alphanums>)) (shen.pair (hd Parse_shen.<alphanums>) (@s (shen.hdtl Parse_shen.<alpha>) (shen.hdtl Parse_shen.<alphanums>))) (fail))) (fail))))

(defun shen.<alphanums> (V2328) (let YaccParse (let Parse_shen.<alphanum> (shen.<alphanum> V2328) (if (not (= (fail) Parse_shen.<alphanum>)) (let Parse_shen.<alphanums> (shen.<alphanums> Parse_shen.<alphanum>) (if (not (= (fail) Parse_shen.<alphanums>)) (shen.pair (hd Parse_shen.<alphanums>) (@s (shen.hdtl Parse_shen.<alphanum>) (shen.hdtl Parse_shen.<alphanums>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2328) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) "") (fail))) YaccParse)))

(defun shen.<alphanum> (V2330) (let YaccParse (let Parse_shen.<alpha> (shen.<alpha> V2330) (if (not (= (fail) Parse_shen.<alpha>)) (shen.pair (hd Parse_shen.<alpha>) (shen.hdtl Parse_shen.<alpha>)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<num> (shen.<num> V2330) (if (not (= (fail) Parse_shen.<num>)) (shen.pair (hd Parse_shen.<num>) (shen.hdtl Parse_shen.<num>)) (fail))) YaccParse)))

(defun shen.<num> (V2332) (if (cons? (hd V2332)) (let Parse_Char (shen.hdhd V2332) (if (shen.numbyte? Parse_Char) (shen.pair (hd (shen.pair (shen.tlhd V2332) (shen.hdtl V2332))) (n->string Parse_Char)) (fail))) (fail)))

(defun shen.numbyte? (V2338) (cond ((= 48 V2338) true) ((= 49 V2338) true) ((= 50 V2338) true) ((= 51 V2338) true) ((= 52 V2338) true) ((= 53 V2338) true) ((= 54 V2338) true) ((= 55 V2338) true) ((= 56 V2338) true) ((= 57 V2338) true) (true false)))

(defun shen.<alpha> (V2340) (if (cons? (hd V2340)) (let Parse_Char (shen.hdhd V2340) (if (shen.symbol-code? Parse_Char) (shen.pair (hd (shen.pair (shen.tlhd V2340) (shen.hdtl V2340))) (n->string Parse_Char)) (fail))) (fail)))

(defun shen.symbol-code? (V2342) (or (= V2342 126) (or (and (> V2342 94) (< V2342 123)) (or (and (> V2342 59) (< V2342 91)) (or (and (> V2342 41) (and (< V2342 58) (not (= V2342 44)))) (or (and (> V2342 34) (< V2342 40)) (= V2342 33)))))))

(defun shen.<str> (V2344) (let Parse_shen.<dbq> (shen.<dbq> V2344) (if (not (= (fail) Parse_shen.<dbq>)) (let Parse_shen.<strcontents> (shen.<strcontents> Parse_shen.<dbq>) (if (not (= (fail) Parse_shen.<strcontents>)) (let Parse_shen.<dbq> (shen.<dbq> Parse_shen.<strcontents>) (if (not (= (fail) Parse_shen.<dbq>)) (shen.pair (hd Parse_shen.<dbq>) (shen.hdtl Parse_shen.<strcontents>)) (fail))) (fail))) (fail))))

(defun shen.<dbq> (V2346) (if (cons? (hd V2346)) (let Parse_Char (shen.hdhd V2346) (if (= Parse_Char 34) (shen.pair (hd (shen.pair (shen.tlhd V2346) (shen.hdtl V2346))) Parse_Char) (fail))) (fail)))

(defun shen.<strcontents> (V2348) (let YaccParse (let Parse_shen.<strc> (shen.<strc> V2348) (if (not (= (fail) Parse_shen.<strc>)) (let Parse_shen.<strcontents> (shen.<strcontents> Parse_shen.<strc>) (if (not (= (fail) Parse_shen.<strcontents>)) (shen.pair (hd Parse_shen.<strcontents>) (cons (shen.hdtl Parse_shen.<strc>) (shen.hdtl Parse_shen.<strcontents>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2348) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<byte> (V2350) (if (cons? (hd V2350)) (let Parse_Char (shen.hdhd V2350) (shen.pair (hd (shen.pair (shen.tlhd V2350) (shen.hdtl V2350))) (n->string Parse_Char))) (fail)))

(defun shen.<strc> (V2352) (if (cons? (hd V2352)) (let Parse_Char (shen.hdhd V2352) (if (not (= Parse_Char 34)) (shen.pair (hd (shen.pair (shen.tlhd V2352) (shen.hdtl V2352))) (n->string Parse_Char)) (fail))) (fail)))

(defun shen.<number> (V2354) (let YaccParse (let Parse_shen.<minus> (shen.<minus> V2354) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<number> (shen.<number> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (- 0 (shen.hdtl Parse_shen.<number>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<plus> (shen.<plus> V2354) (if (not (= (fail) Parse_shen.<plus>)) (let Parse_shen.<number> (shen.<number> Parse_shen.<plus>) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (shen.hdtl Parse_shen.<number>)) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<predigits> (shen.<predigits> V2354) (if (not (= (fail) Parse_shen.<predigits>)) (let Parse_shen.<stop> (shen.<stop> Parse_shen.<predigits>) (if (not (= (fail) Parse_shen.<stop>)) (let Parse_shen.<postdigits> (shen.<postdigits> Parse_shen.<stop>) (if (not (= (fail) Parse_shen.<postdigits>)) (let Parse_shen.<E> (shen.<E> Parse_shen.<postdigits>) (if (not (= (fail) Parse_shen.<E>)) (let Parse_shen.<log10> (shen.<log10> Parse_shen.<E>) (if (not (= (fail) Parse_shen.<log10>)) (shen.pair (hd Parse_shen.<log10>) (* (shen.expt 10 (shen.hdtl Parse_shen.<log10>)) (+ (shen.pre (reverse (shen.hdtl Parse_shen.<predigits>)) 0) (shen.post (shen.hdtl Parse_shen.<postdigits>) 1)))) (fail))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<digits> (shen.<digits> V2354) (if (not (= (fail) Parse_shen.<digits>)) (let Parse_shen.<E> (shen.<E> Parse_shen.<digits>) (if (not (= (fail) Parse_shen.<E>)) (let Parse_shen.<log10> (shen.<log10> Parse_shen.<E>) (if (not (= (fail) Parse_shen.<log10>)) (shen.pair (hd Parse_shen.<log10>) (* (shen.expt 10 (shen.hdtl Parse_shen.<log10>)) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<predigits> (shen.<predigits> V2354) (if (not (= (fail) Parse_shen.<predigits>)) (let Parse_shen.<stop> (shen.<stop> Parse_shen.<predigits>) (if (not (= (fail) Parse_shen.<stop>)) (let Parse_shen.<postdigits> (shen.<postdigits> Parse_shen.<stop>) (if (not (= (fail) Parse_shen.<postdigits>)) (shen.pair (hd Parse_shen.<postdigits>) (+ (shen.pre (reverse (shen.hdtl Parse_shen.<predigits>)) 0) (shen.post (shen.hdtl Parse_shen.<postdigits>) 1))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digits> (shen.<digits> V2354) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.<E> (V2357) (if (and (cons? (hd V2357)) (= 101 (shen.hdhd V2357))) (let NewStream2355 (shen.pair (shen.tlhd V2357) (shen.hdtl V2357)) (shen.pair (hd NewStream2355) shen.skip)) (fail)))

(defun shen.<log10> (V2359) (let YaccParse (let Parse_shen.<minus> (shen.<minus> V2359) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<digits> (shen.<digits> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (- 0 (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digits> (shen.<digits> V2359) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0)) (fail))) YaccParse)))

(defun shen.<plus> (V2361) (if (cons? (hd V2361)) (let Parse_Char (shen.hdhd V2361) (if (= Parse_Char 43) (shen.pair (hd (shen.pair (shen.tlhd V2361) (shen.hdtl V2361))) Parse_Char) (fail))) (fail)))

(defun shen.<stop> (V2363) (if (cons? (hd V2363)) (let Parse_Char (shen.hdhd V2363) (if (= Parse_Char 46) (shen.pair (hd (shen.pair (shen.tlhd V2363) (shen.hdtl V2363))) Parse_Char) (fail))) (fail)))

(defun shen.<predigits> (V2365) (let YaccParse (let Parse_shen.<digits> (shen.<digits> V2365) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.hdtl Parse_shen.<digits>)) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2365) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<postdigits> (V2367) (let Parse_shen.<digits> (shen.<digits> V2367) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.hdtl Parse_shen.<digits>)) (fail))))

(defun shen.<digits> (V2369) (let YaccParse (let Parse_shen.<digit> (shen.<digit> V2369) (if (not (= (fail) Parse_shen.<digit>)) (let Parse_shen.<digits> (shen.<digits> Parse_shen.<digit>) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (cons (shen.hdtl Parse_shen.<digit>) (shen.hdtl Parse_shen.<digits>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digit> (shen.<digit> V2369) (if (not (= (fail) Parse_shen.<digit>)) (shen.pair (hd Parse_shen.<digit>) (cons (shen.hdtl Parse_shen.<digit>) ())) (fail))) YaccParse)))

(defun shen.<digit> (V2371) (if (cons? (hd V2371)) (let Parse_X (shen.hdhd V2371) (if (shen.numbyte? Parse_X) (shen.pair (hd (shen.pair (shen.tlhd V2371) (shen.hdtl V2371))) (shen.byte->digit Parse_X)) (fail))) (fail)))

(defun shen.byte->digit (V2373) (cond ((= 48 V2373) 0) ((= 49 V2373) 1) ((= 50 V2373) 2) ((= 51 V2373) 3) ((= 52 V2373) 4) ((= 53 V2373) 5) ((= 54 V2373) 6) ((= 55 V2373) 7) ((= 56 V2373) 8) ((= 57 V2373) 9) (true (shen.f_error shen.byte->digit))))

(defun shen.pre (V2378 V2379) (cond ((= () V2378) 0) ((cons? V2378) (+ (* (shen.expt 10 V2379) (hd V2378)) (shen.pre (tl V2378) (+ V2379 1)))) (true (shen.f_error shen.pre))))

(defun shen.post (V2384 V2385) (cond ((= () V2384) 0) ((cons? V2384) (+ (* (shen.expt 10 (- 0 V2385)) (hd V2384)) (shen.post (tl V2384) (+ V2385 1)))) (true (shen.f_error shen.post))))

(defun shen.expt (V2390 V2391) (cond ((= 0 V2391) 1) ((> V2391 0) (* V2390 (shen.expt V2390 (- V2391 1)))) (true (* 1.000000000000000 (/ (shen.expt V2390 (+ V2391 1)) V2390)))))

(defun shen.<st_input1> (V2393) (let Parse_shen.<st_input> (shen.<st_input> V2393) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))))

(defun shen.<st_input2> (V2395) (let Parse_shen.<st_input> (shen.<st_input> V2395) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))))

(defun shen.<comment> (V2397) (let YaccParse (let Parse_shen.<singleline> (shen.<singleline> V2397) (if (not (= (fail) Parse_shen.<singleline>)) (shen.pair (hd Parse_shen.<singleline>) shen.skip) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<multiline> (shen.<multiline> V2397) (if (not (= (fail) Parse_shen.<multiline>)) (shen.pair (hd Parse_shen.<multiline>) shen.skip) (fail))) YaccParse)))

(defun shen.<singleline> (V2399) (let Parse_shen.<backslash> (shen.<backslash> V2399) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<backslash> (shen.<backslash> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<anysingle> (shen.<anysingle> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<anysingle>)) (let Parse_shen.<return> (shen.<return> Parse_shen.<anysingle>) (if (not (= (fail) Parse_shen.<return>)) (shen.pair (hd Parse_shen.<return>) shen.skip) (fail))) (fail))) (fail))) (fail))))

(defun shen.<backslash> (V2402) (if (and (cons? (hd V2402)) (= 92 (shen.hdhd V2402))) (let NewStream2400 (shen.pair (shen.tlhd V2402) (shen.hdtl V2402)) (shen.pair (hd NewStream2400) shen.skip)) (fail)))

(defun shen.<anysingle> (V2404) (let YaccParse (let Parse_shen.<non-return> (shen.<non-return> V2404) (if (not (= (fail) Parse_shen.<non-return>)) (let Parse_shen.<anysingle> (shen.<anysingle> Parse_shen.<non-return>) (if (not (= (fail) Parse_shen.<anysingle>)) (shen.pair (hd Parse_shen.<anysingle>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2404) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) shen.skip) (fail))) YaccParse)))

(defun shen.<non-return> (V2406) (if (cons? (hd V2406)) (let Parse_X (shen.hdhd V2406) (if (not (element? Parse_X (cons 10 (cons 13 ())))) (shen.pair (hd (shen.pair (shen.tlhd V2406) (shen.hdtl V2406))) shen.skip) (fail))) (fail)))

(defun shen.<return> (V2408) (if (cons? (hd V2408)) (let Parse_X (shen.hdhd V2408) (if (element? Parse_X (cons 10 (cons 13 ()))) (shen.pair (hd (shen.pair (shen.tlhd V2408) (shen.hdtl V2408))) shen.skip) (fail))) (fail)))

(defun shen.<multiline> (V2410) (let Parse_shen.<backslash> (shen.<backslash> V2410) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<times> (shen.<times> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<times>)) (let Parse_shen.<anymulti> (shen.<anymulti> Parse_shen.<times>) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail))) (fail))) (fail))))

(defun shen.<times> (V2413) (if (and (cons? (hd V2413)) (= 42 (shen.hdhd V2413))) (let NewStream2411 (shen.pair (shen.tlhd V2413) (shen.hdtl V2413)) (shen.pair (hd NewStream2411) shen.skip)) (fail)))

(defun shen.<anymulti> (V2415) (let YaccParse (let Parse_shen.<comment> (shen.<comment> V2415) (if (not (= (fail) Parse_shen.<comment>)) (let Parse_shen.<anymulti> (shen.<anymulti> Parse_shen.<comment>) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<times> (shen.<times> V2415) (if (not (= (fail) Parse_shen.<times>)) (let Parse_shen.<backslash> (shen.<backslash> Parse_shen.<times>) (if (not (= (fail) Parse_shen.<backslash>)) (shen.pair (hd Parse_shen.<backslash>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (if (cons? (hd V2415)) (let Parse_X (shen.hdhd V2415) (let Parse_shen.<anymulti> (shen.<anymulti> (shen.pair (shen.tlhd V2415) (shen.hdtl V2415))) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail)))) (fail)) YaccParse)) YaccParse)))

(defun shen.<whitespaces> (V2417) (let YaccParse (let Parse_shen.<whitespace> (shen.<whitespace> V2417) (if (not (= (fail) Parse_shen.<whitespace>)) (let Parse_shen.<whitespaces> (shen.<whitespaces> Parse_shen.<whitespace>) (if (not (= (fail) Parse_shen.<whitespaces>)) (shen.pair (hd Parse_shen.<whitespaces>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<whitespace> (shen.<whitespace> V2417) (if (not (= (fail) Parse_shen.<whitespace>)) (shen.pair (hd Parse_shen.<whitespace>) shen.skip) (fail))) YaccParse)))

(defun shen.<whitespace> (V2419) (if (cons? (hd V2419)) (let Parse_X (shen.hdhd V2419) (if (let Parse_Case Parse_X (or (= Parse_Case 32) (or (= Parse_Case 13) (or (= Parse_Case 10) (= Parse_Case 9))))) (shen.pair (hd (shen.pair (shen.tlhd V2419) (shen.hdtl V2419))) shen.skip) (fail))) (fail)))

(defun shen.cons_form (V2421) (cond ((= () V2421) ()) ((and (cons? V2421) (and (cons? (tl V2421)) (and (cons? (tl (tl V2421))) (and (= () (tl (tl (tl V2421)))) (= (hd (tl V2421)) bar!))))) (cons cons (cons (hd V2421) (tl (tl V2421))))) ((cons? V2421) (cons cons (cons (hd V2421) (cons (shen.cons_form (tl V2421)) ())))) (true (shen.f_error shen.cons_form))))

(defun shen.package-macro (V2426 V2427) (cond ((and (cons? V2426) (and (= $ (hd V2426)) (and (cons? (tl V2426)) (= () (tl (tl V2426)))))) (append (explode (hd (tl V2426))) V2427)) ((and (cons? V2426) (and (= package (hd V2426)) (and (cons? (tl V2426)) (and (= null (hd (tl V2426))) (cons? (tl (tl V2426))))))) (append (tl (tl (tl V2426))) V2427)) ((and (cons? V2426) (and (= package (hd V2426)) (and (cons? (tl V2426)) (cons? (tl (tl V2426)))))) (let ListofExceptions (shen.eval-without-macros (hd (tl (tl V2426)))) (let External (shen.record-exceptions ListofExceptions (hd (tl V2426))) (let PackageNameDot (intern (cn (str (hd (tl V2426))) ".")) (let ExpPackageNameDot (explode PackageNameDot) (let Packaged (shen.packageh PackageNameDot ListofExceptions (tl (tl (tl V2426))) ExpPackageNameDot) (let Internal (shen.record-internal (hd (tl V2426)) (shen.internal-symbols ExpPackageNameDot Packaged)) (append Packaged V2427)))))))) (true (cons V2426 V2427))))

(defun shen.record-exceptions (V2430 V2431) (let CurrExceptions (trap-error (get V2431 shen.external-symbols (value *property-vector*)) (lambda E ())) (let AllExceptions (union V2430 CurrExceptions) (put V2431 shen.external-symbols AllExceptions (value *property-vector*)))))

(defun shen.record-internal (V2434 V2435) (put V2434 shen.internal-symbols (union V2435 (trap-error (get V2434 shen.internal-symbols (value *property-vector*)) (lambda E ()))) (value *property-vector*)))

(defun shen.internal-symbols (V2446 V2447) (cond ((and (symbol? V2447) (shen.prefix? V2446 (explode V2447))) (cons V2447 ())) ((cons? V2447) (union (shen.internal-symbols V2446 (hd V2447)) (shen.internal-symbols V2446 (tl V2447)))) (true ())))

(defun shen.packageh (V2464 V2465 V2466 V2467) (cond ((cons? V2466) (cons (shen.packageh V2464 V2465 (hd V2466) V2467) (shen.packageh V2464 V2465 (tl V2466) V2467))) ((or (shen.sysfunc? V2466) (or (variable? V2466) (or (element? V2466 V2465) (or (shen.doubleunderline? V2466) (shen.singleunderline? V2466))))) V2466) ((and (symbol? V2466) (let ExplodeX (explode V2466) (and (not (shen.prefix? (cons "s" (cons "h" (cons "e" (cons "n" (cons "." ()))))) ExplodeX)) (not (shen.prefix? V2467 ExplodeX))))) (concat V2464 V2466)) (true V2466)))



