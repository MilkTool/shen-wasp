"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.typecheck (V3488 V3489) (let Curry (shen.curry V3488) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V3489)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V3491) (cond ((and (cons? V3491) (shen.special? (hd V3491))) (cons (hd V3491) (map (lambda Y (shen.curry Y)) (tl V3491)))) ((and (cons? V3491) (and (cons? (tl V3491)) (shen.extraspecial? (hd V3491)))) V3491) ((and (cons? V3491) (and (= type (hd V3491)) (and (cons? (tl V3491)) (and (cons? (tl (tl V3491))) (= () (tl (tl (tl V3491)))))))) (cons type (cons (shen.curry (hd (tl V3491))) (tl (tl V3491))))) ((and (cons? V3491) (and (cons? (tl V3491)) (cons? (tl (tl V3491))))) (shen.curry (cons (cons (hd V3491) (cons (hd (tl V3491)) ())) (tl (tl V3491))))) ((and (cons? V3491) (and (cons? (tl V3491)) (= () (tl (tl V3491))))) (cons (shen.curry (hd V3491)) (cons (shen.curry (hd (tl V3491))) ()))) (true V3491)))

(defun shen.special? (V3493) (element? V3493 (value shen.*special*)))

(defun shen.extraspecial? (V3495) (element? V3495 (value shen.*extraspecial*)))

(defun shen.t* (V3500 V3501 V3502 V3503) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V3502) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V3502 (freeze (bind Error (shen.errormaxinfs) V3502 V3503))))) (if (= Case false) (let Case (let V3480 (shen.lazyderef V3500 V3502) (if (= fail V3480) (do (shen.incinfs) (cut Throwcontrol V3502 (freeze (shen.prolog-failure V3502 V3503)))) false)) (if (= Case false) (let Case (let V3481 (shen.lazyderef V3500 V3502) (if (cons? V3481) (let X (hd V3481) (let V3482 (shen.lazyderef (tl V3481) V3502) (if (cons? V3482) (let V3483 (shen.lazyderef (hd V3482) V3502) (if (= : V3483) (let V3484 (shen.lazyderef (tl V3482) V3502) (if (cons? V3484) (let A (hd V3484) (let V3485 (shen.lazyderef (tl V3484) V3502) (if (= () V3485) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V3502 (freeze (cut Throwcontrol V3502 (freeze (shen.th* X A V3501 V3502 V3503)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V3502) (do (shen.incinfs) (shen.show V3500 V3501 V3502 (freeze (bind Datatypes (value shen.*datatypes*) V3502 (freeze (shen.udefs* V3500 V3501 Datatypes V3502 V3503))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V3509) (cond ((= + V3509) (set shen.*shen-type-theory-enabled?* true)) ((= - V3509) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V3520 V3521) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V3527 V3528 V3529 V3530 V3531) (let Case (let V3476 (shen.lazyderef V3529 V3530) (if (cons? V3476) (let D (hd V3476) (do (shen.incinfs) (call (cons D (cons V3527 (cons V3528 ()))) V3530 V3531))) false)) (if (= Case false) (let V3477 (shen.lazyderef V3529 V3530) (if (cons? V3477) (let Ds (tl V3477) (do (shen.incinfs) (shen.udefs* V3527 V3528 Ds V3530 V3531))) false)) Case)))

(defun shen.th* (V3537 V3538 V3539 V3540 V3541) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V3537 (cons : (cons V3538 ()))) V3539 V3540 (freeze (fwhen false V3540 V3541)))) (if (= Case false) (let Case (let F (shen.newpv V3540) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V3537 V3540)) V3540 (freeze (bind F (shen.sigf (shen.lazyderef V3537 V3540)) V3540 (freeze (call (cons F (cons V3538 ())) V3540 V3541))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V3537 V3538 V3540 V3541)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V3537 V3538 V3539 V3540 V3541)) (if (= Case false) (let Case (let V3372 (shen.lazyderef V3537 V3540) (if (cons? V3372) (let F (hd V3372) (let V3373 (shen.lazyderef (tl V3372) V3540) (if (= () V3373) (do (shen.incinfs) (shen.th* F (cons --> (cons V3538 ())) V3539 V3540 V3541)) false))) false)) (if (= Case false) (let Case (let V3374 (shen.lazyderef V3537 V3540) (if (cons? V3374) (let F (hd V3374) (let V3375 (shen.lazyderef (tl V3374) V3540) (if (cons? V3375) (let X (hd V3375) (let V3376 (shen.lazyderef (tl V3375) V3540) (if (= () V3376) (let B (shen.newpv V3540) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V3538 ()))) V3539 V3540 (freeze (shen.th* X B V3539 V3540 V3541))))) false))) false))) false)) (if (= Case false) (let Case (let V3377 (shen.lazyderef V3537 V3540) (if (cons? V3377) (let V3378 (shen.lazyderef (hd V3377) V3540) (if (= cons V3378) (let V3379 (shen.lazyderef (tl V3377) V3540) (if (cons? V3379) (let X (hd V3379) (let V3380 (shen.lazyderef (tl V3379) V3540) (if (cons? V3380) (let Y (hd V3380) (let V3381 (shen.lazyderef (tl V3380) V3540) (if (= () V3381) (let V3382 (shen.lazyderef V3538 V3540) (if (cons? V3382) (let V3383 (shen.lazyderef (hd V3382) V3540) (if (= list V3383) (let V3384 (shen.lazyderef (tl V3382) V3540) (if (cons? V3384) (let A (hd V3384) (let V3385 (shen.lazyderef (tl V3384) V3540) (if (= () V3385) (do (shen.incinfs) (shen.th* X A V3539 V3540 (freeze (shen.th* Y (cons list (cons A ())) V3539 V3540 V3541)))) (if (shen.pvar? V3385) (do (shen.bindv V3385 () V3540) (let Result (do (shen.incinfs) (shen.th* X A V3539 V3540 (freeze (shen.th* Y (cons list (cons A ())) V3539 V3540 V3541)))) (do (shen.unbindv V3385 V3540) Result))) false)))) (if (shen.pvar? V3384) (let A (shen.newpv V3540) (do (shen.bindv V3384 (cons A ()) V3540) (let Result (do (shen.incinfs) (shen.th* X A V3539 V3540 (freeze (shen.th* Y (cons list (cons A ())) V3539 V3540 V3541)))) (do (shen.unbindv V3384 V3540) Result)))) false))) (if (shen.pvar? V3383) (do (shen.bindv V3383 list V3540) (let Result (let V3386 (shen.lazyderef (tl V3382) V3540) (if (cons? V3386) (let A (hd V3386) (let V3387 (shen.lazyderef (tl V3386) V3540) (if (= () V3387) (do (shen.incinfs) (shen.th* X A V3539 V3540 (freeze (shen.th* Y (cons list (cons A ())) V3539 V3540 V3541)))) (if (shen.pvar? V3387) (do (shen.bindv V3387 () V3540) (let Result (do (shen.incinfs) (shen.th* X A V3539 V3540 (freeze (shen.th* Y (cons list (cons A ())) V3539 V3540 V3541)))) (do (shen.unbindv V3387 V3540) Result))) false)))) (if (shen.pvar? V3386) (let A (shen.newpv V3540) (do (shen.bindv V3386 (cons A ()) V3540) (let Result (do (shen.incinfs) (shen.th* X A V3539 V3540 (freeze (shen.th* Y (cons list (cons A ())) V3539 V3540 V3541)))) (do (shen.unbindv V3386 V3540) Result)))) false))) (do (shen.unbindv V3383 V3540) Result))) false))) (if (shen.pvar? V3382) (let A (shen.newpv V3540) (do (shen.bindv V3382 (cons list (cons A ())) V3540) (let Result (do (shen.incinfs) (shen.th* X A V3539 V3540 (freeze (shen.th* Y (cons list (cons A ())) V3539 V3540 V3541)))) (do (shen.unbindv V3382 V3540) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3388 (shen.lazyderef V3537 V3540) (if (cons? V3388) (let V3389 (shen.lazyderef (hd V3388) V3540) (if (= @p V3389) (let V3390 (shen.lazyderef (tl V3388) V3540) (if (cons? V3390) (let X (hd V3390) (let V3391 (shen.lazyderef (tl V3390) V3540) (if (cons? V3391) (let Y (hd V3391) (let V3392 (shen.lazyderef (tl V3391) V3540) (if (= () V3392) (let V3393 (shen.lazyderef V3538 V3540) (if (cons? V3393) (let A (hd V3393) (let V3394 (shen.lazyderef (tl V3393) V3540) (if (cons? V3394) (let V3395 (shen.lazyderef (hd V3394) V3540) (if (= * V3395) (let V3396 (shen.lazyderef (tl V3394) V3540) (if (cons? V3396) (let B (hd V3396) (let V3397 (shen.lazyderef (tl V3396) V3540) (if (= () V3397) (do (shen.incinfs) (shen.th* X A V3539 V3540 (freeze (shen.th* Y B V3539 V3540 V3541)))) (if (shen.pvar? V3397) (do (shen.bindv V3397 () V3540) (let Result (do (shen.incinfs) (shen.th* X A V3539 V3540 (freeze (shen.th* Y B V3539 V3540 V3541)))) (do (shen.unbindv V3397 V3540) Result))) false)))) (if (shen.pvar? V3396) (let B (shen.newpv V3540) (do (shen.bindv V3396 (cons B ()) V3540) (let Result (do (shen.incinfs) (shen.th* X A V3539 V3540 (freeze (shen.th* Y B V3539 V3540 V3541)))) (do (shen.unbindv V3396 V3540) Result)))) false))) (if (shen.pvar? V3395) (do (shen.bindv V3395 * V3540) (let Result (let V3398 (shen.lazyderef (tl V3394) V3540) (if (cons? V3398) (let B (hd V3398) (let V3399 (shen.lazyderef (tl V3398) V3540) (if (= () V3399) (do (shen.incinfs) (shen.th* X A V3539 V3540 (freeze (shen.th* Y B V3539 V3540 V3541)))) (if (shen.pvar? V3399) (do (shen.bindv V3399 () V3540) (let Result (do (shen.incinfs) (shen.th* X A V3539 V3540 (freeze (shen.th* Y B V3539 V3540 V3541)))) (do (shen.unbindv V3399 V3540) Result))) false)))) (if (shen.pvar? V3398) (let B (shen.newpv V3540) (do (shen.bindv V3398 (cons B ()) V3540) (let Result (do (shen.incinfs) (shen.th* X A V3539 V3540 (freeze (shen.th* Y B V3539 V3540 V3541)))) (do (shen.unbindv V3398 V3540) Result)))) false))) (do (shen.unbindv V3395 V3540) Result))) false))) (if (shen.pvar? V3394) (let B (shen.newpv V3540) (do (shen.bindv V3394 (cons * (cons B ())) V3540) (let Result (do (shen.incinfs) (shen.th* X A V3539 V3540 (freeze (shen.th* Y B V3539 V3540 V3541)))) (do (shen.unbindv V3394 V3540) Result)))) false)))) (if (shen.pvar? V3393) (let A (shen.newpv V3540) (let B (shen.newpv V3540) (do (shen.bindv V3393 (cons A (cons * (cons B ()))) V3540) (let Result (do (shen.incinfs) (shen.th* X A V3539 V3540 (freeze (shen.th* Y B V3539 V3540 V3541)))) (do (shen.unbindv V3393 V3540) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3400 (shen.lazyderef V3537 V3540) (if (cons? V3400) (let V3401 (shen.lazyderef (hd V3400) V3540) (if (= @v V3401) (let V3402 (shen.lazyderef (tl V3400) V3540) (if (cons? V3402) (let X (hd V3402) (let V3403 (shen.lazyderef (tl V3402) V3540) (if (cons? V3403) (let Y (hd V3403) (let V3404 (shen.lazyderef (tl V3403) V3540) (if (= () V3404) (let V3405 (shen.lazyderef V3538 V3540) (if (cons? V3405) (let V3406 (shen.lazyderef (hd V3405) V3540) (if (= vector V3406) (let V3407 (shen.lazyderef (tl V3405) V3540) (if (cons? V3407) (let A (hd V3407) (let V3408 (shen.lazyderef (tl V3407) V3540) (if (= () V3408) (do (shen.incinfs) (shen.th* X A V3539 V3540 (freeze (shen.th* Y (cons vector (cons A ())) V3539 V3540 V3541)))) (if (shen.pvar? V3408) (do (shen.bindv V3408 () V3540) (let Result (do (shen.incinfs) (shen.th* X A V3539 V3540 (freeze (shen.th* Y (cons vector (cons A ())) V3539 V3540 V3541)))) (do (shen.unbindv V3408 V3540) Result))) false)))) (if (shen.pvar? V3407) (let A (shen.newpv V3540) (do (shen.bindv V3407 (cons A ()) V3540) (let Result (do (shen.incinfs) (shen.th* X A V3539 V3540 (freeze (shen.th* Y (cons vector (cons A ())) V3539 V3540 V3541)))) (do (shen.unbindv V3407 V3540) Result)))) false))) (if (shen.pvar? V3406) (do (shen.bindv V3406 vector V3540) (let Result (let V3409 (shen.lazyderef (tl V3405) V3540) (if (cons? V3409) (let A (hd V3409) (let V3410 (shen.lazyderef (tl V3409) V3540) (if (= () V3410) (do (shen.incinfs) (shen.th* X A V3539 V3540 (freeze (shen.th* Y (cons vector (cons A ())) V3539 V3540 V3541)))) (if (shen.pvar? V3410) (do (shen.bindv V3410 () V3540) (let Result (do (shen.incinfs) (shen.th* X A V3539 V3540 (freeze (shen.th* Y (cons vector (cons A ())) V3539 V3540 V3541)))) (do (shen.unbindv V3410 V3540) Result))) false)))) (if (shen.pvar? V3409) (let A (shen.newpv V3540) (do (shen.bindv V3409 (cons A ()) V3540) (let Result (do (shen.incinfs) (shen.th* X A V3539 V3540 (freeze (shen.th* Y (cons vector (cons A ())) V3539 V3540 V3541)))) (do (shen.unbindv V3409 V3540) Result)))) false))) (do (shen.unbindv V3406 V3540) Result))) false))) (if (shen.pvar? V3405) (let A (shen.newpv V3540) (do (shen.bindv V3405 (cons vector (cons A ())) V3540) (let Result (do (shen.incinfs) (shen.th* X A V3539 V3540 (freeze (shen.th* Y (cons vector (cons A ())) V3539 V3540 V3541)))) (do (shen.unbindv V3405 V3540) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3411 (shen.lazyderef V3537 V3540) (if (cons? V3411) (let V3412 (shen.lazyderef (hd V3411) V3540) (if (= @s V3412) (let V3413 (shen.lazyderef (tl V3411) V3540) (if (cons? V3413) (let X (hd V3413) (let V3414 (shen.lazyderef (tl V3413) V3540) (if (cons? V3414) (let Y (hd V3414) (let V3415 (shen.lazyderef (tl V3414) V3540) (if (= () V3415) (let V3416 (shen.lazyderef V3538 V3540) (if (= string V3416) (do (shen.incinfs) (shen.th* X string V3539 V3540 (freeze (shen.th* Y string V3539 V3540 V3541)))) (if (shen.pvar? V3416) (do (shen.bindv V3416 string V3540) (let Result (do (shen.incinfs) (shen.th* X string V3539 V3540 (freeze (shen.th* Y string V3539 V3540 V3541)))) (do (shen.unbindv V3416 V3540) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3417 (shen.lazyderef V3537 V3540) (if (cons? V3417) (let V3418 (shen.lazyderef (hd V3417) V3540) (if (= lambda V3418) (let V3419 (shen.lazyderef (tl V3417) V3540) (if (cons? V3419) (let X (hd V3419) (let V3420 (shen.lazyderef (tl V3419) V3540) (if (cons? V3420) (let Y (hd V3420) (let V3421 (shen.lazyderef (tl V3420) V3540) (if (= () V3421) (let V3422 (shen.lazyderef V3538 V3540) (if (cons? V3422) (let A (hd V3422) (let V3423 (shen.lazyderef (tl V3422) V3540) (if (cons? V3423) (let V3424 (shen.lazyderef (hd V3423) V3540) (if (= --> V3424) (let V3425 (shen.lazyderef (tl V3423) V3540) (if (cons? V3425) (let B (hd V3425) (let V3426 (shen.lazyderef (tl V3425) V3540) (if (= () V3426) (let Z (shen.newpv V3540) (let X&& (shen.newpv V3540) (do (shen.incinfs) (cut Throwcontrol V3540 (freeze (bind X&& (shen.placeholder) V3540 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3540) (shen.lazyderef X V3540) (shen.lazyderef Y V3540)) V3540 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3539) V3540 V3541)))))))))) (if (shen.pvar? V3426) (do (shen.bindv V3426 () V3540) (let Result (let Z (shen.newpv V3540) (let X&& (shen.newpv V3540) (do (shen.incinfs) (cut Throwcontrol V3540 (freeze (bind X&& (shen.placeholder) V3540 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3540) (shen.lazyderef X V3540) (shen.lazyderef Y V3540)) V3540 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3539) V3540 V3541)))))))))) (do (shen.unbindv V3426 V3540) Result))) false)))) (if (shen.pvar? V3425) (let B (shen.newpv V3540) (do (shen.bindv V3425 (cons B ()) V3540) (let Result (let Z (shen.newpv V3540) (let X&& (shen.newpv V3540) (do (shen.incinfs) (cut Throwcontrol V3540 (freeze (bind X&& (shen.placeholder) V3540 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3540) (shen.lazyderef X V3540) (shen.lazyderef Y V3540)) V3540 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3539) V3540 V3541)))))))))) (do (shen.unbindv V3425 V3540) Result)))) false))) (if (shen.pvar? V3424) (do (shen.bindv V3424 --> V3540) (let Result (let V3427 (shen.lazyderef (tl V3423) V3540) (if (cons? V3427) (let B (hd V3427) (let V3428 (shen.lazyderef (tl V3427) V3540) (if (= () V3428) (let Z (shen.newpv V3540) (let X&& (shen.newpv V3540) (do (shen.incinfs) (cut Throwcontrol V3540 (freeze (bind X&& (shen.placeholder) V3540 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3540) (shen.lazyderef X V3540) (shen.lazyderef Y V3540)) V3540 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3539) V3540 V3541)))))))))) (if (shen.pvar? V3428) (do (shen.bindv V3428 () V3540) (let Result (let Z (shen.newpv V3540) (let X&& (shen.newpv V3540) (do (shen.incinfs) (cut Throwcontrol V3540 (freeze (bind X&& (shen.placeholder) V3540 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3540) (shen.lazyderef X V3540) (shen.lazyderef Y V3540)) V3540 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3539) V3540 V3541)))))))))) (do (shen.unbindv V3428 V3540) Result))) false)))) (if (shen.pvar? V3427) (let B (shen.newpv V3540) (do (shen.bindv V3427 (cons B ()) V3540) (let Result (let Z (shen.newpv V3540) (let X&& (shen.newpv V3540) (do (shen.incinfs) (cut Throwcontrol V3540 (freeze (bind X&& (shen.placeholder) V3540 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3540) (shen.lazyderef X V3540) (shen.lazyderef Y V3540)) V3540 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3539) V3540 V3541)))))))))) (do (shen.unbindv V3427 V3540) Result)))) false))) (do (shen.unbindv V3424 V3540) Result))) false))) (if (shen.pvar? V3423) (let B (shen.newpv V3540) (do (shen.bindv V3423 (cons --> (cons B ())) V3540) (let Result (let Z (shen.newpv V3540) (let X&& (shen.newpv V3540) (do (shen.incinfs) (cut Throwcontrol V3540 (freeze (bind X&& (shen.placeholder) V3540 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3540) (shen.lazyderef X V3540) (shen.lazyderef Y V3540)) V3540 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3539) V3540 V3541)))))))))) (do (shen.unbindv V3423 V3540) Result)))) false)))) (if (shen.pvar? V3422) (let A (shen.newpv V3540) (let B (shen.newpv V3540) (do (shen.bindv V3422 (cons A (cons --> (cons B ()))) V3540) (let Result (let Z (shen.newpv V3540) (let X&& (shen.newpv V3540) (do (shen.incinfs) (cut Throwcontrol V3540 (freeze (bind X&& (shen.placeholder) V3540 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3540) (shen.lazyderef X V3540) (shen.lazyderef Y V3540)) V3540 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3539) V3540 V3541)))))))))) (do (shen.unbindv V3422 V3540) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3429 (shen.lazyderef V3537 V3540) (if (cons? V3429) (let V3430 (shen.lazyderef (hd V3429) V3540) (if (= let V3430) (let V3431 (shen.lazyderef (tl V3429) V3540) (if (cons? V3431) (let X (hd V3431) (let V3432 (shen.lazyderef (tl V3431) V3540) (if (cons? V3432) (let Y (hd V3432) (let V3433 (shen.lazyderef (tl V3432) V3540) (if (cons? V3433) (let Z (hd V3433) (let V3434 (shen.lazyderef (tl V3433) V3540) (if (= () V3434) (let W (shen.newpv V3540) (let X&& (shen.newpv V3540) (let B (shen.newpv V3540) (do (shen.incinfs) (shen.th* Y B V3539 V3540 (freeze (bind X&& (shen.placeholder) V3540 (freeze (bind W (shen.ebr (shen.lazyderef X&& V3540) (shen.lazyderef X V3540) (shen.lazyderef Z V3540)) V3540 (freeze (shen.th* W V3538 (cons (cons X&& (cons : (cons B ()))) V3539) V3540 V3541))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3435 (shen.lazyderef V3537 V3540) (if (cons? V3435) (let V3436 (shen.lazyderef (hd V3435) V3540) (if (= open V3436) (let V3437 (shen.lazyderef (tl V3435) V3540) (if (cons? V3437) (let FileName (hd V3437) (let V3438 (shen.lazyderef (tl V3437) V3540) (if (cons? V3438) (let Direction3368 (hd V3438) (let V3439 (shen.lazyderef (tl V3438) V3540) (if (= () V3439) (let V3440 (shen.lazyderef V3538 V3540) (if (cons? V3440) (let V3441 (shen.lazyderef (hd V3440) V3540) (if (= stream V3441) (let V3442 (shen.lazyderef (tl V3440) V3540) (if (cons? V3442) (let Direction (hd V3442) (let V3443 (shen.lazyderef (tl V3442) V3540) (if (= () V3443) (do (shen.incinfs) (unify! Direction Direction3368 V3540 (freeze (cut Throwcontrol V3540 (freeze (fwhen (element? (shen.lazyderef Direction V3540) (cons in (cons out ()))) V3540 (freeze (shen.th* FileName string V3539 V3540 V3541)))))))) (if (shen.pvar? V3443) (do (shen.bindv V3443 () V3540) (let Result (do (shen.incinfs) (unify! Direction Direction3368 V3540 (freeze (cut Throwcontrol V3540 (freeze (fwhen (element? (shen.lazyderef Direction V3540) (cons in (cons out ()))) V3540 (freeze (shen.th* FileName string V3539 V3540 V3541)))))))) (do (shen.unbindv V3443 V3540) Result))) false)))) (if (shen.pvar? V3442) (let Direction (shen.newpv V3540) (do (shen.bindv V3442 (cons Direction ()) V3540) (let Result (do (shen.incinfs) (unify! Direction Direction3368 V3540 (freeze (cut Throwcontrol V3540 (freeze (fwhen (element? (shen.lazyderef Direction V3540) (cons in (cons out ()))) V3540 (freeze (shen.th* FileName string V3539 V3540 V3541)))))))) (do (shen.unbindv V3442 V3540) Result)))) false))) (if (shen.pvar? V3441) (do (shen.bindv V3441 stream V3540) (let Result (let V3444 (shen.lazyderef (tl V3440) V3540) (if (cons? V3444) (let Direction (hd V3444) (let V3445 (shen.lazyderef (tl V3444) V3540) (if (= () V3445) (do (shen.incinfs) (unify! Direction Direction3368 V3540 (freeze (cut Throwcontrol V3540 (freeze (fwhen (element? (shen.lazyderef Direction V3540) (cons in (cons out ()))) V3540 (freeze (shen.th* FileName string V3539 V3540 V3541)))))))) (if (shen.pvar? V3445) (do (shen.bindv V3445 () V3540) (let Result (do (shen.incinfs) (unify! Direction Direction3368 V3540 (freeze (cut Throwcontrol V3540 (freeze (fwhen (element? (shen.lazyderef Direction V3540) (cons in (cons out ()))) V3540 (freeze (shen.th* FileName string V3539 V3540 V3541)))))))) (do (shen.unbindv V3445 V3540) Result))) false)))) (if (shen.pvar? V3444) (let Direction (shen.newpv V3540) (do (shen.bindv V3444 (cons Direction ()) V3540) (let Result (do (shen.incinfs) (unify! Direction Direction3368 V3540 (freeze (cut Throwcontrol V3540 (freeze (fwhen (element? (shen.lazyderef Direction V3540) (cons in (cons out ()))) V3540 (freeze (shen.th* FileName string V3539 V3540 V3541)))))))) (do (shen.unbindv V3444 V3540) Result)))) false))) (do (shen.unbindv V3441 V3540) Result))) false))) (if (shen.pvar? V3440) (let Direction (shen.newpv V3540) (do (shen.bindv V3440 (cons stream (cons Direction ())) V3540) (let Result (do (shen.incinfs) (unify! Direction Direction3368 V3540 (freeze (cut Throwcontrol V3540 (freeze (fwhen (element? (shen.lazyderef Direction V3540) (cons in (cons out ()))) V3540 (freeze (shen.th* FileName string V3539 V3540 V3541)))))))) (do (shen.unbindv V3440 V3540) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3446 (shen.lazyderef V3537 V3540) (if (cons? V3446) (let V3447 (shen.lazyderef (hd V3446) V3540) (if (= type V3447) (let V3448 (shen.lazyderef (tl V3446) V3540) (if (cons? V3448) (let X (hd V3448) (let V3449 (shen.lazyderef (tl V3448) V3540) (if (cons? V3449) (let A (hd V3449) (let V3450 (shen.lazyderef (tl V3449) V3540) (if (= () V3450) (do (shen.incinfs) (cut Throwcontrol V3540 (freeze (unify A V3538 V3540 (freeze (shen.th* X A V3539 V3540 V3541)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3451 (shen.lazyderef V3537 V3540) (if (cons? V3451) (let V3452 (shen.lazyderef (hd V3451) V3540) (if (= input+ V3452) (let V3453 (shen.lazyderef (tl V3451) V3540) (if (cons? V3453) (let A (hd V3453) (let V3454 (shen.lazyderef (tl V3453) V3540) (if (cons? V3454) (let Stream (hd V3454) (let V3455 (shen.lazyderef (tl V3454) V3540) (if (= () V3455) (let C (shen.newpv V3540) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V3540)) V3540 (freeze (unify V3538 C V3540 (freeze (shen.th* Stream (cons stream (cons in ())) V3539 V3540 V3541))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3456 (shen.lazyderef V3537 V3540) (if (cons? V3456) (let V3457 (shen.lazyderef (hd V3456) V3540) (if (= set V3457) (let V3458 (shen.lazyderef (tl V3456) V3540) (if (cons? V3458) (let Var (hd V3458) (let V3459 (shen.lazyderef (tl V3458) V3540) (if (cons? V3459) (let Val (hd V3459) (let V3460 (shen.lazyderef (tl V3459) V3540) (if (= () V3460) (do (shen.incinfs) (cut Throwcontrol V3540 (freeze (shen.th* Var symbol V3539 V3540 (freeze (cut Throwcontrol V3540 (freeze (shen.th* (cons value (cons Var ())) V3538 V3539 V3540 (freeze (shen.th* Val V3538 V3539 V3540 V3541)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V3540) (do (shen.incinfs) (shen.t*-hyps V3539 NewHyp V3540 (freeze (shen.th* V3537 V3538 NewHyp V3540 V3541))))) (if (= Case false) (let Case (let V3461 (shen.lazyderef V3537 V3540) (if (cons? V3461) (let V3462 (shen.lazyderef (hd V3461) V3540) (if (= define V3462) (let V3463 (shen.lazyderef (tl V3461) V3540) (if (cons? V3463) (let F (hd V3463) (let X (tl V3463) (do (shen.incinfs) (cut Throwcontrol V3540 (freeze (shen.t*-def (cons define (cons F X)) V3538 V3539 V3540 V3541)))))) false)) false)) false)) (if (= Case false) (let Case (let V3464 (shen.lazyderef V3537 V3540) (if (cons? V3464) (let V3465 (shen.lazyderef (hd V3464) V3540) (if (= defmacro V3465) (let V3466 (shen.lazyderef V3538 V3540) (if (= unit V3466) (do (shen.incinfs) (cut Throwcontrol V3540 V3541)) (if (shen.pvar? V3466) (do (shen.bindv V3466 unit V3540) (let Result (do (shen.incinfs) (cut Throwcontrol V3540 V3541)) (do (shen.unbindv V3466 V3540) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3467 (shen.lazyderef V3537 V3540) (if (cons? V3467) (let V3468 (shen.lazyderef (hd V3467) V3540) (if (= shen.process-datatype V3468) (let V3469 (shen.lazyderef V3538 V3540) (if (= symbol V3469) (do (shen.incinfs) (thaw V3541)) (if (shen.pvar? V3469) (do (shen.bindv V3469 symbol V3540) (let Result (do (shen.incinfs) (thaw V3541)) (do (shen.unbindv V3469 V3540) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3470 (shen.lazyderef V3537 V3540) (if (cons? V3470) (let V3471 (shen.lazyderef (hd V3470) V3540) (if (= shen.synonyms-help V3471) (let V3472 (shen.lazyderef V3538 V3540) (if (= symbol V3472) (do (shen.incinfs) (thaw V3541)) (if (shen.pvar? V3472) (do (shen.bindv V3472 symbol V3540) (let Result (do (shen.incinfs) (thaw V3541)) (do (shen.unbindv V3472 V3540) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V3540) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V3540 (freeze (shen.udefs* (cons V3537 (cons : (cons V3538 ()))) V3539 Datatypes V3540 V3541))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V3546 V3547 V3548 V3549) (let Case (let V3283 (shen.lazyderef V3546 V3548) (if (cons? V3283) (let V3284 (shen.lazyderef (hd V3283) V3548) (if (cons? V3284) (let V3285 (shen.lazyderef (hd V3284) V3548) (if (cons? V3285) (let V3286 (shen.lazyderef (hd V3285) V3548) (if (= cons V3286) (let V3287 (shen.lazyderef (tl V3285) V3548) (if (cons? V3287) (let X (hd V3287) (let V3288 (shen.lazyderef (tl V3287) V3548) (if (cons? V3288) (let Y (hd V3288) (let V3289 (shen.lazyderef (tl V3288) V3548) (if (= () V3289) (let V3290 (shen.lazyderef (tl V3284) V3548) (if (cons? V3290) (let V3291 (shen.lazyderef (hd V3290) V3548) (if (= : V3291) (let V3292 (shen.lazyderef (tl V3290) V3548) (if (cons? V3292) (let V3293 (shen.lazyderef (hd V3292) V3548) (if (cons? V3293) (let V3294 (shen.lazyderef (hd V3293) V3548) (if (= list V3294) (let V3295 (shen.lazyderef (tl V3293) V3548) (if (cons? V3295) (let A (hd V3295) (let V3296 (shen.lazyderef (tl V3295) V3548) (if (= () V3296) (let V3297 (shen.lazyderef (tl V3292) V3548) (if (= () V3297) (let Hyp (tl V3283) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons list (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3297) (do (shen.bindv V3297 () V3548) (let Result (let Hyp (tl V3283) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons list (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3297 V3548) Result))) false))) (if (shen.pvar? V3296) (do (shen.bindv V3296 () V3548) (let Result (let V3298 (shen.lazyderef (tl V3292) V3548) (if (= () V3298) (let Hyp (tl V3283) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons list (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3298) (do (shen.bindv V3298 () V3548) (let Result (let Hyp (tl V3283) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons list (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3298 V3548) Result))) false))) (do (shen.unbindv V3296 V3548) Result))) false)))) (if (shen.pvar? V3295) (let A (shen.newpv V3548) (do (shen.bindv V3295 (cons A ()) V3548) (let Result (let V3299 (shen.lazyderef (tl V3292) V3548) (if (= () V3299) (let Hyp (tl V3283) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons list (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3299) (do (shen.bindv V3299 () V3548) (let Result (let Hyp (tl V3283) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons list (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3299 V3548) Result))) false))) (do (shen.unbindv V3295 V3548) Result)))) false))) (if (shen.pvar? V3294) (do (shen.bindv V3294 list V3548) (let Result (let V3300 (shen.lazyderef (tl V3293) V3548) (if (cons? V3300) (let A (hd V3300) (let V3301 (shen.lazyderef (tl V3300) V3548) (if (= () V3301) (let V3302 (shen.lazyderef (tl V3292) V3548) (if (= () V3302) (let Hyp (tl V3283) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons list (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3302) (do (shen.bindv V3302 () V3548) (let Result (let Hyp (tl V3283) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons list (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3302 V3548) Result))) false))) (if (shen.pvar? V3301) (do (shen.bindv V3301 () V3548) (let Result (let V3303 (shen.lazyderef (tl V3292) V3548) (if (= () V3303) (let Hyp (tl V3283) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons list (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3303) (do (shen.bindv V3303 () V3548) (let Result (let Hyp (tl V3283) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons list (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3303 V3548) Result))) false))) (do (shen.unbindv V3301 V3548) Result))) false)))) (if (shen.pvar? V3300) (let A (shen.newpv V3548) (do (shen.bindv V3300 (cons A ()) V3548) (let Result (let V3304 (shen.lazyderef (tl V3292) V3548) (if (= () V3304) (let Hyp (tl V3283) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons list (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3304) (do (shen.bindv V3304 () V3548) (let Result (let Hyp (tl V3283) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons list (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3304 V3548) Result))) false))) (do (shen.unbindv V3300 V3548) Result)))) false))) (do (shen.unbindv V3294 V3548) Result))) false))) (if (shen.pvar? V3293) (let A (shen.newpv V3548) (do (shen.bindv V3293 (cons list (cons A ())) V3548) (let Result (let V3305 (shen.lazyderef (tl V3292) V3548) (if (= () V3305) (let Hyp (tl V3283) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons list (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3305) (do (shen.bindv V3305 () V3548) (let Result (let Hyp (tl V3283) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons list (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3305 V3548) Result))) false))) (do (shen.unbindv V3293 V3548) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3306 (shen.lazyderef V3546 V3548) (if (cons? V3306) (let V3307 (shen.lazyderef (hd V3306) V3548) (if (cons? V3307) (let V3308 (shen.lazyderef (hd V3307) V3548) (if (cons? V3308) (let V3309 (shen.lazyderef (hd V3308) V3548) (if (= @p V3309) (let V3310 (shen.lazyderef (tl V3308) V3548) (if (cons? V3310) (let X (hd V3310) (let V3311 (shen.lazyderef (tl V3310) V3548) (if (cons? V3311) (let Y (hd V3311) (let V3312 (shen.lazyderef (tl V3311) V3548) (if (= () V3312) (let V3313 (shen.lazyderef (tl V3307) V3548) (if (cons? V3313) (let V3314 (shen.lazyderef (hd V3313) V3548) (if (= : V3314) (let V3315 (shen.lazyderef (tl V3313) V3548) (if (cons? V3315) (let V3316 (shen.lazyderef (hd V3315) V3548) (if (cons? V3316) (let A (hd V3316) (let V3317 (shen.lazyderef (tl V3316) V3548) (if (cons? V3317) (let V3318 (shen.lazyderef (hd V3317) V3548) (if (= * V3318) (let V3319 (shen.lazyderef (tl V3317) V3548) (if (cons? V3319) (let B (hd V3319) (let V3320 (shen.lazyderef (tl V3319) V3548) (if (= () V3320) (let V3321 (shen.lazyderef (tl V3315) V3548) (if (= () V3321) (let Hyp (tl V3306) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (shen.lazyderef B V3548) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3321) (do (shen.bindv V3321 () V3548) (let Result (let Hyp (tl V3306) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (shen.lazyderef B V3548) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3321 V3548) Result))) false))) (if (shen.pvar? V3320) (do (shen.bindv V3320 () V3548) (let Result (let V3322 (shen.lazyderef (tl V3315) V3548) (if (= () V3322) (let Hyp (tl V3306) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (shen.lazyderef B V3548) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3322) (do (shen.bindv V3322 () V3548) (let Result (let Hyp (tl V3306) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (shen.lazyderef B V3548) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3322 V3548) Result))) false))) (do (shen.unbindv V3320 V3548) Result))) false)))) (if (shen.pvar? V3319) (let B (shen.newpv V3548) (do (shen.bindv V3319 (cons B ()) V3548) (let Result (let V3323 (shen.lazyderef (tl V3315) V3548) (if (= () V3323) (let Hyp (tl V3306) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (shen.lazyderef B V3548) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3323) (do (shen.bindv V3323 () V3548) (let Result (let Hyp (tl V3306) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (shen.lazyderef B V3548) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3323 V3548) Result))) false))) (do (shen.unbindv V3319 V3548) Result)))) false))) (if (shen.pvar? V3318) (do (shen.bindv V3318 * V3548) (let Result (let V3324 (shen.lazyderef (tl V3317) V3548) (if (cons? V3324) (let B (hd V3324) (let V3325 (shen.lazyderef (tl V3324) V3548) (if (= () V3325) (let V3326 (shen.lazyderef (tl V3315) V3548) (if (= () V3326) (let Hyp (tl V3306) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (shen.lazyderef B V3548) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3326) (do (shen.bindv V3326 () V3548) (let Result (let Hyp (tl V3306) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (shen.lazyderef B V3548) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3326 V3548) Result))) false))) (if (shen.pvar? V3325) (do (shen.bindv V3325 () V3548) (let Result (let V3327 (shen.lazyderef (tl V3315) V3548) (if (= () V3327) (let Hyp (tl V3306) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (shen.lazyderef B V3548) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3327) (do (shen.bindv V3327 () V3548) (let Result (let Hyp (tl V3306) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (shen.lazyderef B V3548) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3327 V3548) Result))) false))) (do (shen.unbindv V3325 V3548) Result))) false)))) (if (shen.pvar? V3324) (let B (shen.newpv V3548) (do (shen.bindv V3324 (cons B ()) V3548) (let Result (let V3328 (shen.lazyderef (tl V3315) V3548) (if (= () V3328) (let Hyp (tl V3306) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (shen.lazyderef B V3548) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3328) (do (shen.bindv V3328 () V3548) (let Result (let Hyp (tl V3306) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (shen.lazyderef B V3548) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3328 V3548) Result))) false))) (do (shen.unbindv V3324 V3548) Result)))) false))) (do (shen.unbindv V3318 V3548) Result))) false))) (if (shen.pvar? V3317) (let B (shen.newpv V3548) (do (shen.bindv V3317 (cons * (cons B ())) V3548) (let Result (let V3329 (shen.lazyderef (tl V3315) V3548) (if (= () V3329) (let Hyp (tl V3306) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (shen.lazyderef B V3548) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3329) (do (shen.bindv V3329 () V3548) (let Result (let Hyp (tl V3306) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (shen.lazyderef B V3548) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3329 V3548) Result))) false))) (do (shen.unbindv V3317 V3548) Result)))) false)))) (if (shen.pvar? V3316) (let A (shen.newpv V3548) (let B (shen.newpv V3548) (do (shen.bindv V3316 (cons A (cons * (cons B ()))) V3548) (let Result (let V3330 (shen.lazyderef (tl V3315) V3548) (if (= () V3330) (let Hyp (tl V3306) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (shen.lazyderef B V3548) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3330) (do (shen.bindv V3330 () V3548) (let Result (let Hyp (tl V3306) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (shen.lazyderef B V3548) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3330 V3548) Result))) false))) (do (shen.unbindv V3316 V3548) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3331 (shen.lazyderef V3546 V3548) (if (cons? V3331) (let V3332 (shen.lazyderef (hd V3331) V3548) (if (cons? V3332) (let V3333 (shen.lazyderef (hd V3332) V3548) (if (cons? V3333) (let V3334 (shen.lazyderef (hd V3333) V3548) (if (= @v V3334) (let V3335 (shen.lazyderef (tl V3333) V3548) (if (cons? V3335) (let X (hd V3335) (let V3336 (shen.lazyderef (tl V3335) V3548) (if (cons? V3336) (let Y (hd V3336) (let V3337 (shen.lazyderef (tl V3336) V3548) (if (= () V3337) (let V3338 (shen.lazyderef (tl V3332) V3548) (if (cons? V3338) (let V3339 (shen.lazyderef (hd V3338) V3548) (if (= : V3339) (let V3340 (shen.lazyderef (tl V3338) V3548) (if (cons? V3340) (let V3341 (shen.lazyderef (hd V3340) V3548) (if (cons? V3341) (let V3342 (shen.lazyderef (hd V3341) V3548) (if (= vector V3342) (let V3343 (shen.lazyderef (tl V3341) V3548) (if (cons? V3343) (let A (hd V3343) (let V3344 (shen.lazyderef (tl V3343) V3548) (if (= () V3344) (let V3345 (shen.lazyderef (tl V3340) V3548) (if (= () V3345) (let Hyp (tl V3331) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons vector (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3345) (do (shen.bindv V3345 () V3548) (let Result (let Hyp (tl V3331) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons vector (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3345 V3548) Result))) false))) (if (shen.pvar? V3344) (do (shen.bindv V3344 () V3548) (let Result (let V3346 (shen.lazyderef (tl V3340) V3548) (if (= () V3346) (let Hyp (tl V3331) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons vector (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3346) (do (shen.bindv V3346 () V3548) (let Result (let Hyp (tl V3331) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons vector (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3346 V3548) Result))) false))) (do (shen.unbindv V3344 V3548) Result))) false)))) (if (shen.pvar? V3343) (let A (shen.newpv V3548) (do (shen.bindv V3343 (cons A ()) V3548) (let Result (let V3347 (shen.lazyderef (tl V3340) V3548) (if (= () V3347) (let Hyp (tl V3331) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons vector (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3347) (do (shen.bindv V3347 () V3548) (let Result (let Hyp (tl V3331) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons vector (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3347 V3548) Result))) false))) (do (shen.unbindv V3343 V3548) Result)))) false))) (if (shen.pvar? V3342) (do (shen.bindv V3342 vector V3548) (let Result (let V3348 (shen.lazyderef (tl V3341) V3548) (if (cons? V3348) (let A (hd V3348) (let V3349 (shen.lazyderef (tl V3348) V3548) (if (= () V3349) (let V3350 (shen.lazyderef (tl V3340) V3548) (if (= () V3350) (let Hyp (tl V3331) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons vector (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3350) (do (shen.bindv V3350 () V3548) (let Result (let Hyp (tl V3331) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons vector (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3350 V3548) Result))) false))) (if (shen.pvar? V3349) (do (shen.bindv V3349 () V3548) (let Result (let V3351 (shen.lazyderef (tl V3340) V3548) (if (= () V3351) (let Hyp (tl V3331) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons vector (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3351) (do (shen.bindv V3351 () V3548) (let Result (let Hyp (tl V3331) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons vector (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3351 V3548) Result))) false))) (do (shen.unbindv V3349 V3548) Result))) false)))) (if (shen.pvar? V3348) (let A (shen.newpv V3548) (do (shen.bindv V3348 (cons A ()) V3548) (let Result (let V3352 (shen.lazyderef (tl V3340) V3548) (if (= () V3352) (let Hyp (tl V3331) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons vector (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3352) (do (shen.bindv V3352 () V3548) (let Result (let Hyp (tl V3331) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons vector (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3352 V3548) Result))) false))) (do (shen.unbindv V3348 V3548) Result)))) false))) (do (shen.unbindv V3342 V3548) Result))) false))) (if (shen.pvar? V3341) (let A (shen.newpv V3548) (do (shen.bindv V3341 (cons vector (cons A ())) V3548) (let Result (let V3353 (shen.lazyderef (tl V3340) V3548) (if (= () V3353) (let Hyp (tl V3331) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons vector (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3353) (do (shen.bindv V3353 () V3548) (let Result (let Hyp (tl V3331) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons (shen.lazyderef A V3548) ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons (cons vector (cons (shen.lazyderef A V3548) ())) ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3353 V3548) Result))) false))) (do (shen.unbindv V3341 V3548) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3354 (shen.lazyderef V3546 V3548) (if (cons? V3354) (let V3355 (shen.lazyderef (hd V3354) V3548) (if (cons? V3355) (let V3356 (shen.lazyderef (hd V3355) V3548) (if (cons? V3356) (let V3357 (shen.lazyderef (hd V3356) V3548) (if (= @s V3357) (let V3358 (shen.lazyderef (tl V3356) V3548) (if (cons? V3358) (let X (hd V3358) (let V3359 (shen.lazyderef (tl V3358) V3548) (if (cons? V3359) (let Y (hd V3359) (let V3360 (shen.lazyderef (tl V3359) V3548) (if (= () V3360) (let V3361 (shen.lazyderef (tl V3355) V3548) (if (cons? V3361) (let V3362 (shen.lazyderef (hd V3361) V3548) (if (= : V3362) (let V3363 (shen.lazyderef (tl V3361) V3548) (if (cons? V3363) (let V3364 (shen.lazyderef (hd V3363) V3548) (if (= string V3364) (let V3365 (shen.lazyderef (tl V3363) V3548) (if (= () V3365) (let Hyp (tl V3354) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons string ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3365) (do (shen.bindv V3365 () V3548) (let Result (let Hyp (tl V3354) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons string ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3365 V3548) Result))) false))) (if (shen.pvar? V3364) (do (shen.bindv V3364 string V3548) (let Result (let V3366 (shen.lazyderef (tl V3363) V3548) (if (= () V3366) (let Hyp (tl V3354) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons string ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (if (shen.pvar? V3366) (do (shen.bindv V3366 () V3548) (let Result (let Hyp (tl V3354) (do (shen.incinfs) (bind V3547 (cons (cons (shen.lazyderef X V3548) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3548) (cons : (cons string ()))) (shen.lazyderef Hyp V3548))) V3548 V3549))) (do (shen.unbindv V3366 V3548) Result))) false))) (do (shen.unbindv V3364 V3548) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V3367 (shen.lazyderef V3546 V3548) (if (cons? V3367) (let X (hd V3367) (let Hyp (tl V3367) (let NewHyps (shen.newpv V3548) (do (shen.incinfs) (bind V3547 (cons (shen.lazyderef X V3548) (shen.lazyderef NewHyps V3548)) V3548 (freeze (shen.t*-hyps Hyp NewHyps V3548 V3549))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V3566 V3567 V3568 V3569) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V3566 V3568)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V3567 V3568) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V3569))))))))) (true (thaw V3569))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V3571) (cond ((and (cons? V3571) (and (cons? (tl V3571)) (and (= : (hd (tl V3571))) (and (cons? (tl (tl V3571))) (= () (tl (tl (tl V3571)))))))) (shen.prhush (shen.app (hd V3571) (cn " : " (shen.app (hd (tl (tl V3571))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V3571 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V3576 V3577) (cond ((= () V3576) shen.skip) ((cons? V3576) (do (shen.prhush (shen.app V3577 ". " shen.a) (stoutput)) (do (shen.show-p (hd V3576)) (do (nl 1) (shen.show-assumptions (tl V3576) (+ V3577 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V3579) (cons? (assoc V3579 (value shen.*signedfuncs*))))

(defun shen.sigf (V3581) (concat shen.type-signature-of- V3581))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V3586 V3587 V3588 V3589) (let Case (let V3270 (shen.lazyderef V3587 V3588) (if (= number V3270) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3586 V3588)) V3588 V3589)) (if (shen.pvar? V3270) (do (shen.bindv V3270 number V3588) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3586 V3588)) V3588 V3589)) (do (shen.unbindv V3270 V3588) Result))) false))) (if (= Case false) (let Case (let V3271 (shen.lazyderef V3587 V3588) (if (= boolean V3271) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3586 V3588)) V3588 V3589)) (if (shen.pvar? V3271) (do (shen.bindv V3271 boolean V3588) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3586 V3588)) V3588 V3589)) (do (shen.unbindv V3271 V3588) Result))) false))) (if (= Case false) (let Case (let V3272 (shen.lazyderef V3587 V3588) (if (= string V3272) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3586 V3588)) V3588 V3589)) (if (shen.pvar? V3272) (do (shen.bindv V3272 string V3588) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3586 V3588)) V3588 V3589)) (do (shen.unbindv V3272 V3588) Result))) false))) (if (= Case false) (let Case (let V3273 (shen.lazyderef V3587 V3588) (if (= symbol V3273) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3586 V3588)) V3588 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3586 V3588))) V3588 V3589)))) (if (shen.pvar? V3273) (do (shen.bindv V3273 symbol V3588) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3586 V3588)) V3588 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3586 V3588))) V3588 V3589)))) (do (shen.unbindv V3273 V3588) Result))) false))) (if (= Case false) (let V3274 (shen.lazyderef V3586 V3588) (if (= () V3274) (let V3275 (shen.lazyderef V3587 V3588) (if (cons? V3275) (let V3276 (shen.lazyderef (hd V3275) V3588) (if (= list V3276) (let V3277 (shen.lazyderef (tl V3275) V3588) (if (cons? V3277) (let A (hd V3277) (let V3278 (shen.lazyderef (tl V3277) V3588) (if (= () V3278) (do (shen.incinfs) (thaw V3589)) (if (shen.pvar? V3278) (do (shen.bindv V3278 () V3588) (let Result (do (shen.incinfs) (thaw V3589)) (do (shen.unbindv V3278 V3588) Result))) false)))) (if (shen.pvar? V3277) (let A (shen.newpv V3588) (do (shen.bindv V3277 (cons A ()) V3588) (let Result (do (shen.incinfs) (thaw V3589)) (do (shen.unbindv V3277 V3588) Result)))) false))) (if (shen.pvar? V3276) (do (shen.bindv V3276 list V3588) (let Result (let V3279 (shen.lazyderef (tl V3275) V3588) (if (cons? V3279) (let A (hd V3279) (let V3280 (shen.lazyderef (tl V3279) V3588) (if (= () V3280) (do (shen.incinfs) (thaw V3589)) (if (shen.pvar? V3280) (do (shen.bindv V3280 () V3588) (let Result (do (shen.incinfs) (thaw V3589)) (do (shen.unbindv V3280 V3588) Result))) false)))) (if (shen.pvar? V3279) (let A (shen.newpv V3588) (do (shen.bindv V3279 (cons A ()) V3588) (let Result (do (shen.incinfs) (thaw V3589)) (do (shen.unbindv V3279 V3588) Result)))) false))) (do (shen.unbindv V3276 V3588) Result))) false))) (if (shen.pvar? V3275) (let A (shen.newpv V3588) (do (shen.bindv V3275 (cons list (cons A ())) V3588) (let Result (do (shen.incinfs) (thaw V3589)) (do (shen.unbindv V3275 V3588) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V3595 V3596 V3597 V3598 V3599) (let Case (let V3261 (shen.lazyderef V3597 V3598) (if (cons? V3261) (let V3262 (shen.lazyderef (hd V3261) V3598) (if (cons? V3262) (let Y (hd V3262) (let V3263 (shen.lazyderef (tl V3262) V3598) (if (cons? V3263) (let V3264 (shen.lazyderef (hd V3263) V3598) (if (= : V3264) (let V3265 (shen.lazyderef (tl V3263) V3598) (if (cons? V3265) (let B (hd V3265) (let V3266 (shen.lazyderef (tl V3265) V3598) (if (= () V3266) (do (shen.incinfs) (identical V3595 Y V3598 (freeze (unify! V3596 B V3598 V3599)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V3267 (shen.lazyderef V3597 V3598) (if (cons? V3267) (let Hyp (tl V3267) (do (shen.incinfs) (shen.by_hypothesis V3595 V3596 Hyp V3598 V3599))) false)) Case)))

(defun shen.t*-def (V3605 V3606 V3607 V3608 V3609) (let V3255 (shen.lazyderef V3605 V3608) (if (cons? V3255) (let V3256 (shen.lazyderef (hd V3255) V3608) (if (= define V3256) (let V3257 (shen.lazyderef (tl V3255) V3608) (if (cons? V3257) (let F (hd V3257) (let X (tl V3257) (let Y (shen.newpv V3608) (let E (shen.newpv V3608) (do (shen.incinfs) (shen.t*-defh (compile (lambda Y (shen.<sig+rules> Y)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V3606 V3607 V3608 V3609)))))) false)) false)) false)))

(defun shen.t*-defh (V3616 V3617 V3618 V3619 V3620 V3621) (let V3251 (shen.lazyderef V3616 V3620) (if (cons? V3251) (let Sig (hd V3251) (let Rules (tl V3251) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V3617 V3618 V3619 Rules V3620 V3621)))) false)))

(defun shen.t*-defhh (V3630 V3631 V3632 V3633 V3634 V3635 V3636 V3637) (do (shen.incinfs) (shen.t*-rules V3635 V3631 1 V3632 (cons (cons V3632 (cons : (cons V3631 ()))) V3634) V3636 (freeze (shen.memo V3632 V3630 V3633 V3636 V3637)))))

(defun shen.memo (V3643 V3644 V3645 V3646 V3647) (let Jnk (shen.newpv V3646) (do (shen.incinfs) (unify! V3645 V3644 V3646 (freeze (bind Jnk (declare (shen.lazyderef V3643 V3646) (shen.lazyderef V3645 V3646)) V3646 V3647))))))

(defun shen.<sig+rules> (V3649) (let Parse_shen.<signature> (shen.<signature> V3649) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V3651) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V3651) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V3651) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V3653) (cond ((and (cons? V3653) (and (cons? (tl V3653)) (and (= () (tl (tl V3653))) (= (hd V3653) protect)))) V3653) ((cons? V3653) (map (lambda Z (shen.ue Z)) V3653)) ((variable? V3653) (concat && V3653)) (true V3653)))

(defun shen.ue-sig (V3655) (cond ((cons? V3655) (map (lambda Z (shen.ue-sig Z)) V3655)) ((variable? V3655) (concat &&& V3655)) (true V3655)))

(defun shen.ues (V3661) (cond ((shen.ue? V3661) (cons V3661 ())) ((cons? V3661) (union (shen.ues (hd V3661)) (shen.ues (tl V3661)))) (true ())))

(defun shen.ue? (V3663) (and (symbol? V3663) (shen.ue-h? (str V3663))))

(defun shen.ue-h? (V3671) (cond ((and (shen.+string? V3671) (and (= "&" (pos V3671 0)) (and (shen.+string? (tlstr V3671)) (= "&" (pos (tlstr V3671) 0))))) true) (true false)))

(defun shen.t*-rules (V3679 V3680 V3681 V3682 V3683 V3684 V3685) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3235 (shen.lazyderef V3679 V3684) (if (= () V3235) (do (shen.incinfs) (thaw V3685)) false)) (if (= Case false) (let Case (let V3236 (shen.lazyderef V3679 V3684) (if (cons? V3236) (let Rule (hd V3236) (let Rules (tl V3236) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V3680 V3683 V3684 (freeze (cut Throwcontrol V3684 (freeze (shen.t*-rules Rules V3680 (+ V3681 1) V3682 V3683 V3684 V3685)))))))) false)) (if (= Case false) (let Err (shen.newpv V3684) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V3681 V3684) (cn " of " (shen.app (shen.lazyderef V3682 V3684) "" shen.a)) shen.a))) V3684 V3685))) Case)) Case)))))

(defun shen.t*-rule (V3691 V3692 V3693 V3694 V3695) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V3227 (shen.lazyderef V3691 V3694) (if (cons? V3227) (let Patterns (hd V3227) (let V3228 (shen.lazyderef (tl V3227) V3694) (if (cons? V3228) (let Action (hd V3228) (let V3229 (shen.lazyderef (tl V3228) V3694) (if (= () V3229) (let NewHyps (shen.newpv V3694) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V3693 NewHyps V3694 (freeze (shen.t*-patterns Patterns V3692 NewHyps V3694 (freeze (cut Throwcontrol V3694 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V3692) (shen.patthyps Patterns V3692 V3693) V3694 V3695))))))))) false))) false))) false)))))

(defun shen.placeholders (V3701) (cond ((shen.ue? V3701) (cons V3701 ())) ((cons? V3701) (union (shen.placeholders (hd V3701)) (shen.placeholders (tl V3701)))) (true ())))

(defun shen.newhyps (V3707 V3708 V3709 V3710 V3711) (let Case (let V3214 (shen.lazyderef V3707 V3710) (if (= () V3214) (do (shen.incinfs) (unify! V3709 V3708 V3710 V3711)) false)) (if (= Case false) (let V3215 (shen.lazyderef V3707 V3710) (if (cons? V3215) (let V3210 (hd V3215) (let Vs (tl V3215) (let V3216 (shen.lazyderef V3709 V3710) (if (cons? V3216) (let V3217 (shen.lazyderef (hd V3216) V3710) (if (cons? V3217) (let V (hd V3217) (let V3218 (shen.lazyderef (tl V3217) V3710) (if (cons? V3218) (let V3219 (shen.lazyderef (hd V3218) V3710) (if (= : V3219) (let V3220 (shen.lazyderef (tl V3218) V3710) (if (cons? V3220) (let A (hd V3220) (let V3221 (shen.lazyderef (tl V3220) V3710) (if (= () V3221) (let NewHyp (tl V3216) (do (shen.incinfs) (unify! V V3210 V3710 (freeze (shen.newhyps Vs V3708 NewHyp V3710 V3711))))) (if (shen.pvar? V3221) (do (shen.bindv V3221 () V3710) (let Result (let NewHyp (tl V3216) (do (shen.incinfs) (unify! V V3210 V3710 (freeze (shen.newhyps Vs V3708 NewHyp V3710 V3711))))) (do (shen.unbindv V3221 V3710) Result))) false)))) (if (shen.pvar? V3220) (let A (shen.newpv V3710) (do (shen.bindv V3220 (cons A ()) V3710) (let Result (let NewHyp (tl V3216) (do (shen.incinfs) (unify! V V3210 V3710 (freeze (shen.newhyps Vs V3708 NewHyp V3710 V3711))))) (do (shen.unbindv V3220 V3710) Result)))) false))) (if (shen.pvar? V3219) (do (shen.bindv V3219 : V3710) (let Result (let V3222 (shen.lazyderef (tl V3218) V3710) (if (cons? V3222) (let A (hd V3222) (let V3223 (shen.lazyderef (tl V3222) V3710) (if (= () V3223) (let NewHyp (tl V3216) (do (shen.incinfs) (unify! V V3210 V3710 (freeze (shen.newhyps Vs V3708 NewHyp V3710 V3711))))) (if (shen.pvar? V3223) (do (shen.bindv V3223 () V3710) (let Result (let NewHyp (tl V3216) (do (shen.incinfs) (unify! V V3210 V3710 (freeze (shen.newhyps Vs V3708 NewHyp V3710 V3711))))) (do (shen.unbindv V3223 V3710) Result))) false)))) (if (shen.pvar? V3222) (let A (shen.newpv V3710) (do (shen.bindv V3222 (cons A ()) V3710) (let Result (let NewHyp (tl V3216) (do (shen.incinfs) (unify! V V3210 V3710 (freeze (shen.newhyps Vs V3708 NewHyp V3710 V3711))))) (do (shen.unbindv V3222 V3710) Result)))) false))) (do (shen.unbindv V3219 V3710) Result))) false))) (if (shen.pvar? V3218) (let A (shen.newpv V3710) (do (shen.bindv V3218 (cons : (cons A ())) V3710) (let Result (let NewHyp (tl V3216) (do (shen.incinfs) (unify! V V3210 V3710 (freeze (shen.newhyps Vs V3708 NewHyp V3710 V3711))))) (do (shen.unbindv V3218 V3710) Result)))) false)))) (if (shen.pvar? V3217) (let V (shen.newpv V3710) (let A (shen.newpv V3710) (do (shen.bindv V3217 (cons V (cons : (cons A ()))) V3710) (let Result (let NewHyp (tl V3216) (do (shen.incinfs) (unify! V V3210 V3710 (freeze (shen.newhyps Vs V3708 NewHyp V3710 V3711))))) (do (shen.unbindv V3217 V3710) Result))))) false))) (if (shen.pvar? V3216) (let V (shen.newpv V3710) (let A (shen.newpv V3710) (let NewHyp (shen.newpv V3710) (do (shen.bindv V3216 (cons (cons V (cons : (cons A ()))) NewHyp) V3710) (let Result (do (shen.incinfs) (unify! V V3210 V3710 (freeze (shen.newhyps Vs V3708 NewHyp V3710 V3711)))) (do (shen.unbindv V3216 V3710) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V3717 V3718 V3719) (cond ((= () V3717) V3719) ((and (cons? V3717) (and (cons? V3718) (and (cons? (tl V3718)) (and (= --> (hd (tl V3718))) (and (cons? (tl (tl V3718))) (= () (tl (tl (tl V3718))))))))) (adjoin (cons (hd V3717) (cons : (cons (hd V3718) ()))) (shen.patthyps (tl V3717) (hd (tl (tl V3718))) V3719))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V3726 V3727) (cond ((and (= () V3726) (and (cons? V3727) (and (= --> (hd V3727)) (and (cons? (tl V3727)) (= () (tl (tl V3727))))))) (hd (tl V3727))) ((= () V3726) V3727) ((and (cons? V3726) (and (cons? V3727) (and (cons? (tl V3727)) (and (= --> (hd (tl V3727))) (and (cons? (tl (tl V3727))) (= () (tl (tl (tl V3727))))))))) (shen.result-type (tl V3726) (hd (tl (tl V3727))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V3733 V3734 V3735 V3736 V3737) (let Case (let V3202 (shen.lazyderef V3733 V3736) (if (= () V3202) (do (shen.incinfs) (thaw V3737)) false)) (if (= Case false) (let V3203 (shen.lazyderef V3733 V3736) (if (cons? V3203) (let Pattern (hd V3203) (let Patterns (tl V3203) (let V3204 (shen.lazyderef V3734 V3736) (if (cons? V3204) (let A (hd V3204) (let V3205 (shen.lazyderef (tl V3204) V3736) (if (cons? V3205) (let V3206 (shen.lazyderef (hd V3205) V3736) (if (= --> V3206) (let V3207 (shen.lazyderef (tl V3205) V3736) (if (cons? V3207) (let B (hd V3207) (let V3208 (shen.lazyderef (tl V3207) V3736) (if (= () V3208) (do (shen.incinfs) (shen.t* (cons Pattern (cons : (cons A ()))) V3735 V3736 (freeze (shen.t*-patterns Patterns B V3735 V3736 V3737)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V3743 V3744 V3745 V3746 V3747) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3179 (shen.lazyderef V3743 V3746) (if (cons? V3179) (let V3180 (shen.lazyderef (hd V3179) V3746) (if (= where V3180) (let V3181 (shen.lazyderef (tl V3179) V3746) (if (cons? V3181) (let P (hd V3181) (let V3182 (shen.lazyderef (tl V3181) V3746) (if (cons? V3182) (let Action (hd V3182) (let V3183 (shen.lazyderef (tl V3182) V3746) (if (= () V3183) (do (shen.incinfs) (cut Throwcontrol V3746 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V3745 V3746 (freeze (cut Throwcontrol V3746 (freeze (shen.t*-action Action V3744 (cons (cons P (cons : (cons verified ()))) V3745) V3746 V3747)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3184 (shen.lazyderef V3743 V3746) (if (cons? V3184) (let V3185 (shen.lazyderef (hd V3184) V3746) (if (= shen.choicepoint! V3185) (let V3186 (shen.lazyderef (tl V3184) V3746) (if (cons? V3186) (let V3187 (shen.lazyderef (hd V3186) V3746) (if (cons? V3187) (let V3188 (shen.lazyderef (hd V3187) V3746) (if (cons? V3188) (let V3189 (shen.lazyderef (hd V3188) V3746) (if (= fail-if V3189) (let V3190 (shen.lazyderef (tl V3188) V3746) (if (cons? V3190) (let F (hd V3190) (let V3191 (shen.lazyderef (tl V3190) V3746) (if (= () V3191) (let V3192 (shen.lazyderef (tl V3187) V3746) (if (cons? V3192) (let Action (hd V3192) (let V3193 (shen.lazyderef (tl V3192) V3746) (if (= () V3193) (let V3194 (shen.lazyderef (tl V3186) V3746) (if (= () V3194) (do (shen.incinfs) (cut Throwcontrol V3746 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V3744 V3745 V3746 V3747)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3195 (shen.lazyderef V3743 V3746) (if (cons? V3195) (let V3196 (shen.lazyderef (hd V3195) V3746) (if (= shen.choicepoint! V3196) (let V3197 (shen.lazyderef (tl V3195) V3746) (if (cons? V3197) (let Action (hd V3197) (let V3198 (shen.lazyderef (tl V3197) V3746) (if (= () V3198) (do (shen.incinfs) (cut Throwcontrol V3746 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V3744 V3745 V3746 V3747)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V3743 (cons : (cons V3744 ()))) V3745 V3746 V3747)) Case)) Case)) Case)))))

(defun findall (V3753 V3754 V3755 V3756 V3757) (let B (shen.newpv V3756) (let A (shen.newpv V3756) (do (shen.incinfs) (bind A (gensym shen.a) V3756 (freeze (bind B (set (shen.lazyderef A V3756) ()) V3756 (freeze (shen.findallhelp V3753 V3754 V3755 A V3756 V3757)))))))))

(defun shen.findallhelp (V3764 V3765 V3766 V3767 V3768 V3769) (let Case (do (shen.incinfs) (call V3765 V3768 (freeze (shen.remember V3767 V3764 V3768 (freeze (fwhen false V3768 V3769)))))) (if (= Case false) (do (shen.incinfs) (bind V3766 (value (shen.lazyderef V3767 V3768)) V3768 V3769)) Case)))

(defun shen.remember (V3774 V3775 V3776 V3777) (let B (shen.newpv V3776) (do (shen.incinfs) (bind B (set (shen.deref V3774 V3776) (cons (shen.deref V3775 V3776) (value (shen.deref V3774 V3776)))) V3776 V3777))))



