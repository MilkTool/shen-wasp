"Copyright (c) 2010-2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"

(defun shen.typecheck (V3834 V3835) (let Curry (shen.curry V3834) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V3835)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V3837) (cond ((and (cons? V3837) (shen.special? (hd V3837))) (cons (hd V3837) (map (lambda Y (shen.curry Y)) (tl V3837)))) ((and (cons? V3837) (and (cons? (tl V3837)) (shen.extraspecial? (hd V3837)))) V3837) ((and (cons? V3837) (and (= type (hd V3837)) (and (cons? (tl V3837)) (and (cons? (tl (tl V3837))) (= () (tl (tl (tl V3837)))))))) (cons type (cons (shen.curry (hd (tl V3837))) (tl (tl V3837))))) ((and (cons? V3837) (and (cons? (tl V3837)) (cons? (tl (tl V3837))))) (shen.curry (cons (cons (hd V3837) (cons (hd (tl V3837)) ())) (tl (tl V3837))))) ((and (cons? V3837) (and (cons? (tl V3837)) (= () (tl (tl V3837))))) (cons (shen.curry (hd V3837)) (cons (shen.curry (hd (tl V3837))) ()))) (true V3837)))

(defun shen.special? (V3839) (element? V3839 (value shen.*special*)))

(defun shen.extraspecial? (V3841) (element? V3841 (value shen.*extraspecial*)))

(defun shen.t* (V3846 V3847 V3848 V3849) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V3848) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V3848 (freeze (bind Error (shen.errormaxinfs) V3848 V3849))))) (if (= Case false) (let Case (let V3826 (shen.lazyderef V3846 V3848) (if (= fail V3826) (do (shen.incinfs) (cut Throwcontrol V3848 (freeze (shen.prolog-failure V3848 V3849)))) false)) (if (= Case false) (let Case (let V3827 (shen.lazyderef V3846 V3848) (if (cons? V3827) (let X (hd V3827) (let V3828 (shen.lazyderef (tl V3827) V3848) (if (cons? V3828) (let V3829 (shen.lazyderef (hd V3828) V3848) (if (= : V3829) (let V3830 (shen.lazyderef (tl V3828) V3848) (if (cons? V3830) (let A (hd V3830) (let V3831 (shen.lazyderef (tl V3830) V3848) (if (= () V3831) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V3848 (freeze (cut Throwcontrol V3848 (freeze (shen.th* X A V3847 V3848 V3849)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V3848) (do (shen.incinfs) (shen.show V3846 V3847 V3848 (freeze (bind Datatypes (value shen.*datatypes*) V3848 (freeze (shen.udefs* V3846 V3847 Datatypes V3848 V3849))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V3855) (cond ((= + V3855) (set shen.*shen-type-theory-enabled?* true)) ((= - V3855) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V3866 V3867) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V3873 V3874 V3875 V3876 V3877) (let Case (let V3822 (shen.lazyderef V3875 V3876) (if (cons? V3822) (let D (hd V3822) (do (shen.incinfs) (call (cons D (cons V3873 (cons V3874 ()))) V3876 V3877))) false)) (if (= Case false) (let V3823 (shen.lazyderef V3875 V3876) (if (cons? V3823) (let Ds (tl V3823) (do (shen.incinfs) (shen.udefs* V3873 V3874 Ds V3876 V3877))) false)) Case)))

(defun shen.th* (V3883 V3884 V3885 V3886 V3887) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V3883 (cons : (cons V3884 ()))) V3885 V3886 (freeze (fwhen false V3886 V3887)))) (if (= Case false) (let Case (let F (shen.newpv V3886) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V3883 V3886)) V3886 (freeze (bind F (shen.sigf (shen.lazyderef V3883 V3886)) V3886 (freeze (call (cons F (cons V3884 ())) V3886 V3887))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V3883 V3884 V3886 V3887)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V3883 V3884 V3885 V3886 V3887)) (if (= Case false) (let Case (let V3718 (shen.lazyderef V3883 V3886) (if (cons? V3718) (let F (hd V3718) (let V3719 (shen.lazyderef (tl V3718) V3886) (if (= () V3719) (do (shen.incinfs) (shen.th* F (cons --> (cons V3884 ())) V3885 V3886 V3887)) false))) false)) (if (= Case false) (let Case (let V3720 (shen.lazyderef V3883 V3886) (if (cons? V3720) (let F (hd V3720) (let V3721 (shen.lazyderef (tl V3720) V3886) (if (cons? V3721) (let X (hd V3721) (let V3722 (shen.lazyderef (tl V3721) V3886) (if (= () V3722) (let B (shen.newpv V3886) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V3884 ()))) V3885 V3886 (freeze (shen.th* X B V3885 V3886 V3887))))) false))) false))) false)) (if (= Case false) (let Case (let V3723 (shen.lazyderef V3883 V3886) (if (cons? V3723) (let V3724 (shen.lazyderef (hd V3723) V3886) (if (= cons V3724) (let V3725 (shen.lazyderef (tl V3723) V3886) (if (cons? V3725) (let X (hd V3725) (let V3726 (shen.lazyderef (tl V3725) V3886) (if (cons? V3726) (let Y (hd V3726) (let V3727 (shen.lazyderef (tl V3726) V3886) (if (= () V3727) (let V3728 (shen.lazyderef V3884 V3886) (if (cons? V3728) (let V3729 (shen.lazyderef (hd V3728) V3886) (if (= list V3729) (let V3730 (shen.lazyderef (tl V3728) V3886) (if (cons? V3730) (let A (hd V3730) (let V3731 (shen.lazyderef (tl V3730) V3886) (if (= () V3731) (do (shen.incinfs) (shen.th* X A V3885 V3886 (freeze (shen.th* Y (cons list (cons A ())) V3885 V3886 V3887)))) (if (shen.pvar? V3731) (do (shen.bindv V3731 () V3886) (let Result (do (shen.incinfs) (shen.th* X A V3885 V3886 (freeze (shen.th* Y (cons list (cons A ())) V3885 V3886 V3887)))) (do (shen.unbindv V3731 V3886) Result))) false)))) (if (shen.pvar? V3730) (let A (shen.newpv V3886) (do (shen.bindv V3730 (cons A ()) V3886) (let Result (do (shen.incinfs) (shen.th* X A V3885 V3886 (freeze (shen.th* Y (cons list (cons A ())) V3885 V3886 V3887)))) (do (shen.unbindv V3730 V3886) Result)))) false))) (if (shen.pvar? V3729) (do (shen.bindv V3729 list V3886) (let Result (let V3732 (shen.lazyderef (tl V3728) V3886) (if (cons? V3732) (let A (hd V3732) (let V3733 (shen.lazyderef (tl V3732) V3886) (if (= () V3733) (do (shen.incinfs) (shen.th* X A V3885 V3886 (freeze (shen.th* Y (cons list (cons A ())) V3885 V3886 V3887)))) (if (shen.pvar? V3733) (do (shen.bindv V3733 () V3886) (let Result (do (shen.incinfs) (shen.th* X A V3885 V3886 (freeze (shen.th* Y (cons list (cons A ())) V3885 V3886 V3887)))) (do (shen.unbindv V3733 V3886) Result))) false)))) (if (shen.pvar? V3732) (let A (shen.newpv V3886) (do (shen.bindv V3732 (cons A ()) V3886) (let Result (do (shen.incinfs) (shen.th* X A V3885 V3886 (freeze (shen.th* Y (cons list (cons A ())) V3885 V3886 V3887)))) (do (shen.unbindv V3732 V3886) Result)))) false))) (do (shen.unbindv V3729 V3886) Result))) false))) (if (shen.pvar? V3728) (let A (shen.newpv V3886) (do (shen.bindv V3728 (cons list (cons A ())) V3886) (let Result (do (shen.incinfs) (shen.th* X A V3885 V3886 (freeze (shen.th* Y (cons list (cons A ())) V3885 V3886 V3887)))) (do (shen.unbindv V3728 V3886) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3734 (shen.lazyderef V3883 V3886) (if (cons? V3734) (let V3735 (shen.lazyderef (hd V3734) V3886) (if (= @p V3735) (let V3736 (shen.lazyderef (tl V3734) V3886) (if (cons? V3736) (let X (hd V3736) (let V3737 (shen.lazyderef (tl V3736) V3886) (if (cons? V3737) (let Y (hd V3737) (let V3738 (shen.lazyderef (tl V3737) V3886) (if (= () V3738) (let V3739 (shen.lazyderef V3884 V3886) (if (cons? V3739) (let A (hd V3739) (let V3740 (shen.lazyderef (tl V3739) V3886) (if (cons? V3740) (let V3741 (shen.lazyderef (hd V3740) V3886) (if (= * V3741) (let V3742 (shen.lazyderef (tl V3740) V3886) (if (cons? V3742) (let B (hd V3742) (let V3743 (shen.lazyderef (tl V3742) V3886) (if (= () V3743) (do (shen.incinfs) (shen.th* X A V3885 V3886 (freeze (shen.th* Y B V3885 V3886 V3887)))) (if (shen.pvar? V3743) (do (shen.bindv V3743 () V3886) (let Result (do (shen.incinfs) (shen.th* X A V3885 V3886 (freeze (shen.th* Y B V3885 V3886 V3887)))) (do (shen.unbindv V3743 V3886) Result))) false)))) (if (shen.pvar? V3742) (let B (shen.newpv V3886) (do (shen.bindv V3742 (cons B ()) V3886) (let Result (do (shen.incinfs) (shen.th* X A V3885 V3886 (freeze (shen.th* Y B V3885 V3886 V3887)))) (do (shen.unbindv V3742 V3886) Result)))) false))) (if (shen.pvar? V3741) (do (shen.bindv V3741 * V3886) (let Result (let V3744 (shen.lazyderef (tl V3740) V3886) (if (cons? V3744) (let B (hd V3744) (let V3745 (shen.lazyderef (tl V3744) V3886) (if (= () V3745) (do (shen.incinfs) (shen.th* X A V3885 V3886 (freeze (shen.th* Y B V3885 V3886 V3887)))) (if (shen.pvar? V3745) (do (shen.bindv V3745 () V3886) (let Result (do (shen.incinfs) (shen.th* X A V3885 V3886 (freeze (shen.th* Y B V3885 V3886 V3887)))) (do (shen.unbindv V3745 V3886) Result))) false)))) (if (shen.pvar? V3744) (let B (shen.newpv V3886) (do (shen.bindv V3744 (cons B ()) V3886) (let Result (do (shen.incinfs) (shen.th* X A V3885 V3886 (freeze (shen.th* Y B V3885 V3886 V3887)))) (do (shen.unbindv V3744 V3886) Result)))) false))) (do (shen.unbindv V3741 V3886) Result))) false))) (if (shen.pvar? V3740) (let B (shen.newpv V3886) (do (shen.bindv V3740 (cons * (cons B ())) V3886) (let Result (do (shen.incinfs) (shen.th* X A V3885 V3886 (freeze (shen.th* Y B V3885 V3886 V3887)))) (do (shen.unbindv V3740 V3886) Result)))) false)))) (if (shen.pvar? V3739) (let A (shen.newpv V3886) (let B (shen.newpv V3886) (do (shen.bindv V3739 (cons A (cons * (cons B ()))) V3886) (let Result (do (shen.incinfs) (shen.th* X A V3885 V3886 (freeze (shen.th* Y B V3885 V3886 V3887)))) (do (shen.unbindv V3739 V3886) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3746 (shen.lazyderef V3883 V3886) (if (cons? V3746) (let V3747 (shen.lazyderef (hd V3746) V3886) (if (= @v V3747) (let V3748 (shen.lazyderef (tl V3746) V3886) (if (cons? V3748) (let X (hd V3748) (let V3749 (shen.lazyderef (tl V3748) V3886) (if (cons? V3749) (let Y (hd V3749) (let V3750 (shen.lazyderef (tl V3749) V3886) (if (= () V3750) (let V3751 (shen.lazyderef V3884 V3886) (if (cons? V3751) (let V3752 (shen.lazyderef (hd V3751) V3886) (if (= vector V3752) (let V3753 (shen.lazyderef (tl V3751) V3886) (if (cons? V3753) (let A (hd V3753) (let V3754 (shen.lazyderef (tl V3753) V3886) (if (= () V3754) (do (shen.incinfs) (shen.th* X A V3885 V3886 (freeze (shen.th* Y (cons vector (cons A ())) V3885 V3886 V3887)))) (if (shen.pvar? V3754) (do (shen.bindv V3754 () V3886) (let Result (do (shen.incinfs) (shen.th* X A V3885 V3886 (freeze (shen.th* Y (cons vector (cons A ())) V3885 V3886 V3887)))) (do (shen.unbindv V3754 V3886) Result))) false)))) (if (shen.pvar? V3753) (let A (shen.newpv V3886) (do (shen.bindv V3753 (cons A ()) V3886) (let Result (do (shen.incinfs) (shen.th* X A V3885 V3886 (freeze (shen.th* Y (cons vector (cons A ())) V3885 V3886 V3887)))) (do (shen.unbindv V3753 V3886) Result)))) false))) (if (shen.pvar? V3752) (do (shen.bindv V3752 vector V3886) (let Result (let V3755 (shen.lazyderef (tl V3751) V3886) (if (cons? V3755) (let A (hd V3755) (let V3756 (shen.lazyderef (tl V3755) V3886) (if (= () V3756) (do (shen.incinfs) (shen.th* X A V3885 V3886 (freeze (shen.th* Y (cons vector (cons A ())) V3885 V3886 V3887)))) (if (shen.pvar? V3756) (do (shen.bindv V3756 () V3886) (let Result (do (shen.incinfs) (shen.th* X A V3885 V3886 (freeze (shen.th* Y (cons vector (cons A ())) V3885 V3886 V3887)))) (do (shen.unbindv V3756 V3886) Result))) false)))) (if (shen.pvar? V3755) (let A (shen.newpv V3886) (do (shen.bindv V3755 (cons A ()) V3886) (let Result (do (shen.incinfs) (shen.th* X A V3885 V3886 (freeze (shen.th* Y (cons vector (cons A ())) V3885 V3886 V3887)))) (do (shen.unbindv V3755 V3886) Result)))) false))) (do (shen.unbindv V3752 V3886) Result))) false))) (if (shen.pvar? V3751) (let A (shen.newpv V3886) (do (shen.bindv V3751 (cons vector (cons A ())) V3886) (let Result (do (shen.incinfs) (shen.th* X A V3885 V3886 (freeze (shen.th* Y (cons vector (cons A ())) V3885 V3886 V3887)))) (do (shen.unbindv V3751 V3886) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3757 (shen.lazyderef V3883 V3886) (if (cons? V3757) (let V3758 (shen.lazyderef (hd V3757) V3886) (if (= @s V3758) (let V3759 (shen.lazyderef (tl V3757) V3886) (if (cons? V3759) (let X (hd V3759) (let V3760 (shen.lazyderef (tl V3759) V3886) (if (cons? V3760) (let Y (hd V3760) (let V3761 (shen.lazyderef (tl V3760) V3886) (if (= () V3761) (let V3762 (shen.lazyderef V3884 V3886) (if (= string V3762) (do (shen.incinfs) (shen.th* X string V3885 V3886 (freeze (shen.th* Y string V3885 V3886 V3887)))) (if (shen.pvar? V3762) (do (shen.bindv V3762 string V3886) (let Result (do (shen.incinfs) (shen.th* X string V3885 V3886 (freeze (shen.th* Y string V3885 V3886 V3887)))) (do (shen.unbindv V3762 V3886) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3763 (shen.lazyderef V3883 V3886) (if (cons? V3763) (let V3764 (shen.lazyderef (hd V3763) V3886) (if (= lambda V3764) (let V3765 (shen.lazyderef (tl V3763) V3886) (if (cons? V3765) (let X (hd V3765) (let V3766 (shen.lazyderef (tl V3765) V3886) (if (cons? V3766) (let Y (hd V3766) (let V3767 (shen.lazyderef (tl V3766) V3886) (if (= () V3767) (let V3768 (shen.lazyderef V3884 V3886) (if (cons? V3768) (let A (hd V3768) (let V3769 (shen.lazyderef (tl V3768) V3886) (if (cons? V3769) (let V3770 (shen.lazyderef (hd V3769) V3886) (if (= --> V3770) (let V3771 (shen.lazyderef (tl V3769) V3886) (if (cons? V3771) (let B (hd V3771) (let V3772 (shen.lazyderef (tl V3771) V3886) (if (= () V3772) (let Z (shen.newpv V3886) (let X&& (shen.newpv V3886) (do (shen.incinfs) (cut Throwcontrol V3886 (freeze (bind X&& (shen.placeholder) V3886 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3886) (shen.lazyderef X V3886) (shen.lazyderef Y V3886)) V3886 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3885) V3886 V3887)))))))))) (if (shen.pvar? V3772) (do (shen.bindv V3772 () V3886) (let Result (let Z (shen.newpv V3886) (let X&& (shen.newpv V3886) (do (shen.incinfs) (cut Throwcontrol V3886 (freeze (bind X&& (shen.placeholder) V3886 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3886) (shen.lazyderef X V3886) (shen.lazyderef Y V3886)) V3886 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3885) V3886 V3887)))))))))) (do (shen.unbindv V3772 V3886) Result))) false)))) (if (shen.pvar? V3771) (let B (shen.newpv V3886) (do (shen.bindv V3771 (cons B ()) V3886) (let Result (let Z (shen.newpv V3886) (let X&& (shen.newpv V3886) (do (shen.incinfs) (cut Throwcontrol V3886 (freeze (bind X&& (shen.placeholder) V3886 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3886) (shen.lazyderef X V3886) (shen.lazyderef Y V3886)) V3886 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3885) V3886 V3887)))))))))) (do (shen.unbindv V3771 V3886) Result)))) false))) (if (shen.pvar? V3770) (do (shen.bindv V3770 --> V3886) (let Result (let V3773 (shen.lazyderef (tl V3769) V3886) (if (cons? V3773) (let B (hd V3773) (let V3774 (shen.lazyderef (tl V3773) V3886) (if (= () V3774) (let Z (shen.newpv V3886) (let X&& (shen.newpv V3886) (do (shen.incinfs) (cut Throwcontrol V3886 (freeze (bind X&& (shen.placeholder) V3886 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3886) (shen.lazyderef X V3886) (shen.lazyderef Y V3886)) V3886 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3885) V3886 V3887)))))))))) (if (shen.pvar? V3774) (do (shen.bindv V3774 () V3886) (let Result (let Z (shen.newpv V3886) (let X&& (shen.newpv V3886) (do (shen.incinfs) (cut Throwcontrol V3886 (freeze (bind X&& (shen.placeholder) V3886 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3886) (shen.lazyderef X V3886) (shen.lazyderef Y V3886)) V3886 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3885) V3886 V3887)))))))))) (do (shen.unbindv V3774 V3886) Result))) false)))) (if (shen.pvar? V3773) (let B (shen.newpv V3886) (do (shen.bindv V3773 (cons B ()) V3886) (let Result (let Z (shen.newpv V3886) (let X&& (shen.newpv V3886) (do (shen.incinfs) (cut Throwcontrol V3886 (freeze (bind X&& (shen.placeholder) V3886 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3886) (shen.lazyderef X V3886) (shen.lazyderef Y V3886)) V3886 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3885) V3886 V3887)))))))))) (do (shen.unbindv V3773 V3886) Result)))) false))) (do (shen.unbindv V3770 V3886) Result))) false))) (if (shen.pvar? V3769) (let B (shen.newpv V3886) (do (shen.bindv V3769 (cons --> (cons B ())) V3886) (let Result (let Z (shen.newpv V3886) (let X&& (shen.newpv V3886) (do (shen.incinfs) (cut Throwcontrol V3886 (freeze (bind X&& (shen.placeholder) V3886 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3886) (shen.lazyderef X V3886) (shen.lazyderef Y V3886)) V3886 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3885) V3886 V3887)))))))))) (do (shen.unbindv V3769 V3886) Result)))) false)))) (if (shen.pvar? V3768) (let A (shen.newpv V3886) (let B (shen.newpv V3886) (do (shen.bindv V3768 (cons A (cons --> (cons B ()))) V3886) (let Result (let Z (shen.newpv V3886) (let X&& (shen.newpv V3886) (do (shen.incinfs) (cut Throwcontrol V3886 (freeze (bind X&& (shen.placeholder) V3886 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3886) (shen.lazyderef X V3886) (shen.lazyderef Y V3886)) V3886 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3885) V3886 V3887)))))))))) (do (shen.unbindv V3768 V3886) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3775 (shen.lazyderef V3883 V3886) (if (cons? V3775) (let V3776 (shen.lazyderef (hd V3775) V3886) (if (= let V3776) (let V3777 (shen.lazyderef (tl V3775) V3886) (if (cons? V3777) (let X (hd V3777) (let V3778 (shen.lazyderef (tl V3777) V3886) (if (cons? V3778) (let Y (hd V3778) (let V3779 (shen.lazyderef (tl V3778) V3886) (if (cons? V3779) (let Z (hd V3779) (let V3780 (shen.lazyderef (tl V3779) V3886) (if (= () V3780) (let W (shen.newpv V3886) (let X&& (shen.newpv V3886) (let B (shen.newpv V3886) (do (shen.incinfs) (shen.th* Y B V3885 V3886 (freeze (bind X&& (shen.placeholder) V3886 (freeze (bind W (shen.ebr (shen.lazyderef X&& V3886) (shen.lazyderef X V3886) (shen.lazyderef Z V3886)) V3886 (freeze (shen.th* W V3884 (cons (cons X&& (cons : (cons B ()))) V3885) V3886 V3887))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3781 (shen.lazyderef V3883 V3886) (if (cons? V3781) (let V3782 (shen.lazyderef (hd V3781) V3886) (if (= open V3782) (let V3783 (shen.lazyderef (tl V3781) V3886) (if (cons? V3783) (let FileName (hd V3783) (let V3784 (shen.lazyderef (tl V3783) V3886) (if (cons? V3784) (let Direction3714 (hd V3784) (let V3785 (shen.lazyderef (tl V3784) V3886) (if (= () V3785) (let V3786 (shen.lazyderef V3884 V3886) (if (cons? V3786) (let V3787 (shen.lazyderef (hd V3786) V3886) (if (= stream V3787) (let V3788 (shen.lazyderef (tl V3786) V3886) (if (cons? V3788) (let Direction (hd V3788) (let V3789 (shen.lazyderef (tl V3788) V3886) (if (= () V3789) (do (shen.incinfs) (unify! Direction Direction3714 V3886 (freeze (cut Throwcontrol V3886 (freeze (fwhen (element? (shen.lazyderef Direction V3886) (cons in (cons out ()))) V3886 (freeze (shen.th* FileName string V3885 V3886 V3887)))))))) (if (shen.pvar? V3789) (do (shen.bindv V3789 () V3886) (let Result (do (shen.incinfs) (unify! Direction Direction3714 V3886 (freeze (cut Throwcontrol V3886 (freeze (fwhen (element? (shen.lazyderef Direction V3886) (cons in (cons out ()))) V3886 (freeze (shen.th* FileName string V3885 V3886 V3887)))))))) (do (shen.unbindv V3789 V3886) Result))) false)))) (if (shen.pvar? V3788) (let Direction (shen.newpv V3886) (do (shen.bindv V3788 (cons Direction ()) V3886) (let Result (do (shen.incinfs) (unify! Direction Direction3714 V3886 (freeze (cut Throwcontrol V3886 (freeze (fwhen (element? (shen.lazyderef Direction V3886) (cons in (cons out ()))) V3886 (freeze (shen.th* FileName string V3885 V3886 V3887)))))))) (do (shen.unbindv V3788 V3886) Result)))) false))) (if (shen.pvar? V3787) (do (shen.bindv V3787 stream V3886) (let Result (let V3790 (shen.lazyderef (tl V3786) V3886) (if (cons? V3790) (let Direction (hd V3790) (let V3791 (shen.lazyderef (tl V3790) V3886) (if (= () V3791) (do (shen.incinfs) (unify! Direction Direction3714 V3886 (freeze (cut Throwcontrol V3886 (freeze (fwhen (element? (shen.lazyderef Direction V3886) (cons in (cons out ()))) V3886 (freeze (shen.th* FileName string V3885 V3886 V3887)))))))) (if (shen.pvar? V3791) (do (shen.bindv V3791 () V3886) (let Result (do (shen.incinfs) (unify! Direction Direction3714 V3886 (freeze (cut Throwcontrol V3886 (freeze (fwhen (element? (shen.lazyderef Direction V3886) (cons in (cons out ()))) V3886 (freeze (shen.th* FileName string V3885 V3886 V3887)))))))) (do (shen.unbindv V3791 V3886) Result))) false)))) (if (shen.pvar? V3790) (let Direction (shen.newpv V3886) (do (shen.bindv V3790 (cons Direction ()) V3886) (let Result (do (shen.incinfs) (unify! Direction Direction3714 V3886 (freeze (cut Throwcontrol V3886 (freeze (fwhen (element? (shen.lazyderef Direction V3886) (cons in (cons out ()))) V3886 (freeze (shen.th* FileName string V3885 V3886 V3887)))))))) (do (shen.unbindv V3790 V3886) Result)))) false))) (do (shen.unbindv V3787 V3886) Result))) false))) (if (shen.pvar? V3786) (let Direction (shen.newpv V3886) (do (shen.bindv V3786 (cons stream (cons Direction ())) V3886) (let Result (do (shen.incinfs) (unify! Direction Direction3714 V3886 (freeze (cut Throwcontrol V3886 (freeze (fwhen (element? (shen.lazyderef Direction V3886) (cons in (cons out ()))) V3886 (freeze (shen.th* FileName string V3885 V3886 V3887)))))))) (do (shen.unbindv V3786 V3886) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3792 (shen.lazyderef V3883 V3886) (if (cons? V3792) (let V3793 (shen.lazyderef (hd V3792) V3886) (if (= type V3793) (let V3794 (shen.lazyderef (tl V3792) V3886) (if (cons? V3794) (let X (hd V3794) (let V3795 (shen.lazyderef (tl V3794) V3886) (if (cons? V3795) (let A (hd V3795) (let V3796 (shen.lazyderef (tl V3795) V3886) (if (= () V3796) (do (shen.incinfs) (cut Throwcontrol V3886 (freeze (unify A V3884 V3886 (freeze (shen.th* X A V3885 V3886 V3887)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3797 (shen.lazyderef V3883 V3886) (if (cons? V3797) (let V3798 (shen.lazyderef (hd V3797) V3886) (if (= input+ V3798) (let V3799 (shen.lazyderef (tl V3797) V3886) (if (cons? V3799) (let A (hd V3799) (let V3800 (shen.lazyderef (tl V3799) V3886) (if (cons? V3800) (let Stream (hd V3800) (let V3801 (shen.lazyderef (tl V3800) V3886) (if (= () V3801) (let C (shen.newpv V3886) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V3886)) V3886 (freeze (unify V3884 C V3886 (freeze (shen.th* Stream (cons stream (cons in ())) V3885 V3886 V3887))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3802 (shen.lazyderef V3883 V3886) (if (cons? V3802) (let V3803 (shen.lazyderef (hd V3802) V3886) (if (= set V3803) (let V3804 (shen.lazyderef (tl V3802) V3886) (if (cons? V3804) (let Var (hd V3804) (let V3805 (shen.lazyderef (tl V3804) V3886) (if (cons? V3805) (let Val (hd V3805) (let V3806 (shen.lazyderef (tl V3805) V3886) (if (= () V3806) (do (shen.incinfs) (cut Throwcontrol V3886 (freeze (shen.th* Var symbol V3885 V3886 (freeze (cut Throwcontrol V3886 (freeze (shen.th* (cons value (cons Var ())) V3884 V3885 V3886 (freeze (shen.th* Val V3884 V3885 V3886 V3887)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V3886) (do (shen.incinfs) (shen.t*-hyps V3885 NewHyp V3886 (freeze (shen.th* V3883 V3884 NewHyp V3886 V3887))))) (if (= Case false) (let Case (let V3807 (shen.lazyderef V3883 V3886) (if (cons? V3807) (let V3808 (shen.lazyderef (hd V3807) V3886) (if (= define V3808) (let V3809 (shen.lazyderef (tl V3807) V3886) (if (cons? V3809) (let F (hd V3809) (let X (tl V3809) (do (shen.incinfs) (cut Throwcontrol V3886 (freeze (shen.t*-def (cons define (cons F X)) V3884 V3885 V3886 V3887)))))) false)) false)) false)) (if (= Case false) (let Case (let V3810 (shen.lazyderef V3883 V3886) (if (cons? V3810) (let V3811 (shen.lazyderef (hd V3810) V3886) (if (= defmacro V3811) (let V3812 (shen.lazyderef V3884 V3886) (if (= unit V3812) (do (shen.incinfs) (cut Throwcontrol V3886 V3887)) (if (shen.pvar? V3812) (do (shen.bindv V3812 unit V3886) (let Result (do (shen.incinfs) (cut Throwcontrol V3886 V3887)) (do (shen.unbindv V3812 V3886) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3813 (shen.lazyderef V3883 V3886) (if (cons? V3813) (let V3814 (shen.lazyderef (hd V3813) V3886) (if (= shen.process-datatype V3814) (let V3815 (shen.lazyderef V3884 V3886) (if (= symbol V3815) (do (shen.incinfs) (thaw V3887)) (if (shen.pvar? V3815) (do (shen.bindv V3815 symbol V3886) (let Result (do (shen.incinfs) (thaw V3887)) (do (shen.unbindv V3815 V3886) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3816 (shen.lazyderef V3883 V3886) (if (cons? V3816) (let V3817 (shen.lazyderef (hd V3816) V3886) (if (= shen.synonyms-help V3817) (let V3818 (shen.lazyderef V3884 V3886) (if (= symbol V3818) (do (shen.incinfs) (thaw V3887)) (if (shen.pvar? V3818) (do (shen.bindv V3818 symbol V3886) (let Result (do (shen.incinfs) (thaw V3887)) (do (shen.unbindv V3818 V3886) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V3886) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V3886 (freeze (shen.udefs* (cons V3883 (cons : (cons V3884 ()))) V3885 Datatypes V3886 V3887))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V3892 V3893 V3894 V3895) (let Case (let V3629 (shen.lazyderef V3892 V3894) (if (cons? V3629) (let V3630 (shen.lazyderef (hd V3629) V3894) (if (cons? V3630) (let V3631 (shen.lazyderef (hd V3630) V3894) (if (cons? V3631) (let V3632 (shen.lazyderef (hd V3631) V3894) (if (= cons V3632) (let V3633 (shen.lazyderef (tl V3631) V3894) (if (cons? V3633) (let X (hd V3633) (let V3634 (shen.lazyderef (tl V3633) V3894) (if (cons? V3634) (let Y (hd V3634) (let V3635 (shen.lazyderef (tl V3634) V3894) (if (= () V3635) (let V3636 (shen.lazyderef (tl V3630) V3894) (if (cons? V3636) (let V3637 (shen.lazyderef (hd V3636) V3894) (if (= : V3637) (let V3638 (shen.lazyderef (tl V3636) V3894) (if (cons? V3638) (let V3639 (shen.lazyderef (hd V3638) V3894) (if (cons? V3639) (let V3640 (shen.lazyderef (hd V3639) V3894) (if (= list V3640) (let V3641 (shen.lazyderef (tl V3639) V3894) (if (cons? V3641) (let A (hd V3641) (let V3642 (shen.lazyderef (tl V3641) V3894) (if (= () V3642) (let V3643 (shen.lazyderef (tl V3638) V3894) (if (= () V3643) (let Hyp (tl V3629) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons list (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3643) (do (shen.bindv V3643 () V3894) (let Result (let Hyp (tl V3629) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons list (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3643 V3894) Result))) false))) (if (shen.pvar? V3642) (do (shen.bindv V3642 () V3894) (let Result (let V3644 (shen.lazyderef (tl V3638) V3894) (if (= () V3644) (let Hyp (tl V3629) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons list (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3644) (do (shen.bindv V3644 () V3894) (let Result (let Hyp (tl V3629) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons list (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3644 V3894) Result))) false))) (do (shen.unbindv V3642 V3894) Result))) false)))) (if (shen.pvar? V3641) (let A (shen.newpv V3894) (do (shen.bindv V3641 (cons A ()) V3894) (let Result (let V3645 (shen.lazyderef (tl V3638) V3894) (if (= () V3645) (let Hyp (tl V3629) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons list (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3645) (do (shen.bindv V3645 () V3894) (let Result (let Hyp (tl V3629) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons list (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3645 V3894) Result))) false))) (do (shen.unbindv V3641 V3894) Result)))) false))) (if (shen.pvar? V3640) (do (shen.bindv V3640 list V3894) (let Result (let V3646 (shen.lazyderef (tl V3639) V3894) (if (cons? V3646) (let A (hd V3646) (let V3647 (shen.lazyderef (tl V3646) V3894) (if (= () V3647) (let V3648 (shen.lazyderef (tl V3638) V3894) (if (= () V3648) (let Hyp (tl V3629) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons list (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3648) (do (shen.bindv V3648 () V3894) (let Result (let Hyp (tl V3629) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons list (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3648 V3894) Result))) false))) (if (shen.pvar? V3647) (do (shen.bindv V3647 () V3894) (let Result (let V3649 (shen.lazyderef (tl V3638) V3894) (if (= () V3649) (let Hyp (tl V3629) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons list (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3649) (do (shen.bindv V3649 () V3894) (let Result (let Hyp (tl V3629) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons list (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3649 V3894) Result))) false))) (do (shen.unbindv V3647 V3894) Result))) false)))) (if (shen.pvar? V3646) (let A (shen.newpv V3894) (do (shen.bindv V3646 (cons A ()) V3894) (let Result (let V3650 (shen.lazyderef (tl V3638) V3894) (if (= () V3650) (let Hyp (tl V3629) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons list (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3650) (do (shen.bindv V3650 () V3894) (let Result (let Hyp (tl V3629) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons list (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3650 V3894) Result))) false))) (do (shen.unbindv V3646 V3894) Result)))) false))) (do (shen.unbindv V3640 V3894) Result))) false))) (if (shen.pvar? V3639) (let A (shen.newpv V3894) (do (shen.bindv V3639 (cons list (cons A ())) V3894) (let Result (let V3651 (shen.lazyderef (tl V3638) V3894) (if (= () V3651) (let Hyp (tl V3629) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons list (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3651) (do (shen.bindv V3651 () V3894) (let Result (let Hyp (tl V3629) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons list (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3651 V3894) Result))) false))) (do (shen.unbindv V3639 V3894) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3652 (shen.lazyderef V3892 V3894) (if (cons? V3652) (let V3653 (shen.lazyderef (hd V3652) V3894) (if (cons? V3653) (let V3654 (shen.lazyderef (hd V3653) V3894) (if (cons? V3654) (let V3655 (shen.lazyderef (hd V3654) V3894) (if (= @p V3655) (let V3656 (shen.lazyderef (tl V3654) V3894) (if (cons? V3656) (let X (hd V3656) (let V3657 (shen.lazyderef (tl V3656) V3894) (if (cons? V3657) (let Y (hd V3657) (let V3658 (shen.lazyderef (tl V3657) V3894) (if (= () V3658) (let V3659 (shen.lazyderef (tl V3653) V3894) (if (cons? V3659) (let V3660 (shen.lazyderef (hd V3659) V3894) (if (= : V3660) (let V3661 (shen.lazyderef (tl V3659) V3894) (if (cons? V3661) (let V3662 (shen.lazyderef (hd V3661) V3894) (if (cons? V3662) (let A (hd V3662) (let V3663 (shen.lazyderef (tl V3662) V3894) (if (cons? V3663) (let V3664 (shen.lazyderef (hd V3663) V3894) (if (= * V3664) (let V3665 (shen.lazyderef (tl V3663) V3894) (if (cons? V3665) (let B (hd V3665) (let V3666 (shen.lazyderef (tl V3665) V3894) (if (= () V3666) (let V3667 (shen.lazyderef (tl V3661) V3894) (if (= () V3667) (let Hyp (tl V3652) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (shen.lazyderef B V3894) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3667) (do (shen.bindv V3667 () V3894) (let Result (let Hyp (tl V3652) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (shen.lazyderef B V3894) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3667 V3894) Result))) false))) (if (shen.pvar? V3666) (do (shen.bindv V3666 () V3894) (let Result (let V3668 (shen.lazyderef (tl V3661) V3894) (if (= () V3668) (let Hyp (tl V3652) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (shen.lazyderef B V3894) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3668) (do (shen.bindv V3668 () V3894) (let Result (let Hyp (tl V3652) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (shen.lazyderef B V3894) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3668 V3894) Result))) false))) (do (shen.unbindv V3666 V3894) Result))) false)))) (if (shen.pvar? V3665) (let B (shen.newpv V3894) (do (shen.bindv V3665 (cons B ()) V3894) (let Result (let V3669 (shen.lazyderef (tl V3661) V3894) (if (= () V3669) (let Hyp (tl V3652) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (shen.lazyderef B V3894) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3669) (do (shen.bindv V3669 () V3894) (let Result (let Hyp (tl V3652) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (shen.lazyderef B V3894) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3669 V3894) Result))) false))) (do (shen.unbindv V3665 V3894) Result)))) false))) (if (shen.pvar? V3664) (do (shen.bindv V3664 * V3894) (let Result (let V3670 (shen.lazyderef (tl V3663) V3894) (if (cons? V3670) (let B (hd V3670) (let V3671 (shen.lazyderef (tl V3670) V3894) (if (= () V3671) (let V3672 (shen.lazyderef (tl V3661) V3894) (if (= () V3672) (let Hyp (tl V3652) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (shen.lazyderef B V3894) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3672) (do (shen.bindv V3672 () V3894) (let Result (let Hyp (tl V3652) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (shen.lazyderef B V3894) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3672 V3894) Result))) false))) (if (shen.pvar? V3671) (do (shen.bindv V3671 () V3894) (let Result (let V3673 (shen.lazyderef (tl V3661) V3894) (if (= () V3673) (let Hyp (tl V3652) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (shen.lazyderef B V3894) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3673) (do (shen.bindv V3673 () V3894) (let Result (let Hyp (tl V3652) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (shen.lazyderef B V3894) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3673 V3894) Result))) false))) (do (shen.unbindv V3671 V3894) Result))) false)))) (if (shen.pvar? V3670) (let B (shen.newpv V3894) (do (shen.bindv V3670 (cons B ()) V3894) (let Result (let V3674 (shen.lazyderef (tl V3661) V3894) (if (= () V3674) (let Hyp (tl V3652) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (shen.lazyderef B V3894) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3674) (do (shen.bindv V3674 () V3894) (let Result (let Hyp (tl V3652) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (shen.lazyderef B V3894) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3674 V3894) Result))) false))) (do (shen.unbindv V3670 V3894) Result)))) false))) (do (shen.unbindv V3664 V3894) Result))) false))) (if (shen.pvar? V3663) (let B (shen.newpv V3894) (do (shen.bindv V3663 (cons * (cons B ())) V3894) (let Result (let V3675 (shen.lazyderef (tl V3661) V3894) (if (= () V3675) (let Hyp (tl V3652) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (shen.lazyderef B V3894) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3675) (do (shen.bindv V3675 () V3894) (let Result (let Hyp (tl V3652) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (shen.lazyderef B V3894) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3675 V3894) Result))) false))) (do (shen.unbindv V3663 V3894) Result)))) false)))) (if (shen.pvar? V3662) (let A (shen.newpv V3894) (let B (shen.newpv V3894) (do (shen.bindv V3662 (cons A (cons * (cons B ()))) V3894) (let Result (let V3676 (shen.lazyderef (tl V3661) V3894) (if (= () V3676) (let Hyp (tl V3652) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (shen.lazyderef B V3894) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3676) (do (shen.bindv V3676 () V3894) (let Result (let Hyp (tl V3652) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (shen.lazyderef B V3894) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3676 V3894) Result))) false))) (do (shen.unbindv V3662 V3894) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3677 (shen.lazyderef V3892 V3894) (if (cons? V3677) (let V3678 (shen.lazyderef (hd V3677) V3894) (if (cons? V3678) (let V3679 (shen.lazyderef (hd V3678) V3894) (if (cons? V3679) (let V3680 (shen.lazyderef (hd V3679) V3894) (if (= @v V3680) (let V3681 (shen.lazyderef (tl V3679) V3894) (if (cons? V3681) (let X (hd V3681) (let V3682 (shen.lazyderef (tl V3681) V3894) (if (cons? V3682) (let Y (hd V3682) (let V3683 (shen.lazyderef (tl V3682) V3894) (if (= () V3683) (let V3684 (shen.lazyderef (tl V3678) V3894) (if (cons? V3684) (let V3685 (shen.lazyderef (hd V3684) V3894) (if (= : V3685) (let V3686 (shen.lazyderef (tl V3684) V3894) (if (cons? V3686) (let V3687 (shen.lazyderef (hd V3686) V3894) (if (cons? V3687) (let V3688 (shen.lazyderef (hd V3687) V3894) (if (= vector V3688) (let V3689 (shen.lazyderef (tl V3687) V3894) (if (cons? V3689) (let A (hd V3689) (let V3690 (shen.lazyderef (tl V3689) V3894) (if (= () V3690) (let V3691 (shen.lazyderef (tl V3686) V3894) (if (= () V3691) (let Hyp (tl V3677) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons vector (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3691) (do (shen.bindv V3691 () V3894) (let Result (let Hyp (tl V3677) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons vector (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3691 V3894) Result))) false))) (if (shen.pvar? V3690) (do (shen.bindv V3690 () V3894) (let Result (let V3692 (shen.lazyderef (tl V3686) V3894) (if (= () V3692) (let Hyp (tl V3677) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons vector (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3692) (do (shen.bindv V3692 () V3894) (let Result (let Hyp (tl V3677) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons vector (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3692 V3894) Result))) false))) (do (shen.unbindv V3690 V3894) Result))) false)))) (if (shen.pvar? V3689) (let A (shen.newpv V3894) (do (shen.bindv V3689 (cons A ()) V3894) (let Result (let V3693 (shen.lazyderef (tl V3686) V3894) (if (= () V3693) (let Hyp (tl V3677) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons vector (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3693) (do (shen.bindv V3693 () V3894) (let Result (let Hyp (tl V3677) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons vector (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3693 V3894) Result))) false))) (do (shen.unbindv V3689 V3894) Result)))) false))) (if (shen.pvar? V3688) (do (shen.bindv V3688 vector V3894) (let Result (let V3694 (shen.lazyderef (tl V3687) V3894) (if (cons? V3694) (let A (hd V3694) (let V3695 (shen.lazyderef (tl V3694) V3894) (if (= () V3695) (let V3696 (shen.lazyderef (tl V3686) V3894) (if (= () V3696) (let Hyp (tl V3677) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons vector (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3696) (do (shen.bindv V3696 () V3894) (let Result (let Hyp (tl V3677) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons vector (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3696 V3894) Result))) false))) (if (shen.pvar? V3695) (do (shen.bindv V3695 () V3894) (let Result (let V3697 (shen.lazyderef (tl V3686) V3894) (if (= () V3697) (let Hyp (tl V3677) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons vector (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3697) (do (shen.bindv V3697 () V3894) (let Result (let Hyp (tl V3677) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons vector (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3697 V3894) Result))) false))) (do (shen.unbindv V3695 V3894) Result))) false)))) (if (shen.pvar? V3694) (let A (shen.newpv V3894) (do (shen.bindv V3694 (cons A ()) V3894) (let Result (let V3698 (shen.lazyderef (tl V3686) V3894) (if (= () V3698) (let Hyp (tl V3677) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons vector (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3698) (do (shen.bindv V3698 () V3894) (let Result (let Hyp (tl V3677) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons vector (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3698 V3894) Result))) false))) (do (shen.unbindv V3694 V3894) Result)))) false))) (do (shen.unbindv V3688 V3894) Result))) false))) (if (shen.pvar? V3687) (let A (shen.newpv V3894) (do (shen.bindv V3687 (cons vector (cons A ())) V3894) (let Result (let V3699 (shen.lazyderef (tl V3686) V3894) (if (= () V3699) (let Hyp (tl V3677) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons vector (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3699) (do (shen.bindv V3699 () V3894) (let Result (let Hyp (tl V3677) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons (shen.lazyderef A V3894) ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons (cons vector (cons (shen.lazyderef A V3894) ())) ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3699 V3894) Result))) false))) (do (shen.unbindv V3687 V3894) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3700 (shen.lazyderef V3892 V3894) (if (cons? V3700) (let V3701 (shen.lazyderef (hd V3700) V3894) (if (cons? V3701) (let V3702 (shen.lazyderef (hd V3701) V3894) (if (cons? V3702) (let V3703 (shen.lazyderef (hd V3702) V3894) (if (= @s V3703) (let V3704 (shen.lazyderef (tl V3702) V3894) (if (cons? V3704) (let X (hd V3704) (let V3705 (shen.lazyderef (tl V3704) V3894) (if (cons? V3705) (let Y (hd V3705) (let V3706 (shen.lazyderef (tl V3705) V3894) (if (= () V3706) (let V3707 (shen.lazyderef (tl V3701) V3894) (if (cons? V3707) (let V3708 (shen.lazyderef (hd V3707) V3894) (if (= : V3708) (let V3709 (shen.lazyderef (tl V3707) V3894) (if (cons? V3709) (let V3710 (shen.lazyderef (hd V3709) V3894) (if (= string V3710) (let V3711 (shen.lazyderef (tl V3709) V3894) (if (= () V3711) (let Hyp (tl V3700) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons string ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3711) (do (shen.bindv V3711 () V3894) (let Result (let Hyp (tl V3700) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons string ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3711 V3894) Result))) false))) (if (shen.pvar? V3710) (do (shen.bindv V3710 string V3894) (let Result (let V3712 (shen.lazyderef (tl V3709) V3894) (if (= () V3712) (let Hyp (tl V3700) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons string ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (if (shen.pvar? V3712) (do (shen.bindv V3712 () V3894) (let Result (let Hyp (tl V3700) (do (shen.incinfs) (bind V3893 (cons (cons (shen.lazyderef X V3894) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3894) (cons : (cons string ()))) (shen.lazyderef Hyp V3894))) V3894 V3895))) (do (shen.unbindv V3712 V3894) Result))) false))) (do (shen.unbindv V3710 V3894) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V3713 (shen.lazyderef V3892 V3894) (if (cons? V3713) (let X (hd V3713) (let Hyp (tl V3713) (let NewHyps (shen.newpv V3894) (do (shen.incinfs) (bind V3893 (cons (shen.lazyderef X V3894) (shen.lazyderef NewHyps V3894)) V3894 (freeze (shen.t*-hyps Hyp NewHyps V3894 V3895))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V3912 V3913 V3914 V3915) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V3912 V3914)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V3913 V3914) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V3915))))))))) (true (thaw V3915))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V3917) (cond ((and (cons? V3917) (and (cons? (tl V3917)) (and (= : (hd (tl V3917))) (and (cons? (tl (tl V3917))) (= () (tl (tl (tl V3917)))))))) (shen.prhush (shen.app (hd V3917) (cn " : " (shen.app (hd (tl (tl V3917))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V3917 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V3922 V3923) (cond ((= () V3922) shen.skip) ((cons? V3922) (do (shen.prhush (shen.app V3923 ". " shen.a) (stoutput)) (do (shen.show-p (hd V3922)) (do (nl 1) (shen.show-assumptions (tl V3922) (+ V3923 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V3925) (cons? (assoc V3925 (value shen.*signedfuncs*))))

(defun shen.sigf (V3927) (concat shen.type-signature-of- V3927))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V3932 V3933 V3934 V3935) (let Case (let V3616 (shen.lazyderef V3933 V3934) (if (= number V3616) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3932 V3934)) V3934 V3935)) (if (shen.pvar? V3616) (do (shen.bindv V3616 number V3934) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3932 V3934)) V3934 V3935)) (do (shen.unbindv V3616 V3934) Result))) false))) (if (= Case false) (let Case (let V3617 (shen.lazyderef V3933 V3934) (if (= boolean V3617) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3932 V3934)) V3934 V3935)) (if (shen.pvar? V3617) (do (shen.bindv V3617 boolean V3934) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3932 V3934)) V3934 V3935)) (do (shen.unbindv V3617 V3934) Result))) false))) (if (= Case false) (let Case (let V3618 (shen.lazyderef V3933 V3934) (if (= string V3618) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3932 V3934)) V3934 V3935)) (if (shen.pvar? V3618) (do (shen.bindv V3618 string V3934) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3932 V3934)) V3934 V3935)) (do (shen.unbindv V3618 V3934) Result))) false))) (if (= Case false) (let Case (let V3619 (shen.lazyderef V3933 V3934) (if (= symbol V3619) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3932 V3934)) V3934 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3932 V3934))) V3934 V3935)))) (if (shen.pvar? V3619) (do (shen.bindv V3619 symbol V3934) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3932 V3934)) V3934 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3932 V3934))) V3934 V3935)))) (do (shen.unbindv V3619 V3934) Result))) false))) (if (= Case false) (let V3620 (shen.lazyderef V3932 V3934) (if (= () V3620) (let V3621 (shen.lazyderef V3933 V3934) (if (cons? V3621) (let V3622 (shen.lazyderef (hd V3621) V3934) (if (= list V3622) (let V3623 (shen.lazyderef (tl V3621) V3934) (if (cons? V3623) (let A (hd V3623) (let V3624 (shen.lazyderef (tl V3623) V3934) (if (= () V3624) (do (shen.incinfs) (thaw V3935)) (if (shen.pvar? V3624) (do (shen.bindv V3624 () V3934) (let Result (do (shen.incinfs) (thaw V3935)) (do (shen.unbindv V3624 V3934) Result))) false)))) (if (shen.pvar? V3623) (let A (shen.newpv V3934) (do (shen.bindv V3623 (cons A ()) V3934) (let Result (do (shen.incinfs) (thaw V3935)) (do (shen.unbindv V3623 V3934) Result)))) false))) (if (shen.pvar? V3622) (do (shen.bindv V3622 list V3934) (let Result (let V3625 (shen.lazyderef (tl V3621) V3934) (if (cons? V3625) (let A (hd V3625) (let V3626 (shen.lazyderef (tl V3625) V3934) (if (= () V3626) (do (shen.incinfs) (thaw V3935)) (if (shen.pvar? V3626) (do (shen.bindv V3626 () V3934) (let Result (do (shen.incinfs) (thaw V3935)) (do (shen.unbindv V3626 V3934) Result))) false)))) (if (shen.pvar? V3625) (let A (shen.newpv V3934) (do (shen.bindv V3625 (cons A ()) V3934) (let Result (do (shen.incinfs) (thaw V3935)) (do (shen.unbindv V3625 V3934) Result)))) false))) (do (shen.unbindv V3622 V3934) Result))) false))) (if (shen.pvar? V3621) (let A (shen.newpv V3934) (do (shen.bindv V3621 (cons list (cons A ())) V3934) (let Result (do (shen.incinfs) (thaw V3935)) (do (shen.unbindv V3621 V3934) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V3941 V3942 V3943 V3944 V3945) (let Case (let V3607 (shen.lazyderef V3943 V3944) (if (cons? V3607) (let V3608 (shen.lazyderef (hd V3607) V3944) (if (cons? V3608) (let Y (hd V3608) (let V3609 (shen.lazyderef (tl V3608) V3944) (if (cons? V3609) (let V3610 (shen.lazyderef (hd V3609) V3944) (if (= : V3610) (let V3611 (shen.lazyderef (tl V3609) V3944) (if (cons? V3611) (let B (hd V3611) (let V3612 (shen.lazyderef (tl V3611) V3944) (if (= () V3612) (do (shen.incinfs) (identical V3941 Y V3944 (freeze (unify! V3942 B V3944 V3945)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V3613 (shen.lazyderef V3943 V3944) (if (cons? V3613) (let Hyp (tl V3613) (do (shen.incinfs) (shen.by_hypothesis V3941 V3942 Hyp V3944 V3945))) false)) Case)))

(defun shen.t*-def (V3951 V3952 V3953 V3954 V3955) (let V3601 (shen.lazyderef V3951 V3954) (if (cons? V3601) (let V3602 (shen.lazyderef (hd V3601) V3954) (if (= define V3602) (let V3603 (shen.lazyderef (tl V3601) V3954) (if (cons? V3603) (let F (hd V3603) (let X (tl V3603) (let Y (shen.newpv V3954) (let E (shen.newpv V3954) (do (shen.incinfs) (shen.t*-defh (compile (lambda Y (shen.<sig+rules> Y)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V3952 V3953 V3954 V3955)))))) false)) false)) false)))

(defun shen.t*-defh (V3962 V3963 V3964 V3965 V3966 V3967) (let V3597 (shen.lazyderef V3962 V3966) (if (cons? V3597) (let Sig (hd V3597) (let Rules (tl V3597) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V3963 V3964 V3965 Rules V3966 V3967)))) false)))

(defun shen.t*-defhh (V3976 V3977 V3978 V3979 V3980 V3981 V3982 V3983) (do (shen.incinfs) (shen.t*-rules V3981 V3977 1 V3978 (cons (cons V3978 (cons : (cons V3977 ()))) V3980) V3982 (freeze (shen.memo V3978 V3976 V3979 V3982 V3983)))))

(defun shen.memo (V3989 V3990 V3991 V3992 V3993) (let Jnk (shen.newpv V3992) (do (shen.incinfs) (unify! V3991 V3990 V3992 (freeze (bind Jnk (declare (shen.lazyderef V3989 V3992) (shen.lazyderef V3991 V3992)) V3992 V3993))))))

(defun shen.<sig+rules> (V3995) (let Parse_shen.<signature> (shen.<signature> V3995) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V3997) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V3997) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V3997) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V3999) (cond ((and (cons? V3999) (and (cons? (tl V3999)) (and (= () (tl (tl V3999))) (= (hd V3999) protect)))) V3999) ((cons? V3999) (map (lambda Z (shen.ue Z)) V3999)) ((variable? V3999) (concat && V3999)) (true V3999)))

(defun shen.ue-sig (V4001) (cond ((cons? V4001) (map (lambda Z (shen.ue-sig Z)) V4001)) ((variable? V4001) (concat &&& V4001)) (true V4001)))

(defun shen.ues (V4007) (cond ((shen.ue? V4007) (cons V4007 ())) ((cons? V4007) (union (shen.ues (hd V4007)) (shen.ues (tl V4007)))) (true ())))

(defun shen.ue? (V4009) (and (symbol? V4009) (shen.ue-h? (str V4009))))

(defun shen.ue-h? (V4017) (cond ((and (shen.+string? V4017) (and (= "&" (pos V4017 0)) (and (shen.+string? (tlstr V4017)) (= "&" (pos (tlstr V4017) 0))))) true) (true false)))

(defun shen.t*-rules (V4025 V4026 V4027 V4028 V4029 V4030 V4031) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3581 (shen.lazyderef V4025 V4030) (if (= () V3581) (do (shen.incinfs) (thaw V4031)) false)) (if (= Case false) (let Case (let V3582 (shen.lazyderef V4025 V4030) (if (cons? V3582) (let Rule (hd V3582) (let Rules (tl V3582) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V4026 V4029 V4030 (freeze (cut Throwcontrol V4030 (freeze (shen.t*-rules Rules V4026 (+ V4027 1) V4028 V4029 V4030 V4031)))))))) false)) (if (= Case false) (let Err (shen.newpv V4030) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V4027 V4030) (cn " of " (shen.app (shen.lazyderef V4028 V4030) "" shen.a)) shen.a))) V4030 V4031))) Case)) Case)))))

(defun shen.t*-rule (V4037 V4038 V4039 V4040 V4041) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V3573 (shen.lazyderef V4037 V4040) (if (cons? V3573) (let Patterns (hd V3573) (let V3574 (shen.lazyderef (tl V3573) V4040) (if (cons? V3574) (let Action (hd V3574) (let V3575 (shen.lazyderef (tl V3574) V4040) (if (= () V3575) (let NewHyps (shen.newpv V4040) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V4039 NewHyps V4040 (freeze (shen.t*-patterns Patterns V4038 NewHyps V4040 (freeze (cut Throwcontrol V4040 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V4038) (shen.patthyps Patterns V4038 V4039) V4040 V4041))))))))) false))) false))) false)))))

(defun shen.placeholders (V4047) (cond ((shen.ue? V4047) (cons V4047 ())) ((cons? V4047) (union (shen.placeholders (hd V4047)) (shen.placeholders (tl V4047)))) (true ())))

(defun shen.newhyps (V4053 V4054 V4055 V4056 V4057) (let Case (let V3560 (shen.lazyderef V4053 V4056) (if (= () V3560) (do (shen.incinfs) (unify! V4055 V4054 V4056 V4057)) false)) (if (= Case false) (let V3561 (shen.lazyderef V4053 V4056) (if (cons? V3561) (let V3556 (hd V3561) (let Vs (tl V3561) (let V3562 (shen.lazyderef V4055 V4056) (if (cons? V3562) (let V3563 (shen.lazyderef (hd V3562) V4056) (if (cons? V3563) (let V (hd V3563) (let V3564 (shen.lazyderef (tl V3563) V4056) (if (cons? V3564) (let V3565 (shen.lazyderef (hd V3564) V4056) (if (= : V3565) (let V3566 (shen.lazyderef (tl V3564) V4056) (if (cons? V3566) (let A (hd V3566) (let V3567 (shen.lazyderef (tl V3566) V4056) (if (= () V3567) (let NewHyp (tl V3562) (do (shen.incinfs) (unify! V V3556 V4056 (freeze (shen.newhyps Vs V4054 NewHyp V4056 V4057))))) (if (shen.pvar? V3567) (do (shen.bindv V3567 () V4056) (let Result (let NewHyp (tl V3562) (do (shen.incinfs) (unify! V V3556 V4056 (freeze (shen.newhyps Vs V4054 NewHyp V4056 V4057))))) (do (shen.unbindv V3567 V4056) Result))) false)))) (if (shen.pvar? V3566) (let A (shen.newpv V4056) (do (shen.bindv V3566 (cons A ()) V4056) (let Result (let NewHyp (tl V3562) (do (shen.incinfs) (unify! V V3556 V4056 (freeze (shen.newhyps Vs V4054 NewHyp V4056 V4057))))) (do (shen.unbindv V3566 V4056) Result)))) false))) (if (shen.pvar? V3565) (do (shen.bindv V3565 : V4056) (let Result (let V3568 (shen.lazyderef (tl V3564) V4056) (if (cons? V3568) (let A (hd V3568) (let V3569 (shen.lazyderef (tl V3568) V4056) (if (= () V3569) (let NewHyp (tl V3562) (do (shen.incinfs) (unify! V V3556 V4056 (freeze (shen.newhyps Vs V4054 NewHyp V4056 V4057))))) (if (shen.pvar? V3569) (do (shen.bindv V3569 () V4056) (let Result (let NewHyp (tl V3562) (do (shen.incinfs) (unify! V V3556 V4056 (freeze (shen.newhyps Vs V4054 NewHyp V4056 V4057))))) (do (shen.unbindv V3569 V4056) Result))) false)))) (if (shen.pvar? V3568) (let A (shen.newpv V4056) (do (shen.bindv V3568 (cons A ()) V4056) (let Result (let NewHyp (tl V3562) (do (shen.incinfs) (unify! V V3556 V4056 (freeze (shen.newhyps Vs V4054 NewHyp V4056 V4057))))) (do (shen.unbindv V3568 V4056) Result)))) false))) (do (shen.unbindv V3565 V4056) Result))) false))) (if (shen.pvar? V3564) (let A (shen.newpv V4056) (do (shen.bindv V3564 (cons : (cons A ())) V4056) (let Result (let NewHyp (tl V3562) (do (shen.incinfs) (unify! V V3556 V4056 (freeze (shen.newhyps Vs V4054 NewHyp V4056 V4057))))) (do (shen.unbindv V3564 V4056) Result)))) false)))) (if (shen.pvar? V3563) (let V (shen.newpv V4056) (let A (shen.newpv V4056) (do (shen.bindv V3563 (cons V (cons : (cons A ()))) V4056) (let Result (let NewHyp (tl V3562) (do (shen.incinfs) (unify! V V3556 V4056 (freeze (shen.newhyps Vs V4054 NewHyp V4056 V4057))))) (do (shen.unbindv V3563 V4056) Result))))) false))) (if (shen.pvar? V3562) (let V (shen.newpv V4056) (let A (shen.newpv V4056) (let NewHyp (shen.newpv V4056) (do (shen.bindv V3562 (cons (cons V (cons : (cons A ()))) NewHyp) V4056) (let Result (do (shen.incinfs) (unify! V V3556 V4056 (freeze (shen.newhyps Vs V4054 NewHyp V4056 V4057)))) (do (shen.unbindv V3562 V4056) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V4063 V4064 V4065) (cond ((= () V4063) V4065) ((and (cons? V4063) (and (cons? V4064) (and (cons? (tl V4064)) (and (= --> (hd (tl V4064))) (and (cons? (tl (tl V4064))) (= () (tl (tl (tl V4064))))))))) (adjoin (cons (hd V4063) (cons : (cons (hd V4064) ()))) (shen.patthyps (tl V4063) (hd (tl (tl V4064))) V4065))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V4072 V4073) (cond ((and (= () V4072) (and (cons? V4073) (and (= --> (hd V4073)) (and (cons? (tl V4073)) (= () (tl (tl V4073))))))) (hd (tl V4073))) ((= () V4072) V4073) ((and (cons? V4072) (and (cons? V4073) (and (cons? (tl V4073)) (and (= --> (hd (tl V4073))) (and (cons? (tl (tl V4073))) (= () (tl (tl (tl V4073))))))))) (shen.result-type (tl V4072) (hd (tl (tl V4073))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V4079 V4080 V4081 V4082 V4083) (let Case (let V3548 (shen.lazyderef V4079 V4082) (if (= () V3548) (do (shen.incinfs) (thaw V4083)) false)) (if (= Case false) (let V3549 (shen.lazyderef V4079 V4082) (if (cons? V3549) (let Pattern (hd V3549) (let Patterns (tl V3549) (let V3550 (shen.lazyderef V4080 V4082) (if (cons? V3550) (let A (hd V3550) (let V3551 (shen.lazyderef (tl V3550) V4082) (if (cons? V3551) (let V3552 (shen.lazyderef (hd V3551) V4082) (if (= --> V3552) (let V3553 (shen.lazyderef (tl V3551) V4082) (if (cons? V3553) (let B (hd V3553) (let V3554 (shen.lazyderef (tl V3553) V4082) (if (= () V3554) (do (shen.incinfs) (shen.t* (cons Pattern (cons : (cons A ()))) V4081 V4082 (freeze (shen.t*-patterns Patterns B V4081 V4082 V4083)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V4089 V4090 V4091 V4092 V4093) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3525 (shen.lazyderef V4089 V4092) (if (cons? V3525) (let V3526 (shen.lazyderef (hd V3525) V4092) (if (= where V3526) (let V3527 (shen.lazyderef (tl V3525) V4092) (if (cons? V3527) (let P (hd V3527) (let V3528 (shen.lazyderef (tl V3527) V4092) (if (cons? V3528) (let Action (hd V3528) (let V3529 (shen.lazyderef (tl V3528) V4092) (if (= () V3529) (do (shen.incinfs) (cut Throwcontrol V4092 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V4091 V4092 (freeze (cut Throwcontrol V4092 (freeze (shen.t*-action Action V4090 (cons (cons P (cons : (cons verified ()))) V4091) V4092 V4093)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3530 (shen.lazyderef V4089 V4092) (if (cons? V3530) (let V3531 (shen.lazyderef (hd V3530) V4092) (if (= shen.choicepoint! V3531) (let V3532 (shen.lazyderef (tl V3530) V4092) (if (cons? V3532) (let V3533 (shen.lazyderef (hd V3532) V4092) (if (cons? V3533) (let V3534 (shen.lazyderef (hd V3533) V4092) (if (cons? V3534) (let V3535 (shen.lazyderef (hd V3534) V4092) (if (= fail-if V3535) (let V3536 (shen.lazyderef (tl V3534) V4092) (if (cons? V3536) (let F (hd V3536) (let V3537 (shen.lazyderef (tl V3536) V4092) (if (= () V3537) (let V3538 (shen.lazyderef (tl V3533) V4092) (if (cons? V3538) (let Action (hd V3538) (let V3539 (shen.lazyderef (tl V3538) V4092) (if (= () V3539) (let V3540 (shen.lazyderef (tl V3532) V4092) (if (= () V3540) (do (shen.incinfs) (cut Throwcontrol V4092 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V4090 V4091 V4092 V4093)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3541 (shen.lazyderef V4089 V4092) (if (cons? V3541) (let V3542 (shen.lazyderef (hd V3541) V4092) (if (= shen.choicepoint! V3542) (let V3543 (shen.lazyderef (tl V3541) V4092) (if (cons? V3543) (let Action (hd V3543) (let V3544 (shen.lazyderef (tl V3543) V4092) (if (= () V3544) (do (shen.incinfs) (cut Throwcontrol V4092 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V4090 V4091 V4092 V4093)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V4089 (cons : (cons V4090 ()))) V4091 V4092 V4093)) Case)) Case)) Case)))))

(defun findall (V4099 V4100 V4101 V4102 V4103) (let B (shen.newpv V4102) (let A (shen.newpv V4102) (do (shen.incinfs) (bind A (gensym shen.a) V4102 (freeze (bind B (set (shen.lazyderef A V4102) ()) V4102 (freeze (shen.findallhelp V4099 V4100 V4101 A V4102 V4103)))))))))

(defun shen.findallhelp (V4110 V4111 V4112 V4113 V4114 V4115) (let Case (do (shen.incinfs) (call V4111 V4114 (freeze (shen.remember V4113 V4110 V4114 (freeze (fwhen false V4114 V4115)))))) (if (= Case false) (do (shen.incinfs) (bind V4112 (value (shen.lazyderef V4113 V4114)) V4114 V4115)) Case)))

(defun shen.remember (V4120 V4121 V4122 V4123) (let B (shen.newpv V4122) (do (shen.incinfs) (bind B (set (shen.deref V4120 V4122) (cons (shen.deref V4121 V4122) (value (shen.deref V4120 V4122)))) V4122 V4123))))



