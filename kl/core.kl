"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.shen->kl (V1191 V1192) (compile (lambda X (shen.<define> X)) (cons V1191 V1192) (lambda X (shen.shen-syntax-error V1191 X))))

(defun shen.shen-syntax-error (V1199 V1200) (cond ((cons? V1200) (simple-error (cn "syntax error in " (shen.app V1199 (cn " here:

 " (shen.app (shen.next-50 50 (hd V1200)) "
" shen.a)) shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V1199 "
" shen.a))))))

(defun shen.<define> (V1202) (let YaccParse (let Parse_shen.<name> (shen.<name> V1202) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<signature> (shen.<signature> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<name> (shen.<name> V1202) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) YaccParse)))

(defun shen.<name> (V1204) (if (cons? (hd V1204)) (let Parse_X (shen.hdhd V1204) (shen.pair (hd (shen.pair (shen.tlhd V1204) (shen.hdtl V1204))) (if (and (symbol? Parse_X) (not (shen.sysfunc? Parse_X))) Parse_X (simple-error (shen.app Parse_X " is not a legitimate function name.
" shen.a))))) (fail)))

(defun shen.sysfunc? (V1206) (element? V1206 (get (intern "shen") shen.external-symbols (value *property-vector*))))

(defun shen.<signature> (V1210) (if (and (cons? (hd V1210)) (= { (shen.hdhd V1210))) (let NewStream1207 (shen.pair (shen.tlhd V1210) (shen.hdtl V1210)) (let Parse_shen.<signature-help> (shen.<signature-help> NewStream1207) (if (not (= (fail) Parse_shen.<signature-help>)) (if (and (cons? (hd Parse_shen.<signature-help>)) (= } (shen.hdhd Parse_shen.<signature-help>))) (let NewStream1208 (shen.pair (shen.tlhd Parse_shen.<signature-help>) (shen.hdtl Parse_shen.<signature-help>)) (shen.pair (hd NewStream1208) (shen.demodulate (shen.curry-type (shen.hdtl Parse_shen.<signature-help>))))) (fail)) (fail)))) (fail)))

(defun shen.curry-type (V1212) (cond ((and (cons? V1212) (and (cons? (tl V1212)) (and (= --> (hd (tl V1212))) (and (cons? (tl (tl V1212))) (and (cons? (tl (tl (tl V1212)))) (= --> (hd (tl (tl (tl V1212)))))))))) (shen.curry-type (cons (hd V1212) (cons --> (cons (tl (tl V1212)) ()))))) ((and (cons? V1212) (and (cons? (tl V1212)) (and (= * (hd (tl V1212))) (and (cons? (tl (tl V1212))) (and (cons? (tl (tl (tl V1212)))) (= * (hd (tl (tl (tl V1212)))))))))) (shen.curry-type (cons (hd V1212) (cons * (cons (tl (tl V1212)) ()))))) ((cons? V1212) (map (lambda Z (shen.curry-type Z)) V1212)) (true V1212)))

(defun shen.<signature-help> (V1214) (let YaccParse (if (cons? (hd V1214)) (let Parse_X (shen.hdhd V1214) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (shen.tlhd V1214) (shen.hdtl V1214))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (not (element? Parse_X (cons { (cons } ())))) (shen.pair (hd Parse_shen.<signature-help>) (cons Parse_X (shen.hdtl Parse_shen.<signature-help>))) (fail)) (fail)))) (fail)) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1214) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<rules> (V1216) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V1216) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V1216) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) ())) (fail))) YaccParse)))

(defun shen.<rule> (V1224) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1224) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (shen.hdhd Parse_shen.<patterns>))) (let NewStream1217 (shen.pair (shen.tlhd Parse_shen.<patterns>) (shen.hdtl Parse_shen.<patterns>)) (let Parse_shen.<action> (shen.<action> NewStream1217) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (shen.hdhd Parse_shen.<action>))) (let NewStream1218 (shen.pair (shen.tlhd Parse_shen.<action>) (shen.hdtl Parse_shen.<action>)) (let Parse_shen.<guard> (shen.<guard> NewStream1218) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<action>) ()))) ()))) (fail)))) (fail)) (fail)))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1224) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (shen.hdhd Parse_shen.<patterns>))) (let NewStream1219 (shen.pair (shen.tlhd Parse_shen.<patterns>) (shen.hdtl Parse_shen.<patterns>)) (let Parse_shen.<action> (shen.<action> NewStream1219) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<action>) ()))) (fail)))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1224) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (shen.hdhd Parse_shen.<patterns>))) (let NewStream1220 (shen.pair (shen.tlhd Parse_shen.<patterns>) (shen.hdtl Parse_shen.<patterns>)) (let Parse_shen.<action> (shen.<action> NewStream1220) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (shen.hdhd Parse_shen.<action>))) (let NewStream1221 (shen.pair (shen.tlhd Parse_shen.<action>) (shen.hdtl Parse_shen.<action>)) (let Parse_shen.<guard> (shen.<guard> NewStream1221) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) ()))) (fail)))) (fail)) (fail)))) (fail)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<patterns> (shen.<patterns> V1224) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (shen.hdhd Parse_shen.<patterns>))) (let NewStream1222 (shen.pair (shen.tlhd Parse_shen.<patterns>) (shen.hdtl Parse_shen.<patterns>)) (let Parse_shen.<action> (shen.<action> NewStream1222) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) (fail)))) (fail)) (fail))) YaccParse)) YaccParse)) YaccParse)))

(defun shen.fail_if (V1227 V1228) (if (V1227 V1228) (fail) V1228))

(defun shen.succeeds? (V1234) (cond ((= V1234 (fail)) false) (true true)))

(defun shen.<patterns> (V1236) (let YaccParse (let Parse_shen.<pattern> (shen.<pattern> V1236) (if (not (= (fail) Parse_shen.<pattern>)) (let Parse_shen.<patterns> (shen.<patterns> Parse_shen.<pattern>) (if (not (= (fail) Parse_shen.<patterns>)) (shen.pair (hd Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<pattern>) (shen.hdtl Parse_shen.<patterns>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1236) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<pattern> (V1249) (let YaccParse (if (and (cons? (hd V1249)) (cons? (shen.hdhd V1249))) (if (and (cons? (hd (shen.pair (shen.hdhd V1249) (shen.hdtl V1249)))) (= @p (shen.hdhd (shen.pair (shen.hdhd V1249) (shen.hdtl V1249))))) (let NewStream1238 (shen.pair (shen.tlhd (shen.pair (shen.hdhd V1249) (shen.hdtl V1249))) (shen.hdtl (shen.pair (shen.hdhd V1249) (shen.hdtl V1249)))) (let Parse_shen.<pattern1> (shen.<pattern1> NewStream1238) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (shen.tlhd V1249) (shen.hdtl V1249))) (cons @p (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail)))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1249)) (cons? (shen.hdhd V1249))) (if (and (cons? (hd (shen.pair (shen.hdhd V1249) (shen.hdtl V1249)))) (= cons (shen.hdhd (shen.pair (shen.hdhd V1249) (shen.hdtl V1249))))) (let NewStream1240 (shen.pair (shen.tlhd (shen.pair (shen.hdhd V1249) (shen.hdtl V1249))) (shen.hdtl (shen.pair (shen.hdhd V1249) (shen.hdtl V1249)))) (let Parse_shen.<pattern1> (shen.<pattern1> NewStream1240) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (shen.tlhd V1249) (shen.hdtl V1249))) (cons cons (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail)))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1249)) (cons? (shen.hdhd V1249))) (if (and (cons? (hd (shen.pair (shen.hdhd V1249) (shen.hdtl V1249)))) (= @v (shen.hdhd (shen.pair (shen.hdhd V1249) (shen.hdtl V1249))))) (let NewStream1242 (shen.pair (shen.tlhd (shen.pair (shen.hdhd V1249) (shen.hdtl V1249))) (shen.hdtl (shen.pair (shen.hdhd V1249) (shen.hdtl V1249)))) (let Parse_shen.<pattern1> (shen.<pattern1> NewStream1242) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (shen.tlhd V1249) (shen.hdtl V1249))) (cons @v (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail)))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1249)) (cons? (shen.hdhd V1249))) (if (and (cons? (hd (shen.pair (shen.hdhd V1249) (shen.hdtl V1249)))) (= @s (shen.hdhd (shen.pair (shen.hdhd V1249) (shen.hdtl V1249))))) (let NewStream1244 (shen.pair (shen.tlhd (shen.pair (shen.hdhd V1249) (shen.hdtl V1249))) (shen.hdtl (shen.pair (shen.hdhd V1249) (shen.hdtl V1249)))) (let Parse_shen.<pattern1> (shen.<pattern1> NewStream1244) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (shen.tlhd V1249) (shen.hdtl V1249))) (cons @s (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail)))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1249)) (cons? (shen.hdhd V1249))) (if (and (cons? (hd (shen.pair (shen.hdhd V1249) (shen.hdtl V1249)))) (= vector (shen.hdhd (shen.pair (shen.hdhd V1249) (shen.hdtl V1249))))) (let NewStream1246 (shen.pair (shen.tlhd (shen.pair (shen.hdhd V1249) (shen.hdtl V1249))) (shen.hdtl (shen.pair (shen.hdhd V1249) (shen.hdtl V1249)))) (if (and (cons? (hd NewStream1246)) (= 0 (shen.hdhd NewStream1246))) (let NewStream1247 (shen.pair (shen.tlhd NewStream1246) (shen.hdtl NewStream1246)) (shen.pair (hd (shen.pair (shen.tlhd V1249) (shen.hdtl V1249))) (cons vector (cons 0 ())))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (cons? (hd V1249)) (let Parse_X (shen.hdhd V1249) (if (cons? Parse_X) (shen.pair (hd (shen.pair (shen.tlhd V1249) (shen.hdtl V1249))) (shen.constructor-error Parse_X)) (fail))) (fail)) (if (= YaccParse (fail)) (let Parse_shen.<simple_pattern> (shen.<simple_pattern> V1249) (if (not (= (fail) Parse_shen.<simple_pattern>)) (shen.pair (hd Parse_shen.<simple_pattern>) (shen.hdtl Parse_shen.<simple_pattern>)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.constructor-error (V1251) (simple-error (shen.app V1251 " is not a legitimate constructor
" shen.a)))

(defun shen.<simple_pattern> (V1253) (let YaccParse (if (cons? (hd V1253)) (let Parse_X (shen.hdhd V1253) (if (= Parse_X _) (shen.pair (hd (shen.pair (shen.tlhd V1253) (shen.hdtl V1253))) (gensym Parse_Y)) (fail))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V1253)) (let Parse_X (shen.hdhd V1253) (if (not (element? Parse_X (cons -> (cons <- ())))) (shen.pair (hd (shen.pair (shen.tlhd V1253) (shen.hdtl V1253))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<pattern1> (V1255) (let Parse_shen.<pattern> (shen.<pattern> V1255) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<pattern2> (V1257) (let Parse_shen.<pattern> (shen.<pattern> V1257) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<action> (V1259) (if (cons? (hd V1259)) (let Parse_X (shen.hdhd V1259) (shen.pair (hd (shen.pair (shen.tlhd V1259) (shen.hdtl V1259))) Parse_X)) (fail)))

(defun shen.<guard> (V1261) (if (cons? (hd V1261)) (let Parse_X (shen.hdhd V1261) (shen.pair (hd (shen.pair (shen.tlhd V1261) (shen.hdtl V1261))) Parse_X)) (fail)))

(defun shen.compile_to_machine_code (V1264 V1265) (let Lambda+ (shen.compile_to_lambda+ V1264 V1265) (let KL (shen.compile_to_kl V1264 Lambda+) (let Record (shen.record-source V1264 KL) KL))))

(defun shen.record-source (V1270 V1271) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1270 shen.source V1271 (value *property-vector*)))))

(defun shen.compile_to_lambda+ (V1274 V1275) (let Arity (shen.aritycheck V1274 V1275) (let UpDateSymbolTable (shen.update-symbol-table V1274 Arity) (let Free (shen.for-each (lambda Rule (shen.free_variable_check V1274 Rule)) V1275) (let Variables (shen.parameters Arity) (let Strip (map (lambda X (shen.strip-protect X)) V1275) (let Abstractions (map (lambda X (shen.abstract_rule X)) Strip) (let Applications (map (lambda X (shen.application_build Variables X)) Abstractions) (cons Variables (cons Applications ()))))))))))

(defun shen.update-symbol-table (V1278 V1279) (cond ((= 0 V1279) shen.skip) (true (put V1278 shen.lambda-form (eval-kl (shen.lambda-form V1278 V1279)) (value *property-vector*)))))

(defun shen.free_variable_check (V1282 V1283) (cond ((and (cons? V1283) (and (cons? (tl V1283)) (= () (tl (tl V1283))))) (let Bound (shen.extract_vars (hd V1283)) (let Free (shen.extract_free_vars Bound (hd (tl V1283))) (shen.free_variable_warnings V1282 Free)))) (true (shen.f_error shen.free_variable_check))))

(defun shen.extract_vars (V1285) (cond ((variable? V1285) (cons V1285 ())) ((cons? V1285) (union (shen.extract_vars (hd V1285)) (shen.extract_vars (tl V1285)))) (true ())))

(defun shen.extract_free_vars (V1297 V1298) (cond ((and (cons? V1298) (and (cons? (tl V1298)) (and (= () (tl (tl V1298))) (= (hd V1298) protect)))) ()) ((and (variable? V1298) (not (element? V1298 V1297))) (cons V1298 ())) ((and (cons? V1298) (and (= lambda (hd V1298)) (and (cons? (tl V1298)) (and (cons? (tl (tl V1298))) (= () (tl (tl (tl V1298)))))))) (shen.extract_free_vars (cons (hd (tl V1298)) V1297) (hd (tl (tl V1298))))) ((and (cons? V1298) (and (= let (hd V1298)) (and (cons? (tl V1298)) (and (cons? (tl (tl V1298))) (and (cons? (tl (tl (tl V1298)))) (= () (tl (tl (tl (tl V1298)))))))))) (union (shen.extract_free_vars V1297 (hd (tl (tl V1298)))) (shen.extract_free_vars (cons (hd (tl V1298)) V1297) (hd (tl (tl (tl V1298))))))) ((cons? V1298) (union (shen.extract_free_vars V1297 (hd V1298)) (shen.extract_free_vars V1297 (tl V1298)))) (true ())))

(defun shen.free_variable_warnings (V1303 V1304) (cond ((= () V1304) _) (true (simple-error (cn "error: the following variables are free in " (shen.app V1303 (cn ": " (shen.app (shen.list_variables V1304) "" shen.a)) shen.a))))))

(defun shen.list_variables (V1306) (cond ((and (cons? V1306) (= () (tl V1306))) (cn (str (hd V1306)) ".")) ((cons? V1306) (cn (str (hd V1306)) (cn ", " (shen.list_variables (tl V1306))))) (true (shen.f_error shen.list_variables))))

(defun shen.strip-protect (V1308) (cond ((and (cons? V1308) (and (cons? (tl V1308)) (and (= () (tl (tl V1308))) (= (hd V1308) protect)))) (shen.strip-protect (hd (tl V1308)))) ((cons? V1308) (map (lambda Z (shen.strip-protect Z)) V1308)) (true V1308)))

(defun shen.linearise (V1310) (cond ((and (cons? V1310) (and (cons? (tl V1310)) (= () (tl (tl V1310))))) (shen.linearise_help (shen.flatten (hd V1310)) (hd V1310) (hd (tl V1310)))) (true (shen.f_error shen.linearise))))

(defun shen.flatten (V1312) (cond ((= () V1312) ()) ((cons? V1312) (append (shen.flatten (hd V1312)) (shen.flatten (tl V1312)))) (true (cons V1312 ()))))

(defun shen.linearise_help (V1316 V1317 V1318) (cond ((= () V1316) (cons V1317 (cons V1318 ()))) ((cons? V1316) (if (and (variable? (hd V1316)) (element? (hd V1316) (tl V1316))) (let Var (gensym (hd V1316)) (let NewAction (cons where (cons (cons = (cons (hd V1316) (cons Var ()))) (cons V1318 ()))) (let NewPatts (shen.linearise_X (hd V1316) Var V1317) (shen.linearise_help (tl V1316) NewPatts NewAction)))) (shen.linearise_help (tl V1316) V1317 V1318))) (true (shen.f_error shen.linearise_help))))

(defun shen.linearise_X (V1331 V1332 V1333) (cond ((= V1333 V1331) V1332) ((cons? V1333) (let L (shen.linearise_X V1331 V1332 (hd V1333)) (if (= L (hd V1333)) (cons (hd V1333) (shen.linearise_X V1331 V1332 (tl V1333))) (cons L (tl V1333))))) (true V1333)))

(defun shen.aritycheck (V1336 V1337) (cond ((and (cons? V1337) (and (cons? (hd V1337)) (and (cons? (tl (hd V1337))) (and (= () (tl (tl (hd V1337)))) (= () (tl V1337)))))) (do (shen.aritycheck-action (hd (tl (hd V1337)))) (shen.aritycheck-name V1336 (arity V1336) (length (hd (hd V1337)))))) ((and (cons? V1337) (and (cons? (hd V1337)) (and (cons? (tl (hd V1337))) (and (= () (tl (tl (hd V1337)))) (and (cons? (tl V1337)) (and (cons? (hd (tl V1337))) (and (cons? (tl (hd (tl V1337)))) (= () (tl (tl (hd (tl V1337)))))))))))) (if (= (length (hd (hd V1337))) (length (hd (hd (tl V1337))))) (do (shen.aritycheck-action (hd (tl (hd V1337)))) (shen.aritycheck V1336 (tl V1337))) (simple-error (cn "arity error in " (shen.app V1336 "
" shen.a))))) (true (shen.f_error shen.aritycheck))))

(defun shen.aritycheck-name (V1350 V1351 V1352) (cond ((= -1 V1351) V1352) ((= V1352 V1351) V1352) (true (do (shen.prhush (cn "
warning: changing the arity of " (shen.app V1350 " can cause errors.
" shen.a)) (stoutput)) V1352))))

(defun shen.aritycheck-action (V1358) (cond ((cons? V1358) (do (shen.aah (hd V1358) (tl V1358)) (shen.for-each (lambda Y (shen.aritycheck-action Y)) V1358))) (true shen.skip)))

(defun shen.aah (V1361 V1362) (let Arity (arity V1361) (let Len (length V1362) (if (and (> Arity -1) (> Len Arity)) (shen.prhush (cn "warning: " (shen.app V1361 (cn " might not like " (shen.app Len (cn " argument" (shen.app (if (> Len 1) "s" "") ".
" shen.a)) shen.a)) shen.a)) (stoutput)) shen.skip))))

(defun shen.abstract_rule (V1364) (cond ((and (cons? V1364) (and (cons? (tl V1364)) (= () (tl (tl V1364))))) (shen.abstraction_build (hd V1364) (hd (tl V1364)))) (true (shen.f_error shen.abstract_rule))))

(defun shen.abstraction_build (V1367 V1368) (cond ((= () V1367) V1368) ((cons? V1367) (cons /. (cons (hd V1367) (cons (shen.abstraction_build (tl V1367) V1368) ())))) (true (shen.f_error shen.abstraction_build))))

(defun shen.parameters (V1370) (cond ((= 0 V1370) ()) (true (cons (gensym V) (shen.parameters (- V1370 1))))))

(defun shen.application_build (V1373 V1374) (cond ((= () V1373) V1374) ((cons? V1373) (shen.application_build (tl V1373) (cons V1374 (cons (hd V1373) ())))) (true (shen.f_error shen.application_build))))

(defun shen.compile_to_kl (V1377 V1378) (cond ((and (cons? V1378) (and (cons? (tl V1378)) (= () (tl (tl V1378))))) (let Arity (shen.store-arity V1377 (length (hd V1378))) (let Reduce (map (lambda X (shen.reduce X)) (hd (tl V1378))) (let CondExpression (shen.cond-expression V1377 (hd V1378) Reduce) (let TypeTable (if (value shen.*optimise*) (shen.typextable (shen.get-type V1377) (hd V1378)) shen.skip) (let TypedCondExpression (if (value shen.*optimise*) (shen.assign-types (hd V1378) TypeTable CondExpression) CondExpression) (cons defun (cons V1377 (cons (hd V1378) (cons TypedCondExpression ())))))))))) (true (shen.f_error shen.compile_to_kl))))

(defun shen.get-type (V1384) (cond ((cons? V1384) shen.skip) (true (let FType (assoc V1384 (value shen.*signedfuncs*)) (if (empty? FType) shen.skip (tl FType))))))

(defun shen.typextable (V1395 V1396) (cond ((and (cons? V1395) (and (cons? (tl V1395)) (and (= --> (hd (tl V1395))) (and (cons? (tl (tl V1395))) (and (= () (tl (tl (tl V1395)))) (cons? V1396)))))) (if (variable? (hd V1395)) (shen.typextable (hd (tl (tl V1395))) (tl V1396)) (cons (cons (hd V1396) (hd V1395)) (shen.typextable (hd (tl (tl V1395))) (tl V1396))))) (true ())))

(defun shen.assign-types (V1400 V1401 V1402) (cond ((and (cons? V1402) (and (= let (hd V1402)) (and (cons? (tl V1402)) (and (cons? (tl (tl V1402))) (and (cons? (tl (tl (tl V1402)))) (= () (tl (tl (tl (tl V1402)))))))))) (cons let (cons (hd (tl V1402)) (cons (shen.assign-types V1400 V1401 (hd (tl (tl V1402)))) (cons (shen.assign-types (cons (hd (tl V1402)) V1400) V1401 (hd (tl (tl (tl V1402))))) ()))))) ((and (cons? V1402) (and (= lambda (hd V1402)) (and (cons? (tl V1402)) (and (cons? (tl (tl V1402))) (= () (tl (tl (tl V1402)))))))) (cons lambda (cons (hd (tl V1402)) (cons (shen.assign-types (cons (hd (tl V1402)) V1400) V1401 (hd (tl (tl V1402)))) ())))) ((and (cons? V1402) (= cond (hd V1402))) (cons cond (map (lambda Y (cons (shen.assign-types V1400 V1401 (hd Y)) (cons (shen.assign-types V1400 V1401 (hd (tl Y))) ()))) (tl V1402)))) ((cons? V1402) (let NewTable (shen.typextable (shen.get-type (hd V1402)) (tl V1402)) (cons (hd V1402) (map (lambda Y (shen.assign-types V1400 (append V1401 NewTable) Y)) (tl V1402))))) (true (let AtomType (assoc V1402 V1401) (if (cons? AtomType) (cons type (cons V1402 (cons (tl AtomType) ()))) (if (element? V1402 V1400) V1402 (shen.atom-type V1402)))))))

(defun shen.atom-type (V1404) (if (string? V1404) (cons type (cons V1404 (cons string ()))) (if (number? V1404) (cons type (cons V1404 (cons number ()))) (if (boolean? V1404) (cons type (cons V1404 (cons boolean ()))) (if (symbol? V1404) (cons type (cons V1404 (cons symbol ()))) V1404)))))

(defun shen.store-arity (V1409 V1410) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1409 arity V1410 (value *property-vector*)))))

(defun shen.reduce (V1412) (do (set shen.*teststack* ()) (let Result (shen.reduce_help V1412) (cons (cons : (cons shen.tests (reverse (value shen.*teststack*)))) (cons Result ())))))

(defun shen.reduce_help (V1414) (cond ((and (cons? V1414) (and (cons? (hd V1414)) (and (= /. (hd (hd V1414))) (and (cons? (tl (hd V1414))) (and (cons? (hd (tl (hd V1414)))) (and (= cons (hd (hd (tl (hd V1414))))) (and (cons? (tl (hd (tl (hd V1414))))) (and (cons? (tl (tl (hd (tl (hd V1414)))))) (and (= () (tl (tl (tl (hd (tl (hd V1414))))))) (and (cons? (tl (tl (hd V1414)))) (and (= () (tl (tl (tl (hd V1414))))) (and (cons? (tl V1414)) (= () (tl (tl V1414))))))))))))))) (do (shen.add_test (cons cons? (tl V1414))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1414))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1414)))))) (cons (shen.ebr (hd (tl V1414)) (hd (tl (hd V1414))) (hd (tl (tl (hd V1414))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hd (tl V1414)) ())) (cons (cons tl (tl V1414)) ())) (shen.reduce_help Application))))) ((and (cons? V1414) (and (cons? (hd V1414)) (and (= /. (hd (hd V1414))) (and (cons? (tl (hd V1414))) (and (cons? (hd (tl (hd V1414)))) (and (= @p (hd (hd (tl (hd V1414))))) (and (cons? (tl (hd (tl (hd V1414))))) (and (cons? (tl (tl (hd (tl (hd V1414)))))) (and (= () (tl (tl (tl (hd (tl (hd V1414))))))) (and (cons? (tl (tl (hd V1414)))) (and (= () (tl (tl (tl (hd V1414))))) (and (cons? (tl V1414)) (= () (tl (tl V1414))))))))))))))) (do (shen.add_test (cons tuple? (tl V1414))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1414))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1414)))))) (cons (shen.ebr (hd (tl V1414)) (hd (tl (hd V1414))) (hd (tl (tl (hd V1414))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons fst (tl V1414)) ())) (cons (cons snd (tl V1414)) ())) (shen.reduce_help Application))))) ((and (cons? V1414) (and (cons? (hd V1414)) (and (= /. (hd (hd V1414))) (and (cons? (tl (hd V1414))) (and (cons? (hd (tl (hd V1414)))) (and (= @v (hd (hd (tl (hd V1414))))) (and (cons? (tl (hd (tl (hd V1414))))) (and (cons? (tl (tl (hd (tl (hd V1414)))))) (and (= () (tl (tl (tl (hd (tl (hd V1414))))))) (and (cons? (tl (tl (hd V1414)))) (and (= () (tl (tl (tl (hd V1414))))) (and (cons? (tl V1414)) (= () (tl (tl V1414))))))))))))))) (do (shen.add_test (cons shen.+vector? (tl V1414))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1414))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1414)))))) (cons (shen.ebr (hd (tl V1414)) (hd (tl (hd V1414))) (hd (tl (tl (hd V1414))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hdv (tl V1414)) ())) (cons (cons tlv (tl V1414)) ())) (shen.reduce_help Application))))) ((and (cons? V1414) (and (cons? (hd V1414)) (and (= /. (hd (hd V1414))) (and (cons? (tl (hd V1414))) (and (cons? (hd (tl (hd V1414)))) (and (= @s (hd (hd (tl (hd V1414))))) (and (cons? (tl (hd (tl (hd V1414))))) (and (cons? (tl (tl (hd (tl (hd V1414)))))) (and (= () (tl (tl (tl (hd (tl (hd V1414))))))) (and (cons? (tl (tl (hd V1414)))) (and (= () (tl (tl (tl (hd V1414))))) (and (cons? (tl V1414)) (= () (tl (tl V1414))))))))))))))) (do (shen.add_test (cons shen.+string? (tl V1414))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1414))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1414)))))) (cons (shen.ebr (hd (tl V1414)) (hd (tl (hd V1414))) (hd (tl (tl (hd V1414))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons pos (cons (hd (tl V1414)) (cons 0 ()))) ())) (cons (cons tlstr (tl V1414)) ())) (shen.reduce_help Application))))) ((and (cons? V1414) (and (cons? (hd V1414)) (and (= /. (hd (hd V1414))) (and (cons? (tl (hd V1414))) (and (cons? (tl (tl (hd V1414)))) (and (= () (tl (tl (tl (hd V1414))))) (and (cons? (tl V1414)) (and (= () (tl (tl V1414))) (not (variable? (hd (tl (hd V1414))))))))))))) (do (shen.add_test (cons = (cons (hd (tl (hd V1414))) (tl V1414)))) (shen.reduce_help (hd (tl (tl (hd V1414))))))) ((and (cons? V1414) (and (cons? (hd V1414)) (and (= /. (hd (hd V1414))) (and (cons? (tl (hd V1414))) (and (cons? (tl (tl (hd V1414)))) (and (= () (tl (tl (tl (hd V1414))))) (and (cons? (tl V1414)) (= () (tl (tl V1414)))))))))) (shen.reduce_help (shen.ebr (hd (tl V1414)) (hd (tl (hd V1414))) (hd (tl (tl (hd V1414))))))) ((and (cons? V1414) (and (= where (hd V1414)) (and (cons? (tl V1414)) (and (cons? (tl (tl V1414))) (= () (tl (tl (tl V1414)))))))) (do (shen.add_test (hd (tl V1414))) (shen.reduce_help (hd (tl (tl V1414)))))) ((and (cons? V1414) (and (cons? (tl V1414)) (= () (tl (tl V1414))))) (let Z (shen.reduce_help (hd V1414)) (if (= (hd V1414) Z) V1414 (shen.reduce_help (cons Z (tl V1414)))))) (true V1414)))

(defun shen.+string? (V1416) (cond ((= "" V1416) false) (true (string? V1416))))

(defun shen.+vector? (V1418) (and (absvector? V1418) (> (<-address V1418 0) 0)))

(defun shen.ebr (V1432 V1433 V1434) (cond ((= V1434 V1433) V1432) ((and (cons? V1434) (and (= /. (hd V1434)) (and (cons? (tl V1434)) (and (cons? (tl (tl V1434))) (and (= () (tl (tl (tl V1434)))) (> (occurrences V1433 (hd (tl V1434))) 0)))))) V1434) ((and (cons? V1434) (and (= lambda (hd V1434)) (and (cons? (tl V1434)) (and (cons? (tl (tl V1434))) (and (= () (tl (tl (tl V1434)))) (> (occurrences V1433 (hd (tl V1434))) 0)))))) V1434) ((and (cons? V1434) (and (= let (hd V1434)) (and (cons? (tl V1434)) (and (cons? (tl (tl V1434))) (and (cons? (tl (tl (tl V1434)))) (and (= () (tl (tl (tl (tl V1434))))) (= (hd (tl V1434)) V1433))))))) (cons let (cons (hd (tl V1434)) (cons (shen.ebr V1432 (hd (tl V1434)) (hd (tl (tl V1434)))) (tl (tl (tl V1434))))))) ((cons? V1434) (cons (shen.ebr V1432 V1433 (hd V1434)) (shen.ebr V1432 V1433 (tl V1434)))) (true V1434)))

(defun shen.add_test (V1436) (set shen.*teststack* (cons V1436 (value shen.*teststack*))))

(defun shen.cond-expression (V1440 V1441 V1442) (let Err (shen.err-condition V1440) (let Cases (shen.case-form V1442 Err) (let EncodeChoices (shen.encode-choices Cases V1440) (shen.cond-form EncodeChoices)))))

(defun shen.cond-form (V1446) (cond ((and (cons? V1446) (and (cons? (hd V1446)) (and (= true (hd (hd V1446))) (and (cons? (tl (hd V1446))) (= () (tl (tl (hd V1446)))))))) (hd (tl (hd V1446)))) (true (cons cond V1446))))

(defun shen.encode-choices (V1451 V1452) (cond ((= () V1451) ()) ((and (cons? V1451) (and (cons? (hd V1451)) (and (= true (hd (hd V1451))) (and (cons? (tl (hd V1451))) (and (cons? (hd (tl (hd V1451)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1451))))) (and (cons? (tl (hd (tl (hd V1451))))) (and (= () (tl (tl (hd (tl (hd V1451)))))) (and (= () (tl (tl (hd V1451)))) (= () (tl V1451))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1451))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (if (value shen.*installing-kl*) (cons shen.sys-error (cons V1452 ())) (cons shen.f_error (cons V1452 ()))) (cons Result ())))) ())))) ())) ())) ((and (cons? V1451) (and (cons? (hd V1451)) (and (= true (hd (hd V1451))) (and (cons? (tl (hd V1451))) (and (cons? (hd (tl (hd V1451)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1451))))) (and (cons? (tl (hd (tl (hd V1451))))) (and (= () (tl (tl (hd (tl (hd V1451)))))) (= () (tl (tl (hd V1451)))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1451))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (shen.cond-form (shen.encode-choices (tl V1451) V1452)) (cons Result ())))) ())))) ())) ())) ((and (cons? V1451) (and (cons? (hd V1451)) (and (cons? (tl (hd V1451))) (and (cons? (hd (tl (hd V1451)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1451))))) (and (cons? (tl (hd (tl (hd V1451))))) (and (= () (tl (tl (hd (tl (hd V1451)))))) (= () (tl (tl (hd V1451))))))))))) (cons (cons true (cons (cons let (cons Freeze (cons (cons freeze (cons (shen.cond-form (shen.encode-choices (tl V1451) V1452)) ())) (cons (cons if (cons (hd (hd V1451)) (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1451))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (cons thaw (cons Freeze ())) (cons Result ())))) ())))) (cons (cons thaw (cons Freeze ())) ())))) ())))) ())) ())) ((and (cons? V1451) (and (cons? (hd V1451)) (and (cons? (tl (hd V1451))) (= () (tl (tl (hd V1451))))))) (cons (hd V1451) (shen.encode-choices (tl V1451) V1452))) (true (shen.f_error shen.encode-choices))))

(defun shen.case-form (V1459 V1460) (cond ((= () V1459) (cons V1460 ())) ((and (cons? V1459) (and (cons? (hd V1459)) (and (cons? (hd (hd V1459))) (and (= : (hd (hd (hd V1459)))) (and (cons? (tl (hd (hd V1459)))) (and (= shen.tests (hd (tl (hd (hd V1459))))) (and (= () (tl (tl (hd (hd V1459))))) (and (cons? (tl (hd V1459))) (and (cons? (hd (tl (hd V1459)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1459))))) (and (cons? (tl (hd (tl (hd V1459))))) (and (= () (tl (tl (hd (tl (hd V1459)))))) (= () (tl (tl (hd V1459)))))))))))))))) (cons (cons true (tl (hd V1459))) (shen.case-form (tl V1459) V1460))) ((and (cons? V1459) (and (cons? (hd V1459)) (and (cons? (hd (hd V1459))) (and (= : (hd (hd (hd V1459)))) (and (cons? (tl (hd (hd V1459)))) (and (= shen.tests (hd (tl (hd (hd V1459))))) (and (= () (tl (tl (hd (hd V1459))))) (and (cons? (tl (hd V1459))) (= () (tl (tl (hd V1459)))))))))))) (cons (cons true (tl (hd V1459))) ())) ((and (cons? V1459) (and (cons? (hd V1459)) (and (cons? (hd (hd V1459))) (and (= : (hd (hd (hd V1459)))) (and (cons? (tl (hd (hd V1459)))) (and (= shen.tests (hd (tl (hd (hd V1459))))) (and (cons? (tl (hd V1459))) (= () (tl (tl (hd V1459))))))))))) (cons (cons (shen.embed-and (tl (tl (hd (hd V1459))))) (tl (hd V1459))) (shen.case-form (tl V1459) V1460))) (true (shen.f_error shen.case-form))))

(defun shen.embed-and (V1462) (cond ((and (cons? V1462) (= () (tl V1462))) (hd V1462)) ((cons? V1462) (cons and (cons (hd V1462) (cons (shen.embed-and (tl V1462)) ())))) (true (shen.f_error shen.embed-and))))

(defun shen.err-condition (V1464) (cons true (cons (cons shen.f_error (cons V1464 ())) ())))

(defun shen.sys-error (V1466) (simple-error (cn "system function " (shen.app V1466 ": unexpected argument
" shen.a))))



