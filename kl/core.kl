"Copyright (c) 2010-2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"

(defun shen.shen->kl (V1261 V1262) (compile (lambda X (shen.<define> X)) (cons V1261 V1262) (lambda X (shen.shen-syntax-error V1261 X))))

(defun shen.shen-syntax-error (V1269 V1270) (cond ((cons? V1270) (simple-error (cn "syntax error in " (shen.app V1269 (cn " here:

 " (shen.app (shen.next-50 50 (hd V1270)) "
" shen.a)) shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V1269 "
" shen.a))))))

(defun shen.<define> (V1272) (let YaccParse (let Parse_shen.<name> (shen.<name> V1272) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<signature> (shen.<signature> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<name> (shen.<name> V1272) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) YaccParse)))

(defun shen.<name> (V1274) (if (cons? (hd V1274)) (let Parse_X (shen.hdhd V1274) (shen.pair (hd (shen.pair (shen.tlhd V1274) (shen.hdtl V1274))) (if (and (symbol? Parse_X) (not (shen.sysfunc? Parse_X))) Parse_X (simple-error (shen.app Parse_X " is not a legitimate function name.
" shen.a))))) (fail)))

(defun shen.sysfunc? (V1276) (element? V1276 (get (intern "shen") shen.external-symbols (value *property-vector*))))

(defun shen.<signature> (V1280) (if (and (cons? (hd V1280)) (= { (shen.hdhd V1280))) (let NewStream1277 (shen.pair (shen.tlhd V1280) (shen.hdtl V1280)) (let Parse_shen.<signature-help> (shen.<signature-help> NewStream1277) (if (not (= (fail) Parse_shen.<signature-help>)) (if (and (cons? (hd Parse_shen.<signature-help>)) (= } (shen.hdhd Parse_shen.<signature-help>))) (let NewStream1278 (shen.pair (shen.tlhd Parse_shen.<signature-help>) (shen.hdtl Parse_shen.<signature-help>)) (shen.pair (hd NewStream1278) (shen.demodulate (shen.curry-type (shen.hdtl Parse_shen.<signature-help>))))) (fail)) (fail)))) (fail)))

(defun shen.curry-type (V1282) (shen.active-cons (shen.curry-type-h V1282)))

(defun shen.active-cons (V1284) (cond ((and (cons? V1284) (and (cons? (tl V1284)) (and (cons? (tl (tl V1284))) (and (= () (tl (tl (tl V1284)))) (= (hd (tl V1284)) bar!))))) (cons (shen.active-cons (hd V1284)) (shen.active-cons (hd (tl (tl V1284)))))) ((cons? V1284) (cons (shen.active-cons (hd V1284)) (shen.active-cons (tl V1284)))) (true V1284)))

(defun shen.curry-type-h (V1286) (cond ((and (cons? V1286) (and (cons? (tl V1286)) (and (= --> (hd (tl V1286))) (and (cons? (tl (tl V1286))) (and (cons? (tl (tl (tl V1286)))) (= --> (hd (tl (tl (tl V1286)))))))))) (shen.curry-type-h (cons (hd V1286) (cons --> (cons (tl (tl V1286)) ()))))) ((and (cons? V1286) (and (cons? (tl V1286)) (and (= * (hd (tl V1286))) (and (cons? (tl (tl V1286))) (and (cons? (tl (tl (tl V1286)))) (= * (hd (tl (tl (tl V1286)))))))))) (shen.curry-type-h (cons (hd V1286) (cons * (cons (tl (tl V1286)) ()))))) ((cons? V1286) (map (lambda Z (shen.curry-type-h Z)) V1286)) (true V1286)))

(defun shen.<signature-help> (V1288) (let YaccParse (if (cons? (hd V1288)) (let Parse_X (shen.hdhd V1288) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (shen.tlhd V1288) (shen.hdtl V1288))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (not (element? Parse_X (cons { (cons } ())))) (shen.pair (hd Parse_shen.<signature-help>) (cons Parse_X (shen.hdtl Parse_shen.<signature-help>))) (fail)) (fail)))) (fail)) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1288) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<rules> (V1290) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V1290) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V1290) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) ())) (fail))) YaccParse)))

(defun shen.<rule> (V1298) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1298) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (shen.hdhd Parse_shen.<patterns>))) (let NewStream1291 (shen.pair (shen.tlhd Parse_shen.<patterns>) (shen.hdtl Parse_shen.<patterns>)) (let Parse_shen.<action> (shen.<action> NewStream1291) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (shen.hdhd Parse_shen.<action>))) (let NewStream1292 (shen.pair (shen.tlhd Parse_shen.<action>) (shen.hdtl Parse_shen.<action>)) (let Parse_shen.<guard> (shen.<guard> NewStream1292) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<action>) ()))) ()))) (fail)))) (fail)) (fail)))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1298) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (shen.hdhd Parse_shen.<patterns>))) (let NewStream1293 (shen.pair (shen.tlhd Parse_shen.<patterns>) (shen.hdtl Parse_shen.<patterns>)) (let Parse_shen.<action> (shen.<action> NewStream1293) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<action>) ()))) (fail)))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1298) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (shen.hdhd Parse_shen.<patterns>))) (let NewStream1294 (shen.pair (shen.tlhd Parse_shen.<patterns>) (shen.hdtl Parse_shen.<patterns>)) (let Parse_shen.<action> (shen.<action> NewStream1294) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (shen.hdhd Parse_shen.<action>))) (let NewStream1295 (shen.pair (shen.tlhd Parse_shen.<action>) (shen.hdtl Parse_shen.<action>)) (let Parse_shen.<guard> (shen.<guard> NewStream1295) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) ()))) (fail)))) (fail)) (fail)))) (fail)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<patterns> (shen.<patterns> V1298) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (shen.hdhd Parse_shen.<patterns>))) (let NewStream1296 (shen.pair (shen.tlhd Parse_shen.<patterns>) (shen.hdtl Parse_shen.<patterns>)) (let Parse_shen.<action> (shen.<action> NewStream1296) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) (fail)))) (fail)) (fail))) YaccParse)) YaccParse)) YaccParse)))

(defun shen.fail_if (V1301 V1302) (if (V1301 V1302) (fail) V1302))

(defun shen.succeeds? (V1308) (cond ((= V1308 (fail)) false) (true true)))

(defun shen.<patterns> (V1310) (let YaccParse (let Parse_shen.<pattern> (shen.<pattern> V1310) (if (not (= (fail) Parse_shen.<pattern>)) (let Parse_shen.<patterns> (shen.<patterns> Parse_shen.<pattern>) (if (not (= (fail) Parse_shen.<patterns>)) (shen.pair (hd Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<pattern>) (shen.hdtl Parse_shen.<patterns>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1310) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<pattern> (V1323) (let YaccParse (if (and (cons? (hd V1323)) (cons? (shen.hdhd V1323))) (if (and (cons? (hd (shen.pair (shen.hdhd V1323) (shen.hdtl V1323)))) (= @p (shen.hdhd (shen.pair (shen.hdhd V1323) (shen.hdtl V1323))))) (let NewStream1312 (shen.pair (shen.tlhd (shen.pair (shen.hdhd V1323) (shen.hdtl V1323))) (shen.hdtl (shen.pair (shen.hdhd V1323) (shen.hdtl V1323)))) (let Parse_shen.<pattern1> (shen.<pattern1> NewStream1312) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (shen.tlhd V1323) (shen.hdtl V1323))) (cons @p (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail)))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1323)) (cons? (shen.hdhd V1323))) (if (and (cons? (hd (shen.pair (shen.hdhd V1323) (shen.hdtl V1323)))) (= cons (shen.hdhd (shen.pair (shen.hdhd V1323) (shen.hdtl V1323))))) (let NewStream1314 (shen.pair (shen.tlhd (shen.pair (shen.hdhd V1323) (shen.hdtl V1323))) (shen.hdtl (shen.pair (shen.hdhd V1323) (shen.hdtl V1323)))) (let Parse_shen.<pattern1> (shen.<pattern1> NewStream1314) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (shen.tlhd V1323) (shen.hdtl V1323))) (cons cons (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail)))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1323)) (cons? (shen.hdhd V1323))) (if (and (cons? (hd (shen.pair (shen.hdhd V1323) (shen.hdtl V1323)))) (= @v (shen.hdhd (shen.pair (shen.hdhd V1323) (shen.hdtl V1323))))) (let NewStream1316 (shen.pair (shen.tlhd (shen.pair (shen.hdhd V1323) (shen.hdtl V1323))) (shen.hdtl (shen.pair (shen.hdhd V1323) (shen.hdtl V1323)))) (let Parse_shen.<pattern1> (shen.<pattern1> NewStream1316) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (shen.tlhd V1323) (shen.hdtl V1323))) (cons @v (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail)))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1323)) (cons? (shen.hdhd V1323))) (if (and (cons? (hd (shen.pair (shen.hdhd V1323) (shen.hdtl V1323)))) (= @s (shen.hdhd (shen.pair (shen.hdhd V1323) (shen.hdtl V1323))))) (let NewStream1318 (shen.pair (shen.tlhd (shen.pair (shen.hdhd V1323) (shen.hdtl V1323))) (shen.hdtl (shen.pair (shen.hdhd V1323) (shen.hdtl V1323)))) (let Parse_shen.<pattern1> (shen.<pattern1> NewStream1318) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (shen.tlhd V1323) (shen.hdtl V1323))) (cons @s (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail)))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1323)) (cons? (shen.hdhd V1323))) (if (and (cons? (hd (shen.pair (shen.hdhd V1323) (shen.hdtl V1323)))) (= vector (shen.hdhd (shen.pair (shen.hdhd V1323) (shen.hdtl V1323))))) (let NewStream1320 (shen.pair (shen.tlhd (shen.pair (shen.hdhd V1323) (shen.hdtl V1323))) (shen.hdtl (shen.pair (shen.hdhd V1323) (shen.hdtl V1323)))) (if (and (cons? (hd NewStream1320)) (= 0 (shen.hdhd NewStream1320))) (let NewStream1321 (shen.pair (shen.tlhd NewStream1320) (shen.hdtl NewStream1320)) (shen.pair (hd (shen.pair (shen.tlhd V1323) (shen.hdtl V1323))) (cons vector (cons 0 ())))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (cons? (hd V1323)) (let Parse_X (shen.hdhd V1323) (if (cons? Parse_X) (shen.pair (hd (shen.pair (shen.tlhd V1323) (shen.hdtl V1323))) (shen.constructor-error Parse_X)) (fail))) (fail)) (if (= YaccParse (fail)) (let Parse_shen.<simple_pattern> (shen.<simple_pattern> V1323) (if (not (= (fail) Parse_shen.<simple_pattern>)) (shen.pair (hd Parse_shen.<simple_pattern>) (shen.hdtl Parse_shen.<simple_pattern>)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.constructor-error (V1325) (simple-error (shen.app V1325 " is not a legitimate constructor
" shen.a)))

(defun shen.<simple_pattern> (V1327) (let YaccParse (if (cons? (hd V1327)) (let Parse_X (shen.hdhd V1327) (if (= Parse_X _) (shen.pair (hd (shen.pair (shen.tlhd V1327) (shen.hdtl V1327))) (gensym Parse_Y)) (fail))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V1327)) (let Parse_X (shen.hdhd V1327) (if (not (element? Parse_X (cons -> (cons <- ())))) (shen.pair (hd (shen.pair (shen.tlhd V1327) (shen.hdtl V1327))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<pattern1> (V1329) (let Parse_shen.<pattern> (shen.<pattern> V1329) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<pattern2> (V1331) (let Parse_shen.<pattern> (shen.<pattern> V1331) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<action> (V1333) (if (cons? (hd V1333)) (let Parse_X (shen.hdhd V1333) (shen.pair (hd (shen.pair (shen.tlhd V1333) (shen.hdtl V1333))) Parse_X)) (fail)))

(defun shen.<guard> (V1335) (if (cons? (hd V1335)) (let Parse_X (shen.hdhd V1335) (shen.pair (hd (shen.pair (shen.tlhd V1335) (shen.hdtl V1335))) Parse_X)) (fail)))

(defun shen.compile_to_machine_code (V1338 V1339) (let Lambda+ (shen.compile_to_lambda+ V1338 V1339) (let KL (shen.compile_to_kl V1338 Lambda+) (let Record (shen.record-source V1338 KL) KL))))

(defun shen.record-source (V1344 V1345) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1344 shen.source V1345 (value *property-vector*)))))

(defun shen.compile_to_lambda+ (V1348 V1349) (let Arity (shen.aritycheck V1348 V1349) (let UpDateSymbolTable (shen.update-symbol-table V1348 Arity) (let Free (shen.for-each (lambda Rule (shen.free_variable_check V1348 Rule)) V1349) (let Variables (shen.parameters Arity) (let Strip (map (lambda X (shen.strip-protect X)) V1349) (let Abstractions (map (lambda X (shen.abstract_rule X)) Strip) (let Applications (map (lambda X (shen.application_build Variables X)) Abstractions) (cons Variables (cons Applications ()))))))))))

(defun shen.update-symbol-table (V1352 V1353) (cond ((= 0 V1353) shen.skip) (true (put V1352 shen.lambda-form (eval-kl (shen.lambda-form V1352 V1353)) (value *property-vector*)))))

(defun shen.free_variable_check (V1356 V1357) (cond ((and (cons? V1357) (and (cons? (tl V1357)) (= () (tl (tl V1357))))) (let Bound (shen.extract_vars (hd V1357)) (let Free (shen.extract_free_vars Bound (hd (tl V1357))) (shen.free_variable_warnings V1356 Free)))) (true (shen.f_error shen.free_variable_check))))

(defun shen.extract_vars (V1359) (cond ((variable? V1359) (cons V1359 ())) ((cons? V1359) (union (shen.extract_vars (hd V1359)) (shen.extract_vars (tl V1359)))) (true ())))

(defun shen.extract_free_vars (V1371 V1372) (cond ((and (cons? V1372) (and (cons? (tl V1372)) (and (= () (tl (tl V1372))) (= (hd V1372) protect)))) ()) ((and (variable? V1372) (not (element? V1372 V1371))) (cons V1372 ())) ((and (cons? V1372) (and (= lambda (hd V1372)) (and (cons? (tl V1372)) (and (cons? (tl (tl V1372))) (= () (tl (tl (tl V1372)))))))) (shen.extract_free_vars (cons (hd (tl V1372)) V1371) (hd (tl (tl V1372))))) ((and (cons? V1372) (and (= let (hd V1372)) (and (cons? (tl V1372)) (and (cons? (tl (tl V1372))) (and (cons? (tl (tl (tl V1372)))) (= () (tl (tl (tl (tl V1372)))))))))) (union (shen.extract_free_vars V1371 (hd (tl (tl V1372)))) (shen.extract_free_vars (cons (hd (tl V1372)) V1371) (hd (tl (tl (tl V1372))))))) ((cons? V1372) (union (shen.extract_free_vars V1371 (hd V1372)) (shen.extract_free_vars V1371 (tl V1372)))) (true ())))

(defun shen.free_variable_warnings (V1377 V1378) (cond ((= () V1378) _) (true (simple-error (cn "error: the following variables are free in " (shen.app V1377 (cn ": " (shen.app (shen.list_variables V1378) "" shen.a)) shen.a))))))

(defun shen.list_variables (V1380) (cond ((and (cons? V1380) (= () (tl V1380))) (cn (str (hd V1380)) ".")) ((cons? V1380) (cn (str (hd V1380)) (cn ", " (shen.list_variables (tl V1380))))) (true (shen.f_error shen.list_variables))))

(defun shen.strip-protect (V1382) (cond ((and (cons? V1382) (and (cons? (tl V1382)) (and (= () (tl (tl V1382))) (= (hd V1382) protect)))) (shen.strip-protect (hd (tl V1382)))) ((cons? V1382) (map (lambda Z (shen.strip-protect Z)) V1382)) (true V1382)))

(defun shen.linearise (V1384) (cond ((and (cons? V1384) (and (cons? (tl V1384)) (= () (tl (tl V1384))))) (shen.linearise_help (shen.flatten (hd V1384)) (hd V1384) (hd (tl V1384)))) (true (shen.f_error shen.linearise))))

(defun shen.flatten (V1386) (cond ((= () V1386) ()) ((cons? V1386) (append (shen.flatten (hd V1386)) (shen.flatten (tl V1386)))) (true (cons V1386 ()))))

(defun shen.linearise_help (V1390 V1391 V1392) (cond ((= () V1390) (cons V1391 (cons V1392 ()))) ((cons? V1390) (if (and (variable? (hd V1390)) (element? (hd V1390) (tl V1390))) (let Var (gensym (hd V1390)) (let NewAction (cons where (cons (cons = (cons (hd V1390) (cons Var ()))) (cons V1392 ()))) (let NewPatts (shen.linearise_X (hd V1390) Var V1391) (shen.linearise_help (tl V1390) NewPatts NewAction)))) (shen.linearise_help (tl V1390) V1391 V1392))) (true (shen.f_error shen.linearise_help))))

(defun shen.linearise_X (V1405 V1406 V1407) (cond ((= V1407 V1405) V1406) ((cons? V1407) (let L (shen.linearise_X V1405 V1406 (hd V1407)) (if (= L (hd V1407)) (cons (hd V1407) (shen.linearise_X V1405 V1406 (tl V1407))) (cons L (tl V1407))))) (true V1407)))

(defun shen.aritycheck (V1410 V1411) (cond ((and (cons? V1411) (and (cons? (hd V1411)) (and (cons? (tl (hd V1411))) (and (= () (tl (tl (hd V1411)))) (= () (tl V1411)))))) (do (shen.aritycheck-action (hd (tl (hd V1411)))) (shen.aritycheck-name V1410 (arity V1410) (length (hd (hd V1411)))))) ((and (cons? V1411) (and (cons? (hd V1411)) (and (cons? (tl (hd V1411))) (and (= () (tl (tl (hd V1411)))) (and (cons? (tl V1411)) (and (cons? (hd (tl V1411))) (and (cons? (tl (hd (tl V1411)))) (= () (tl (tl (hd (tl V1411)))))))))))) (if (= (length (hd (hd V1411))) (length (hd (hd (tl V1411))))) (do (shen.aritycheck-action (hd (tl (hd V1411)))) (shen.aritycheck V1410 (tl V1411))) (simple-error (cn "arity error in " (shen.app V1410 "
" shen.a))))) (true (shen.f_error shen.aritycheck))))

(defun shen.aritycheck-name (V1424 V1425 V1426) (cond ((= -1 V1425) V1426) ((= V1426 V1425) V1426) (true (do (shen.prhush (cn "
warning: changing the arity of " (shen.app V1424 " can cause errors.
" shen.a)) (stoutput)) V1426))))

(defun shen.aritycheck-action (V1432) (cond ((cons? V1432) (do (shen.aah (hd V1432) (tl V1432)) (shen.for-each (lambda Y (shen.aritycheck-action Y)) V1432))) (true shen.skip)))

(defun shen.aah (V1435 V1436) (let Arity (arity V1435) (let Len (length V1436) (if (and (> Arity -1) (> Len Arity)) (shen.prhush (cn "warning: " (shen.app V1435 (cn " might not like " (shen.app Len (cn " argument" (shen.app (if (> Len 1) "s" "") ".
" shen.a)) shen.a)) shen.a)) (stoutput)) shen.skip))))

(defun shen.abstract_rule (V1438) (cond ((and (cons? V1438) (and (cons? (tl V1438)) (= () (tl (tl V1438))))) (shen.abstraction_build (hd V1438) (hd (tl V1438)))) (true (shen.f_error shen.abstract_rule))))

(defun shen.abstraction_build (V1441 V1442) (cond ((= () V1441) V1442) ((cons? V1441) (cons /. (cons (hd V1441) (cons (shen.abstraction_build (tl V1441) V1442) ())))) (true (shen.f_error shen.abstraction_build))))

(defun shen.parameters (V1444) (cond ((= 0 V1444) ()) (true (cons (gensym V) (shen.parameters (- V1444 1))))))

(defun shen.application_build (V1447 V1448) (cond ((= () V1447) V1448) ((cons? V1447) (shen.application_build (tl V1447) (cons V1448 (cons (hd V1447) ())))) (true (shen.f_error shen.application_build))))

(defun shen.compile_to_kl (V1451 V1452) (cond ((and (cons? V1452) (and (cons? (tl V1452)) (= () (tl (tl V1452))))) (let Arity (shen.store-arity V1451 (length (hd V1452))) (let Reduce (map (lambda X (shen.reduce X)) (hd (tl V1452))) (let CondExpression (shen.cond-expression V1451 (hd V1452) Reduce) (let TypeTable (if (value shen.*optimise*) (shen.typextable (shen.get-type V1451) (hd V1452)) shen.skip) (let TypedCondExpression (if (value shen.*optimise*) (shen.assign-types (hd V1452) TypeTable CondExpression) CondExpression) (cons defun (cons V1451 (cons (hd V1452) (cons TypedCondExpression ())))))))))) (true (shen.f_error shen.compile_to_kl))))

(defun shen.get-type (V1458) (cond ((cons? V1458) shen.skip) (true (let FType (assoc V1458 (value shen.*signedfuncs*)) (if (empty? FType) shen.skip (tl FType))))))

(defun shen.typextable (V1469 V1470) (cond ((and (cons? V1469) (and (cons? (tl V1469)) (and (= --> (hd (tl V1469))) (and (cons? (tl (tl V1469))) (and (= () (tl (tl (tl V1469)))) (cons? V1470)))))) (if (variable? (hd V1469)) (shen.typextable (hd (tl (tl V1469))) (tl V1470)) (cons (cons (hd V1470) (hd V1469)) (shen.typextable (hd (tl (tl V1469))) (tl V1470))))) (true ())))

(defun shen.assign-types (V1474 V1475 V1476) (cond ((and (cons? V1476) (and (= let (hd V1476)) (and (cons? (tl V1476)) (and (cons? (tl (tl V1476))) (and (cons? (tl (tl (tl V1476)))) (= () (tl (tl (tl (tl V1476)))))))))) (cons let (cons (hd (tl V1476)) (cons (shen.assign-types V1474 V1475 (hd (tl (tl V1476)))) (cons (shen.assign-types (cons (hd (tl V1476)) V1474) V1475 (hd (tl (tl (tl V1476))))) ()))))) ((and (cons? V1476) (and (= lambda (hd V1476)) (and (cons? (tl V1476)) (and (cons? (tl (tl V1476))) (= () (tl (tl (tl V1476)))))))) (cons lambda (cons (hd (tl V1476)) (cons (shen.assign-types (cons (hd (tl V1476)) V1474) V1475 (hd (tl (tl V1476)))) ())))) ((and (cons? V1476) (= cond (hd V1476))) (cons cond (map (lambda Y (cons (shen.assign-types V1474 V1475 (hd Y)) (cons (shen.assign-types V1474 V1475 (hd (tl Y))) ()))) (tl V1476)))) ((cons? V1476) (let NewTable (shen.typextable (shen.get-type (hd V1476)) (tl V1476)) (cons (hd V1476) (map (lambda Y (shen.assign-types V1474 (append V1475 NewTable) Y)) (tl V1476))))) (true (let AtomType (assoc V1476 V1475) (if (cons? AtomType) (cons type (cons V1476 (cons (tl AtomType) ()))) (if (element? V1476 V1474) V1476 (shen.atom-type V1476)))))))

(defun shen.atom-type (V1478) (if (string? V1478) (cons type (cons V1478 (cons string ()))) (if (number? V1478) (cons type (cons V1478 (cons number ()))) (if (boolean? V1478) (cons type (cons V1478 (cons boolean ()))) (if (symbol? V1478) (cons type (cons V1478 (cons symbol ()))) V1478)))))

(defun shen.store-arity (V1483 V1484) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1483 arity V1484 (value *property-vector*)))))

(defun shen.reduce (V1486) (do (set shen.*teststack* ()) (let Result (shen.reduce_help V1486) (cons (cons : (cons shen.tests (reverse (value shen.*teststack*)))) (cons Result ())))))

(defun shen.reduce_help (V1488) (cond ((and (cons? V1488) (and (cons? (hd V1488)) (and (= /. (hd (hd V1488))) (and (cons? (tl (hd V1488))) (and (cons? (hd (tl (hd V1488)))) (and (= cons (hd (hd (tl (hd V1488))))) (and (cons? (tl (hd (tl (hd V1488))))) (and (cons? (tl (tl (hd (tl (hd V1488)))))) (and (= () (tl (tl (tl (hd (tl (hd V1488))))))) (and (cons? (tl (tl (hd V1488)))) (and (= () (tl (tl (tl (hd V1488))))) (and (cons? (tl V1488)) (= () (tl (tl V1488))))))))))))))) (do (shen.add_test (cons cons? (tl V1488))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1488))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1488)))))) (cons (shen.ebr (hd (tl V1488)) (hd (tl (hd V1488))) (hd (tl (tl (hd V1488))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hd (tl V1488)) ())) (cons (cons tl (tl V1488)) ())) (shen.reduce_help Application))))) ((and (cons? V1488) (and (cons? (hd V1488)) (and (= /. (hd (hd V1488))) (and (cons? (tl (hd V1488))) (and (cons? (hd (tl (hd V1488)))) (and (= @p (hd (hd (tl (hd V1488))))) (and (cons? (tl (hd (tl (hd V1488))))) (and (cons? (tl (tl (hd (tl (hd V1488)))))) (and (= () (tl (tl (tl (hd (tl (hd V1488))))))) (and (cons? (tl (tl (hd V1488)))) (and (= () (tl (tl (tl (hd V1488))))) (and (cons? (tl V1488)) (= () (tl (tl V1488))))))))))))))) (do (shen.add_test (cons tuple? (tl V1488))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1488))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1488)))))) (cons (shen.ebr (hd (tl V1488)) (hd (tl (hd V1488))) (hd (tl (tl (hd V1488))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons fst (tl V1488)) ())) (cons (cons snd (tl V1488)) ())) (shen.reduce_help Application))))) ((and (cons? V1488) (and (cons? (hd V1488)) (and (= /. (hd (hd V1488))) (and (cons? (tl (hd V1488))) (and (cons? (hd (tl (hd V1488)))) (and (= @v (hd (hd (tl (hd V1488))))) (and (cons? (tl (hd (tl (hd V1488))))) (and (cons? (tl (tl (hd (tl (hd V1488)))))) (and (= () (tl (tl (tl (hd (tl (hd V1488))))))) (and (cons? (tl (tl (hd V1488)))) (and (= () (tl (tl (tl (hd V1488))))) (and (cons? (tl V1488)) (= () (tl (tl V1488))))))))))))))) (do (shen.add_test (cons shen.+vector? (tl V1488))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1488))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1488)))))) (cons (shen.ebr (hd (tl V1488)) (hd (tl (hd V1488))) (hd (tl (tl (hd V1488))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hdv (tl V1488)) ())) (cons (cons tlv (tl V1488)) ())) (shen.reduce_help Application))))) ((and (cons? V1488) (and (cons? (hd V1488)) (and (= /. (hd (hd V1488))) (and (cons? (tl (hd V1488))) (and (cons? (hd (tl (hd V1488)))) (and (= @s (hd (hd (tl (hd V1488))))) (and (cons? (tl (hd (tl (hd V1488))))) (and (cons? (tl (tl (hd (tl (hd V1488)))))) (and (= () (tl (tl (tl (hd (tl (hd V1488))))))) (and (cons? (tl (tl (hd V1488)))) (and (= () (tl (tl (tl (hd V1488))))) (and (cons? (tl V1488)) (= () (tl (tl V1488))))))))))))))) (do (shen.add_test (cons shen.+string? (tl V1488))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1488))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1488)))))) (cons (shen.ebr (hd (tl V1488)) (hd (tl (hd V1488))) (hd (tl (tl (hd V1488))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons pos (cons (hd (tl V1488)) (cons 0 ()))) ())) (cons (cons tlstr (tl V1488)) ())) (shen.reduce_help Application))))) ((and (cons? V1488) (and (cons? (hd V1488)) (and (= /. (hd (hd V1488))) (and (cons? (tl (hd V1488))) (and (cons? (tl (tl (hd V1488)))) (and (= () (tl (tl (tl (hd V1488))))) (and (cons? (tl V1488)) (and (= () (tl (tl V1488))) (not (variable? (hd (tl (hd V1488))))))))))))) (do (shen.add_test (cons = (cons (hd (tl (hd V1488))) (tl V1488)))) (shen.reduce_help (hd (tl (tl (hd V1488))))))) ((and (cons? V1488) (and (cons? (hd V1488)) (and (= /. (hd (hd V1488))) (and (cons? (tl (hd V1488))) (and (cons? (tl (tl (hd V1488)))) (and (= () (tl (tl (tl (hd V1488))))) (and (cons? (tl V1488)) (= () (tl (tl V1488)))))))))) (shen.reduce_help (shen.ebr (hd (tl V1488)) (hd (tl (hd V1488))) (hd (tl (tl (hd V1488))))))) ((and (cons? V1488) (and (= where (hd V1488)) (and (cons? (tl V1488)) (and (cons? (tl (tl V1488))) (= () (tl (tl (tl V1488)))))))) (do (shen.add_test (hd (tl V1488))) (shen.reduce_help (hd (tl (tl V1488)))))) ((and (cons? V1488) (and (cons? (tl V1488)) (= () (tl (tl V1488))))) (let Z (shen.reduce_help (hd V1488)) (if (= (hd V1488) Z) V1488 (shen.reduce_help (cons Z (tl V1488)))))) (true V1488)))

(defun shen.+string? (V1490) (cond ((= "" V1490) false) (true (string? V1490))))

(defun shen.+vector? (V1492) (and (absvector? V1492) (> (<-address V1492 0) 0)))

(defun shen.ebr (V1505 V1506 V1507) (cond ((= V1507 V1506) V1505) ((and (cons? V1507) (and (= lambda (hd V1507)) (and (cons? (tl V1507)) (and (cons? (tl (tl V1507))) (and (= () (tl (tl (tl V1507)))) (shen.clash? (hd (tl V1507)) V1506)))))) V1507) ((and (cons? V1507) (and (= let (hd V1507)) (and (cons? (tl V1507)) (and (cons? (tl (tl V1507))) (and (cons? (tl (tl (tl V1507)))) (and (= () (tl (tl (tl (tl V1507))))) (shen.clash? (hd (tl V1507)) V1506))))))) (cons let (cons (hd (tl V1507)) (cons (shen.ebr V1505 V1506 (hd (tl (tl V1507)))) (tl (tl (tl V1507))))))) ((cons? V1507) (cons (shen.ebr V1505 V1506 (hd V1507)) (shen.ebr V1505 V1506 (tl V1507)))) (true V1507)))

(defun shen.clash? (V1519 V1520) (cond ((= V1520 V1519) true) ((cons? V1520) (or (shen.clash? V1519 (hd V1520)) (shen.clash? V1519 (tl V1520)))) (true false)))

(defun shen.add_test (V1522) (set shen.*teststack* (cons V1522 (value shen.*teststack*))))

(defun shen.cond-expression (V1526 V1527 V1528) (let Err (shen.err-condition V1526) (let Cases (shen.case-form V1528 Err) (let EncodeChoices (shen.encode-choices Cases V1526) (shen.cond-form EncodeChoices)))))

(defun shen.cond-form (V1532) (cond ((and (cons? V1532) (and (cons? (hd V1532)) (and (= true (hd (hd V1532))) (and (cons? (tl (hd V1532))) (= () (tl (tl (hd V1532)))))))) (hd (tl (hd V1532)))) (true (cons cond V1532))))

(defun shen.encode-choices (V1537 V1538) (cond ((= () V1537) ()) ((and (cons? V1537) (and (cons? (hd V1537)) (and (= true (hd (hd V1537))) (and (cons? (tl (hd V1537))) (and (cons? (hd (tl (hd V1537)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1537))))) (and (cons? (tl (hd (tl (hd V1537))))) (and (= () (tl (tl (hd (tl (hd V1537)))))) (and (= () (tl (tl (hd V1537)))) (= () (tl V1537))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1537))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (if (value shen.*installing-kl*) (cons shen.sys-error (cons V1538 ())) (cons shen.f_error (cons V1538 ()))) (cons Result ())))) ())))) ())) ())) ((and (cons? V1537) (and (cons? (hd V1537)) (and (= true (hd (hd V1537))) (and (cons? (tl (hd V1537))) (and (cons? (hd (tl (hd V1537)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1537))))) (and (cons? (tl (hd (tl (hd V1537))))) (and (= () (tl (tl (hd (tl (hd V1537)))))) (= () (tl (tl (hd V1537)))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1537))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (shen.cond-form (shen.encode-choices (tl V1537) V1538)) (cons Result ())))) ())))) ())) ())) ((and (cons? V1537) (and (cons? (hd V1537)) (and (cons? (tl (hd V1537))) (and (cons? (hd (tl (hd V1537)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1537))))) (and (cons? (tl (hd (tl (hd V1537))))) (and (= () (tl (tl (hd (tl (hd V1537)))))) (= () (tl (tl (hd V1537))))))))))) (cons (cons true (cons (cons let (cons Freeze (cons (cons freeze (cons (shen.cond-form (shen.encode-choices (tl V1537) V1538)) ())) (cons (cons if (cons (hd (hd V1537)) (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1537))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (cons thaw (cons Freeze ())) (cons Result ())))) ())))) (cons (cons thaw (cons Freeze ())) ())))) ())))) ())) ())) ((and (cons? V1537) (and (cons? (hd V1537)) (and (cons? (tl (hd V1537))) (= () (tl (tl (hd V1537))))))) (cons (hd V1537) (shen.encode-choices (tl V1537) V1538))) (true (shen.f_error shen.encode-choices))))

(defun shen.case-form (V1545 V1546) (cond ((= () V1545) (cons V1546 ())) ((and (cons? V1545) (and (cons? (hd V1545)) (and (cons? (hd (hd V1545))) (and (= : (hd (hd (hd V1545)))) (and (cons? (tl (hd (hd V1545)))) (and (= shen.tests (hd (tl (hd (hd V1545))))) (and (= () (tl (tl (hd (hd V1545))))) (and (cons? (tl (hd V1545))) (and (cons? (hd (tl (hd V1545)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1545))))) (and (cons? (tl (hd (tl (hd V1545))))) (and (= () (tl (tl (hd (tl (hd V1545)))))) (= () (tl (tl (hd V1545)))))))))))))))) (cons (cons true (tl (hd V1545))) (shen.case-form (tl V1545) V1546))) ((and (cons? V1545) (and (cons? (hd V1545)) (and (cons? (hd (hd V1545))) (and (= : (hd (hd (hd V1545)))) (and (cons? (tl (hd (hd V1545)))) (and (= shen.tests (hd (tl (hd (hd V1545))))) (and (= () (tl (tl (hd (hd V1545))))) (and (cons? (tl (hd V1545))) (= () (tl (tl (hd V1545)))))))))))) (cons (cons true (tl (hd V1545))) ())) ((and (cons? V1545) (and (cons? (hd V1545)) (and (cons? (hd (hd V1545))) (and (= : (hd (hd (hd V1545)))) (and (cons? (tl (hd (hd V1545)))) (and (= shen.tests (hd (tl (hd (hd V1545))))) (and (cons? (tl (hd V1545))) (= () (tl (tl (hd V1545))))))))))) (cons (cons (shen.embed-and (tl (tl (hd (hd V1545))))) (tl (hd V1545))) (shen.case-form (tl V1545) V1546))) (true (shen.f_error shen.case-form))))

(defun shen.embed-and (V1548) (cond ((and (cons? V1548) (= () (tl V1548))) (hd V1548)) ((cons? V1548) (cons and (cons (hd V1548) (cons (shen.embed-and (tl V1548)) ())))) (true (shen.f_error shen.embed-and))))

(defun shen.err-condition (V1550) (cons true (cons (cons shen.f_error (cons V1550 ())) ())))

(defun shen.sys-error (V1552) (simple-error (cn "system function " (shen.app V1552 ": unexpected argument
" shen.a))))



