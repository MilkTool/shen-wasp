"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun pr (V3991 V3992) (trap-error (shen.prh V3991 V3992 0) (lambda E V3991)))

(defun shen.prh (V3996 V3997 V3998) (shen.prh V3996 V3997 (shen.write-char-and-inc V3996 V3997 V3998)))

(defun shen.write-char-and-inc (V4002 V4003 V4004) (do (write-byte (string->n (pos V4002 V4004)) V4003) (+ V4004 1)))

(defun print (V4006) (let String (shen.insert V4006 "~S") (let Print (shen.prhush String (stoutput)) V4006)))

(defun shen.prhush (V4009 V4010) (if (value *hush*) V4009 (pr V4009 V4010)))

(defun shen.mkstr (V4013 V4014) (cond ((string? V4013) (shen.mkstr-l (shen.proc-nl V4013) V4014)) (true (shen.mkstr-r (cons shen.proc-nl (cons V4013 ())) V4014))))

(defun shen.mkstr-l (V4017 V4018) (cond ((= () V4018) V4017) ((cons? V4018) (shen.mkstr-l (shen.insert-l (hd V4018) V4017) (tl V4018))) (true (shen.f_error shen.mkstr-l))))

(defun shen.insert-l (V4023 V4024) (cond ((= "" V4024) "") ((and (shen.+string? V4024) (and (= "~" (pos V4024 0)) (and (shen.+string? (tlstr V4024)) (= "A" (pos (tlstr V4024) 0))))) (cons shen.app (cons V4023 (cons (tlstr (tlstr V4024)) (cons shen.a ()))))) ((and (shen.+string? V4024) (and (= "~" (pos V4024 0)) (and (shen.+string? (tlstr V4024)) (= "R" (pos (tlstr V4024) 0))))) (cons shen.app (cons V4023 (cons (tlstr (tlstr V4024)) (cons shen.r ()))))) ((and (shen.+string? V4024) (and (= "~" (pos V4024 0)) (and (shen.+string? (tlstr V4024)) (= "S" (pos (tlstr V4024) 0))))) (cons shen.app (cons V4023 (cons (tlstr (tlstr V4024)) (cons shen.s ()))))) ((shen.+string? V4024) (shen.factor-cn (cons cn (cons (pos V4024 0) (cons (shen.insert-l V4023 (tlstr V4024)) ()))))) ((and (cons? V4024) (and (= cn (hd V4024)) (and (cons? (tl V4024)) (and (cons? (tl (tl V4024))) (= () (tl (tl (tl V4024)))))))) (cons cn (cons (hd (tl V4024)) (cons (shen.insert-l V4023 (hd (tl (tl V4024)))) ())))) ((and (cons? V4024) (and (= shen.app (hd V4024)) (and (cons? (tl V4024)) (and (cons? (tl (tl V4024))) (and (cons? (tl (tl (tl V4024)))) (= () (tl (tl (tl (tl V4024)))))))))) (cons shen.app (cons (hd (tl V4024)) (cons (shen.insert-l V4023 (hd (tl (tl V4024)))) (tl (tl (tl V4024))))))) (true (shen.f_error shen.insert-l))))

(defun shen.factor-cn (V4026) (cond ((and (cons? V4026) (and (= cn (hd V4026)) (and (cons? (tl V4026)) (and (cons? (tl (tl V4026))) (and (cons? (hd (tl (tl V4026)))) (and (= cn (hd (hd (tl (tl V4026))))) (and (cons? (tl (hd (tl (tl V4026))))) (and (cons? (tl (tl (hd (tl (tl V4026)))))) (and (= () (tl (tl (tl (hd (tl (tl V4026))))))) (and (= () (tl (tl (tl V4026)))) (and (string? (hd (tl V4026))) (string? (hd (tl (hd (tl (tl V4026))))))))))))))))) (cons cn (cons (cn (hd (tl V4026)) (hd (tl (hd (tl (tl V4026)))))) (tl (tl (hd (tl (tl V4026)))))))) (true V4026)))

(defun shen.proc-nl (V4028) (cond ((= "" V4028) "") ((and (shen.+string? V4028) (and (= "~" (pos V4028 0)) (and (shen.+string? (tlstr V4028)) (= "%" (pos (tlstr V4028) 0))))) (cn (n->string 10) (shen.proc-nl (tlstr (tlstr V4028))))) ((shen.+string? V4028) (cn (pos V4028 0) (shen.proc-nl (tlstr V4028)))) (true (shen.f_error shen.proc-nl))))

(defun shen.mkstr-r (V4031 V4032) (cond ((= () V4032) V4031) ((cons? V4032) (shen.mkstr-r (cons shen.insert (cons (hd V4032) (cons V4031 ()))) (tl V4032))) (true (shen.f_error shen.mkstr-r))))

(defun shen.insert (V4035 V4036) (shen.insert-h V4035 V4036 ""))

(defun shen.insert-h (V4042 V4043 V4044) (cond ((= "" V4043) V4044) ((and (shen.+string? V4043) (and (= "~" (pos V4043 0)) (and (shen.+string? (tlstr V4043)) (= "A" (pos (tlstr V4043) 0))))) (cn V4044 (shen.app V4042 (tlstr (tlstr V4043)) shen.a))) ((and (shen.+string? V4043) (and (= "~" (pos V4043 0)) (and (shen.+string? (tlstr V4043)) (= "R" (pos (tlstr V4043) 0))))) (cn V4044 (shen.app V4042 (tlstr (tlstr V4043)) shen.r))) ((and (shen.+string? V4043) (and (= "~" (pos V4043 0)) (and (shen.+string? (tlstr V4043)) (= "S" (pos (tlstr V4043) 0))))) (cn V4044 (shen.app V4042 (tlstr (tlstr V4043)) shen.s))) ((shen.+string? V4043) (shen.insert-h V4042 (tlstr V4043) (cn V4044 (pos V4043 0)))) (true (shen.f_error shen.insert-h))))

(defun shen.app (V4048 V4049 V4050) (cn (shen.arg->str V4048 V4050) V4049))

(defun shen.arg->str (V4058 V4059) (cond ((= V4058 (fail)) "...") ((shen.list? V4058) (shen.list->str V4058 V4059)) ((string? V4058) (shen.str->str V4058 V4059)) ((absvector? V4058) (shen.vector->str V4058 V4059)) (true (shen.atom->str V4058))))

(defun shen.list->str (V4062 V4063) (cond ((= shen.r V4063) (@s "(" (@s (shen.iter-list V4062 shen.r (shen.maxseq)) ")"))) (true (@s "[" (@s (shen.iter-list V4062 V4063 (shen.maxseq)) "]")))))

(defun shen.maxseq () (value *maximum-print-sequence-size*))

(defun shen.iter-list (V4077 V4078 V4079) (cond ((= () V4077) "") ((= 0 V4079) "... etc") ((and (cons? V4077) (= () (tl V4077))) (shen.arg->str (hd V4077) V4078)) ((cons? V4077) (@s (shen.arg->str (hd V4077) V4078) (@s " " (shen.iter-list (tl V4077) V4078 (- V4079 1))))) (true (@s "|" (@s " " (shen.arg->str V4077 V4078))))))

(defun shen.str->str (V4086 V4087) (cond ((= shen.a V4087) V4086) (true (@s (n->string 34) (@s V4086 (n->string 34))))))

(defun shen.vector->str (V4090 V4091) (if (shen.print-vector? V4090) ((function (<-address V4090 0)) V4090) (if (vector? V4090) (@s "<" (@s (shen.iter-vector V4090 1 V4091 (shen.maxseq)) ">")) (@s "<" (@s "<" (@s (shen.iter-vector V4090 0 V4091 (shen.maxseq)) ">>"))))))

(defun shen.print-vector? (V4093) (let Zero (<-address V4093 0) (if (= Zero shen.tuple) true (if (= Zero shen.pvar) true (if (= Zero shen.dictionary) true (if (not (number? Zero)) (shen.fbound? Zero) false))))))

(defun shen.fbound? (V4095) (trap-error (do (shen.lookup-func V4095) true) (lambda E false)))

(defun shen.tuple (V4097) (cn "(@p " (shen.app (<-address V4097 1) (cn " " (shen.app (<-address V4097 2) ")" shen.s)) shen.s)))

(defun shen.dictionary (V4099) "(dict ...)")

(defun shen.iter-vector (V4110 V4111 V4112 V4113) (cond ((= 0 V4113) "... etc") (true (let Item (trap-error (<-address V4110 V4111) (lambda E shen.out-of-bounds)) (let Next (trap-error (<-address V4110 (+ V4111 1)) (lambda E shen.out-of-bounds)) (if (= Item shen.out-of-bounds) "" (if (= Next shen.out-of-bounds) (shen.arg->str Item V4112) (@s (shen.arg->str Item V4112) (@s " " (shen.iter-vector V4110 (+ V4111 1) V4112 (- V4113 1)))))))))))

(defun shen.atom->str (V4115) (trap-error (str V4115) (lambda E (shen.funexstring))))

(defun shen.funexstring () (@s "" (@s "f" (@s "u" (@s "n" (@s "e" (@s (shen.arg->str (gensym (intern "x")) shen.a) "")))))))

(defun shen.list? (V4117) (or (empty? V4117) (cons? V4117)))



