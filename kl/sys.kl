"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun thaw (V2671) (V2671))

(defun eval (V2673) (let Macroexpand (shen.walk (lambda Y (macroexpand Y)) V2673) (if (shen.packaged? Macroexpand) (map (lambda Z (shen.eval-without-macros Z)) (shen.package-contents Macroexpand)) (shen.eval-without-macros Macroexpand))))

(defun shen.eval-without-macros (V2675) (eval-kl (shen.elim-def (shen.proc-input+ V2675))))

(defun shen.proc-input+ (V2677) (cond ((and (cons? V2677) (and (= input+ (hd V2677)) (and (cons? (tl V2677)) (and (cons? (tl (tl V2677))) (= () (tl (tl (tl V2677)))))))) (cons input+ (cons (shen.rcons_form (hd (tl V2677))) (tl (tl V2677))))) ((and (cons? V2677) (and (= shen.read+ (hd V2677)) (and (cons? (tl V2677)) (and (cons? (tl (tl V2677))) (= () (tl (tl (tl V2677)))))))) (cons shen.read+ (cons (shen.rcons_form (hd (tl V2677))) (tl (tl V2677))))) ((cons? V2677) (map (lambda Z (shen.proc-input+ Z)) V2677)) (true V2677)))

(defun shen.elim-def (V2679) (cond ((and (cons? V2679) (and (= define (hd V2679)) (cons? (tl V2679)))) (shen.shen->kl (hd (tl V2679)) (tl (tl V2679)))) ((and (cons? V2679) (and (= defmacro (hd V2679)) (cons? (tl V2679)))) (let Default (cons X (cons -> (cons X ()))) (let Def (shen.elim-def (cons define (cons (hd (tl V2679)) (append (tl (tl V2679)) Default)))) (let MacroAdd (shen.add-macro (hd (tl V2679))) Def)))) ((and (cons? V2679) (and (= defcc (hd V2679)) (cons? (tl V2679)))) (shen.elim-def (shen.yacc V2679))) ((cons? V2679) (map (lambda Z (shen.elim-def Z)) V2679)) (true V2679)))

(defun shen.add-macro (V2681) (let MacroReg (value shen.*macroreg*) (let NewMacroReg (set shen.*macroreg* (adjoin V2681 (value shen.*macroreg*))) (if (= MacroReg NewMacroReg) shen.skip (set *macros* (cons (function V2681) (value *macros*)))))))

(defun shen.packaged? (V2689) (cond ((and (cons? V2689) (and (= package (hd V2689)) (and (cons? (tl V2689)) (cons? (tl (tl V2689)))))) true) (true false)))

(defun external (V2691) (trap-error (get V2691 shen.external-symbols (value *property-vector*)) (lambda E (simple-error (cn "package " (shen.app V2691 " has not been used.
" shen.a))))))

(defun internal (V2693) (trap-error (get V2693 shen.internal-symbols (value *property-vector*)) (lambda E (simple-error (cn "package " (shen.app V2693 " has not been used.
" shen.a))))))

(defun shen.package-contents (V2697) (cond ((and (cons? V2697) (and (= package (hd V2697)) (and (cons? (tl V2697)) (and (= null (hd (tl V2697))) (cons? (tl (tl V2697))))))) (tl (tl (tl V2697)))) ((and (cons? V2697) (and (= package (hd V2697)) (and (cons? (tl V2697)) (cons? (tl (tl V2697)))))) (let PackageNameDot (intern (cn (str (hd (tl V2697))) ".")) (let ExpPackageNameDot (explode PackageNameDot) (shen.packageh (hd (tl V2697)) (hd (tl (tl V2697))) (tl (tl (tl V2697))) ExpPackageNameDot)))) (true (shen.f_error shen.package-contents))))

(defun shen.walk (V2700 V2701) (cond ((cons? V2701) (V2700 (map (lambda Z (shen.walk V2700 Z)) V2701))) (true (V2700 V2701))))

(defun compile (V2705 V2706 V2707) (let O (V2705 (cons V2706 (cons () ()))) (if (or (= (fail) O) (not (empty? (hd O)))) (V2707 O) (shen.hdtl O))))

(defun fail-if (V2710 V2711) (if (V2710 V2711) (fail) V2711))

(defun @s (V2714 V2715) (cn V2714 V2715))

(defun tc? () (value shen.*tc*))

(defun ps (V2717) (trap-error (get V2717 shen.source (value *property-vector*)) (lambda E (simple-error (shen.app V2717 " not found.
" shen.a)))))

(defun stinput () (value *stinput*))

(defun vector (V2719) (let Vector (absvector (+ V2719 1)) (let ZeroStamp (address-> Vector 0 V2719) (let Standard (if (= V2719 0) ZeroStamp (shen.fillvector ZeroStamp 1 V2719 (fail))) Standard))))

(defun shen.fillvector (V2725 V2726 V2727 V2728) (cond ((= V2727 V2726) (address-> V2725 V2727 V2728)) (true (shen.fillvector (address-> V2725 V2726 V2728) (+ 1 V2726) V2727 V2728))))

(defun vector? (V2730) (and (absvector? V2730) (let X (trap-error (<-address V2730 0) (lambda E -1)) (and (number? X) (>= X 0)))))

(defun vector-> (V2734 V2735 V2736) (if (= V2735 0) (simple-error "cannot access 0th element of a vector
") (address-> V2734 V2735 V2736)))

(defun <-vector (V2739 V2740) (if (= V2740 0) (simple-error "cannot access 0th element of a vector
") (let VectorElement (<-address V2739 V2740) (if (= VectorElement (fail)) (simple-error "vector element not found
") VectorElement))))

(defun shen.posint? (V2742) (and (integer? V2742) (>= V2742 0)))

(defun limit (V2744) (<-address V2744 0))

(defun symbol? (V2746) (cond ((or (boolean? V2746) (or (number? V2746) (string? V2746))) false) (true (trap-error (let String (str V2746) (shen.analyse-symbol? String)) (lambda E false)))))

(defun shen.analyse-symbol? (V2748) (cond ((= "" V2748) false) ((shen.+string? V2748) (and (shen.alpha? (pos V2748 0)) (shen.alphanums? (tlstr V2748)))) (true (shen.f_error shen.analyse-symbol?))))

(defun shen.alpha? (V2750) (element? V2750 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" (cons "a" (cons "b" (cons "c" (cons "d" (cons "e" (cons "f" (cons "g" (cons "h" (cons "i" (cons "j" (cons "k" (cons "l" (cons "m" (cons "n" (cons "o" (cons "p" (cons "q" (cons "r" (cons "s" (cons "t" (cons "u" (cons "v" (cons "w" (cons "x" (cons "y" (cons "z" (cons "=" (cons "*" (cons "/" (cons "+" (cons "-" (cons "_" (cons "?" (cons "$" (cons "!" (cons "@" (cons "~" (cons ">" (cons "<" (cons "&" (cons "%" (cons "{" (cons "}" (cons ":" (cons ";" (cons "`" (cons "#" (cons "'" (cons "." ())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(defun shen.alphanums? (V2752) (cond ((= "" V2752) true) ((shen.+string? V2752) (and (shen.alphanum? (pos V2752 0)) (shen.alphanums? (tlstr V2752)))) (true (shen.f_error shen.alphanums?))))

(defun shen.alphanum? (V2754) (or (shen.alpha? V2754) (shen.digit? V2754)))

(defun shen.digit? (V2756) (element? V2756 (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ()))))))))))))

(defun variable? (V2758) (cond ((or (boolean? V2758) (or (number? V2758) (string? V2758))) false) (true (trap-error (let String (str V2758) (shen.analyse-variable? String)) (lambda E false)))))

(defun shen.analyse-variable? (V2760) (cond ((shen.+string? V2760) (and (shen.uppercase? (pos V2760 0)) (shen.alphanums? (tlstr V2760)))) (true (shen.f_error shen.analyse-variable?))))

(defun shen.uppercase? (V2762) (element? V2762 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" ()))))))))))))))))))))))))))))

(defun gensym (V2764) (concat V2764 (set shen.*gensym* (+ 1 (value shen.*gensym*)))))

(defun concat (V2767 V2768) (intern (cn (str V2767) (str V2768))))

(defun @p (V2771 V2772) (let Vector (absvector 3) (let Tag (address-> Vector 0 shen.tuple) (let Fst (address-> Vector 1 V2771) (let Snd (address-> Vector 2 V2772) Vector)))))

(defun fst (V2774) (<-address V2774 1))

(defun snd (V2776) (<-address V2776 2))

(defun tuple? (V2778) (and (absvector? V2778) (= shen.tuple (trap-error (<-address V2778 0) (lambda E shen.not-tuple)))))

(defun append (V2781 V2782) (cond ((= () V2781) V2782) ((cons? V2781) (cons (hd V2781) (append (tl V2781) V2782))) (true (shen.f_error append))))

(defun @v (V2785 V2786) (let Limit (limit V2786) (let NewVector (vector (+ Limit 1)) (let X+NewVector (vector-> NewVector 1 V2785) (if (= Limit 0) X+NewVector (shen.@v-help V2786 1 Limit X+NewVector))))))

(defun shen.@v-help (V2792 V2793 V2794 V2795) (cond ((= V2794 V2793) (shen.copyfromvector V2792 V2795 V2794 (+ V2794 1))) (true (shen.@v-help V2792 (+ V2793 1) V2794 (shen.copyfromvector V2792 V2795 V2793 (+ V2793 1))))))

(defun shen.copyfromvector (V2800 V2801 V2802 V2803) (trap-error (vector-> V2801 V2803 (<-vector V2800 V2802)) (lambda E V2801)))

(defun hdv (V2805) (trap-error (<-vector V2805 1) (lambda E (simple-error (cn "hdv needs a non-empty vector as an argument; not " (shen.app V2805 "
" shen.s))))))

(defun tlv (V2807) (let Limit (limit V2807) (if (= Limit 0) (simple-error "cannot take the tail of the empty vector
") (if (= Limit 1) (vector 0) (let NewVector (vector (- Limit 1)) (shen.tlv-help V2807 2 Limit (vector (- Limit 1))))))))

(defun shen.tlv-help (V2813 V2814 V2815 V2816) (cond ((= V2815 V2814) (shen.copyfromvector V2813 V2816 V2815 (- V2815 1))) (true (shen.tlv-help V2813 (+ V2814 1) V2815 (shen.copyfromvector V2813 V2816 V2814 (- V2814 1))))))

(defun assoc (V2828 V2829) (cond ((= () V2829) ()) ((and (cons? V2829) (and (cons? (hd V2829)) (= (hd (hd V2829)) V2828))) (hd V2829)) ((cons? V2829) (assoc V2828 (tl V2829))) (true (shen.f_error assoc))))

(defun shen.assoc-set (V2836 V2837 V2838) (cond ((= () V2838) (cons (cons V2836 V2837) ())) ((and (cons? V2838) (and (cons? (hd V2838)) (= (hd (hd V2838)) V2836))) (cons (cons (hd (hd V2838)) V2837) (tl V2838))) ((cons? V2838) (cons (hd V2838) (shen.assoc-set V2836 V2837 (tl V2838)))) (true (shen.f_error shen.assoc-set))))

(defun shen.assoc-rm (V2844 V2845) (cond ((= () V2845) ()) ((and (cons? V2845) (and (cons? (hd V2845)) (= (hd (hd V2845)) V2844))) (tl V2845)) ((cons? V2845) (cons (hd V2845) (shen.assoc-rm V2844 (tl V2845)))) (true (shen.f_error shen.assoc-rm))))

(defun boolean? (V2851) (cond ((= true V2851) true) ((= false V2851) true) (true false)))

(defun nl (V2853) (cond ((= 0 V2853) 0) (true (do (shen.prhush "
" (stoutput)) (nl (- V2853 1))))))

(defun difference (V2858 V2859) (cond ((= () V2858) ()) ((cons? V2858) (if (element? (hd V2858) V2859) (difference (tl V2858) V2859) (cons (hd V2858) (difference (tl V2858) V2859)))) (true (shen.f_error difference))))

(defun do (V2862 V2863) V2863)

(defun element? (V2875 V2876) (cond ((= () V2876) false) ((and (cons? V2876) (= (hd V2876) V2875)) true) ((cons? V2876) (element? V2875 (tl V2876))) (true (shen.f_error element?))))

(defun empty? (V2882) (cond ((= () V2882) true) (true false)))

(defun fix (V2885 V2886) (shen.fix-help V2885 V2886 (V2885 V2886)))

(defun shen.fix-help (V2897 V2898 V2899) (cond ((= V2899 V2898) V2899) (true (shen.fix-help V2897 V2899 (V2897 V2899)))))

(defun put (V2904 V2905 V2906 V2907) (let Curr (trap-error (shen.<-dict V2907 V2904) (lambda E ())) (let Added (shen.assoc-set V2905 V2906 Curr) (let Update (shen.dict-> V2907 V2904 Added) V2906))))

(defun unput (V2911 V2912 V2913) (let Curr (trap-error (shen.<-dict V2913 V2911) (lambda E ())) (let Removed (shen.assoc-rm V2912 Curr) (let Update (shen.dict-> V2913 V2911 Removed) V2911))))

(defun get (V2917 V2918 V2919) (let Entry (trap-error (shen.<-dict V2919 V2917) (lambda E ())) (let Result (assoc V2918 Entry) (if (empty? Result) (simple-error "value not found
") (tl Result)))))

(defun hash (V2922 V2923) (shen.mod (sum (map (lambda X (string->n X)) (explode V2922))) V2923))

(defun shen.mod (V2926 V2927) (shen.modh V2926 (shen.multiples V2926 (cons V2927 ()))))

(defun shen.multiples (V2930 V2931) (cond ((and (cons? V2931) (> (hd V2931) V2930)) (tl V2931)) ((cons? V2931) (shen.multiples V2930 (cons (* 2 (hd V2931)) V2931))) (true (shen.f_error shen.multiples))))

(defun shen.modh (V2936 V2937) (cond ((= 0 V2936) 0) ((= () V2937) V2936) ((and (cons? V2937) (> (hd V2937) V2936)) (if (empty? (tl V2937)) V2936 (shen.modh V2936 (tl V2937)))) ((cons? V2937) (shen.modh (- V2936 (hd V2937)) V2937)) (true (shen.f_error shen.modh))))

(defun sum (V2939) (cond ((= () V2939) 0) ((cons? V2939) (+ (hd V2939) (sum (tl V2939)))) (true (shen.f_error sum))))

(defun head (V2947) (cond ((cons? V2947) (hd V2947)) (true (simple-error "head expects a non-empty list"))))

(defun tail (V2955) (cond ((cons? V2955) (tl V2955)) (true (simple-error "tail expects a non-empty list"))))

(defun hdstr (V2957) (pos V2957 0))

(defun intersection (V2962 V2963) (cond ((= () V2962) ()) ((cons? V2962) (if (element? (hd V2962) V2963) (cons (hd V2962) (intersection (tl V2962) V2963)) (intersection (tl V2962) V2963))) (true (shen.f_error intersection))))

(defun reverse (V2965) (shen.reverse_help V2965 ()))

(defun shen.reverse_help (V2968 V2969) (cond ((= () V2968) V2969) ((cons? V2968) (shen.reverse_help (tl V2968) (cons (hd V2968) V2969))) (true (shen.f_error shen.reverse_help))))

(defun union (V2972 V2973) (cond ((= () V2972) V2973) ((cons? V2972) (if (element? (hd V2972) V2973) (union (tl V2972) V2973) (cons (hd V2972) (union (tl V2972) V2973)))) (true (shen.f_error union))))

(defun y-or-n? (V2975) (let Message (shen.prhush (shen.proc-nl V2975) (stoutput)) (let Y-or-N (shen.prhush " (y/n) " (stoutput)) (let Input (shen.app (read (stinput)) "" shen.s) (if (= "y" Input) true (if (= "n" Input) false (do (shen.prhush "please answer y or n
" (stoutput)) (y-or-n? V2975))))))))

(defun not (V2977) (if V2977 false true))

(defun subst (V2990 V2991 V2992) (cond ((= V2992 V2991) V2990) ((cons? V2992) (map (lambda W (subst V2990 V2991 W)) V2992)) (true V2992)))

(defun explode (V2994) (shen.explode-h (shen.app V2994 "" shen.a)))

(defun shen.explode-h (V2996) (cond ((= "" V2996) ()) ((shen.+string? V2996) (cons (pos V2996 0) (shen.explode-h (tlstr V2996)))) (true (shen.f_error shen.explode-h))))

(defun cd (V2998) (set *home-directory* (if (= V2998 "") "" (shen.app V2998 "/" shen.a))))

(defun shen.for-each (V3001 V3002) (cond ((= () V3002) true) ((cons? V3002) (let _ (V3001 (hd V3002)) (shen.for-each V3001 (tl V3002)))) (true (shen.f_error shen.for-each))))

(defun map (V3005 V3006) (shen.map-h V3005 V3006 ()))

(defun shen.map-h (V3012 V3013 V3014) (cond ((= () V3013) (reverse V3014)) ((cons? V3013) (shen.map-h V3012 (tl V3013) (cons (V3012 (hd V3013)) V3014))) (true (shen.f_error shen.map-h))))

(defun length (V3016) (shen.length-h V3016 0))

(defun shen.length-h (V3019 V3020) (cond ((= () V3019) V3020) (true (shen.length-h (tl V3019) (+ V3020 1)))))

(defun occurrences (V3032 V3033) (cond ((= V3033 V3032) 1) ((cons? V3033) (+ (occurrences V3032 (hd V3033)) (occurrences V3032 (tl V3033)))) (true 0)))

(defun nth (V3040 V3041) (cond ((and (= 1 V3040) (cons? V3041)) (hd V3041)) ((cons? V3041) (nth (- V3040 1) (tl V3041))) (true (simple-error (cn "nth applied to " (shen.app V3040 (cn ", " (shen.app V3041 "
" shen.a)) shen.a))))))

(defun integer? (V3043) (and (number? V3043) (let Abs (shen.abs V3043) (shen.integer-test? Abs (shen.magless Abs 1)))))

(defun shen.abs (V3045) (if (> V3045 0) V3045 (- 0 V3045)))

(defun shen.magless (V3048 V3049) (let Nx2 (* V3049 2) (if (> Nx2 V3048) V3049 (shen.magless V3048 Nx2))))

(defun shen.integer-test? (V3055 V3056) (cond ((= 0 V3055) true) ((> 1 V3055) false) (true (let Abs-N (- V3055 V3056) (if (> 0 Abs-N) (integer? V3055) (shen.integer-test? Abs-N V3056))))))

(defun mapcan (V3061 V3062) (cond ((= () V3062) ()) ((cons? V3062) (append (V3061 (hd V3062)) (mapcan V3061 (tl V3062)))) (true (shen.f_error mapcan))))

(defun == (V3074 V3075) (cond ((= V3075 V3074) true) (true false)))

(defun abort () (simple-error ""))

(defun bound? (V3077) (and (symbol? V3077) (let Val (trap-error (value V3077) (lambda E shen.this-symbol-is-unbound)) (if (= Val shen.this-symbol-is-unbound) false true))))

(defun shen.string->bytes (V3079) (cond ((= "" V3079) ()) (true (cons (string->n (pos V3079 0)) (shen.string->bytes (tlstr V3079))))))

(defun maxinferences (V3081) (set shen.*maxinferences* V3081))

(defun inferences () (value shen.*infs*))

(defun protect (V3083) V3083)

(defun stoutput () (value *stoutput*))

(defun sterror () (value *sterror*))

(defun string->symbol (V3085) (let Symbol (intern V3085) (if (symbol? Symbol) Symbol (simple-error (cn "cannot intern " (shen.app V3085 " to a symbol" shen.s))))))

(defun optimise (V3091) (cond ((= + V3091) (set shen.*optimise* true)) ((= - V3091) (set shen.*optimise* false)) (true (simple-error "optimise expects a + or a -.
"))))

(defun os () (value *os*))

(defun language () (value *language*))

(defun version () (value *version*))

(defun port () (value *port*))

(defun porters () (value *porters*))

(defun implementation () (value *implementation*))

(defun release () (value *release*))

(defun package? (V3093) (trap-error (do (external V3093) true) (lambda E false)))

(defun function (V3095) (shen.lookup-func V3095))

(defun shen.lookup-func (V3097) (trap-error (get V3097 shen.lambda-form (value *property-vector*)) (lambda E (simple-error (shen.app V3097 " has no lambda expansion
" shen.a)))))



