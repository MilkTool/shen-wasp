(module "compiled/prolog.kl")
"Copyright (c) 2010-2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
(begin (register-function-arity (quote shen.<defprolog>) 1) (define (kl:shen.<defprolog> V1970) (let ((Parse_shen.<predicate*> (kl:shen.<predicate*> V1970))) (if (kl:not (kl:= (kl:fail) Parse_shen.<predicate*>)) (let ((Parse_shen.<clauses*> (kl:shen.<clauses*> Parse_shen.<predicate*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<clauses*>)) (kl:shen.pair (car Parse_shen.<clauses*>) (car (kl:shen.prolog->shen (kl:map (lambda (Parse_X) (kl:shen.insert-predicate (kl:shen.hdtl Parse_shen.<predicate*>) Parse_X)) (kl:shen.hdtl Parse_shen.<clauses*>))))) (kl:fail))) (kl:fail)))) (export shen.<defprolog>) (quote shen.<defprolog>))
(begin (register-function-arity (quote shen.prolog-error) 2) (define (kl:shen.prolog-error V1979 V1980) (cond ((and (pair? V1980) (and (pair? (cdr V1980)) (null? (cdr (cdr V1980))))) (simple-error (string-append "prolog syntax error in " (kl:shen.app V1979 (string-append " here:\n\n " (kl:shen.app (kl:shen.next-50 50 (car V1980)) "\n" (quote shen.a))) (quote shen.a))))) (#t (simple-error (string-append "prolog syntax error in " (kl:shen.app V1979 "\n" (quote shen.a))))))) (export shen.prolog-error) (quote shen.prolog-error))
(begin (register-function-arity (quote shen.next-50) 2) (define (kl:shen.next-50 V1987 V1988) (cond ((null? V1988) "") ((kl:= 0 V1987) "") ((pair? V1988) (string-append (kl:shen.decons-string (car V1988)) (kl:shen.next-50 (- V1987 1) (cdr V1988)))) (#t (kl:shen.f_error (quote shen.next-50))))) (export shen.next-50) (quote shen.next-50))
(begin (register-function-arity (quote shen.decons-string) 1) (define (kl:shen.decons-string V1990) (cond ((and (pair? V1990) (and (eq? (quote cons) (car V1990)) (and (pair? (cdr V1990)) (and (pair? (cdr (cdr V1990))) (null? (cdr (cdr (cdr V1990)))))))) (kl:shen.app (kl:shen.eval-cons V1990) " " (quote shen.s))) (#t (kl:shen.app V1990 " " (quote shen.r))))) (export shen.decons-string) (quote shen.decons-string))
(begin (register-function-arity (quote shen.insert-predicate) 2) (define (kl:shen.insert-predicate V1993 V1994) (cond ((and (pair? V1994) (and (pair? (cdr V1994)) (null? (cdr (cdr V1994))))) (cons (cons V1993 (car V1994)) (cons (quote :-) (cdr V1994)))) (#t (kl:shen.f_error (quote shen.insert-predicate))))) (export shen.insert-predicate) (quote shen.insert-predicate))
(begin (register-function-arity (quote shen.<predicate*>) 1) (define (kl:shen.<predicate*> V1996) (if (pair? (car V1996)) (let ((Parse_X (kl:shen.hdhd V1996))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1996) (kl:shen.hdtl V1996))) Parse_X)) (kl:fail))) (export shen.<predicate*>) (quote shen.<predicate*>))
(begin (register-function-arity (quote shen.<clauses*>) 1) (define (kl:shen.<clauses*> V1998) (let ((YaccParse (let ((Parse_shen.<clause*> (kl:shen.<clause*> V1998))) (if (kl:not (kl:= (kl:fail) Parse_shen.<clause*>)) (let ((Parse_shen.<clauses*> (kl:shen.<clauses*> Parse_shen.<clause*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<clauses*>)) (kl:shen.pair (car Parse_shen.<clauses*>) (cons (kl:shen.hdtl Parse_shen.<clause*>) (kl:shen.hdtl Parse_shen.<clauses*>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1998))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<clauses*>) (quote shen.<clauses*>))
(begin (register-function-arity (quote shen.<clause*>) 1) (define (kl:shen.<clause*> V2001) (let ((Parse_shen.<head*> (kl:shen.<head*> V2001))) (if (kl:not (kl:= (kl:fail) Parse_shen.<head*>)) (if (and (pair? (car Parse_shen.<head*>)) (eq? (quote <--) (kl:shen.hdhd Parse_shen.<head*>))) (let ((NewStream1999 (kl:shen.pair (kl:shen.tlhd Parse_shen.<head*>) (kl:shen.hdtl Parse_shen.<head*>)))) (let ((Parse_shen.<body*> (kl:shen.<body*> NewStream1999))) (if (kl:not (kl:= (kl:fail) Parse_shen.<body*>)) (let ((Parse_shen.<end*> (kl:shen.<end*> Parse_shen.<body*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<end*>)) (kl:shen.pair (car Parse_shen.<end*>) (cons (kl:shen.hdtl Parse_shen.<head*>) (cons (kl:shen.hdtl Parse_shen.<body*>) (quote ())))) (kl:fail))) (kl:fail)))) (kl:fail)) (kl:fail)))) (export shen.<clause*>) (quote shen.<clause*>))
(begin (register-function-arity (quote shen.<head*>) 1) (define (kl:shen.<head*> V2003) (let ((YaccParse (let ((Parse_shen.<term*> (kl:shen.<term*> V2003))) (if (kl:not (kl:= (kl:fail) Parse_shen.<term*>)) (let ((Parse_shen.<head*> (kl:shen.<head*> Parse_shen.<term*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<head*>)) (kl:shen.pair (car Parse_shen.<head*>) (cons (kl:shen.hdtl Parse_shen.<term*>) (kl:shen.hdtl Parse_shen.<head*>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2003))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<head*>) (quote shen.<head*>))
(begin (register-function-arity (quote shen.<term*>) 1) (define (kl:shen.<term*> V2005) (if (pair? (car V2005)) (let ((Parse_X (kl:shen.hdhd V2005))) (if (and (kl:not (eq? (quote <--) Parse_X)) (assert-boolean (kl:shen.legitimate-term? Parse_X))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2005) (kl:shen.hdtl V2005))) (kl:shen.eval-cons Parse_X)) (kl:fail))) (kl:fail))) (export shen.<term*>) (quote shen.<term*>))
(begin (register-function-arity (quote shen.legitimate-term?) 1) (define (kl:shen.legitimate-term? V2011) (cond ((and (pair? V2011) (and (eq? (quote cons) (car V2011)) (and (pair? (cdr V2011)) (and (pair? (cdr (cdr V2011))) (null? (cdr (cdr (cdr V2011)))))))) (and (assert-boolean (kl:shen.legitimate-term? (car (cdr V2011)))) (assert-boolean (kl:shen.legitimate-term? (car (cdr (cdr V2011))))))) ((and (pair? V2011) (and (eq? (quote mode) (car V2011)) (and (pair? (cdr V2011)) (and (pair? (cdr (cdr V2011))) (and (eq? (quote +) (car (cdr (cdr V2011)))) (null? (cdr (cdr (cdr V2011))))))))) (kl:shen.legitimate-term? (car (cdr V2011)))) ((and (pair? V2011) (and (eq? (quote mode) (car V2011)) (and (pair? (cdr V2011)) (and (pair? (cdr (cdr V2011))) (and (eq? (quote -) (car (cdr (cdr V2011)))) (null? (cdr (cdr (cdr V2011))))))))) (kl:shen.legitimate-term? (car (cdr V2011)))) ((pair? V2011) #f) (#t #t))) (export shen.legitimate-term?) (quote shen.legitimate-term?))
(begin (register-function-arity (quote shen.eval-cons) 1) (define (kl:shen.eval-cons V2013) (cond ((and (pair? V2013) (and (eq? (quote cons) (car V2013)) (and (pair? (cdr V2013)) (and (pair? (cdr (cdr V2013))) (null? (cdr (cdr (cdr V2013)))))))) (cons (kl:shen.eval-cons (car (cdr V2013))) (kl:shen.eval-cons (car (cdr (cdr V2013)))))) ((and (pair? V2013) (and (eq? (quote mode) (car V2013)) (and (pair? (cdr V2013)) (and (pair? (cdr (cdr V2013))) (null? (cdr (cdr (cdr V2013)))))))) (cons (quote mode) (cons (kl:shen.eval-cons (car (cdr V2013))) (cdr (cdr V2013))))) (#t V2013))) (export shen.eval-cons) (quote shen.eval-cons))
(begin (register-function-arity (quote shen.<body*>) 1) (define (kl:shen.<body*> V2015) (let ((YaccParse (let ((Parse_shen.<literal*> (kl:shen.<literal*> V2015))) (if (kl:not (kl:= (kl:fail) Parse_shen.<literal*>)) (let ((Parse_shen.<body*> (kl:shen.<body*> Parse_shen.<literal*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<body*>)) (kl:shen.pair (car Parse_shen.<body*>) (cons (kl:shen.hdtl Parse_shen.<literal*>) (kl:shen.hdtl Parse_shen.<body*>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2015))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<body*>) (quote shen.<body*>))
(begin (register-function-arity (quote shen.<literal*>) 1) (define (kl:shen.<literal*> V2018) (let ((YaccParse (if (and (pair? (car V2018)) (eq? (quote !) (kl:shen.hdhd V2018))) (let ((NewStream2016 (kl:shen.pair (kl:shen.tlhd V2018) (kl:shen.hdtl V2018)))) (kl:shen.pair (car NewStream2016) (cons (quote cut) (cons (kl:intern "Throwcontrol") (quote ()))))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (if (pair? (car V2018)) (let ((Parse_X (kl:shen.hdhd V2018))) (if (pair? Parse_X) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2018) (kl:shen.hdtl V2018))) Parse_X) (kl:fail))) (kl:fail)) YaccParse))) (export shen.<literal*>) (quote shen.<literal*>))
(begin (register-function-arity (quote shen.<end*>) 1) (define (kl:shen.<end*> V2020) (if (pair? (car V2020)) (let ((Parse_X (kl:shen.hdhd V2020))) (if (eq? Parse_X (quote _waspvm_sc_)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2020) (kl:shen.hdtl V2020))) Parse_X) (kl:fail))) (kl:fail))) (export shen.<end*>) (quote shen.<end*>))
(begin (register-function-arity (quote cut) 3) (define (kl:cut V2024 V2025 V2026) (let ((Result (kl:thaw V2026))) (if (kl:= Result #f) V2024 Result))) (export cut) (quote cut))
(begin (register-function-arity (quote shen.insert_modes) 1) (define (kl:shen.insert_modes V2028) (cond ((and (pair? V2028) (and (eq? (quote mode) (car V2028)) (and (pair? (cdr V2028)) (and (pair? (cdr (cdr V2028))) (null? (cdr (cdr (cdr V2028)))))))) V2028) ((null? V2028) (quote ())) ((pair? V2028) (cons (cons (quote mode) (cons (car V2028) (cons (quote +) (quote ())))) (cons (quote mode) (cons (kl:shen.insert_modes (cdr V2028)) (cons (quote -) (quote ())))))) (#t V2028))) (export shen.insert_modes) (quote shen.insert_modes))
(begin (register-function-arity (quote shen.s-prolog) 1) (define (kl:shen.s-prolog V2030) (kl:map (lambda (X) (kl:eval X)) (kl:shen.prolog->shen V2030))) (export shen.s-prolog) (quote shen.s-prolog))
(begin (register-function-arity (quote shen.prolog->shen) 1) (define (kl:shen.prolog->shen V2032) (kl:map (lambda (X) (kl:shen.compile_prolog_procedure X)) (kl:shen.group_clauses (kl:map (lambda (X) (kl:shen.s-prolog_clause X)) (kl:mapcan (lambda (X) (kl:shen.head_abstraction X)) V2032))))) (export shen.prolog->shen) (quote shen.prolog->shen))
(begin (register-function-arity (quote shen.s-prolog_clause) 1) (define (kl:shen.s-prolog_clause V2034) (cond ((and (pair? V2034) (and (pair? (cdr V2034)) (and (eq? (quote :-) (car (cdr V2034))) (and (pair? (cdr (cdr V2034))) (null? (cdr (cdr (cdr V2034)))))))) (cons (car V2034) (cons (quote :-) (cons (kl:map (lambda (X) (kl:shen.s-prolog_literal X)) (car (cdr (cdr V2034)))) (quote ()))))) (#t (kl:shen.f_error (quote shen.s-prolog_clause))))) (export shen.s-prolog_clause) (quote shen.s-prolog_clause))
(begin (register-function-arity (quote shen.head_abstraction) 1) (define (kl:shen.head_abstraction V2036) (cond ((and (pair? V2036) (and (pair? (cdr V2036)) (and (eq? (quote :-) (car (cdr V2036))) (and (pair? (cdr (cdr V2036))) (and (null? (cdr (cdr (cdr V2036)))) (assert-boolean (guard (lambda (_) #f) (< (kl:shen.complexity_head (car V2036)) (kl:value (quote shen.*maxcomplexity*)))))))))) (cons V2036 (quote ()))) ((and (pair? V2036) (and (pair? (car V2036)) (and (pair? (cdr V2036)) (and (eq? (quote :-) (car (cdr V2036))) (and (pair? (cdr (cdr V2036))) (null? (cdr (cdr (cdr V2036))))))))) (let ((Terms (kl:map (lambda (Y) (kl:gensym (quote V))) (cdr (car V2036))))) (let ((XTerms (kl:shen.rcons_form (kl:shen.remove_modes (cdr (car V2036)))))) (let ((Literal (cons (quote unify) (cons (kl:shen.cons_form Terms) (cons XTerms (quote ())))))) (let ((Clause (cons (cons (car (car V2036)) Terms) (cons (quote :-) (cons (cons Literal (car (cdr (cdr V2036)))) (quote ())))))) (cons Clause (quote ()))))))) (#t (kl:shen.f_error (quote shen.head_abstraction))))) (export shen.head_abstraction) (quote shen.head_abstraction))
(begin (register-function-arity (quote shen.complexity_head) 1) (define (kl:shen.complexity_head V2042) (cond ((pair? V2042) (kl:shen.safe-product (kl:map (lambda (X) (kl:shen.complexity X)) (cdr V2042)))) (#t (kl:shen.f_error (quote shen.complexity_head))))) (export shen.complexity_head) (quote shen.complexity_head))
(begin (register-function-arity (quote shen.safe-multiply) 2) (define (kl:shen.safe-multiply V2045 V2046) (* V2045 V2046)) (export shen.safe-multiply) (quote shen.safe-multiply))
(begin (register-function-arity (quote shen.complexity) 1) (define (kl:shen.complexity V2055) (cond ((and (pair? V2055) (and (eq? (quote mode) (car V2055)) (and (pair? (cdr V2055)) (and (pair? (car (cdr V2055))) (and (eq? (quote mode) (car (car (cdr V2055)))) (and (pair? (cdr (car (cdr V2055)))) (and (pair? (cdr (cdr (car (cdr V2055))))) (and (null? (cdr (cdr (cdr (car (cdr V2055)))))) (and (pair? (cdr (cdr V2055))) (null? (cdr (cdr (cdr V2055))))))))))))) (kl:shen.complexity (car (cdr V2055)))) ((and (pair? V2055) (and (eq? (quote mode) (car V2055)) (and (pair? (cdr V2055)) (and (pair? (car (cdr V2055))) (and (pair? (cdr (cdr V2055))) (and (eq? (quote +) (car (cdr (cdr V2055)))) (null? (cdr (cdr (cdr V2055)))))))))) (kl:shen.safe-multiply 2 (kl:shen.safe-multiply (kl:shen.complexity (cons (quote mode) (cons (car (car (cdr V2055))) (cdr (cdr V2055))))) (kl:shen.complexity (cons (quote mode) (cons (cdr (car (cdr V2055))) (cdr (cdr V2055)))))))) ((and (pair? V2055) (and (eq? (quote mode) (car V2055)) (and (pair? (cdr V2055)) (and (pair? (car (cdr V2055))) (and (pair? (cdr (cdr V2055))) (and (eq? (quote -) (car (cdr (cdr V2055)))) (null? (cdr (cdr (cdr V2055)))))))))) (kl:shen.safe-multiply (kl:shen.complexity (cons (quote mode) (cons (car (car (cdr V2055))) (cdr (cdr V2055))))) (kl:shen.complexity (cons (quote mode) (cons (cdr (car (cdr V2055))) (cdr (cdr V2055))))))) ((and (pair? V2055) (and (eq? (quote mode) (car V2055)) (and (pair? (cdr V2055)) (and (pair? (cdr (cdr V2055))) (and (null? (cdr (cdr (cdr V2055)))) (kl:variable? (car (cdr V2055)))))))) 1) ((and (pair? V2055) (and (eq? (quote mode) (car V2055)) (and (pair? (cdr V2055)) (and (pair? (cdr (cdr V2055))) (and (eq? (quote +) (car (cdr (cdr V2055)))) (null? (cdr (cdr (cdr V2055))))))))) 2) ((and (pair? V2055) (and (eq? (quote mode) (car V2055)) (and (pair? (cdr V2055)) (and (pair? (cdr (cdr V2055))) (and (eq? (quote -) (car (cdr (cdr V2055)))) (null? (cdr (cdr (cdr V2055))))))))) 1) (#t (kl:shen.complexity (cons (quote mode) (cons V2055 (cons (quote +) (quote ())))))))) (export shen.complexity) (quote shen.complexity))
(begin (register-function-arity (quote shen.safe-product) 1) (define (kl:shen.safe-product V2057) (cond ((null? V2057) 1) ((pair? V2057) (kl:shen.safe-multiply (car V2057) (kl:shen.safe-product (cdr V2057)))) (#t (kl:shen.f_error (quote shen.safe-product))))) (export shen.safe-product) (quote shen.safe-product))
(begin (register-function-arity (quote shen.s-prolog_literal) 1) (define (kl:shen.s-prolog_literal V2059) (cond ((and (pair? V2059) (and (eq? (quote is) (car V2059)) (and (pair? (cdr V2059)) (and (pair? (cdr (cdr V2059))) (null? (cdr (cdr (cdr V2059)))))))) (cons (quote bind) (cons (car (cdr V2059)) (cons (kl:shen.insert-deref (car (cdr (cdr V2059))) (quote ProcessN)) (quote ()))))) ((and (pair? V2059) (and (eq? (quote when) (car V2059)) (and (pair? (cdr V2059)) (null? (cdr (cdr V2059)))))) (cons (quote fwhen) (cons (kl:shen.insert-deref (car (cdr V2059)) (quote ProcessN)) (quote ())))) ((and (pair? V2059) (and (eq? (quote bind) (car V2059)) (and (pair? (cdr V2059)) (and (pair? (cdr (cdr V2059))) (null? (cdr (cdr (cdr V2059)))))))) (cons (quote bind) (cons (car (cdr V2059)) (cons (kl:shen.insert-lazyderef (car (cdr (cdr V2059))) (quote ProcessN)) (quote ()))))) ((and (pair? V2059) (and (eq? (quote fwhen) (car V2059)) (and (pair? (cdr V2059)) (null? (cdr (cdr V2059)))))) (cons (quote fwhen) (cons (kl:shen.insert-lazyderef (car (cdr V2059)) (quote ProcessN)) (quote ())))) ((pair? V2059) V2059) (#t (kl:shen.f_error (quote shen.s-prolog_literal))))) (export shen.s-prolog_literal) (quote shen.s-prolog_literal))
(begin (register-function-arity (quote shen.insert-deref) 2) (define (kl:shen.insert-deref V2066 V2067) (cond ((kl:variable? V2066) (cons (quote shen.deref) (cons V2066 (cons V2067 (quote ()))))) ((and (pair? V2066) (and (eq? (quote lambda) (car V2066)) (and (pair? (cdr V2066)) (and (pair? (cdr (cdr V2066))) (null? (cdr (cdr (cdr V2066)))))))) (cons (quote lambda) (cons (car (cdr V2066)) (cons (kl:shen.insert-deref (car (cdr (cdr V2066))) V2067) (quote ()))))) ((and (pair? V2066) (and (eq? (quote let) (car V2066)) (and (pair? (cdr V2066)) (and (pair? (cdr (cdr V2066))) (and (pair? (cdr (cdr (cdr V2066)))) (null? (cdr (cdr (cdr (cdr V2066)))))))))) (cons (quote let) (cons (car (cdr V2066)) (cons (kl:shen.insert-deref (car (cdr (cdr V2066))) V2067) (cons (kl:shen.insert-deref (car (cdr (cdr (cdr V2066)))) V2067) (quote ())))))) ((pair? V2066) (cons (kl:shen.insert-deref (car V2066) V2067) (kl:shen.insert-deref (cdr V2066) V2067))) (#t V2066))) (export shen.insert-deref) (quote shen.insert-deref))
(begin (register-function-arity (quote shen.insert-lazyderef) 2) (define (kl:shen.insert-lazyderef V2074 V2075) (cond ((kl:variable? V2074) (cons (quote shen.lazyderef) (cons V2074 (cons V2075 (quote ()))))) ((and (pair? V2074) (and (eq? (quote lambda) (car V2074)) (and (pair? (cdr V2074)) (and (pair? (cdr (cdr V2074))) (null? (cdr (cdr (cdr V2074)))))))) (cons (quote lambda) (cons (car (cdr V2074)) (cons (kl:shen.insert-lazyderef (car (cdr (cdr V2074))) V2075) (quote ()))))) ((and (pair? V2074) (and (eq? (quote let) (car V2074)) (and (pair? (cdr V2074)) (and (pair? (cdr (cdr V2074))) (and (pair? (cdr (cdr (cdr V2074)))) (null? (cdr (cdr (cdr (cdr V2074)))))))))) (cons (quote let) (cons (car (cdr V2074)) (cons (kl:shen.insert-lazyderef (car (cdr (cdr V2074))) V2075) (cons (kl:shen.insert-lazyderef (car (cdr (cdr (cdr V2074)))) V2075) (quote ())))))) ((pair? V2074) (cons (kl:shen.insert-lazyderef (car V2074) V2075) (kl:shen.insert-lazyderef (cdr V2074) V2075))) (#t V2074))) (export shen.insert-lazyderef) (quote shen.insert-lazyderef))
(begin (register-function-arity (quote shen.group_clauses) 1) (define (kl:shen.group_clauses V2077) (cond ((null? V2077) (quote ())) ((pair? V2077) (let ((Group (kl:shen.collect (lambda (X) (kl:shen.same_predicate? (car V2077) X)) V2077))) (let ((Rest (kl:difference V2077 Group))) (cons Group (kl:shen.group_clauses Rest))))) (#t (kl:shen.f_error (quote shen.group_clauses))))) (export shen.group_clauses) (quote shen.group_clauses))
(begin (register-function-arity (quote shen.collect) 2) (define (kl:shen.collect V2082 V2083) (cond ((null? V2083) (quote ())) ((pair? V2083) (if (assert-boolean (V2082 (car V2083))) (cons (car V2083) (kl:shen.collect V2082 (cdr V2083))) (kl:shen.collect V2082 (cdr V2083)))) (#t (kl:shen.f_error (quote shen.collect))))) (export shen.collect) (quote shen.collect))
(begin (register-function-arity (quote shen.same_predicate?) 2) (define (kl:shen.same_predicate? V2102 V2103) (cond ((and (pair? V2102) (and (pair? (car V2102)) (and (pair? V2103) (pair? (car V2103))))) (kl:= (car (car V2102)) (car (car V2103)))) (#t (kl:shen.f_error (quote shen.same_predicate?))))) (export shen.same_predicate?) (quote shen.same_predicate?))
(begin (register-function-arity (quote shen.compile_prolog_procedure) 1) (define (kl:shen.compile_prolog_procedure V2105) (let ((F (kl:shen.procedure_name V2105))) (let ((Shen (kl:shen.clauses-to-shen F V2105))) Shen))) (export shen.compile_prolog_procedure) (quote shen.compile_prolog_procedure))
(begin (register-function-arity (quote shen.procedure_name) 1) (define (kl:shen.procedure_name V2119) (cond ((and (pair? V2119) (and (pair? (car V2119)) (pair? (car (car V2119))))) (car (car (car V2119)))) (#t (kl:shen.f_error (quote shen.procedure_name))))) (export shen.procedure_name) (quote shen.procedure_name))
(begin (register-function-arity (quote shen.clauses-to-shen) 2) (define (kl:shen.clauses-to-shen V2122 V2123) (let ((Linear (kl:map (lambda (X) (kl:shen.linearise-clause X)) V2123))) (let ((Arity (kl:shen.prolog-aritycheck V2122 (kl:map (lambda (X) (kl:head X)) V2123)))) (let ((Parameters (kl:shen.parameters Arity))) (let ((AUM_instructions (kl:map (lambda (X) (kl:shen.aum X Parameters)) Linear))) (let ((Code (kl:shen.catch-cut (kl:shen.nest-disjunct (kl:map (lambda (X) (kl:shen.aum_to_shen X)) AUM_instructions))))) (let ((ShenDef (cons (quote define) (cons V2122 (kl:append Parameters (kl:append (cons (quote ProcessN) (cons (quote Continuation) (quote ()))) (cons (quote ->) (cons Code (quote ()))))))))) ShenDef))))))) (export shen.clauses-to-shen) (quote shen.clauses-to-shen))
(begin (register-function-arity (quote shen.catch-cut) 1) (define (kl:shen.catch-cut V2125) (cond ((kl:not (kl:shen.occurs? (quote cut) V2125)) V2125) (#t (cons (quote let) (cons (quote Throwcontrol) (cons (cons (quote shen.catchpoint) (quote ())) (cons (cons (quote shen.cutpoint) (cons (quote Throwcontrol) (cons V2125 (quote ())))) (quote ())))))))) (export shen.catch-cut) (quote shen.catch-cut))
(begin (register-function-arity (quote shen.catchpoint) 0) (define (kl:shen.catchpoint) (kl:set (quote shen.*catch*) (+ 1 (kl:value (quote shen.*catch*))))) (export shen.catchpoint) (quote shen.catchpoint))
(begin (register-function-arity (quote shen.cutpoint) 2) (define (kl:shen.cutpoint V2133 V2134) (cond ((kl:= V2134 V2133) #f) (#t V2134))) (export shen.cutpoint) (quote shen.cutpoint))
(begin (register-function-arity (quote shen.nest-disjunct) 1) (define (kl:shen.nest-disjunct V2136) (cond ((and (pair? V2136) (null? (cdr V2136))) (car V2136)) ((pair? V2136) (kl:shen.lisp-or (car V2136) (kl:shen.nest-disjunct (cdr V2136)))) (#t (kl:shen.f_error (quote shen.nest-disjunct))))) (export shen.nest-disjunct) (quote shen.nest-disjunct))
(begin (register-function-arity (quote shen.lisp-or) 2) (define (kl:shen.lisp-or V2139 V2140) (cons (quote let) (cons (quote Case) (cons V2139 (cons (cons (quote if) (cons (cons (quote =) (cons (quote Case) (cons #f (quote ())))) (cons V2140 (cons (quote Case) (quote ()))))) (quote ())))))) (export shen.lisp-or) (quote shen.lisp-or))
(begin (register-function-arity (quote shen.prolog-aritycheck) 2) (define (kl:shen.prolog-aritycheck V2145 V2146) (cond ((and (pair? V2146) (null? (cdr V2146))) (- (kl:length (car V2146)) 1)) ((and (pair? V2146) (pair? (cdr V2146))) (if (kl:= (kl:length (car V2146)) (kl:length (car (cdr V2146)))) (kl:shen.prolog-aritycheck V2145 (cdr V2146)) (simple-error (string-append "arity error in prolog procedure " (kl:shen.app (cons V2145 (quote ())) "\n" (quote shen.a)))))) (#t (kl:shen.f_error (quote shen.prolog-aritycheck))))) (export shen.prolog-aritycheck) (quote shen.prolog-aritycheck))
(begin (register-function-arity (quote shen.linearise-clause) 1) (define (kl:shen.linearise-clause V2148) (cond ((and (pair? V2148) (and (pair? (cdr V2148)) (and (eq? (quote :-) (car (cdr V2148))) (and (pair? (cdr (cdr V2148))) (null? (cdr (cdr (cdr V2148)))))))) (let ((Linear (kl:shen.linearise (cons (car V2148) (cdr (cdr V2148)))))) (kl:shen.clause_form Linear))) (#t (kl:shen.f_error (quote shen.linearise-clause))))) (export shen.linearise-clause) (quote shen.linearise-clause))
(begin (register-function-arity (quote shen.clause_form) 1) (define (kl:shen.clause_form V2150) (cond ((and (pair? V2150) (and (pair? (cdr V2150)) (null? (cdr (cdr V2150))))) (cons (kl:shen.explicit_modes (car V2150)) (cons (quote :-) (cons (kl:shen.cf_help (car (cdr V2150))) (quote ()))))) (#t (kl:shen.f_error (quote shen.clause_form))))) (export shen.clause_form) (quote shen.clause_form))
(begin (register-function-arity (quote shen.explicit_modes) 1) (define (kl:shen.explicit_modes V2152) (cond ((pair? V2152) (cons (car V2152) (kl:map (lambda (X) (kl:shen.em_help X)) (cdr V2152)))) (#t (kl:shen.f_error (quote shen.explicit_modes))))) (export shen.explicit_modes) (quote shen.explicit_modes))
(begin (register-function-arity (quote shen.em_help) 1) (define (kl:shen.em_help V2154) (cond ((and (pair? V2154) (and (eq? (quote mode) (car V2154)) (and (pair? (cdr V2154)) (and (pair? (cdr (cdr V2154))) (null? (cdr (cdr (cdr V2154)))))))) V2154) (#t (cons (quote mode) (cons V2154 (cons (quote +) (quote ()))))))) (export shen.em_help) (quote shen.em_help))
(begin (register-function-arity (quote shen.cf_help) 1) (define (kl:shen.cf_help V2156) (cond ((and (pair? V2156) (and (eq? (quote where) (car V2156)) (and (pair? (cdr V2156)) (and (pair? (car (cdr V2156))) (and (eq? (quote =) (car (car (cdr V2156)))) (and (pair? (cdr (car (cdr V2156)))) (and (pair? (cdr (cdr (car (cdr V2156))))) (and (null? (cdr (cdr (cdr (car (cdr V2156)))))) (and (pair? (cdr (cdr V2156))) (null? (cdr (cdr (cdr V2156))))))))))))) (cons (cons (if (assert-boolean (kl:value (quote shen.*occurs*))) (quote unify!) (quote unify)) (cdr (car (cdr V2156)))) (kl:shen.cf_help (car (cdr (cdr V2156)))))) (#t V2156))) (export shen.cf_help) (quote shen.cf_help))
(begin (register-function-arity (quote occurs-check) 1) (define (kl:occurs-check V2162) (cond ((eq? (quote +) V2162) (kl:set (quote shen.*occurs*) #t)) ((eq? (quote -) V2162) (kl:set (quote shen.*occurs*) #f)) (#t (simple-error "occurs-check expects + or -\n")))) (export occurs-check) (quote occurs-check))
(begin (register-function-arity (quote shen.aum) 2) (define (kl:shen.aum V2165 V2166) (cond ((and (pair? V2165) (and (pair? (car V2165)) (and (pair? (cdr V2165)) (and (eq? (quote :-) (car (cdr V2165))) (and (pair? (cdr (cdr V2165))) (null? (cdr (cdr (cdr V2165))))))))) (let ((MuApplication (kl:shen.make_mu_application (cons (quote shen.mu) (cons (cdr (car V2165)) (cons (kl:shen.continuation_call (cdr (car V2165)) (car (cdr (cdr V2165)))) (quote ())))) V2166))) (kl:shen.mu_reduction MuApplication (quote +)))) (#t (kl:shen.f_error (quote shen.aum))))) (export shen.aum) (quote shen.aum))
(begin (register-function-arity (quote shen.continuation_call) 2) (define (kl:shen.continuation_call V2169 V2170) (let ((VTerms (cons (quote ProcessN) (kl:shen.extract_vars V2169)))) (let ((VBody (kl:shen.extract_vars V2170))) (let ((Free (kl:remove (quote Throwcontrol) (kl:difference VBody VTerms)))) (kl:shen.cc_help Free V2170))))) (export shen.continuation_call) (quote shen.continuation_call))
(begin (register-function-arity (quote remove) 2) (define (kl:remove V2173 V2174) (kl:shen.remove-h V2173 V2174 (quote ()))) (export remove) (quote remove))
(begin (register-function-arity (quote shen.remove-h) 3) (define (kl:shen.remove-h V2181 V2182 V2183) (cond ((null? V2182) (kl:reverse V2183)) ((and (pair? V2182) (kl:= (car V2182) V2181)) (kl:shen.remove-h (car V2182) (cdr V2182) V2183)) ((pair? V2182) (kl:shen.remove-h V2181 (cdr V2182) (cons (car V2182) V2183))) (#t (kl:shen.f_error (quote shen.remove-h))))) (export shen.remove-h) (quote shen.remove-h))
(begin (register-function-arity (quote shen.cc_help) 2) (define (kl:shen.cc_help V2186 V2187) (cond ((and (null? V2186) (null? V2187)) (cons (quote shen.pop) (cons (quote shen.the) (cons (quote shen.stack) (quote ()))))) ((null? V2187) (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons V2186 (cons (quote and) (cons (quote shen.then) (cons (cons (quote shen.pop) (cons (quote shen.the) (cons (quote shen.stack) (quote ())))) (quote ())))))))))) ((null? V2186) (cons (quote call) (cons (quote shen.the) (cons (quote shen.continuation) (cons V2187 (quote ())))))) (#t (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons V2186 (cons (quote and) (cons (quote shen.then) (cons (cons (quote call) (cons (quote shen.the) (cons (quote shen.continuation) (cons V2187 (quote ()))))) (quote ())))))))))))) (export shen.cc_help) (quote shen.cc_help))
(begin (register-function-arity (quote shen.make_mu_application) 2) (define (kl:shen.make_mu_application V2190 V2191) (cond ((and (pair? V2190) (and (eq? (quote shen.mu) (car V2190)) (and (pair? (cdr V2190)) (and (null? (car (cdr V2190))) (and (pair? (cdr (cdr V2190))) (and (null? (cdr (cdr (cdr V2190)))) (null? V2191))))))) (car (cdr (cdr V2190)))) ((and (pair? V2190) (and (eq? (quote shen.mu) (car V2190)) (and (pair? (cdr V2190)) (and (pair? (car (cdr V2190))) (and (pair? (cdr (cdr V2190))) (and (null? (cdr (cdr (cdr V2190)))) (pair? V2191))))))) (cons (cons (quote shen.mu) (cons (car (car (cdr V2190))) (cons (kl:shen.make_mu_application (cons (quote shen.mu) (cons (cdr (car (cdr V2190))) (cdr (cdr V2190)))) (cdr V2191)) (quote ())))) (cons (car V2191) (quote ())))) (#t (kl:shen.f_error (quote shen.make_mu_application))))) (export shen.make_mu_application) (quote shen.make_mu_application))
(begin (register-function-arity (quote shen.mu_reduction) 2) (define (kl:shen.mu_reduction V2200 V2201) (cond ((and (pair? V2200) (and (pair? (car V2200)) (and (eq? (quote shen.mu) (car (car V2200))) (and (pair? (cdr (car V2200))) (and (pair? (car (cdr (car V2200)))) (and (eq? (quote mode) (car (car (cdr (car V2200))))) (and (pair? (cdr (car (cdr (car V2200))))) (and (pair? (cdr (cdr (car (cdr (car V2200)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V2200))))))) (and (pair? (cdr (cdr (car V2200)))) (and (null? (cdr (cdr (cdr (car V2200))))) (and (pair? (cdr V2200)) (null? (cdr (cdr V2200))))))))))))))) (kl:shen.mu_reduction (cons (cons (quote shen.mu) (cons (car (cdr (car (cdr (car V2200))))) (cdr (cdr (car V2200))))) (cdr V2200)) (car (cdr (cdr (car (cdr (car V2200)))))))) ((and (pair? V2200) (and (pair? (car V2200)) (and (eq? (quote shen.mu) (car (car V2200))) (and (pair? (cdr (car V2200))) (and (pair? (cdr (cdr (car V2200)))) (and (null? (cdr (cdr (cdr (car V2200))))) (and (pair? (cdr V2200)) (and (null? (cdr (cdr V2200))) (eq? (quote _) (car (cdr (car V2200)))))))))))) (kl:shen.mu_reduction (car (cdr (cdr (car V2200)))) V2201)) ((and (pair? V2200) (and (pair? (car V2200)) (and (eq? (quote shen.mu) (car (car V2200))) (and (pair? (cdr (car V2200))) (and (pair? (cdr (cdr (car V2200)))) (and (null? (cdr (cdr (cdr (car V2200))))) (and (pair? (cdr V2200)) (and (null? (cdr (cdr V2200))) (assert-boolean (kl:shen.ephemeral_variable? (car (cdr (car V2200))) (car (cdr V2200)))))))))))) (kl:subst (car (cdr V2200)) (car (cdr (car V2200))) (kl:shen.mu_reduction (car (cdr (cdr (car V2200)))) V2201))) ((and (pair? V2200) (and (pair? (car V2200)) (and (eq? (quote shen.mu) (car (car V2200))) (and (pair? (cdr (car V2200))) (and (pair? (cdr (cdr (car V2200)))) (and (null? (cdr (cdr (cdr (car V2200))))) (and (pair? (cdr V2200)) (and (null? (cdr (cdr V2200))) (kl:variable? (car (cdr (car V2200)))))))))))) (cons (quote let) (cons (car (cdr (car V2200))) (cons (quote shen.be) (cons (car (cdr V2200)) (cons (quote in) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V2200)))) V2201) (quote ())))))))) ((and (pair? V2200) (and (pair? (car V2200)) (and (eq? (quote shen.mu) (car (car V2200))) (and (pair? (cdr (car V2200))) (and (pair? (cdr (cdr (car V2200)))) (and (null? (cdr (cdr (cdr (car V2200))))) (and (pair? (cdr V2200)) (and (null? (cdr (cdr V2200))) (and (eq? (quote -) V2201) (assert-boolean (kl:shen.prolog_constant? (car (cdr (car V2200)))))))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V2200))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote identical) (cons (quote shen.to) (cons (car (cdr (car V2200))) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V2200)))) (quote -)) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))))) ((and (pair? V2200) (and (pair? (car V2200)) (and (eq? (quote shen.mu) (car (car V2200))) (and (pair? (cdr (car V2200))) (and (pair? (cdr (cdr (car V2200)))) (and (null? (cdr (cdr (cdr (car V2200))))) (and (pair? (cdr V2200)) (and (null? (cdr (cdr V2200))) (and (eq? (quote +) V2201) (assert-boolean (kl:shen.prolog_constant? (car (cdr (car V2200)))))))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V2200))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote identical) (cons (quote shen.to) (cons (car (cdr (car V2200))) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V2200)))) (quote +)) (cons (quote shen.else) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.variable) (quote ()))))) (cons (quote shen.then) (cons (cons (quote bind) (cons Z (cons (quote shen.to) (cons (car (cdr (car V2200))) (cons (quote in) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V2200)))) (quote +)) (quote ()))))))) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))) (quote ()))))))))) ((and (pair? V2200) (and (pair? (car V2200)) (and (eq? (quote shen.mu) (car (car V2200))) (and (pair? (cdr (car V2200))) (and (pair? (car (cdr (car V2200)))) (and (pair? (cdr (cdr (car V2200)))) (and (null? (cdr (cdr (cdr (car V2200))))) (and (pair? (cdr V2200)) (and (null? (cdr (cdr V2200))) (eq? (quote -) V2201)))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V2200))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.non-empty) (cons (quote list) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (cons (cons (quote shen.mu) (cons (car (car (cdr (car V2200)))) (cons (cons (cons (quote shen.mu) (cons (cdr (car (cdr (car V2200)))) (cdr (cdr (car V2200))))) (cons (cons (quote shen.the) (cons (quote tail) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote ())))) (cons (cons (quote shen.the) (cons (quote head) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote -)) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))))) ((and (pair? V2200) (and (pair? (car V2200)) (and (eq? (quote shen.mu) (car (car V2200))) (and (pair? (cdr (car V2200))) (and (pair? (car (cdr (car V2200)))) (and (pair? (cdr (cdr (car V2200)))) (and (null? (cdr (cdr (cdr (car V2200))))) (and (pair? (cdr V2200)) (and (null? (cdr (cdr V2200))) (eq? (quote +) V2201)))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V2200))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.non-empty) (cons (quote list) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (cons (cons (quote shen.mu) (cons (car (car (cdr (car V2200)))) (cons (cons (cons (quote shen.mu) (cons (cdr (car (cdr (car V2200)))) (cdr (cdr (car V2200))))) (cons (cons (quote shen.the) (cons (quote tail) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote ())))) (cons (cons (quote shen.the) (cons (quote head) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote +)) (cons (quote shen.else) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.variable) (quote ()))))) (cons (quote shen.then) (cons (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons (kl:shen.extract_vars (car (cdr (car V2200)))) (cons (quote and) (cons (quote shen.then) (cons (cons (quote bind) (cons Z (cons (quote shen.to) (cons (kl:shen.rcons_form (kl:shen.remove_modes (car (cdr (car V2200))))) (cons (quote in) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V2200)))) (quote +)) (quote ()))))))) (quote ()))))))))) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))) (quote ()))))))))) (#t V2200))) (export shen.mu_reduction) (quote shen.mu_reduction))
(begin (register-function-arity (quote shen.rcons_form) 1) (define (kl:shen.rcons_form V2203) (cond ((pair? V2203) (cons (quote cons) (cons (kl:shen.rcons_form (car V2203)) (cons (kl:shen.rcons_form (cdr V2203)) (quote ()))))) (#t V2203))) (export shen.rcons_form) (quote shen.rcons_form))
(begin (register-function-arity (quote shen.remove_modes) 1) (define (kl:shen.remove_modes V2205) (cond ((and (pair? V2205) (and (eq? (quote mode) (car V2205)) (and (pair? (cdr V2205)) (and (pair? (cdr (cdr V2205))) (and (eq? (quote +) (car (cdr (cdr V2205)))) (null? (cdr (cdr (cdr V2205))))))))) (kl:shen.remove_modes (car (cdr V2205)))) ((and (pair? V2205) (and (eq? (quote mode) (car V2205)) (and (pair? (cdr V2205)) (and (pair? (cdr (cdr V2205))) (and (eq? (quote -) (car (cdr (cdr V2205)))) (null? (cdr (cdr (cdr V2205))))))))) (kl:shen.remove_modes (car (cdr V2205)))) ((pair? V2205) (cons (kl:shen.remove_modes (car V2205)) (kl:shen.remove_modes (cdr V2205)))) (#t V2205))) (export shen.remove_modes) (quote shen.remove_modes))
(begin (register-function-arity (quote shen.ephemeral_variable?) 2) (define (kl:shen.ephemeral_variable? V2208 V2209) (and (kl:variable? V2208) (kl:variable? V2209))) (export shen.ephemeral_variable?) (quote shen.ephemeral_variable?))
(begin (register-function-arity (quote shen.prolog_constant?) 1) (define (kl:shen.prolog_constant? V2219) (cond ((pair? V2219) #f) (#t #t))) (export shen.prolog_constant?) (quote shen.prolog_constant?))
(begin (register-function-arity (quote shen.aum_to_shen) 1) (define (kl:shen.aum_to_shen V2221) (cond ((and (pair? V2221) (and (eq? (quote let) (car V2221)) (and (pair? (cdr V2221)) (and (pair? (cdr (cdr V2221))) (and (eq? (quote shen.be) (car (cdr (cdr V2221)))) (and (pair? (cdr (cdr (cdr V2221)))) (and (pair? (cdr (cdr (cdr (cdr V2221))))) (and (eq? (quote in) (car (cdr (cdr (cdr (cdr V2221)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V2221)))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr V2221)))))))))))))))) (cons (quote let) (cons (car (cdr V2221)) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr V2221))))) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr V2221))))))) (quote ())))))) ((and (pair? V2221) (and (eq? (quote shen.the) (car V2221)) (and (pair? (cdr V2221)) (and (eq? (quote shen.result) (car (cdr V2221))) (and (pair? (cdr (cdr V2221))) (and (eq? (quote shen.of) (car (cdr (cdr V2221)))) (and (pair? (cdr (cdr (cdr V2221)))) (and (eq? (quote shen.dereferencing) (car (cdr (cdr (cdr V2221))))) (and (pair? (cdr (cdr (cdr (cdr V2221))))) (null? (cdr (cdr (cdr (cdr (cdr V2221))))))))))))))) (cons (quote shen.lazyderef) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr V2221)))))) (cons (quote ProcessN) (quote ()))))) ((and (pair? V2221) (and (eq? (quote if) (car V2221)) (and (pair? (cdr V2221)) (and (pair? (cdr (cdr V2221))) (and (eq? (quote shen.then) (car (cdr (cdr V2221)))) (and (pair? (cdr (cdr (cdr V2221)))) (and (pair? (cdr (cdr (cdr (cdr V2221))))) (and (eq? (quote shen.else) (car (cdr (cdr (cdr (cdr V2221)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V2221)))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr V2221)))))))))))))))) (cons (quote if) (cons (kl:shen.aum_to_shen (car (cdr V2221))) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr V2221))))) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr V2221))))))) (quote ())))))) ((and (pair? V2221) (and (pair? (cdr V2221)) (and (eq? (quote is) (car (cdr V2221))) (and (pair? (cdr (cdr V2221))) (and (eq? (quote shen.a) (car (cdr (cdr V2221)))) (and (pair? (cdr (cdr (cdr V2221)))) (and (eq? (quote shen.variable) (car (cdr (cdr (cdr V2221))))) (null? (cdr (cdr (cdr (cdr V2221)))))))))))) (cons (quote shen.pvar?) (cons (car V2221) (quote ())))) ((and (pair? V2221) (and (pair? (cdr V2221)) (and (eq? (quote is) (car (cdr V2221))) (and (pair? (cdr (cdr V2221))) (and (eq? (quote shen.a) (car (cdr (cdr V2221)))) (and (pair? (cdr (cdr (cdr V2221)))) (and (eq? (quote shen.non-empty) (car (cdr (cdr (cdr V2221))))) (and (pair? (cdr (cdr (cdr (cdr V2221))))) (and (eq? (quote list) (car (cdr (cdr (cdr (cdr V2221)))))) (null? (cdr (cdr (cdr (cdr (cdr V2221))))))))))))))) (cons (quote cons?) (cons (car V2221) (quote ())))) ((and (pair? V2221) (and (eq? (quote shen.rename) (car V2221)) (and (pair? (cdr V2221)) (and (eq? (quote shen.the) (car (cdr V2221))) (and (pair? (cdr (cdr V2221))) (and (eq? (quote shen.variables) (car (cdr (cdr V2221)))) (and (pair? (cdr (cdr (cdr V2221)))) (and (eq? (quote in) (car (cdr (cdr (cdr V2221))))) (and (pair? (cdr (cdr (cdr (cdr V2221))))) (and (null? (car (cdr (cdr (cdr (cdr V2221)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V2221)))))) (and (eq? (quote and) (car (cdr (cdr (cdr (cdr (cdr V2221))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr V2221))))))) (and (eq? (quote shen.then) (car (cdr (cdr (cdr (cdr (cdr (cdr V2221)))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr (cdr V2221)))))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr V2221)))))))))))))))))))))))) (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr V2221)))))))))) ((and (pair? V2221) (and (eq? (quote shen.rename) (car V2221)) (and (pair? (cdr V2221)) (and (eq? (quote shen.the) (car (cdr V2221))) (and (pair? (cdr (cdr V2221))) (and (eq? (quote shen.variables) (car (cdr (cdr V2221)))) (and (pair? (cdr (cdr (cdr V2221)))) (and (eq? (quote in) (car (cdr (cdr (cdr V2221))))) (and (pair? (cdr (cdr (cdr (cdr V2221))))) (and (pair? (car (cdr (cdr (cdr (cdr V2221)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V2221)))))) (and (eq? (quote and) (car (cdr (cdr (cdr (cdr (cdr V2221))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr V2221))))))) (and (eq? (quote shen.then) (car (cdr (cdr (cdr (cdr (cdr (cdr V2221)))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr (cdr V2221)))))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr V2221)))))))))))))))))))))))) (cons (quote let) (cons (car (car (cdr (cdr (cdr (cdr V2221)))))) (cons (cons (quote shen.newpv) (cons (quote ProcessN) (quote ()))) (cons (kl:shen.aum_to_shen (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons (cdr (car (cdr (cdr (cdr (cdr V2221)))))) (cdr (cdr (cdr (cdr (cdr V2221))))))))))) (quote ())))))) ((and (pair? V2221) (and (eq? (quote bind) (car V2221)) (and (pair? (cdr V2221)) (and (pair? (cdr (cdr V2221))) (and (eq? (quote shen.to) (car (cdr (cdr V2221)))) (and (pair? (cdr (cdr (cdr V2221)))) (and (pair? (cdr (cdr (cdr (cdr V2221))))) (and (eq? (quote in) (car (cdr (cdr (cdr (cdr V2221)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V2221)))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr V2221)))))))))))))))) (cons (quote do) (cons (cons (quote shen.bindv) (cons (car (cdr V2221)) (cons (kl:shen.chwild (car (cdr (cdr (cdr V2221))))) (cons (quote ProcessN) (quote ()))))) (cons (cons (quote let) (cons (quote Result) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr V2221))))))) (cons (cons (quote do) (cons (cons (quote shen.unbindv) (cons (car (cdr V2221)) (cons (quote ProcessN) (quote ())))) (cons (quote Result) (quote ())))) (quote ()))))) (quote ()))))) ((and (pair? V2221) (and (pair? (cdr V2221)) (and (eq? (quote is) (car (cdr V2221))) (and (pair? (cdr (cdr V2221))) (and (eq? (quote identical) (car (cdr (cdr V2221)))) (and (pair? (cdr (cdr (cdr V2221)))) (and (eq? (quote shen.to) (car (cdr (cdr (cdr V2221))))) (and (pair? (cdr (cdr (cdr (cdr V2221))))) (null? (cdr (cdr (cdr (cdr (cdr V2221)))))))))))))) (cons (quote =) (cons (car (cdr (cdr (cdr (cdr V2221))))) (cons (car V2221) (quote ()))))) ((eq? (quote shen.failed!) V2221) #f) ((and (pair? V2221) (and (eq? (quote shen.the) (car V2221)) (and (pair? (cdr V2221)) (and (eq? (quote head) (car (cdr V2221))) (and (pair? (cdr (cdr V2221))) (and (eq? (quote shen.of) (car (cdr (cdr V2221)))) (and (pair? (cdr (cdr (cdr V2221)))) (null? (cdr (cdr (cdr (cdr V2221)))))))))))) (cons (quote hd) (cdr (cdr (cdr V2221))))) ((and (pair? V2221) (and (eq? (quote shen.the) (car V2221)) (and (pair? (cdr V2221)) (and (eq? (quote tail) (car (cdr V2221))) (and (pair? (cdr (cdr V2221))) (and (eq? (quote shen.of) (car (cdr (cdr V2221)))) (and (pair? (cdr (cdr (cdr V2221)))) (null? (cdr (cdr (cdr (cdr V2221)))))))))))) (cons (quote tl) (cdr (cdr (cdr V2221))))) ((and (pair? V2221) (and (eq? (quote shen.pop) (car V2221)) (and (pair? (cdr V2221)) (and (eq? (quote shen.the) (car (cdr V2221))) (and (pair? (cdr (cdr V2221))) (and (eq? (quote shen.stack) (car (cdr (cdr V2221)))) (null? (cdr (cdr (cdr V2221)))))))))) (cons (quote do) (cons (cons (quote shen.incinfs) (quote ())) (cons (cons (quote thaw) (cons (quote Continuation) (quote ()))) (quote ()))))) ((and (pair? V2221) (and (eq? (quote call) (car V2221)) (and (pair? (cdr V2221)) (and (eq? (quote shen.the) (car (cdr V2221))) (and (pair? (cdr (cdr V2221))) (and (eq? (quote shen.continuation) (car (cdr (cdr V2221)))) (and (pair? (cdr (cdr (cdr V2221)))) (null? (cdr (cdr (cdr (cdr V2221)))))))))))) (cons (quote do) (cons (cons (quote shen.incinfs) (quote ())) (cons (kl:shen.call_the_continuation (kl:shen.chwild (car (cdr (cdr (cdr V2221))))) (quote ProcessN) (quote Continuation)) (quote ()))))) (#t V2221))) (export shen.aum_to_shen) (quote shen.aum_to_shen))
(begin (register-function-arity (quote shen.chwild) 1) (define (kl:shen.chwild V2223) (cond ((eq? V2223 (quote _)) (cons (quote shen.newpv) (cons (quote ProcessN) (quote ())))) ((pair? V2223) (kl:map (lambda (Z) (kl:shen.chwild Z)) V2223)) (#t V2223))) (export shen.chwild) (quote shen.chwild))
(begin (register-function-arity (quote shen.newpv) 1) (define (kl:shen.newpv V2225) (let ((Count+1 (+ (vector-ref (kl:value (quote shen.*varcounter*)) V2225) 1))) (let ((IncVar (let ((_tmp (kl:value (quote shen.*varcounter*)))) (vector-set! _tmp V2225 Count+1) _tmp))) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V2225))) (let ((ResizeVectorIfNeeded (if (kl:= Count+1 (kl:limit Vector)) (kl:shen.resizeprocessvector V2225 Count+1) (quote shen.skip)))) (kl:shen.mk-pvar Count+1)))))) (export shen.newpv) (quote shen.newpv))
(begin (register-function-arity (quote shen.resizeprocessvector) 2) (define (kl:shen.resizeprocessvector V2228 V2229) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V2228))) (let ((BigVector (kl:shen.resize-vector Vector (+ V2229 V2229) (quote shen.-null-)))) (let ((_tmp (kl:value (quote shen.*prologvectors*)))) (vector-set! _tmp V2228 BigVector) _tmp)))) (export shen.resizeprocessvector) (quote shen.resizeprocessvector))
(begin (register-function-arity (quote shen.resize-vector) 3) (define (kl:shen.resize-vector V2233 V2234 V2235) (let ((BigVector (let ((_tmp (make-vector (+ 1 V2234) (quote (quote shen.fail!))))) (vector-set! _tmp 0 V2234) _tmp))) (kl:shen.copy-vector V2233 BigVector (kl:limit V2233) V2234 V2235))) (export shen.resize-vector) (quote shen.resize-vector))
(begin (register-function-arity (quote shen.copy-vector) 5) (define (kl:shen.copy-vector V2241 V2242 V2243 V2244 V2245) (kl:shen.copy-vector-stage-2 (+ 1 V2243) (+ V2244 1) V2245 (kl:shen.copy-vector-stage-1 1 V2241 V2242 (+ 1 V2243)))) (export shen.copy-vector) (quote shen.copy-vector))
(begin (register-function-arity (quote shen.copy-vector-stage-1) 4) (define (kl:shen.copy-vector-stage-1 V2253 V2254 V2255 V2256) (cond ((kl:= V2256 V2253) V2255) (#t (kl:shen.copy-vector-stage-1 (+ 1 V2253) V2254 (let ((_tmp V2255)) (vector-set! _tmp V2253 (vector-ref V2254 V2253)) _tmp) V2256)))) (export shen.copy-vector-stage-1) (quote shen.copy-vector-stage-1))
(begin (register-function-arity (quote shen.copy-vector-stage-2) 4) (define (kl:shen.copy-vector-stage-2 V2264 V2265 V2266 V2267) (cond ((kl:= V2265 V2264) V2267) (#t (kl:shen.copy-vector-stage-2 (+ V2264 1) V2265 V2266 (let ((_tmp V2267)) (vector-set! _tmp V2264 V2266) _tmp))))) (export shen.copy-vector-stage-2) (quote shen.copy-vector-stage-2))
(begin (register-function-arity (quote shen.mk-pvar) 1) (define (kl:shen.mk-pvar V2269) (let ((_tmp (let ((_tmp (make-vector 2 (quote (quote shen.fail!))))) (vector-set! _tmp 0 (quote shen.pvar)) _tmp))) (vector-set! _tmp 1 V2269) _tmp)) (export shen.mk-pvar) (quote shen.mk-pvar))
(begin (register-function-arity (quote shen.pvar?) 1) (define (kl:shen.pvar? V2271) (and (vector? V2271) (eq? (guard (lambda (E) (quote shen.not-pvar)) (vector-ref V2271 0)) (quote shen.pvar)))) (export shen.pvar?) (quote shen.pvar?))
(begin (register-function-arity (quote shen.bindv) 3) (define (kl:shen.bindv V2275 V2276 V2277) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V2277))) (let ((_tmp Vector)) (vector-set! _tmp (vector-ref V2275 1) V2276) _tmp))) (export shen.bindv) (quote shen.bindv))
(begin (register-function-arity (quote shen.unbindv) 2) (define (kl:shen.unbindv V2280 V2281) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V2281))) (let ((_tmp Vector)) (vector-set! _tmp (vector-ref V2280 1) (quote shen.-null-)) _tmp))) (export shen.unbindv) (quote shen.unbindv))
(begin (register-function-arity (quote shen.incinfs) 0) (define (kl:shen.incinfs) (kl:set (quote shen.*infs*) (+ 1 (kl:value (quote shen.*infs*))))) (export shen.incinfs) (quote shen.incinfs))
(begin (register-function-arity (quote shen.call_the_continuation) 3) (define (kl:shen.call_the_continuation V2285 V2286 V2287) (cond ((and (pair? V2285) (and (pair? (car V2285)) (null? (cdr V2285)))) (cons (car (car V2285)) (kl:append (cdr (car V2285)) (cons V2286 (cons V2287 (quote ())))))) ((and (pair? V2285) (pair? (car V2285))) (let ((NewContinuation (kl:shen.newcontinuation (cdr V2285) V2286 V2287))) (cons (car (car V2285)) (kl:append (cdr (car V2285)) (cons V2286 (cons NewContinuation (quote ()))))))) (#t (kl:shen.f_error (quote shen.call_the_continuation))))) (export shen.call_the_continuation) (quote shen.call_the_continuation))
(begin (register-function-arity (quote shen.newcontinuation) 3) (define (kl:shen.newcontinuation V2291 V2292 V2293) (cond ((null? V2291) V2293) ((and (pair? V2291) (pair? (car V2291))) (cons (quote freeze) (cons (cons (car (car V2291)) (kl:append (cdr (car V2291)) (cons V2292 (cons (kl:shen.newcontinuation (cdr V2291) V2292 V2293) (quote ()))))) (quote ())))) (#t (kl:shen.f_error (quote shen.newcontinuation))))) (export shen.newcontinuation) (quote shen.newcontinuation))
(begin (register-function-arity (quote return) 3) (define (kl:return V2301 V2302 V2303) (kl:shen.deref V2301 V2302)) (export return) (quote return))
(begin (register-function-arity (quote shen.measure&return) 3) (define (kl:shen.measure&return V2311 V2312 V2313) (begin (kl:shen.prhush (kl:shen.app (kl:value (quote shen.*infs*)) " inferences\n" (quote shen.a)) (kl:stoutput)) (kl:shen.deref V2311 V2312))) (export shen.measure&return) (quote shen.measure&return))
(begin (register-function-arity (quote unify) 4) (define (kl:unify V2318 V2319 V2320 V2321) (kl:shen.lzy= (kl:shen.lazyderef V2318 V2320) (kl:shen.lazyderef V2319 V2320) V2320 V2321)) (export unify) (quote unify))
(begin (register-function-arity (quote shen.lzy=) 4) (define (kl:shen.lzy= V2343 V2344 V2345 V2346) (cond ((kl:= V2344 V2343) (kl:thaw V2346)) ((kl:shen.pvar? V2343) (kl:bind V2343 V2344 V2345 V2346)) ((kl:shen.pvar? V2344) (kl:bind V2344 V2343 V2345 V2346)) ((and (pair? V2343) (pair? V2344)) (kl:shen.lzy= (kl:shen.lazyderef (car V2343) V2345) (kl:shen.lazyderef (car V2344) V2345) V2345 (lambda () (kl:shen.lzy= (kl:shen.lazyderef (cdr V2343) V2345) (kl:shen.lazyderef (cdr V2344) V2345) V2345 V2346)))) (#t #f))) (export shen.lzy=) (quote shen.lzy=))
(begin (register-function-arity (quote shen.deref) 2) (define (kl:shen.deref V2349 V2350) (cond ((pair? V2349) (cons (kl:shen.deref (car V2349) V2350) (kl:shen.deref (cdr V2349) V2350))) (#t (if (kl:shen.pvar? V2349) (let ((Value (kl:shen.valvector V2349 V2350))) (if (eq? Value (quote shen.-null-)) V2349 (kl:shen.deref Value V2350))) V2349)))) (export shen.deref) (quote shen.deref))
(begin (register-function-arity (quote shen.lazyderef) 2) (define (kl:shen.lazyderef V2353 V2354) (if (kl:shen.pvar? V2353) (let ((Value (kl:shen.valvector V2353 V2354))) (if (eq? Value (quote shen.-null-)) V2353 (kl:shen.lazyderef Value V2354))) V2353)) (export shen.lazyderef) (quote shen.lazyderef))
(begin (register-function-arity (quote shen.valvector) 2) (define (kl:shen.valvector V2357 V2358) (vector-ref (vector-ref (kl:value (quote shen.*prologvectors*)) V2358) (vector-ref V2357 1))) (export shen.valvector) (quote shen.valvector))
(begin (register-function-arity (quote unify!) 4) (define (kl:unify! V2363 V2364 V2365 V2366) (kl:shen.lzy=! (kl:shen.lazyderef V2363 V2365) (kl:shen.lazyderef V2364 V2365) V2365 V2366)) (export unify!) (quote unify!))
(begin (register-function-arity (quote shen.lzy=!) 4) (define (kl:shen.lzy=! V2388 V2389 V2390 V2391) (cond ((kl:= V2389 V2388) (kl:thaw V2391)) ((and (kl:shen.pvar? V2388) (kl:not (kl:shen.occurs? V2388 (kl:shen.deref V2389 V2390)))) (kl:bind V2388 V2389 V2390 V2391)) ((and (kl:shen.pvar? V2389) (kl:not (kl:shen.occurs? V2389 (kl:shen.deref V2388 V2390)))) (kl:bind V2389 V2388 V2390 V2391)) ((and (pair? V2388) (pair? V2389)) (kl:shen.lzy=! (kl:shen.lazyderef (car V2388) V2390) (kl:shen.lazyderef (car V2389) V2390) V2390 (lambda () (kl:shen.lzy=! (kl:shen.lazyderef (cdr V2388) V2390) (kl:shen.lazyderef (cdr V2389) V2390) V2390 V2391)))) (#t #f))) (export shen.lzy=!) (quote shen.lzy=!))
(begin (register-function-arity (quote shen.occurs?) 2) (define (kl:shen.occurs? V2403 V2404) (cond ((kl:= V2404 V2403) #t) ((pair? V2404) (or (assert-boolean (kl:shen.occurs? V2403 (car V2404))) (assert-boolean (kl:shen.occurs? V2403 (cdr V2404))))) (#t #f))) (export shen.occurs?) (quote shen.occurs?))
(begin (register-function-arity (quote identical) 4) (define (kl:identical V2409 V2410 V2411 V2412) (kl:shen.lzy== (kl:shen.lazyderef V2409 V2411) (kl:shen.lazyderef V2410 V2411) V2411 V2412)) (export identical) (quote identical))
(begin (register-function-arity (quote shen.lzy==) 4) (define (kl:shen.lzy== V2434 V2435 V2436 V2437) (cond ((kl:= V2435 V2434) (kl:thaw V2437)) ((and (pair? V2434) (pair? V2435)) (kl:shen.lzy== (kl:shen.lazyderef (car V2434) V2436) (kl:shen.lazyderef (car V2435) V2436) V2436 (lambda () (kl:shen.lzy== (cdr V2434) (cdr V2435) V2436 V2437)))) (#t #f))) (export shen.lzy==) (quote shen.lzy==))
(begin (register-function-arity (quote shen.pvar) 1) (define (kl:shen.pvar V2439) (string-append "Var" (kl:shen.app (vector-ref V2439 1) "" (quote shen.a)))) (export shen.pvar) (quote shen.pvar))
(begin (register-function-arity (quote bind) 4) (define (kl:bind V2444 V2445 V2446 V2447) (begin (kl:shen.bindv V2444 V2445 V2446) (let ((Result (kl:thaw V2447))) (begin (kl:shen.unbindv V2444 V2446) Result)))) (export bind) (quote bind))
(begin (register-function-arity (quote fwhen) 3) (define (kl:fwhen V2465 V2466 V2467) (cond ((kl:= #t V2465) (kl:thaw V2467)) ((kl:= #f V2465) #f) (#t (simple-error (string-append "fwhen expects a boolean: not " (kl:shen.app V2465 "%" (quote shen.s))))))) (export fwhen) (quote fwhen))
(begin (register-function-arity (quote call) 3) (define (kl:call V2483 V2484 V2485) (cond ((pair? V2483) (kl:shen.call-help (kl:function (kl:shen.lazyderef (car V2483) V2484)) (cdr V2483) V2484 V2485)) ((kl:shen.pvar? V2483) (kl:call (kl:shen.lazyderef V2483 V2484) V2484 V2485)) (#t #f))) (export call) (quote call))
(begin (register-function-arity (quote shen.call-help) 4) (define (kl:shen.call-help V2490 V2491 V2492 V2493) (cond ((null? V2491) ((V2490 V2492) V2493)) ((pair? V2491) (kl:shen.call-help (V2490 (car V2491)) (cdr V2491) V2492 V2493)) (#t (kl:shen.f_error (quote shen.call-help))))) (export shen.call-help) (quote shen.call-help))
(begin (register-function-arity (quote shen.intprolog) 1) (define (kl:shen.intprolog V2495) (cond ((and (pair? V2495) (pair? (car V2495))) (let ((ProcessN (kl:shen.start-new-prolog-process))) (kl:shen.intprolog-help (car (car V2495)) (kl:shen.insert-prolog-variables (cons (cdr (car V2495)) (cons (cdr V2495) (quote ()))) ProcessN) ProcessN))) (#t (kl:shen.f_error (quote shen.intprolog))))) (export shen.intprolog) (quote shen.intprolog))
(begin (register-function-arity (quote shen.intprolog-help) 3) (define (kl:shen.intprolog-help V2499 V2500 V2501) (cond ((and (pair? V2500) (and (pair? (cdr V2500)) (null? (cdr (cdr V2500))))) (kl:shen.intprolog-help-help V2499 (car V2500) (car (cdr V2500)) V2501)) (#t (kl:shen.f_error (quote shen.intprolog-help))))) (export shen.intprolog-help) (quote shen.intprolog-help))
(begin (register-function-arity (quote shen.intprolog-help-help) 4) (define (kl:shen.intprolog-help-help V2506 V2507 V2508 V2509) (cond ((null? V2507) ((V2506 V2509) (lambda () (kl:shen.call-rest V2508 V2509)))) ((pair? V2507) (kl:shen.intprolog-help-help (V2506 (car V2507)) (cdr V2507) V2508 V2509)) (#t (kl:shen.f_error (quote shen.intprolog-help-help))))) (export shen.intprolog-help-help) (quote shen.intprolog-help-help))
(begin (register-function-arity (quote shen.call-rest) 2) (define (kl:shen.call-rest V2514 V2515) (cond ((null? V2514) #t) ((and (pair? V2514) (and (pair? (car V2514)) (pair? (cdr (car V2514))))) (kl:shen.call-rest (cons (cons ((car (car V2514)) (car (cdr (car V2514)))) (cdr (cdr (car V2514)))) (cdr V2514)) V2515)) ((and (pair? V2514) (and (pair? (car V2514)) (null? (cdr (car V2514))))) (((car (car V2514)) V2515) (lambda () (kl:shen.call-rest (cdr V2514) V2515)))) (#t (kl:shen.f_error (quote shen.call-rest))))) (export shen.call-rest) (quote shen.call-rest))
(begin (register-function-arity (quote shen.start-new-prolog-process) 0) (define (kl:shen.start-new-prolog-process) (let ((IncrementProcessCounter (kl:set (quote shen.*process-counter*) (+ 1 (kl:value (quote shen.*process-counter*)))))) (kl:shen.initialise-prolog IncrementProcessCounter))) (export shen.start-new-prolog-process) (quote shen.start-new-prolog-process))
(begin (register-function-arity (quote shen.insert-prolog-variables) 2) (define (kl:shen.insert-prolog-variables V2518 V2519) (kl:shen.insert-prolog-variables-help V2518 (kl:shen.flatten V2518) V2519)) (export shen.insert-prolog-variables) (quote shen.insert-prolog-variables))
(begin (register-function-arity (quote shen.insert-prolog-variables-help) 3) (define (kl:shen.insert-prolog-variables-help V2527 V2528 V2529) (cond ((null? V2528) V2527) ((and (pair? V2528) (kl:variable? (car V2528))) (let ((V (kl:shen.newpv V2529))) (let ((XV/Y (kl:subst V (car V2528) V2527))) (let ((Z-Y (kl:remove (car V2528) (cdr V2528)))) (kl:shen.insert-prolog-variables-help XV/Y Z-Y V2529))))) ((pair? V2528) (kl:shen.insert-prolog-variables-help V2527 (cdr V2528) V2529)) (#t (kl:shen.f_error (quote shen.insert-prolog-variables-help))))) (export shen.insert-prolog-variables-help) (quote shen.insert-prolog-variables-help))
(begin (register-function-arity (quote shen.initialise-prolog) 1) (define (kl:shen.initialise-prolog V2531) (let ((Vector (let ((_tmp (kl:value (quote shen.*prologvectors*)))) (vector-set! _tmp V2531 (kl:shen.fillvector (kl:vector 10) 1 10 (quote shen.-null-))) _tmp))) (let ((Counter (let ((_tmp (kl:value (quote shen.*varcounter*)))) (vector-set! _tmp V2531 1) _tmp))) V2531))) (export shen.initialise-prolog) (quote shen.initialise-prolog))
