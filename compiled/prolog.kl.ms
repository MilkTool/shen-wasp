"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.<defprolog>) 1) (define (kl:shen.<defprolog> V1630) (let ((Parse_shen.<predicate*> (kl:shen.<predicate*> V1630))) (if (kl:not (kl:= (kl:fail) Parse_shen.<predicate*>)) (let ((Parse_shen.<clauses*> (kl:shen.<clauses*> Parse_shen.<predicate*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<clauses*>)) (kl:shen.pair (car Parse_shen.<clauses*>) (car (kl:shen.prolog->shen (kl:map (lambda (Parse_X) (kl:shen.insert-predicate (kl:shen.hdtl Parse_shen.<predicate*>) Parse_X)) (kl:shen.hdtl Parse_shen.<clauses*>))))) (kl:fail))) (kl:fail)))) (quote shen.<defprolog>))
(begin (register-function-arity (quote shen.prolog-error) 2) (define (kl:shen.prolog-error V1639 V1640) (cond ((and (pair? V1640) (and (pair? (cdr V1640)) (null? (cdr (cdr V1640))))) (simple-error (string-append "prolog syntax error in " (kl:shen.app V1639 (string-append " here:\n\n " (kl:shen.app (kl:shen.next-50 50 (car V1640)) "\n" (quote shen.a))) (quote shen.a))))) (#t (simple-error (string-append "prolog syntax error in " (kl:shen.app V1639 "\n" (quote shen.a))))))) (quote shen.prolog-error))
(begin (register-function-arity (quote shen.next-50) 2) (define (kl:shen.next-50 V1647 V1648) (cond ((null? V1648) "") ((kl:= 0 V1647) "") ((pair? V1648) (string-append (kl:shen.decons-string (car V1648)) (kl:shen.next-50 (- V1647 1) (cdr V1648)))) (#t (kl:shen.f_error (quote shen.next-50))))) (quote shen.next-50))
(begin (register-function-arity (quote shen.decons-string) 1) (define (kl:shen.decons-string V1650) (cond ((and (pair? V1650) (and (eq? (quote cons) (car V1650)) (and (pair? (cdr V1650)) (and (pair? (cdr (cdr V1650))) (null? (cdr (cdr (cdr V1650)))))))) (kl:shen.app (kl:shen.eval-cons V1650) " " (quote shen.s))) (#t (kl:shen.app V1650 " " (quote shen.r))))) (quote shen.decons-string))
(begin (register-function-arity (quote shen.insert-predicate) 2) (define (kl:shen.insert-predicate V1653 V1654) (cond ((and (pair? V1654) (and (pair? (cdr V1654)) (null? (cdr (cdr V1654))))) (cons (cons V1653 (car V1654)) (cons (quote :-) (cdr V1654)))) (#t (kl:shen.f_error (quote shen.insert-predicate))))) (quote shen.insert-predicate))
(begin (register-function-arity (quote shen.<predicate*>) 1) (define (kl:shen.<predicate*> V1656) (if (pair? (car V1656)) (let ((Parse_X (kl:shen.hdhd V1656))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1656) (kl:shen.hdtl V1656))) Parse_X)) (kl:fail))) (quote shen.<predicate*>))
(begin (register-function-arity (quote shen.<clauses*>) 1) (define (kl:shen.<clauses*> V1658) (let ((YaccParse (let ((Parse_shen.<clause*> (kl:shen.<clause*> V1658))) (if (kl:not (kl:= (kl:fail) Parse_shen.<clause*>)) (let ((Parse_shen.<clauses*> (kl:shen.<clauses*> Parse_shen.<clause*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<clauses*>)) (kl:shen.pair (car Parse_shen.<clauses*>) (cons (kl:shen.hdtl Parse_shen.<clause*>) (kl:shen.hdtl Parse_shen.<clauses*>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1658))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<clauses*>))
(begin (register-function-arity (quote shen.<clause*>) 1) (define (kl:shen.<clause*> V1661) (let ((Parse_shen.<head*> (kl:shen.<head*> V1661))) (if (kl:not (kl:= (kl:fail) Parse_shen.<head*>)) (if (and (pair? (car Parse_shen.<head*>)) (eq? (quote <--) (kl:shen.hdhd Parse_shen.<head*>))) (let ((NewStream1659 (kl:shen.pair (kl:shen.tlhd Parse_shen.<head*>) (kl:shen.hdtl Parse_shen.<head*>)))) (let ((Parse_shen.<body*> (kl:shen.<body*> NewStream1659))) (if (kl:not (kl:= (kl:fail) Parse_shen.<body*>)) (let ((Parse_shen.<end*> (kl:shen.<end*> Parse_shen.<body*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<end*>)) (kl:shen.pair (car Parse_shen.<end*>) (cons (kl:shen.hdtl Parse_shen.<head*>) (cons (kl:shen.hdtl Parse_shen.<body*>) (quote ())))) (kl:fail))) (kl:fail)))) (kl:fail)) (kl:fail)))) (quote shen.<clause*>))
(begin (register-function-arity (quote shen.<head*>) 1) (define (kl:shen.<head*> V1663) (let ((YaccParse (let ((Parse_shen.<term*> (kl:shen.<term*> V1663))) (if (kl:not (kl:= (kl:fail) Parse_shen.<term*>)) (let ((Parse_shen.<head*> (kl:shen.<head*> Parse_shen.<term*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<head*>)) (kl:shen.pair (car Parse_shen.<head*>) (cons (kl:shen.hdtl Parse_shen.<term*>) (kl:shen.hdtl Parse_shen.<head*>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1663))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<head*>))
(begin (register-function-arity (quote shen.<term*>) 1) (define (kl:shen.<term*> V1665) (if (pair? (car V1665)) (let ((Parse_X (kl:shen.hdhd V1665))) (if (and (kl:not (eq? (quote <--) Parse_X)) (assert-boolean (kl:shen.legitimate-term? Parse_X))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1665) (kl:shen.hdtl V1665))) (kl:shen.eval-cons Parse_X)) (kl:fail))) (kl:fail))) (quote shen.<term*>))
(begin (register-function-arity (quote shen.legitimate-term?) 1) (define (kl:shen.legitimate-term? V1671) (cond ((and (pair? V1671) (and (eq? (quote cons) (car V1671)) (and (pair? (cdr V1671)) (and (pair? (cdr (cdr V1671))) (null? (cdr (cdr (cdr V1671)))))))) (and (assert-boolean (kl:shen.legitimate-term? (car (cdr V1671)))) (assert-boolean (kl:shen.legitimate-term? (car (cdr (cdr V1671))))))) ((and (pair? V1671) (and (eq? (quote mode) (car V1671)) (and (pair? (cdr V1671)) (and (pair? (cdr (cdr V1671))) (and (eq? (quote +) (car (cdr (cdr V1671)))) (null? (cdr (cdr (cdr V1671))))))))) (kl:shen.legitimate-term? (car (cdr V1671)))) ((and (pair? V1671) (and (eq? (quote mode) (car V1671)) (and (pair? (cdr V1671)) (and (pair? (cdr (cdr V1671))) (and (eq? (quote -) (car (cdr (cdr V1671)))) (null? (cdr (cdr (cdr V1671))))))))) (kl:shen.legitimate-term? (car (cdr V1671)))) ((pair? V1671) #f) (#t #t))) (quote shen.legitimate-term?))
(begin (register-function-arity (quote shen.eval-cons) 1) (define (kl:shen.eval-cons V1673) (cond ((and (pair? V1673) (and (eq? (quote cons) (car V1673)) (and (pair? (cdr V1673)) (and (pair? (cdr (cdr V1673))) (null? (cdr (cdr (cdr V1673)))))))) (cons (kl:shen.eval-cons (car (cdr V1673))) (kl:shen.eval-cons (car (cdr (cdr V1673)))))) ((and (pair? V1673) (and (eq? (quote mode) (car V1673)) (and (pair? (cdr V1673)) (and (pair? (cdr (cdr V1673))) (null? (cdr (cdr (cdr V1673)))))))) (cons (quote mode) (cons (kl:shen.eval-cons (car (cdr V1673))) (cdr (cdr V1673))))) (#t V1673))) (quote shen.eval-cons))
(begin (register-function-arity (quote shen.<body*>) 1) (define (kl:shen.<body*> V1675) (let ((YaccParse (let ((Parse_shen.<literal*> (kl:shen.<literal*> V1675))) (if (kl:not (kl:= (kl:fail) Parse_shen.<literal*>)) (let ((Parse_shen.<body*> (kl:shen.<body*> Parse_shen.<literal*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<body*>)) (kl:shen.pair (car Parse_shen.<body*>) (cons (kl:shen.hdtl Parse_shen.<literal*>) (kl:shen.hdtl Parse_shen.<body*>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1675))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<body*>))
(begin (register-function-arity (quote shen.<literal*>) 1) (define (kl:shen.<literal*> V1678) (let ((YaccParse (if (and (pair? (car V1678)) (eq? (quote !) (kl:shen.hdhd V1678))) (let ((NewStream1676 (kl:shen.pair (kl:shen.tlhd V1678) (kl:shen.hdtl V1678)))) (kl:shen.pair (car NewStream1676) (cons (quote cut) (cons (kl:intern "Throwcontrol") (quote ()))))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (if (pair? (car V1678)) (let ((Parse_X (kl:shen.hdhd V1678))) (if (pair? Parse_X) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1678) (kl:shen.hdtl V1678))) Parse_X) (kl:fail))) (kl:fail)) YaccParse))) (quote shen.<literal*>))
(begin (register-function-arity (quote shen.<end*>) 1) (define (kl:shen.<end*> V1680) (if (pair? (car V1680)) (let ((Parse_X (kl:shen.hdhd V1680))) (if (eq? Parse_X (quote _waspvm_sc_)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1680) (kl:shen.hdtl V1680))) Parse_X) (kl:fail))) (kl:fail))) (quote shen.<end*>))
(begin (register-function-arity (quote cut) 3) (define (kl:cut V1684 V1685 V1686) (let ((Result (kl:thaw V1686))) (if (kl:= Result #f) V1684 Result))) (quote cut))
(begin (register-function-arity (quote shen.insert_modes) 1) (define (kl:shen.insert_modes V1688) (cond ((and (pair? V1688) (and (eq? (quote mode) (car V1688)) (and (pair? (cdr V1688)) (and (pair? (cdr (cdr V1688))) (null? (cdr (cdr (cdr V1688)))))))) V1688) ((null? V1688) (quote ())) ((pair? V1688) (cons (cons (quote mode) (cons (car V1688) (cons (quote +) (quote ())))) (cons (quote mode) (cons (kl:shen.insert_modes (cdr V1688)) (cons (quote -) (quote ())))))) (#t V1688))) (quote shen.insert_modes))
(begin (register-function-arity (quote shen.s-prolog) 1) (define (kl:shen.s-prolog V1690) (kl:map (lambda (X) (kl:eval X)) (kl:shen.prolog->shen V1690))) (quote shen.s-prolog))
(begin (register-function-arity (quote shen.prolog->shen) 1) (define (kl:shen.prolog->shen V1692) (kl:map (lambda (X) (kl:shen.compile_prolog_procedure X)) (kl:shen.group_clauses (kl:map (lambda (X) (kl:shen.s-prolog_clause X)) (kl:mapcan (lambda (X) (kl:shen.head_abstraction X)) V1692))))) (quote shen.prolog->shen))
(begin (register-function-arity (quote shen.s-prolog_clause) 1) (define (kl:shen.s-prolog_clause V1694) (cond ((and (pair? V1694) (and (pair? (cdr V1694)) (and (eq? (quote :-) (car (cdr V1694))) (and (pair? (cdr (cdr V1694))) (null? (cdr (cdr (cdr V1694)))))))) (cons (car V1694) (cons (quote :-) (cons (kl:map (lambda (X) (kl:shen.s-prolog_literal X)) (car (cdr (cdr V1694)))) (quote ()))))) (#t (kl:shen.f_error (quote shen.s-prolog_clause))))) (quote shen.s-prolog_clause))
(begin (register-function-arity (quote shen.head_abstraction) 1) (define (kl:shen.head_abstraction V1696) (cond ((and (pair? V1696) (and (pair? (cdr V1696)) (and (eq? (quote :-) (car (cdr V1696))) (and (pair? (cdr (cdr V1696))) (and (null? (cdr (cdr (cdr V1696)))) (assert-boolean (guard (lambda (_) #f) (< (kl:shen.complexity_head (car V1696)) (kl:value (quote shen.*maxcomplexity*)))))))))) (cons V1696 (quote ()))) ((and (pair? V1696) (and (pair? (car V1696)) (and (pair? (cdr V1696)) (and (eq? (quote :-) (car (cdr V1696))) (and (pair? (cdr (cdr V1696))) (null? (cdr (cdr (cdr V1696))))))))) (let ((Terms (kl:map (lambda (Y) (kl:gensym (quote V))) (cdr (car V1696))))) (let ((XTerms (kl:shen.rcons_form (kl:shen.remove_modes (cdr (car V1696)))))) (let ((Literal (cons (quote unify) (cons (kl:shen.cons_form Terms) (cons XTerms (quote ())))))) (let ((Clause (cons (cons (car (car V1696)) Terms) (cons (quote :-) (cons (cons Literal (car (cdr (cdr V1696)))) (quote ())))))) (cons Clause (quote ()))))))) (#t (kl:shen.f_error (quote shen.head_abstraction))))) (quote shen.head_abstraction))
(begin (register-function-arity (quote shen.complexity_head) 1) (define (kl:shen.complexity_head V1702) (cond ((pair? V1702) (kl:shen.safe-product (kl:map (lambda (X) (kl:shen.complexity X)) (cdr V1702)))) (#t (kl:shen.f_error (quote shen.complexity_head))))) (quote shen.complexity_head))
(begin (register-function-arity (quote shen.safe-multiply) 2) (define (kl:shen.safe-multiply V1705 V1706) (* V1705 V1706)) (quote shen.safe-multiply))
(begin (register-function-arity (quote shen.complexity) 1) (define (kl:shen.complexity V1715) (cond ((and (pair? V1715) (and (eq? (quote mode) (car V1715)) (and (pair? (cdr V1715)) (and (pair? (car (cdr V1715))) (and (eq? (quote mode) (car (car (cdr V1715)))) (and (pair? (cdr (car (cdr V1715)))) (and (pair? (cdr (cdr (car (cdr V1715))))) (and (null? (cdr (cdr (cdr (car (cdr V1715)))))) (and (pair? (cdr (cdr V1715))) (null? (cdr (cdr (cdr V1715))))))))))))) (kl:shen.complexity (car (cdr V1715)))) ((and (pair? V1715) (and (eq? (quote mode) (car V1715)) (and (pair? (cdr V1715)) (and (pair? (car (cdr V1715))) (and (pair? (cdr (cdr V1715))) (and (eq? (quote +) (car (cdr (cdr V1715)))) (null? (cdr (cdr (cdr V1715)))))))))) (kl:shen.safe-multiply 2 (kl:shen.safe-multiply (kl:shen.complexity (cons (quote mode) (cons (car (car (cdr V1715))) (cdr (cdr V1715))))) (kl:shen.complexity (cons (quote mode) (cons (cdr (car (cdr V1715))) (cdr (cdr V1715)))))))) ((and (pair? V1715) (and (eq? (quote mode) (car V1715)) (and (pair? (cdr V1715)) (and (pair? (car (cdr V1715))) (and (pair? (cdr (cdr V1715))) (and (eq? (quote -) (car (cdr (cdr V1715)))) (null? (cdr (cdr (cdr V1715)))))))))) (kl:shen.safe-multiply (kl:shen.complexity (cons (quote mode) (cons (car (car (cdr V1715))) (cdr (cdr V1715))))) (kl:shen.complexity (cons (quote mode) (cons (cdr (car (cdr V1715))) (cdr (cdr V1715))))))) ((and (pair? V1715) (and (eq? (quote mode) (car V1715)) (and (pair? (cdr V1715)) (and (pair? (cdr (cdr V1715))) (and (null? (cdr (cdr (cdr V1715)))) (kl:variable? (car (cdr V1715)))))))) 1) ((and (pair? V1715) (and (eq? (quote mode) (car V1715)) (and (pair? (cdr V1715)) (and (pair? (cdr (cdr V1715))) (and (eq? (quote +) (car (cdr (cdr V1715)))) (null? (cdr (cdr (cdr V1715))))))))) 2) ((and (pair? V1715) (and (eq? (quote mode) (car V1715)) (and (pair? (cdr V1715)) (and (pair? (cdr (cdr V1715))) (and (eq? (quote -) (car (cdr (cdr V1715)))) (null? (cdr (cdr (cdr V1715))))))))) 1) (#t (kl:shen.complexity (cons (quote mode) (cons V1715 (cons (quote +) (quote ())))))))) (quote shen.complexity))
(begin (register-function-arity (quote shen.safe-product) 1) (define (kl:shen.safe-product V1717) (cond ((null? V1717) 1) ((pair? V1717) (kl:shen.safe-multiply (car V1717) (kl:shen.safe-product (cdr V1717)))) (#t (kl:shen.f_error (quote shen.safe-product))))) (quote shen.safe-product))
(begin (register-function-arity (quote shen.s-prolog_literal) 1) (define (kl:shen.s-prolog_literal V1719) (cond ((and (pair? V1719) (and (eq? (quote is) (car V1719)) (and (pair? (cdr V1719)) (and (pair? (cdr (cdr V1719))) (null? (cdr (cdr (cdr V1719)))))))) (cons (quote bind) (cons (car (cdr V1719)) (cons (kl:shen.insert_deref (car (cdr (cdr V1719)))) (quote ()))))) ((and (pair? V1719) (and (eq? (quote when) (car V1719)) (and (pair? (cdr V1719)) (null? (cdr (cdr V1719)))))) (cons (quote fwhen) (cons (kl:shen.insert_deref (car (cdr V1719))) (quote ())))) ((and (pair? V1719) (and (eq? (quote bind) (car V1719)) (and (pair? (cdr V1719)) (and (pair? (cdr (cdr V1719))) (null? (cdr (cdr (cdr V1719)))))))) (cons (quote bind) (cons (car (cdr V1719)) (cons (kl:shen.insert_lazyderef (car (cdr (cdr V1719)))) (quote ()))))) ((and (pair? V1719) (and (eq? (quote fwhen) (car V1719)) (and (pair? (cdr V1719)) (null? (cdr (cdr V1719)))))) (cons (quote fwhen) (cons (kl:shen.insert_lazyderef (car (cdr V1719))) (quote ())))) ((pair? V1719) V1719) (#t (kl:shen.f_error (quote shen.s-prolog_literal))))) (quote shen.s-prolog_literal))
(begin (register-function-arity (quote shen.insert_deref) 1) (define (kl:shen.insert_deref V1721) (cond ((kl:variable? V1721) (cons (quote shen.deref) (cons V1721 (cons (quote ProcessN) (quote ()))))) ((pair? V1721) (cons (kl:shen.insert_deref (car V1721)) (kl:shen.insert_deref (cdr V1721)))) (#t V1721))) (quote shen.insert_deref))
(begin (register-function-arity (quote shen.insert_lazyderef) 1) (define (kl:shen.insert_lazyderef V1723) (cond ((kl:variable? V1723) (cons (quote shen.lazyderef) (cons V1723 (cons (quote ProcessN) (quote ()))))) ((pair? V1723) (cons (kl:shen.insert_lazyderef (car V1723)) (kl:shen.insert_lazyderef (cdr V1723)))) (#t V1723))) (quote shen.insert_lazyderef))
(begin (register-function-arity (quote shen.group_clauses) 1) (define (kl:shen.group_clauses V1725) (cond ((null? V1725) (quote ())) ((pair? V1725) (let ((Group (kl:shen.collect (lambda (X) (kl:shen.same_predicate? (car V1725) X)) V1725))) (let ((Rest (kl:difference V1725 Group))) (cons Group (kl:shen.group_clauses Rest))))) (#t (kl:shen.f_error (quote shen.group_clauses))))) (quote shen.group_clauses))
(begin (register-function-arity (quote shen.collect) 2) (define (kl:shen.collect V1730 V1731) (cond ((null? V1731) (quote ())) ((pair? V1731) (if (assert-boolean (V1730 (car V1731))) (cons (car V1731) (kl:shen.collect V1730 (cdr V1731))) (kl:shen.collect V1730 (cdr V1731)))) (#t (kl:shen.f_error (quote shen.collect))))) (quote shen.collect))
(begin (register-function-arity (quote shen.same_predicate?) 2) (define (kl:shen.same_predicate? V1750 V1751) (cond ((and (pair? V1750) (and (pair? (car V1750)) (and (pair? V1751) (pair? (car V1751))))) (kl:= (car (car V1750)) (car (car V1751)))) (#t (kl:shen.f_error (quote shen.same_predicate?))))) (quote shen.same_predicate?))
(begin (register-function-arity (quote shen.compile_prolog_procedure) 1) (define (kl:shen.compile_prolog_procedure V1753) (let ((F (kl:shen.procedure_name V1753))) (let ((Shen (kl:shen.clauses-to-shen F V1753))) Shen))) (quote shen.compile_prolog_procedure))
(begin (register-function-arity (quote shen.procedure_name) 1) (define (kl:shen.procedure_name V1767) (cond ((and (pair? V1767) (and (pair? (car V1767)) (pair? (car (car V1767))))) (car (car (car V1767)))) (#t (kl:shen.f_error (quote shen.procedure_name))))) (quote shen.procedure_name))
(begin (register-function-arity (quote shen.clauses-to-shen) 2) (define (kl:shen.clauses-to-shen V1770 V1771) (let ((Linear (kl:map (lambda (X) (kl:shen.linearise-clause X)) V1771))) (let ((Arity (kl:shen.prolog-aritycheck V1770 (kl:map (lambda (X) (kl:head X)) V1771)))) (let ((Parameters (kl:shen.parameters Arity))) (let ((AUM_instructions (kl:map (lambda (X) (kl:shen.aum X Parameters)) Linear))) (let ((Code (kl:shen.catch-cut (kl:shen.nest-disjunct (kl:map (lambda (X) (kl:shen.aum_to_shen X)) AUM_instructions))))) (let ((ShenDef (cons (quote define) (cons V1770 (kl:append Parameters (kl:append (cons (quote ProcessN) (cons (quote Continuation) (quote ()))) (cons (quote ->) (cons Code (quote ()))))))))) ShenDef))))))) (quote shen.clauses-to-shen))
(begin (register-function-arity (quote shen.catch-cut) 1) (define (kl:shen.catch-cut V1773) (cond ((kl:not (kl:shen.occurs? (quote cut) V1773)) V1773) (#t (cons (quote let) (cons (quote Throwcontrol) (cons (cons (quote shen.catchpoint) (quote ())) (cons (cons (quote shen.cutpoint) (cons (quote Throwcontrol) (cons V1773 (quote ())))) (quote ())))))))) (quote shen.catch-cut))
(begin (register-function-arity (quote shen.catchpoint) 0) (define (kl:shen.catchpoint) (kl:set (quote shen.*catch*) (+ 1 (kl:value (quote shen.*catch*))))) (quote shen.catchpoint))
(begin (register-function-arity (quote shen.cutpoint) 2) (define (kl:shen.cutpoint V1781 V1782) (cond ((kl:= V1782 V1781) #f) (#t V1782))) (quote shen.cutpoint))
(begin (register-function-arity (quote shen.nest-disjunct) 1) (define (kl:shen.nest-disjunct V1784) (cond ((and (pair? V1784) (null? (cdr V1784))) (car V1784)) ((pair? V1784) (kl:shen.lisp-or (car V1784) (kl:shen.nest-disjunct (cdr V1784)))) (#t (kl:shen.f_error (quote shen.nest-disjunct))))) (quote shen.nest-disjunct))
(begin (register-function-arity (quote shen.lisp-or) 2) (define (kl:shen.lisp-or V1787 V1788) (cons (quote let) (cons (quote Case) (cons V1787 (cons (cons (quote if) (cons (cons (quote =) (cons (quote Case) (cons #f (quote ())))) (cons V1788 (cons (quote Case) (quote ()))))) (quote ())))))) (quote shen.lisp-or))
(begin (register-function-arity (quote shen.prolog-aritycheck) 2) (define (kl:shen.prolog-aritycheck V1793 V1794) (cond ((and (pair? V1794) (null? (cdr V1794))) (- (kl:length (car V1794)) 1)) ((and (pair? V1794) (pair? (cdr V1794))) (if (kl:= (kl:length (car V1794)) (kl:length (car (cdr V1794)))) (kl:shen.prolog-aritycheck V1793 (cdr V1794)) (simple-error (string-append "arity error in prolog procedure " (kl:shen.app (cons V1793 (quote ())) "\n" (quote shen.a)))))) (#t (kl:shen.f_error (quote shen.prolog-aritycheck))))) (quote shen.prolog-aritycheck))
(begin (register-function-arity (quote shen.linearise-clause) 1) (define (kl:shen.linearise-clause V1796) (cond ((and (pair? V1796) (and (pair? (cdr V1796)) (and (eq? (quote :-) (car (cdr V1796))) (and (pair? (cdr (cdr V1796))) (null? (cdr (cdr (cdr V1796)))))))) (let ((Linear (kl:shen.linearise (cons (car V1796) (cdr (cdr V1796)))))) (kl:shen.clause_form Linear))) (#t (kl:shen.f_error (quote shen.linearise-clause))))) (quote shen.linearise-clause))
(begin (register-function-arity (quote shen.clause_form) 1) (define (kl:shen.clause_form V1798) (cond ((and (pair? V1798) (and (pair? (cdr V1798)) (null? (cdr (cdr V1798))))) (cons (kl:shen.explicit_modes (car V1798)) (cons (quote :-) (cons (kl:shen.cf_help (car (cdr V1798))) (quote ()))))) (#t (kl:shen.f_error (quote shen.clause_form))))) (quote shen.clause_form))
(begin (register-function-arity (quote shen.explicit_modes) 1) (define (kl:shen.explicit_modes V1800) (cond ((pair? V1800) (cons (car V1800) (kl:map (lambda (X) (kl:shen.em_help X)) (cdr V1800)))) (#t (kl:shen.f_error (quote shen.explicit_modes))))) (quote shen.explicit_modes))
(begin (register-function-arity (quote shen.em_help) 1) (define (kl:shen.em_help V1802) (cond ((and (pair? V1802) (and (eq? (quote mode) (car V1802)) (and (pair? (cdr V1802)) (and (pair? (cdr (cdr V1802))) (null? (cdr (cdr (cdr V1802)))))))) V1802) (#t (cons (quote mode) (cons V1802 (cons (quote +) (quote ()))))))) (quote shen.em_help))
(begin (register-function-arity (quote shen.cf_help) 1) (define (kl:shen.cf_help V1804) (cond ((and (pair? V1804) (and (eq? (quote where) (car V1804)) (and (pair? (cdr V1804)) (and (pair? (car (cdr V1804))) (and (eq? (quote =) (car (car (cdr V1804)))) (and (pair? (cdr (car (cdr V1804)))) (and (pair? (cdr (cdr (car (cdr V1804))))) (and (null? (cdr (cdr (cdr (car (cdr V1804)))))) (and (pair? (cdr (cdr V1804))) (null? (cdr (cdr (cdr V1804))))))))))))) (cons (cons (if (assert-boolean (kl:value (quote shen.*occurs*))) (quote unify!) (quote unify)) (cdr (car (cdr V1804)))) (kl:shen.cf_help (car (cdr (cdr V1804)))))) (#t V1804))) (quote shen.cf_help))
(begin (register-function-arity (quote occurs-check) 1) (define (kl:occurs-check V1810) (cond ((eq? (quote +) V1810) (kl:set (quote shen.*occurs*) #t)) ((eq? (quote -) V1810) (kl:set (quote shen.*occurs*) #f)) (#t (simple-error "occurs-check expects + or -\n")))) (quote occurs-check))
(begin (register-function-arity (quote shen.aum) 2) (define (kl:shen.aum V1813 V1814) (cond ((and (pair? V1813) (and (pair? (car V1813)) (and (pair? (cdr V1813)) (and (eq? (quote :-) (car (cdr V1813))) (and (pair? (cdr (cdr V1813))) (null? (cdr (cdr (cdr V1813))))))))) (let ((MuApplication (kl:shen.make_mu_application (cons (quote shen.mu) (cons (cdr (car V1813)) (cons (kl:shen.continuation_call (cdr (car V1813)) (car (cdr (cdr V1813)))) (quote ())))) V1814))) (kl:shen.mu_reduction MuApplication (quote +)))) (#t (kl:shen.f_error (quote shen.aum))))) (quote shen.aum))
(begin (register-function-arity (quote shen.continuation_call) 2) (define (kl:shen.continuation_call V1817 V1818) (let ((VTerms (cons (quote ProcessN) (kl:shen.extract_vars V1817)))) (let ((VBody (kl:shen.extract_vars V1818))) (let ((Free (kl:remove (quote Throwcontrol) (kl:difference VBody VTerms)))) (kl:shen.cc_help Free V1818))))) (quote shen.continuation_call))
(begin (register-function-arity (quote remove) 2) (define (kl:remove V1821 V1822) (kl:shen.remove-h V1821 V1822 (quote ()))) (quote remove))
(begin (register-function-arity (quote shen.remove-h) 3) (define (kl:shen.remove-h V1829 V1830 V1831) (cond ((null? V1830) (kl:reverse V1831)) ((and (pair? V1830) (kl:= (car V1830) V1829)) (kl:shen.remove-h (car V1830) (cdr V1830) V1831)) ((pair? V1830) (kl:shen.remove-h V1829 (cdr V1830) (cons (car V1830) V1831))) (#t (kl:shen.f_error (quote shen.remove-h))))) (quote shen.remove-h))
(begin (register-function-arity (quote shen.cc_help) 2) (define (kl:shen.cc_help V1834 V1835) (cond ((and (null? V1834) (null? V1835)) (cons (quote shen.pop) (cons (quote shen.the) (cons (quote shen.stack) (quote ()))))) ((null? V1835) (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons V1834 (cons (quote and) (cons (quote shen.then) (cons (cons (quote shen.pop) (cons (quote shen.the) (cons (quote shen.stack) (quote ())))) (quote ())))))))))) ((null? V1834) (cons (quote call) (cons (quote shen.the) (cons (quote shen.continuation) (cons V1835 (quote ())))))) (#t (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons V1834 (cons (quote and) (cons (quote shen.then) (cons (cons (quote call) (cons (quote shen.the) (cons (quote shen.continuation) (cons V1835 (quote ()))))) (quote ())))))))))))) (quote shen.cc_help))
(begin (register-function-arity (quote shen.make_mu_application) 2) (define (kl:shen.make_mu_application V1838 V1839) (cond ((and (pair? V1838) (and (eq? (quote shen.mu) (car V1838)) (and (pair? (cdr V1838)) (and (null? (car (cdr V1838))) (and (pair? (cdr (cdr V1838))) (and (null? (cdr (cdr (cdr V1838)))) (null? V1839))))))) (car (cdr (cdr V1838)))) ((and (pair? V1838) (and (eq? (quote shen.mu) (car V1838)) (and (pair? (cdr V1838)) (and (pair? (car (cdr V1838))) (and (pair? (cdr (cdr V1838))) (and (null? (cdr (cdr (cdr V1838)))) (pair? V1839))))))) (cons (cons (quote shen.mu) (cons (car (car (cdr V1838))) (cons (kl:shen.make_mu_application (cons (quote shen.mu) (cons (cdr (car (cdr V1838))) (cdr (cdr V1838)))) (cdr V1839)) (quote ())))) (cons (car V1839) (quote ())))) (#t (kl:shen.f_error (quote shen.make_mu_application))))) (quote shen.make_mu_application))
(begin (register-function-arity (quote shen.mu_reduction) 2) (define (kl:shen.mu_reduction V1848 V1849) (cond ((and (pair? V1848) (and (pair? (car V1848)) (and (eq? (quote shen.mu) (car (car V1848))) (and (pair? (cdr (car V1848))) (and (pair? (car (cdr (car V1848)))) (and (eq? (quote mode) (car (car (cdr (car V1848))))) (and (pair? (cdr (car (cdr (car V1848))))) (and (pair? (cdr (cdr (car (cdr (car V1848)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1848))))))) (and (pair? (cdr (cdr (car V1848)))) (and (null? (cdr (cdr (cdr (car V1848))))) (and (pair? (cdr V1848)) (null? (cdr (cdr V1848))))))))))))))) (kl:shen.mu_reduction (cons (cons (quote shen.mu) (cons (car (cdr (car (cdr (car V1848))))) (cdr (cdr (car V1848))))) (cdr V1848)) (car (cdr (cdr (car (cdr (car V1848)))))))) ((and (pair? V1848) (and (pair? (car V1848)) (and (eq? (quote shen.mu) (car (car V1848))) (and (pair? (cdr (car V1848))) (and (pair? (cdr (cdr (car V1848)))) (and (null? (cdr (cdr (cdr (car V1848))))) (and (pair? (cdr V1848)) (and (null? (cdr (cdr V1848))) (eq? (quote _) (car (cdr (car V1848)))))))))))) (kl:shen.mu_reduction (car (cdr (cdr (car V1848)))) V1849)) ((and (pair? V1848) (and (pair? (car V1848)) (and (eq? (quote shen.mu) (car (car V1848))) (and (pair? (cdr (car V1848))) (and (pair? (cdr (cdr (car V1848)))) (and (null? (cdr (cdr (cdr (car V1848))))) (and (pair? (cdr V1848)) (and (null? (cdr (cdr V1848))) (assert-boolean (kl:shen.ephemeral_variable? (car (cdr (car V1848))) (car (cdr V1848)))))))))))) (kl:subst (car (cdr V1848)) (car (cdr (car V1848))) (kl:shen.mu_reduction (car (cdr (cdr (car V1848)))) V1849))) ((and (pair? V1848) (and (pair? (car V1848)) (and (eq? (quote shen.mu) (car (car V1848))) (and (pair? (cdr (car V1848))) (and (pair? (cdr (cdr (car V1848)))) (and (null? (cdr (cdr (cdr (car V1848))))) (and (pair? (cdr V1848)) (and (null? (cdr (cdr V1848))) (kl:variable? (car (cdr (car V1848)))))))))))) (cons (quote let) (cons (car (cdr (car V1848))) (cons (quote shen.be) (cons (car (cdr V1848)) (cons (quote in) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1848)))) V1849) (quote ())))))))) ((and (pair? V1848) (and (pair? (car V1848)) (and (eq? (quote shen.mu) (car (car V1848))) (and (pair? (cdr (car V1848))) (and (pair? (cdr (cdr (car V1848)))) (and (null? (cdr (cdr (cdr (car V1848))))) (and (pair? (cdr V1848)) (and (null? (cdr (cdr V1848))) (and (eq? (quote -) V1849) (assert-boolean (kl:shen.prolog_constant? (car (cdr (car V1848)))))))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V1848))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote identical) (cons (quote shen.to) (cons (car (cdr (car V1848))) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1848)))) (quote -)) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))))) ((and (pair? V1848) (and (pair? (car V1848)) (and (eq? (quote shen.mu) (car (car V1848))) (and (pair? (cdr (car V1848))) (and (pair? (cdr (cdr (car V1848)))) (and (null? (cdr (cdr (cdr (car V1848))))) (and (pair? (cdr V1848)) (and (null? (cdr (cdr V1848))) (and (eq? (quote +) V1849) (assert-boolean (kl:shen.prolog_constant? (car (cdr (car V1848)))))))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V1848))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote identical) (cons (quote shen.to) (cons (car (cdr (car V1848))) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1848)))) (quote +)) (cons (quote shen.else) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.variable) (quote ()))))) (cons (quote shen.then) (cons (cons (quote bind) (cons Z (cons (quote shen.to) (cons (car (cdr (car V1848))) (cons (quote in) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1848)))) (quote +)) (quote ()))))))) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))) (quote ()))))))))) ((and (pair? V1848) (and (pair? (car V1848)) (and (eq? (quote shen.mu) (car (car V1848))) (and (pair? (cdr (car V1848))) (and (pair? (car (cdr (car V1848)))) (and (pair? (cdr (cdr (car V1848)))) (and (null? (cdr (cdr (cdr (car V1848))))) (and (pair? (cdr V1848)) (and (null? (cdr (cdr V1848))) (eq? (quote -) V1849)))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V1848))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.non-empty) (cons (quote list) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (cons (cons (quote shen.mu) (cons (car (car (cdr (car V1848)))) (cons (cons (cons (quote shen.mu) (cons (cdr (car (cdr (car V1848)))) (cdr (cdr (car V1848))))) (cons (cons (quote shen.the) (cons (quote tail) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote ())))) (cons (cons (quote shen.the) (cons (quote head) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote -)) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))))) ((and (pair? V1848) (and (pair? (car V1848)) (and (eq? (quote shen.mu) (car (car V1848))) (and (pair? (cdr (car V1848))) (and (pair? (car (cdr (car V1848)))) (and (pair? (cdr (cdr (car V1848)))) (and (null? (cdr (cdr (cdr (car V1848))))) (and (pair? (cdr V1848)) (and (null? (cdr (cdr V1848))) (eq? (quote +) V1849)))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V1848))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.non-empty) (cons (quote list) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (cons (cons (quote shen.mu) (cons (car (car (cdr (car V1848)))) (cons (cons (cons (quote shen.mu) (cons (cdr (car (cdr (car V1848)))) (cdr (cdr (car V1848))))) (cons (cons (quote shen.the) (cons (quote tail) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote ())))) (cons (cons (quote shen.the) (cons (quote head) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote +)) (cons (quote shen.else) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.variable) (quote ()))))) (cons (quote shen.then) (cons (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons (kl:shen.extract_vars (car (cdr (car V1848)))) (cons (quote and) (cons (quote shen.then) (cons (cons (quote bind) (cons Z (cons (quote shen.to) (cons (kl:shen.rcons_form (kl:shen.remove_modes (car (cdr (car V1848))))) (cons (quote in) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1848)))) (quote +)) (quote ()))))))) (quote ()))))))))) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))) (quote ()))))))))) (#t V1848))) (quote shen.mu_reduction))
(begin (register-function-arity (quote shen.rcons_form) 1) (define (kl:shen.rcons_form V1851) (cond ((pair? V1851) (cons (quote cons) (cons (kl:shen.rcons_form (car V1851)) (cons (kl:shen.rcons_form (cdr V1851)) (quote ()))))) (#t V1851))) (quote shen.rcons_form))
(begin (register-function-arity (quote shen.remove_modes) 1) (define (kl:shen.remove_modes V1853) (cond ((and (pair? V1853) (and (eq? (quote mode) (car V1853)) (and (pair? (cdr V1853)) (and (pair? (cdr (cdr V1853))) (and (eq? (quote +) (car (cdr (cdr V1853)))) (null? (cdr (cdr (cdr V1853))))))))) (kl:shen.remove_modes (car (cdr V1853)))) ((and (pair? V1853) (and (eq? (quote mode) (car V1853)) (and (pair? (cdr V1853)) (and (pair? (cdr (cdr V1853))) (and (eq? (quote -) (car (cdr (cdr V1853)))) (null? (cdr (cdr (cdr V1853))))))))) (kl:shen.remove_modes (car (cdr V1853)))) ((pair? V1853) (cons (kl:shen.remove_modes (car V1853)) (kl:shen.remove_modes (cdr V1853)))) (#t V1853))) (quote shen.remove_modes))
(begin (register-function-arity (quote shen.ephemeral_variable?) 2) (define (kl:shen.ephemeral_variable? V1856 V1857) (and (kl:variable? V1856) (kl:variable? V1857))) (quote shen.ephemeral_variable?))
(begin (register-function-arity (quote shen.prolog_constant?) 1) (define (kl:shen.prolog_constant? V1867) (cond ((pair? V1867) #f) (#t #t))) (quote shen.prolog_constant?))
(begin (register-function-arity (quote shen.aum_to_shen) 1) (define (kl:shen.aum_to_shen V1869) (cond ((and (pair? V1869) (and (eq? (quote let) (car V1869)) (and (pair? (cdr V1869)) (and (pair? (cdr (cdr V1869))) (and (eq? (quote shen.be) (car (cdr (cdr V1869)))) (and (pair? (cdr (cdr (cdr V1869)))) (and (pair? (cdr (cdr (cdr (cdr V1869))))) (and (eq? (quote in) (car (cdr (cdr (cdr (cdr V1869)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1869)))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr V1869)))))))))))))))) (cons (quote let) (cons (car (cdr V1869)) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr V1869))))) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr V1869))))))) (quote ())))))) ((and (pair? V1869) (and (eq? (quote shen.the) (car V1869)) (and (pair? (cdr V1869)) (and (eq? (quote shen.result) (car (cdr V1869))) (and (pair? (cdr (cdr V1869))) (and (eq? (quote shen.of) (car (cdr (cdr V1869)))) (and (pair? (cdr (cdr (cdr V1869)))) (and (eq? (quote shen.dereferencing) (car (cdr (cdr (cdr V1869))))) (and (pair? (cdr (cdr (cdr (cdr V1869))))) (null? (cdr (cdr (cdr (cdr (cdr V1869))))))))))))))) (cons (quote shen.lazyderef) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr V1869)))))) (cons (quote ProcessN) (quote ()))))) ((and (pair? V1869) (and (eq? (quote if) (car V1869)) (and (pair? (cdr V1869)) (and (pair? (cdr (cdr V1869))) (and (eq? (quote shen.then) (car (cdr (cdr V1869)))) (and (pair? (cdr (cdr (cdr V1869)))) (and (pair? (cdr (cdr (cdr (cdr V1869))))) (and (eq? (quote shen.else) (car (cdr (cdr (cdr (cdr V1869)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1869)))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr V1869)))))))))))))))) (cons (quote if) (cons (kl:shen.aum_to_shen (car (cdr V1869))) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr V1869))))) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr V1869))))))) (quote ())))))) ((and (pair? V1869) (and (pair? (cdr V1869)) (and (eq? (quote is) (car (cdr V1869))) (and (pair? (cdr (cdr V1869))) (and (eq? (quote shen.a) (car (cdr (cdr V1869)))) (and (pair? (cdr (cdr (cdr V1869)))) (and (eq? (quote shen.variable) (car (cdr (cdr (cdr V1869))))) (null? (cdr (cdr (cdr (cdr V1869)))))))))))) (cons (quote shen.pvar?) (cons (car V1869) (quote ())))) ((and (pair? V1869) (and (pair? (cdr V1869)) (and (eq? (quote is) (car (cdr V1869))) (and (pair? (cdr (cdr V1869))) (and (eq? (quote shen.a) (car (cdr (cdr V1869)))) (and (pair? (cdr (cdr (cdr V1869)))) (and (eq? (quote shen.non-empty) (car (cdr (cdr (cdr V1869))))) (and (pair? (cdr (cdr (cdr (cdr V1869))))) (and (eq? (quote list) (car (cdr (cdr (cdr (cdr V1869)))))) (null? (cdr (cdr (cdr (cdr (cdr V1869))))))))))))))) (cons (quote cons?) (cons (car V1869) (quote ())))) ((and (pair? V1869) (and (eq? (quote shen.rename) (car V1869)) (and (pair? (cdr V1869)) (and (eq? (quote shen.the) (car (cdr V1869))) (and (pair? (cdr (cdr V1869))) (and (eq? (quote shen.variables) (car (cdr (cdr V1869)))) (and (pair? (cdr (cdr (cdr V1869)))) (and (eq? (quote in) (car (cdr (cdr (cdr V1869))))) (and (pair? (cdr (cdr (cdr (cdr V1869))))) (and (null? (car (cdr (cdr (cdr (cdr V1869)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1869)))))) (and (eq? (quote and) (car (cdr (cdr (cdr (cdr (cdr V1869))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr V1869))))))) (and (eq? (quote shen.then) (car (cdr (cdr (cdr (cdr (cdr (cdr V1869)))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1869)))))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1869)))))))))))))))))))))))) (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1869)))))))))) ((and (pair? V1869) (and (eq? (quote shen.rename) (car V1869)) (and (pair? (cdr V1869)) (and (eq? (quote shen.the) (car (cdr V1869))) (and (pair? (cdr (cdr V1869))) (and (eq? (quote shen.variables) (car (cdr (cdr V1869)))) (and (pair? (cdr (cdr (cdr V1869)))) (and (eq? (quote in) (car (cdr (cdr (cdr V1869))))) (and (pair? (cdr (cdr (cdr (cdr V1869))))) (and (pair? (car (cdr (cdr (cdr (cdr V1869)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1869)))))) (and (eq? (quote and) (car (cdr (cdr (cdr (cdr (cdr V1869))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr V1869))))))) (and (eq? (quote shen.then) (car (cdr (cdr (cdr (cdr (cdr (cdr V1869)))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1869)))))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1869)))))))))))))))))))))))) (cons (quote let) (cons (car (car (cdr (cdr (cdr (cdr V1869)))))) (cons (cons (quote shen.newpv) (cons (quote ProcessN) (quote ()))) (cons (kl:shen.aum_to_shen (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons (cdr (car (cdr (cdr (cdr (cdr V1869)))))) (cdr (cdr (cdr (cdr (cdr V1869))))))))))) (quote ())))))) ((and (pair? V1869) (and (eq? (quote bind) (car V1869)) (and (pair? (cdr V1869)) (and (pair? (cdr (cdr V1869))) (and (eq? (quote shen.to) (car (cdr (cdr V1869)))) (and (pair? (cdr (cdr (cdr V1869)))) (and (pair? (cdr (cdr (cdr (cdr V1869))))) (and (eq? (quote in) (car (cdr (cdr (cdr (cdr V1869)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1869)))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr V1869)))))))))))))))) (cons (quote do) (cons (cons (quote shen.bindv) (cons (car (cdr V1869)) (cons (kl:shen.chwild (car (cdr (cdr (cdr V1869))))) (cons (quote ProcessN) (quote ()))))) (cons (cons (quote let) (cons (quote Result) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr V1869))))))) (cons (cons (quote do) (cons (cons (quote shen.unbindv) (cons (car (cdr V1869)) (cons (quote ProcessN) (quote ())))) (cons (quote Result) (quote ())))) (quote ()))))) (quote ()))))) ((and (pair? V1869) (and (pair? (cdr V1869)) (and (eq? (quote is) (car (cdr V1869))) (and (pair? (cdr (cdr V1869))) (and (eq? (quote identical) (car (cdr (cdr V1869)))) (and (pair? (cdr (cdr (cdr V1869)))) (and (eq? (quote shen.to) (car (cdr (cdr (cdr V1869))))) (and (pair? (cdr (cdr (cdr (cdr V1869))))) (null? (cdr (cdr (cdr (cdr (cdr V1869)))))))))))))) (cons (quote =) (cons (car (cdr (cdr (cdr (cdr V1869))))) (cons (car V1869) (quote ()))))) ((eq? (quote shen.failed!) V1869) #f) ((and (pair? V1869) (and (eq? (quote shen.the) (car V1869)) (and (pair? (cdr V1869)) (and (eq? (quote head) (car (cdr V1869))) (and (pair? (cdr (cdr V1869))) (and (eq? (quote shen.of) (car (cdr (cdr V1869)))) (and (pair? (cdr (cdr (cdr V1869)))) (null? (cdr (cdr (cdr (cdr V1869)))))))))))) (cons (quote hd) (cdr (cdr (cdr V1869))))) ((and (pair? V1869) (and (eq? (quote shen.the) (car V1869)) (and (pair? (cdr V1869)) (and (eq? (quote tail) (car (cdr V1869))) (and (pair? (cdr (cdr V1869))) (and (eq? (quote shen.of) (car (cdr (cdr V1869)))) (and (pair? (cdr (cdr (cdr V1869)))) (null? (cdr (cdr (cdr (cdr V1869)))))))))))) (cons (quote tl) (cdr (cdr (cdr V1869))))) ((and (pair? V1869) (and (eq? (quote shen.pop) (car V1869)) (and (pair? (cdr V1869)) (and (eq? (quote shen.the) (car (cdr V1869))) (and (pair? (cdr (cdr V1869))) (and (eq? (quote shen.stack) (car (cdr (cdr V1869)))) (null? (cdr (cdr (cdr V1869)))))))))) (cons (quote do) (cons (cons (quote shen.incinfs) (quote ())) (cons (cons (quote thaw) (cons (quote Continuation) (quote ()))) (quote ()))))) ((and (pair? V1869) (and (eq? (quote call) (car V1869)) (and (pair? (cdr V1869)) (and (eq? (quote shen.the) (car (cdr V1869))) (and (pair? (cdr (cdr V1869))) (and (eq? (quote shen.continuation) (car (cdr (cdr V1869)))) (and (pair? (cdr (cdr (cdr V1869)))) (null? (cdr (cdr (cdr (cdr V1869)))))))))))) (cons (quote do) (cons (cons (quote shen.incinfs) (quote ())) (cons (kl:shen.call_the_continuation (kl:shen.chwild (car (cdr (cdr (cdr V1869))))) (quote ProcessN) (quote Continuation)) (quote ()))))) (#t V1869))) (quote shen.aum_to_shen))
(begin (register-function-arity (quote shen.chwild) 1) (define (kl:shen.chwild V1871) (cond ((eq? V1871 (quote _)) (cons (quote shen.newpv) (cons (quote ProcessN) (quote ())))) ((pair? V1871) (kl:map (lambda (Z) (kl:shen.chwild Z)) V1871)) (#t V1871))) (quote shen.chwild))
(begin (register-function-arity (quote shen.newpv) 1) (define (kl:shen.newpv V1873) (let ((Count+1 (+ (vector-ref (kl:value (quote shen.*varcounter*)) V1873) 1))) (let ((IncVar (let ((_tmp (kl:value (quote shen.*varcounter*)))) (vector-set! _tmp V1873 Count+1) _tmp))) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V1873))) (let ((ResizeVectorIfNeeded (if (kl:= Count+1 (kl:limit Vector)) (kl:shen.resizeprocessvector V1873 Count+1) (quote shen.skip)))) (kl:shen.mk-pvar Count+1)))))) (quote shen.newpv))
(begin (register-function-arity (quote shen.resizeprocessvector) 2) (define (kl:shen.resizeprocessvector V1876 V1877) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V1876))) (let ((BigVector (kl:shen.resize-vector Vector (+ V1877 V1877) (quote shen.-null-)))) (let ((_tmp (kl:value (quote shen.*prologvectors*)))) (vector-set! _tmp V1876 BigVector) _tmp)))) (quote shen.resizeprocessvector))
(begin (register-function-arity (quote shen.resize-vector) 3) (define (kl:shen.resize-vector V1881 V1882 V1883) (let ((BigVector (let ((_tmp (make-vector (+ 1 V1882) (quote (quote shen.fail!))))) (vector-set! _tmp 0 V1882) _tmp))) (kl:shen.copy-vector V1881 BigVector (kl:limit V1881) V1882 V1883))) (quote shen.resize-vector))
(begin (register-function-arity (quote shen.copy-vector) 5) (define (kl:shen.copy-vector V1889 V1890 V1891 V1892 V1893) (kl:shen.copy-vector-stage-2 (+ 1 V1891) (+ V1892 1) V1893 (kl:shen.copy-vector-stage-1 1 V1889 V1890 (+ 1 V1891)))) (quote shen.copy-vector))
(begin (register-function-arity (quote shen.copy-vector-stage-1) 4) (define (kl:shen.copy-vector-stage-1 V1901 V1902 V1903 V1904) (cond ((kl:= V1904 V1901) V1903) (#t (kl:shen.copy-vector-stage-1 (+ 1 V1901) V1902 (let ((_tmp V1903)) (vector-set! _tmp V1901 (vector-ref V1902 V1901)) _tmp) V1904)))) (quote shen.copy-vector-stage-1))
(begin (register-function-arity (quote shen.copy-vector-stage-2) 4) (define (kl:shen.copy-vector-stage-2 V1912 V1913 V1914 V1915) (cond ((kl:= V1913 V1912) V1915) (#t (kl:shen.copy-vector-stage-2 (+ V1912 1) V1913 V1914 (let ((_tmp V1915)) (vector-set! _tmp V1912 V1914) _tmp))))) (quote shen.copy-vector-stage-2))
(begin (register-function-arity (quote shen.mk-pvar) 1) (define (kl:shen.mk-pvar V1917) (let ((_tmp (let ((_tmp (make-vector 2 (quote (quote shen.fail!))))) (vector-set! _tmp 0 (quote shen.pvar)) _tmp))) (vector-set! _tmp 1 V1917) _tmp)) (quote shen.mk-pvar))
(begin (register-function-arity (quote shen.pvar?) 1) (define (kl:shen.pvar? V1919) (and (vector? V1919) (eq? (guard (lambda (E) (quote shen.not-pvar)) (vector-ref V1919 0)) (quote shen.pvar)))) (quote shen.pvar?))
(begin (register-function-arity (quote shen.bindv) 3) (define (kl:shen.bindv V1923 V1924 V1925) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V1925))) (let ((_tmp Vector)) (vector-set! _tmp (vector-ref V1923 1) V1924) _tmp))) (quote shen.bindv))
(begin (register-function-arity (quote shen.unbindv) 2) (define (kl:shen.unbindv V1928 V1929) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V1929))) (let ((_tmp Vector)) (vector-set! _tmp (vector-ref V1928 1) (quote shen.-null-)) _tmp))) (quote shen.unbindv))
(begin (register-function-arity (quote shen.incinfs) 0) (define (kl:shen.incinfs) (kl:set (quote shen.*infs*) (+ 1 (kl:value (quote shen.*infs*))))) (quote shen.incinfs))
(begin (register-function-arity (quote shen.call_the_continuation) 3) (define (kl:shen.call_the_continuation V1933 V1934 V1935) (cond ((and (pair? V1933) (and (pair? (car V1933)) (null? (cdr V1933)))) (cons (car (car V1933)) (kl:append (cdr (car V1933)) (cons V1934 (cons V1935 (quote ())))))) ((and (pair? V1933) (pair? (car V1933))) (let ((NewContinuation (kl:shen.newcontinuation (cdr V1933) V1934 V1935))) (cons (car (car V1933)) (kl:append (cdr (car V1933)) (cons V1934 (cons NewContinuation (quote ()))))))) (#t (kl:shen.f_error (quote shen.call_the_continuation))))) (quote shen.call_the_continuation))
(begin (register-function-arity (quote shen.newcontinuation) 3) (define (kl:shen.newcontinuation V1939 V1940 V1941) (cond ((null? V1939) V1941) ((and (pair? V1939) (pair? (car V1939))) (cons (quote freeze) (cons (cons (car (car V1939)) (kl:append (cdr (car V1939)) (cons V1940 (cons (kl:shen.newcontinuation (cdr V1939) V1940 V1941) (quote ()))))) (quote ())))) (#t (kl:shen.f_error (quote shen.newcontinuation))))) (quote shen.newcontinuation))
(begin (register-function-arity (quote return) 3) (define (kl:return V1949 V1950 V1951) (kl:shen.deref V1949 V1950)) (quote return))
(begin (register-function-arity (quote shen.measure&return) 3) (define (kl:shen.measure&return V1959 V1960 V1961) (begin (kl:shen.prhush (kl:shen.app (kl:value (quote shen.*infs*)) " inferences\n" (quote shen.a)) (kl:stoutput)) (kl:shen.deref V1959 V1960))) (quote shen.measure&return))
(begin (register-function-arity (quote unify) 4) (define (kl:unify V1966 V1967 V1968 V1969) (kl:shen.lzy= (kl:shen.lazyderef V1966 V1968) (kl:shen.lazyderef V1967 V1968) V1968 V1969)) (quote unify))
(begin (register-function-arity (quote shen.lzy=) 4) (define (kl:shen.lzy= V1991 V1992 V1993 V1994) (cond ((kl:= V1992 V1991) (kl:thaw V1994)) ((kl:shen.pvar? V1991) (kl:bind V1991 V1992 V1993 V1994)) ((kl:shen.pvar? V1992) (kl:bind V1992 V1991 V1993 V1994)) ((and (pair? V1991) (pair? V1992)) (kl:shen.lzy= (kl:shen.lazyderef (car V1991) V1993) (kl:shen.lazyderef (car V1992) V1993) V1993 (lambda () (kl:shen.lzy= (kl:shen.lazyderef (cdr V1991) V1993) (kl:shen.lazyderef (cdr V1992) V1993) V1993 V1994)))) (#t #f))) (quote shen.lzy=))
(begin (register-function-arity (quote shen.deref) 2) (define (kl:shen.deref V1997 V1998) (cond ((pair? V1997) (cons (kl:shen.deref (car V1997) V1998) (kl:shen.deref (cdr V1997) V1998))) (#t (if (kl:shen.pvar? V1997) (let ((Value (kl:shen.valvector V1997 V1998))) (if (eq? Value (quote shen.-null-)) V1997 (kl:shen.deref Value V1998))) V1997)))) (quote shen.deref))
(begin (register-function-arity (quote shen.lazyderef) 2) (define (kl:shen.lazyderef V2001 V2002) (if (kl:shen.pvar? V2001) (let ((Value (kl:shen.valvector V2001 V2002))) (if (eq? Value (quote shen.-null-)) V2001 (kl:shen.lazyderef Value V2002))) V2001)) (quote shen.lazyderef))
(begin (register-function-arity (quote shen.valvector) 2) (define (kl:shen.valvector V2005 V2006) (vector-ref (vector-ref (kl:value (quote shen.*prologvectors*)) V2006) (vector-ref V2005 1))) (quote shen.valvector))
(begin (register-function-arity (quote unify!) 4) (define (kl:unify! V2011 V2012 V2013 V2014) (kl:shen.lzy=! (kl:shen.lazyderef V2011 V2013) (kl:shen.lazyderef V2012 V2013) V2013 V2014)) (quote unify!))
(begin (register-function-arity (quote shen.lzy=!) 4) (define (kl:shen.lzy=! V2036 V2037 V2038 V2039) (cond ((kl:= V2037 V2036) (kl:thaw V2039)) ((and (kl:shen.pvar? V2036) (kl:not (kl:shen.occurs? V2036 (kl:shen.deref V2037 V2038)))) (kl:bind V2036 V2037 V2038 V2039)) ((and (kl:shen.pvar? V2037) (kl:not (kl:shen.occurs? V2037 (kl:shen.deref V2036 V2038)))) (kl:bind V2037 V2036 V2038 V2039)) ((and (pair? V2036) (pair? V2037)) (kl:shen.lzy=! (kl:shen.lazyderef (car V2036) V2038) (kl:shen.lazyderef (car V2037) V2038) V2038 (lambda () (kl:shen.lzy=! (kl:shen.lazyderef (cdr V2036) V2038) (kl:shen.lazyderef (cdr V2037) V2038) V2038 V2039)))) (#t #f))) (quote shen.lzy=!))
(begin (register-function-arity (quote shen.occurs?) 2) (define (kl:shen.occurs? V2051 V2052) (cond ((kl:= V2052 V2051) #t) ((pair? V2052) (or (assert-boolean (kl:shen.occurs? V2051 (car V2052))) (assert-boolean (kl:shen.occurs? V2051 (cdr V2052))))) (#t #f))) (quote shen.occurs?))
(begin (register-function-arity (quote identical) 4) (define (kl:identical V2057 V2058 V2059 V2060) (kl:shen.lzy== (kl:shen.lazyderef V2057 V2059) (kl:shen.lazyderef V2058 V2059) V2059 V2060)) (quote identical))
(begin (register-function-arity (quote shen.lzy==) 4) (define (kl:shen.lzy== V2082 V2083 V2084 V2085) (cond ((kl:= V2083 V2082) (kl:thaw V2085)) ((and (pair? V2082) (pair? V2083)) (kl:shen.lzy== (kl:shen.lazyderef (car V2082) V2084) (kl:shen.lazyderef (car V2083) V2084) V2084 (lambda () (kl:shen.lzy== (cdr V2082) (cdr V2083) V2084 V2085)))) (#t #f))) (quote shen.lzy==))
(begin (register-function-arity (quote shen.pvar) 1) (define (kl:shen.pvar V2087) (string-append "Var" (kl:shen.app (vector-ref V2087 1) "" (quote shen.a)))) (quote shen.pvar))
(begin (register-function-arity (quote bind) 4) (define (kl:bind V2092 V2093 V2094 V2095) (begin (kl:shen.bindv V2092 V2093 V2094) (let ((Result (kl:thaw V2095))) (begin (kl:shen.unbindv V2092 V2094) Result)))) (quote bind))
(begin (register-function-arity (quote fwhen) 3) (define (kl:fwhen V2113 V2114 V2115) (cond ((kl:= #t V2113) (kl:thaw V2115)) ((kl:= #f V2113) #f) (#t (simple-error (string-append "fwhen expects a boolean: not " (kl:shen.app V2113 "%" (quote shen.s))))))) (quote fwhen))
(begin (register-function-arity (quote call) 3) (define (kl:call V2131 V2132 V2133) (cond ((pair? V2131) (kl:shen.call-help (kl:function (kl:shen.lazyderef (car V2131) V2132)) (cdr V2131) V2132 V2133)) (#t #f))) (quote call))
(begin (register-function-arity (quote shen.call-help) 4) (define (kl:shen.call-help V2138 V2139 V2140 V2141) (cond ((null? V2139) ((V2138 V2140) V2141)) ((pair? V2139) (kl:shen.call-help (V2138 (car V2139)) (cdr V2139) V2140 V2141)) (#t (kl:shen.f_error (quote shen.call-help))))) (quote shen.call-help))
(begin (register-function-arity (quote shen.intprolog) 1) (define (kl:shen.intprolog V2143) (cond ((and (pair? V2143) (pair? (car V2143))) (let ((ProcessN (kl:shen.start-new-prolog-process))) (kl:shen.intprolog-help (car (car V2143)) (kl:shen.insert-prolog-variables (cons (cdr (car V2143)) (cons (cdr V2143) (quote ()))) ProcessN) ProcessN))) (#t (kl:shen.f_error (quote shen.intprolog))))) (quote shen.intprolog))
(begin (register-function-arity (quote shen.intprolog-help) 3) (define (kl:shen.intprolog-help V2147 V2148 V2149) (cond ((and (pair? V2148) (and (pair? (cdr V2148)) (null? (cdr (cdr V2148))))) (kl:shen.intprolog-help-help V2147 (car V2148) (car (cdr V2148)) V2149)) (#t (kl:shen.f_error (quote shen.intprolog-help))))) (quote shen.intprolog-help))
(begin (register-function-arity (quote shen.intprolog-help-help) 4) (define (kl:shen.intprolog-help-help V2154 V2155 V2156 V2157) (cond ((null? V2155) ((V2154 V2157) (lambda () (kl:shen.call-rest V2156 V2157)))) ((pair? V2155) (kl:shen.intprolog-help-help (V2154 (car V2155)) (cdr V2155) V2156 V2157)) (#t (kl:shen.f_error (quote shen.intprolog-help-help))))) (quote shen.intprolog-help-help))
(begin (register-function-arity (quote shen.call-rest) 2) (define (kl:shen.call-rest V2162 V2163) (cond ((null? V2162) #t) ((and (pair? V2162) (and (pair? (car V2162)) (pair? (cdr (car V2162))))) (kl:shen.call-rest (cons (cons ((car (car V2162)) (car (cdr (car V2162)))) (cdr (cdr (car V2162)))) (cdr V2162)) V2163)) ((and (pair? V2162) (and (pair? (car V2162)) (null? (cdr (car V2162))))) (((car (car V2162)) V2163) (lambda () (kl:shen.call-rest (cdr V2162) V2163)))) (#t (kl:shen.f_error (quote shen.call-rest))))) (quote shen.call-rest))
(begin (register-function-arity (quote shen.start-new-prolog-process) 0) (define (kl:shen.start-new-prolog-process) (let ((IncrementProcessCounter (kl:set (quote shen.*process-counter*) (+ 1 (kl:value (quote shen.*process-counter*)))))) (kl:shen.initialise-prolog IncrementProcessCounter))) (quote shen.start-new-prolog-process))
(begin (register-function-arity (quote shen.insert-prolog-variables) 2) (define (kl:shen.insert-prolog-variables V2166 V2167) (kl:shen.insert-prolog-variables-help V2166 (kl:shen.flatten V2166) V2167)) (quote shen.insert-prolog-variables))
(begin (register-function-arity (quote shen.insert-prolog-variables-help) 3) (define (kl:shen.insert-prolog-variables-help V2175 V2176 V2177) (cond ((null? V2176) V2175) ((and (pair? V2176) (kl:variable? (car V2176))) (let ((V (kl:shen.newpv V2177))) (let ((XV/Y (kl:subst V (car V2176) V2175))) (let ((Z-Y (kl:remove (car V2176) (cdr V2176)))) (kl:shen.insert-prolog-variables-help XV/Y Z-Y V2177))))) ((pair? V2176) (kl:shen.insert-prolog-variables-help V2175 (cdr V2176) V2177)) (#t (kl:shen.f_error (quote shen.insert-prolog-variables-help))))) (quote shen.insert-prolog-variables-help))
(begin (register-function-arity (quote shen.initialise-prolog) 1) (define (kl:shen.initialise-prolog V2179) (let ((Vector (let ((_tmp (kl:value (quote shen.*prologvectors*)))) (vector-set! _tmp V2179 (kl:shen.fillvector (kl:vector 10) 1 10 (quote shen.-null-))) _tmp))) (let ((Counter (let ((_tmp (kl:value (quote shen.*varcounter*)))) (vector-set! _tmp V2179 1) _tmp))) V2179))) (quote shen.initialise-prolog))
