"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.<defprolog>) 1) (define (kl:shen.<defprolog> V1625) (let ((Parse_shen.<predicate*> (kl:shen.<predicate*> V1625))) (if (kl:not (kl:= (kl:fail) Parse_shen.<predicate*>)) (let ((Parse_shen.<clauses*> (kl:shen.<clauses*> Parse_shen.<predicate*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<clauses*>)) (kl:shen.pair (car Parse_shen.<clauses*>) (car (kl:shen.prolog->shen (kl:map (lambda (Parse_X) (kl:shen.insert-predicate (kl:shen.hdtl Parse_shen.<predicate*>) Parse_X)) (kl:shen.hdtl Parse_shen.<clauses*>))))) (kl:fail))) (kl:fail)))) (quote shen.<defprolog>))
(begin (register-function-arity (quote shen.prolog-error) 2) (define (kl:shen.prolog-error V1634 V1635) (cond ((and (pair? V1635) (and (pair? (cdr V1635)) (null? (cdr (cdr V1635))))) (simple-error (string-append "prolog syntax error in " (kl:shen.app V1634 (string-append " here:\n\n " (kl:shen.app (kl:shen.next-50 50 (car V1635)) "\n" (quote shen.a))) (quote shen.a))))) (#t (simple-error (string-append "prolog syntax error in " (kl:shen.app V1634 "\n" (quote shen.a))))))) (quote shen.prolog-error))
(begin (register-function-arity (quote shen.next-50) 2) (define (kl:shen.next-50 V1642 V1643) (cond ((null? V1643) "") ((kl:= 0 V1642) "") ((pair? V1643) (string-append (kl:shen.decons-string (car V1643)) (kl:shen.next-50 (- V1642 1) (cdr V1643)))) (#t (kl:shen.f_error (quote shen.next-50))))) (quote shen.next-50))
(begin (register-function-arity (quote shen.decons-string) 1) (define (kl:shen.decons-string V1645) (cond ((and (pair? V1645) (and (eq? (quote cons) (car V1645)) (and (pair? (cdr V1645)) (and (pair? (cdr (cdr V1645))) (null? (cdr (cdr (cdr V1645)))))))) (kl:shen.app (kl:shen.eval-cons V1645) " " (quote shen.s))) (#t (kl:shen.app V1645 " " (quote shen.r))))) (quote shen.decons-string))
(begin (register-function-arity (quote shen.insert-predicate) 2) (define (kl:shen.insert-predicate V1648 V1649) (cond ((and (pair? V1649) (and (pair? (cdr V1649)) (null? (cdr (cdr V1649))))) (cons (cons V1648 (car V1649)) (cons (quote :-) (cdr V1649)))) (#t (kl:shen.f_error (quote shen.insert-predicate))))) (quote shen.insert-predicate))
(begin (register-function-arity (quote shen.<predicate*>) 1) (define (kl:shen.<predicate*> V1651) (if (pair? (car V1651)) (let ((Parse_X (car (car V1651)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1651)) (kl:shen.hdtl V1651))) Parse_X)) (kl:fail))) (quote shen.<predicate*>))
(begin (register-function-arity (quote shen.<clauses*>) 1) (define (kl:shen.<clauses*> V1653) (let ((YaccParse (let ((Parse_shen.<clause*> (kl:shen.<clause*> V1653))) (if (kl:not (kl:= (kl:fail) Parse_shen.<clause*>)) (let ((Parse_shen.<clauses*> (kl:shen.<clauses*> Parse_shen.<clause*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<clauses*>)) (kl:shen.pair (car Parse_shen.<clauses*>) (cons (kl:shen.hdtl Parse_shen.<clause*>) (kl:shen.hdtl Parse_shen.<clauses*>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1653))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<clauses*>))
(begin (register-function-arity (quote shen.<clause*>) 1) (define (kl:shen.<clause*> V1655) (let ((Parse_shen.<head*> (kl:shen.<head*> V1655))) (if (kl:not (kl:= (kl:fail) Parse_shen.<head*>)) (if (and (pair? (car Parse_shen.<head*>)) (eq? (quote <--) (car (car Parse_shen.<head*>)))) (let ((Parse_shen.<body*> (kl:shen.<body*> (kl:shen.pair (cdr (car Parse_shen.<head*>)) (kl:shen.hdtl Parse_shen.<head*>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<body*>)) (let ((Parse_shen.<end*> (kl:shen.<end*> Parse_shen.<body*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<end*>)) (kl:shen.pair (car Parse_shen.<end*>) (cons (kl:shen.hdtl Parse_shen.<head*>) (cons (kl:shen.hdtl Parse_shen.<body*>) (quote ())))) (kl:fail))) (kl:fail))) (kl:fail)) (kl:fail)))) (quote shen.<clause*>))
(begin (register-function-arity (quote shen.<head*>) 1) (define (kl:shen.<head*> V1657) (let ((YaccParse (let ((Parse_shen.<term*> (kl:shen.<term*> V1657))) (if (kl:not (kl:= (kl:fail) Parse_shen.<term*>)) (let ((Parse_shen.<head*> (kl:shen.<head*> Parse_shen.<term*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<head*>)) (kl:shen.pair (car Parse_shen.<head*>) (cons (kl:shen.hdtl Parse_shen.<term*>) (kl:shen.hdtl Parse_shen.<head*>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1657))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<head*>))
(begin (register-function-arity (quote shen.<term*>) 1) (define (kl:shen.<term*> V1659) (if (pair? (car V1659)) (let ((Parse_X (car (car V1659)))) (if (and (kl:not (eq? (quote <--) Parse_X)) (assert-boolean (kl:shen.legitimate-term? Parse_X))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1659)) (kl:shen.hdtl V1659))) (kl:shen.eval-cons Parse_X)) (kl:fail))) (kl:fail))) (quote shen.<term*>))
(begin (register-function-arity (quote shen.legitimate-term?) 1) (define (kl:shen.legitimate-term? V1665) (cond ((and (pair? V1665) (and (eq? (quote cons) (car V1665)) (and (pair? (cdr V1665)) (and (pair? (cdr (cdr V1665))) (null? (cdr (cdr (cdr V1665)))))))) (and (assert-boolean (kl:shen.legitimate-term? (car (cdr V1665)))) (assert-boolean (kl:shen.legitimate-term? (car (cdr (cdr V1665))))))) ((and (pair? V1665) (and (eq? (quote mode) (car V1665)) (and (pair? (cdr V1665)) (and (pair? (cdr (cdr V1665))) (and (eq? (quote +) (car (cdr (cdr V1665)))) (null? (cdr (cdr (cdr V1665))))))))) (kl:shen.legitimate-term? (car (cdr V1665)))) ((and (pair? V1665) (and (eq? (quote mode) (car V1665)) (and (pair? (cdr V1665)) (and (pair? (cdr (cdr V1665))) (and (eq? (quote -) (car (cdr (cdr V1665)))) (null? (cdr (cdr (cdr V1665))))))))) (kl:shen.legitimate-term? (car (cdr V1665)))) ((pair? V1665) #f) (#t #t))) (quote shen.legitimate-term?))
(begin (register-function-arity (quote shen.eval-cons) 1) (define (kl:shen.eval-cons V1667) (cond ((and (pair? V1667) (and (eq? (quote cons) (car V1667)) (and (pair? (cdr V1667)) (and (pair? (cdr (cdr V1667))) (null? (cdr (cdr (cdr V1667)))))))) (cons (kl:shen.eval-cons (car (cdr V1667))) (kl:shen.eval-cons (car (cdr (cdr V1667)))))) ((and (pair? V1667) (and (eq? (quote mode) (car V1667)) (and (pair? (cdr V1667)) (and (pair? (cdr (cdr V1667))) (null? (cdr (cdr (cdr V1667)))))))) (cons (quote mode) (cons (kl:shen.eval-cons (car (cdr V1667))) (cdr (cdr V1667))))) (#t V1667))) (quote shen.eval-cons))
(begin (register-function-arity (quote shen.<body*>) 1) (define (kl:shen.<body*> V1669) (let ((YaccParse (let ((Parse_shen.<literal*> (kl:shen.<literal*> V1669))) (if (kl:not (kl:= (kl:fail) Parse_shen.<literal*>)) (let ((Parse_shen.<body*> (kl:shen.<body*> Parse_shen.<literal*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<body*>)) (kl:shen.pair (car Parse_shen.<body*>) (cons (kl:shen.hdtl Parse_shen.<literal*>) (kl:shen.hdtl Parse_shen.<body*>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1669))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<body*>))
(begin (register-function-arity (quote shen.<literal*>) 1) (define (kl:shen.<literal*> V1671) (let ((YaccParse (if (and (pair? (car V1671)) (eq? (quote !) (car (car V1671)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1671)) (kl:shen.hdtl V1671))) (cons (quote cut) (cons (kl:intern "Throwcontrol") (quote ())))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (if (pair? (car V1671)) (let ((Parse_X (car (car V1671)))) (if (pair? Parse_X) (kl:shen.pair (car (kl:shen.pair (cdr (car V1671)) (kl:shen.hdtl V1671))) Parse_X) (kl:fail))) (kl:fail)) YaccParse))) (quote shen.<literal*>))
(begin (register-function-arity (quote shen.<end*>) 1) (define (kl:shen.<end*> V1673) (if (pair? (car V1673)) (let ((Parse_X (car (car V1673)))) (if (eq? Parse_X (quote _waspvm_sc_)) (kl:shen.pair (car (kl:shen.pair (cdr (car V1673)) (kl:shen.hdtl V1673))) Parse_X) (kl:fail))) (kl:fail))) (quote shen.<end*>))
(begin (register-function-arity (quote cut) 3) (define (kl:cut V1677 V1678 V1679) (let ((Result (kl:thaw V1679))) (if (kl:= Result #f) V1677 Result))) (quote cut))
(begin (register-function-arity (quote shen.insert_modes) 1) (define (kl:shen.insert_modes V1681) (cond ((and (pair? V1681) (and (eq? (quote mode) (car V1681)) (and (pair? (cdr V1681)) (and (pair? (cdr (cdr V1681))) (null? (cdr (cdr (cdr V1681)))))))) V1681) ((null? V1681) (quote ())) ((pair? V1681) (cons (cons (quote mode) (cons (car V1681) (cons (quote +) (quote ())))) (cons (quote mode) (cons (kl:shen.insert_modes (cdr V1681)) (cons (quote -) (quote ())))))) (#t V1681))) (quote shen.insert_modes))
(begin (register-function-arity (quote shen.s-prolog) 1) (define (kl:shen.s-prolog V1683) (kl:map (lambda (X) (kl:eval X)) (kl:shen.prolog->shen V1683))) (quote shen.s-prolog))
(begin (register-function-arity (quote shen.prolog->shen) 1) (define (kl:shen.prolog->shen V1685) (kl:map (lambda (X) (kl:shen.compile_prolog_procedure X)) (kl:shen.group_clauses (kl:map (lambda (X) (kl:shen.s-prolog_clause X)) (kl:mapcan (lambda (X) (kl:shen.head_abstraction X)) V1685))))) (quote shen.prolog->shen))
(begin (register-function-arity (quote shen.s-prolog_clause) 1) (define (kl:shen.s-prolog_clause V1687) (cond ((and (pair? V1687) (and (pair? (cdr V1687)) (and (eq? (quote :-) (car (cdr V1687))) (and (pair? (cdr (cdr V1687))) (null? (cdr (cdr (cdr V1687)))))))) (cons (car V1687) (cons (quote :-) (cons (kl:map (lambda (X) (kl:shen.s-prolog_literal X)) (car (cdr (cdr V1687)))) (quote ()))))) (#t (kl:shen.f_error (quote shen.s-prolog_clause))))) (quote shen.s-prolog_clause))
(begin (register-function-arity (quote shen.head_abstraction) 1) (define (kl:shen.head_abstraction V1689) (cond ((and (pair? V1689) (and (pair? (cdr V1689)) (and (eq? (quote :-) (car (cdr V1689))) (and (pair? (cdr (cdr V1689))) (and (null? (cdr (cdr (cdr V1689)))) (< (kl:shen.complexity_head (car V1689)) (kl:value (quote shen.*maxcomplexity*)))))))) (cons V1689 (quote ()))) ((and (pair? V1689) (and (pair? (car V1689)) (and (pair? (cdr V1689)) (and (eq? (quote :-) (car (cdr V1689))) (and (pair? (cdr (cdr V1689))) (null? (cdr (cdr (cdr V1689))))))))) (let ((Terms (kl:map (lambda (Y) (kl:gensym (quote V))) (cdr (car V1689))))) (let ((XTerms (kl:shen.rcons_form (kl:shen.remove_modes (cdr (car V1689)))))) (let ((Literal (cons (quote unify) (cons (kl:shen.cons_form Terms) (cons XTerms (quote ())))))) (let ((Clause (cons (cons (car (car V1689)) Terms) (cons (quote :-) (cons (cons Literal (car (cdr (cdr V1689)))) (quote ())))))) (cons Clause (quote ()))))))) (#t (kl:shen.f_error (quote shen.head_abstraction))))) (quote shen.head_abstraction))
(begin (register-function-arity (quote shen.complexity_head) 1) (define (kl:shen.complexity_head V1695) (cond ((pair? V1695) (kl:shen.product (kl:map (lambda (X) (kl:shen.complexity X)) (cdr V1695)))) (#t (kl:shen.f_error (quote shen.complexity_head))))) (quote shen.complexity_head))
(begin (register-function-arity (quote shen.complexity) 1) (define (kl:shen.complexity V1704) (cond ((and (pair? V1704) (and (eq? (quote mode) (car V1704)) (and (pair? (cdr V1704)) (and (pair? (car (cdr V1704))) (and (eq? (quote mode) (car (car (cdr V1704)))) (and (pair? (cdr (car (cdr V1704)))) (and (pair? (cdr (cdr (car (cdr V1704))))) (and (null? (cdr (cdr (cdr (car (cdr V1704)))))) (and (pair? (cdr (cdr V1704))) (null? (cdr (cdr (cdr V1704))))))))))))) (kl:shen.complexity (car (cdr V1704)))) ((and (pair? V1704) (and (eq? (quote mode) (car V1704)) (and (pair? (cdr V1704)) (and (pair? (car (cdr V1704))) (and (pair? (cdr (cdr V1704))) (and (eq? (quote +) (car (cdr (cdr V1704)))) (null? (cdr (cdr (cdr V1704)))))))))) (* 2 (* (kl:shen.complexity (cons (quote mode) (cons (car (car (cdr V1704))) (cdr (cdr V1704))))) (kl:shen.complexity (cons (quote mode) (cons (cdr (car (cdr V1704))) (cdr (cdr V1704)))))))) ((and (pair? V1704) (and (eq? (quote mode) (car V1704)) (and (pair? (cdr V1704)) (and (pair? (car (cdr V1704))) (and (pair? (cdr (cdr V1704))) (and (eq? (quote -) (car (cdr (cdr V1704)))) (null? (cdr (cdr (cdr V1704)))))))))) (* (kl:shen.complexity (cons (quote mode) (cons (car (car (cdr V1704))) (cdr (cdr V1704))))) (kl:shen.complexity (cons (quote mode) (cons (cdr (car (cdr V1704))) (cdr (cdr V1704))))))) ((and (pair? V1704) (and (eq? (quote mode) (car V1704)) (and (pair? (cdr V1704)) (and (pair? (cdr (cdr V1704))) (and (null? (cdr (cdr (cdr V1704)))) (kl:variable? (car (cdr V1704)))))))) 1) ((and (pair? V1704) (and (eq? (quote mode) (car V1704)) (and (pair? (cdr V1704)) (and (pair? (cdr (cdr V1704))) (and (eq? (quote +) (car (cdr (cdr V1704)))) (null? (cdr (cdr (cdr V1704))))))))) 2) ((and (pair? V1704) (and (eq? (quote mode) (car V1704)) (and (pair? (cdr V1704)) (and (pair? (cdr (cdr V1704))) (and (eq? (quote -) (car (cdr (cdr V1704)))) (null? (cdr (cdr (cdr V1704))))))))) 1) (#t (kl:shen.complexity (cons (quote mode) (cons V1704 (cons (quote +) (quote ())))))))) (quote shen.complexity))
(begin (register-function-arity (quote shen.product) 1) (define (kl:shen.product V1706) (cond ((null? V1706) 1) ((pair? V1706) (* (car V1706) (kl:shen.product (cdr V1706)))) (#t (kl:shen.f_error (quote shen.product))))) (quote shen.product))
(begin (register-function-arity (quote shen.s-prolog_literal) 1) (define (kl:shen.s-prolog_literal V1708) (cond ((and (pair? V1708) (and (eq? (quote is) (car V1708)) (and (pair? (cdr V1708)) (and (pair? (cdr (cdr V1708))) (null? (cdr (cdr (cdr V1708)))))))) (cons (quote bind) (cons (car (cdr V1708)) (cons (kl:shen.insert_deref (car (cdr (cdr V1708)))) (quote ()))))) ((and (pair? V1708) (and (eq? (quote when) (car V1708)) (and (pair? (cdr V1708)) (null? (cdr (cdr V1708)))))) (cons (quote fwhen) (cons (kl:shen.insert_deref (car (cdr V1708))) (quote ())))) ((and (pair? V1708) (and (eq? (quote bind) (car V1708)) (and (pair? (cdr V1708)) (and (pair? (cdr (cdr V1708))) (null? (cdr (cdr (cdr V1708)))))))) (cons (quote bind) (cons (car (cdr V1708)) (cons (kl:shen.insert_lazyderef (car (cdr (cdr V1708)))) (quote ()))))) ((and (pair? V1708) (and (eq? (quote fwhen) (car V1708)) (and (pair? (cdr V1708)) (null? (cdr (cdr V1708)))))) (cons (quote fwhen) (cons (kl:shen.insert_lazyderef (car (cdr V1708))) (quote ())))) ((pair? V1708) V1708) (#t (kl:shen.f_error (quote shen.s-prolog_literal))))) (quote shen.s-prolog_literal))
(begin (register-function-arity (quote shen.insert_deref) 1) (define (kl:shen.insert_deref V1710) (cond ((kl:variable? V1710) (cons (quote shen.deref) (cons V1710 (cons (quote ProcessN) (quote ()))))) ((pair? V1710) (cons (kl:shen.insert_deref (car V1710)) (kl:shen.insert_deref (cdr V1710)))) (#t V1710))) (quote shen.insert_deref))
(begin (register-function-arity (quote shen.insert_lazyderef) 1) (define (kl:shen.insert_lazyderef V1712) (cond ((kl:variable? V1712) (cons (quote shen.lazyderef) (cons V1712 (cons (quote ProcessN) (quote ()))))) ((pair? V1712) (cons (kl:shen.insert_lazyderef (car V1712)) (kl:shen.insert_lazyderef (cdr V1712)))) (#t V1712))) (quote shen.insert_lazyderef))
(begin (register-function-arity (quote shen.group_clauses) 1) (define (kl:shen.group_clauses V1714) (cond ((null? V1714) (quote ())) ((pair? V1714) (let ((Group (kl:shen.collect (lambda (X) (kl:shen.same_predicate? (car V1714) X)) V1714))) (let ((Rest (kl:difference V1714 Group))) (cons Group (kl:shen.group_clauses Rest))))) (#t (kl:shen.f_error (quote shen.group_clauses))))) (quote shen.group_clauses))
(begin (register-function-arity (quote shen.collect) 2) (define (kl:shen.collect V1719 V1720) (cond ((null? V1720) (quote ())) ((pair? V1720) (if (assert-boolean (V1719 (car V1720))) (cons (car V1720) (kl:shen.collect V1719 (cdr V1720))) (kl:shen.collect V1719 (cdr V1720)))) (#t (kl:shen.f_error (quote shen.collect))))) (quote shen.collect))
(begin (register-function-arity (quote shen.same_predicate?) 2) (define (kl:shen.same_predicate? V1739 V1740) (cond ((and (pair? V1739) (and (pair? (car V1739)) (and (pair? V1740) (pair? (car V1740))))) (kl:= (car (car V1739)) (car (car V1740)))) (#t (kl:shen.f_error (quote shen.same_predicate?))))) (quote shen.same_predicate?))
(begin (register-function-arity (quote shen.compile_prolog_procedure) 1) (define (kl:shen.compile_prolog_procedure V1742) (let ((F (kl:shen.procedure_name V1742))) (let ((Shen (kl:shen.clauses-to-shen F V1742))) Shen))) (quote shen.compile_prolog_procedure))
(begin (register-function-arity (quote shen.procedure_name) 1) (define (kl:shen.procedure_name V1756) (cond ((and (pair? V1756) (and (pair? (car V1756)) (pair? (car (car V1756))))) (car (car (car V1756)))) (#t (kl:shen.f_error (quote shen.procedure_name))))) (quote shen.procedure_name))
(begin (register-function-arity (quote shen.clauses-to-shen) 2) (define (kl:shen.clauses-to-shen V1759 V1760) (let ((Linear (kl:map (lambda (X) (kl:shen.linearise-clause X)) V1760))) (let ((Arity (kl:shen.prolog-aritycheck V1759 (kl:map (lambda (X) (kl:head X)) V1760)))) (let ((Parameters (kl:shen.parameters Arity))) (let ((AUM_instructions (kl:map (lambda (X) (kl:shen.aum X Parameters)) Linear))) (let ((Code (kl:shen.catch-cut (kl:shen.nest-disjunct (kl:map (lambda (X) (kl:shen.aum_to_shen X)) AUM_instructions))))) (let ((ShenDef (cons (quote define) (cons V1759 (kl:append Parameters (kl:append (cons (quote ProcessN) (cons (quote Continuation) (quote ()))) (cons (quote ->) (cons Code (quote ()))))))))) ShenDef))))))) (quote shen.clauses-to-shen))
(begin (register-function-arity (quote shen.catch-cut) 1) (define (kl:shen.catch-cut V1762) (cond ((kl:not (kl:shen.occurs? (quote cut) V1762)) V1762) (#t (cons (quote let) (cons (quote Throwcontrol) (cons (cons (quote shen.catchpoint) (quote ())) (cons (cons (quote shen.cutpoint) (cons (quote Throwcontrol) (cons V1762 (quote ())))) (quote ())))))))) (quote shen.catch-cut))
(begin (register-function-arity (quote shen.catchpoint) 0) (define (kl:shen.catchpoint) (kl:set (quote shen.*catch*) (+ 1 (kl:value (quote shen.*catch*))))) (quote shen.catchpoint))
(begin (register-function-arity (quote shen.cutpoint) 2) (define (kl:shen.cutpoint V1770 V1771) (cond ((kl:= V1771 V1770) #f) (#t V1771))) (quote shen.cutpoint))
(begin (register-function-arity (quote shen.nest-disjunct) 1) (define (kl:shen.nest-disjunct V1773) (cond ((and (pair? V1773) (null? (cdr V1773))) (car V1773)) ((pair? V1773) (kl:shen.lisp-or (car V1773) (kl:shen.nest-disjunct (cdr V1773)))) (#t (kl:shen.f_error (quote shen.nest-disjunct))))) (quote shen.nest-disjunct))
(begin (register-function-arity (quote shen.lisp-or) 2) (define (kl:shen.lisp-or V1776 V1777) (cons (quote let) (cons (quote Case) (cons V1776 (cons (cons (quote if) (cons (cons (quote =) (cons (quote Case) (cons #f (quote ())))) (cons V1777 (cons (quote Case) (quote ()))))) (quote ())))))) (quote shen.lisp-or))
(begin (register-function-arity (quote shen.prolog-aritycheck) 2) (define (kl:shen.prolog-aritycheck V1782 V1783) (cond ((and (pair? V1783) (null? (cdr V1783))) (- (kl:length (car V1783)) 1)) ((and (pair? V1783) (pair? (cdr V1783))) (if (kl:= (kl:length (car V1783)) (kl:length (car (cdr V1783)))) (kl:shen.prolog-aritycheck V1782 (cdr V1783)) (simple-error (string-append "arity error in prolog procedure " (kl:shen.app (cons V1782 (quote ())) "\n" (quote shen.a)))))) (#t (kl:shen.f_error (quote shen.prolog-aritycheck))))) (quote shen.prolog-aritycheck))
(begin (register-function-arity (quote shen.linearise-clause) 1) (define (kl:shen.linearise-clause V1785) (cond ((and (pair? V1785) (and (pair? (cdr V1785)) (and (eq? (quote :-) (car (cdr V1785))) (and (pair? (cdr (cdr V1785))) (null? (cdr (cdr (cdr V1785)))))))) (let ((Linear (kl:shen.linearise (cons (car V1785) (cdr (cdr V1785)))))) (kl:shen.clause_form Linear))) (#t (kl:shen.f_error (quote shen.linearise-clause))))) (quote shen.linearise-clause))
(begin (register-function-arity (quote shen.clause_form) 1) (define (kl:shen.clause_form V1787) (cond ((and (pair? V1787) (and (pair? (cdr V1787)) (null? (cdr (cdr V1787))))) (cons (kl:shen.explicit_modes (car V1787)) (cons (quote :-) (cons (kl:shen.cf_help (car (cdr V1787))) (quote ()))))) (#t (kl:shen.f_error (quote shen.clause_form))))) (quote shen.clause_form))
(begin (register-function-arity (quote shen.explicit_modes) 1) (define (kl:shen.explicit_modes V1789) (cond ((pair? V1789) (cons (car V1789) (kl:map (lambda (X) (kl:shen.em_help X)) (cdr V1789)))) (#t (kl:shen.f_error (quote shen.explicit_modes))))) (quote shen.explicit_modes))
(begin (register-function-arity (quote shen.em_help) 1) (define (kl:shen.em_help V1791) (cond ((and (pair? V1791) (and (eq? (quote mode) (car V1791)) (and (pair? (cdr V1791)) (and (pair? (cdr (cdr V1791))) (null? (cdr (cdr (cdr V1791)))))))) V1791) (#t (cons (quote mode) (cons V1791 (cons (quote +) (quote ()))))))) (quote shen.em_help))
(begin (register-function-arity (quote shen.cf_help) 1) (define (kl:shen.cf_help V1793) (cond ((and (pair? V1793) (and (eq? (quote where) (car V1793)) (and (pair? (cdr V1793)) (and (pair? (car (cdr V1793))) (and (eq? (quote =) (car (car (cdr V1793)))) (and (pair? (cdr (car (cdr V1793)))) (and (pair? (cdr (cdr (car (cdr V1793))))) (and (null? (cdr (cdr (cdr (car (cdr V1793)))))) (and (pair? (cdr (cdr V1793))) (null? (cdr (cdr (cdr V1793))))))))))))) (cons (cons (if (assert-boolean (kl:value (quote shen.*occurs*))) (quote unify!) (quote unify)) (cdr (car (cdr V1793)))) (kl:shen.cf_help (car (cdr (cdr V1793)))))) (#t V1793))) (quote shen.cf_help))
(begin (register-function-arity (quote occurs-check) 1) (define (kl:occurs-check V1799) (cond ((eq? (quote +) V1799) (kl:set (quote shen.*occurs*) #t)) ((eq? (quote -) V1799) (kl:set (quote shen.*occurs*) #f)) (#t (simple-error "occurs-check expects + or -\n")))) (quote occurs-check))
(begin (register-function-arity (quote shen.aum) 2) (define (kl:shen.aum V1802 V1803) (cond ((and (pair? V1802) (and (pair? (car V1802)) (and (pair? (cdr V1802)) (and (eq? (quote :-) (car (cdr V1802))) (and (pair? (cdr (cdr V1802))) (null? (cdr (cdr (cdr V1802))))))))) (let ((MuApplication (kl:shen.make_mu_application (cons (quote shen.mu) (cons (cdr (car V1802)) (cons (kl:shen.continuation_call (cdr (car V1802)) (car (cdr (cdr V1802)))) (quote ())))) V1803))) (kl:shen.mu_reduction MuApplication (quote +)))) (#t (kl:shen.f_error (quote shen.aum))))) (quote shen.aum))
(begin (register-function-arity (quote shen.continuation_call) 2) (define (kl:shen.continuation_call V1806 V1807) (let ((VTerms (cons (quote ProcessN) (kl:shen.extract_vars V1806)))) (let ((VBody (kl:shen.extract_vars V1807))) (let ((Free (kl:remove (quote Throwcontrol) (kl:difference VBody VTerms)))) (kl:shen.cc_help Free V1807))))) (quote shen.continuation_call))
(begin (register-function-arity (quote remove) 2) (define (kl:remove V1810 V1811) (kl:shen.remove-h V1810 V1811 (quote ()))) (quote remove))
(begin (register-function-arity (quote shen.remove-h) 3) (define (kl:shen.remove-h V1818 V1819 V1820) (cond ((null? V1819) (kl:reverse V1820)) ((and (pair? V1819) (kl:= (car V1819) V1818)) (kl:shen.remove-h (car V1819) (cdr V1819) V1820)) ((pair? V1819) (kl:shen.remove-h V1818 (cdr V1819) (cons (car V1819) V1820))) (#t (kl:shen.f_error (quote shen.remove-h))))) (quote shen.remove-h))
(begin (register-function-arity (quote shen.cc_help) 2) (define (kl:shen.cc_help V1823 V1824) (cond ((and (null? V1823) (null? V1824)) (cons (quote shen.pop) (cons (quote shen.the) (cons (quote shen.stack) (quote ()))))) ((null? V1824) (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons V1823 (cons (quote and) (cons (quote shen.then) (cons (cons (quote shen.pop) (cons (quote shen.the) (cons (quote shen.stack) (quote ())))) (quote ())))))))))) ((null? V1823) (cons (quote call) (cons (quote shen.the) (cons (quote shen.continuation) (cons V1824 (quote ())))))) (#t (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons V1823 (cons (quote and) (cons (quote shen.then) (cons (cons (quote call) (cons (quote shen.the) (cons (quote shen.continuation) (cons V1824 (quote ()))))) (quote ())))))))))))) (quote shen.cc_help))
(begin (register-function-arity (quote shen.make_mu_application) 2) (define (kl:shen.make_mu_application V1827 V1828) (cond ((and (pair? V1827) (and (eq? (quote shen.mu) (car V1827)) (and (pair? (cdr V1827)) (and (null? (car (cdr V1827))) (and (pair? (cdr (cdr V1827))) (and (null? (cdr (cdr (cdr V1827)))) (null? V1828))))))) (car (cdr (cdr V1827)))) ((and (pair? V1827) (and (eq? (quote shen.mu) (car V1827)) (and (pair? (cdr V1827)) (and (pair? (car (cdr V1827))) (and (pair? (cdr (cdr V1827))) (and (null? (cdr (cdr (cdr V1827)))) (pair? V1828))))))) (cons (cons (quote shen.mu) (cons (car (car (cdr V1827))) (cons (kl:shen.make_mu_application (cons (quote shen.mu) (cons (cdr (car (cdr V1827))) (cdr (cdr V1827)))) (cdr V1828)) (quote ())))) (cons (car V1828) (quote ())))) (#t (kl:shen.f_error (quote shen.make_mu_application))))) (quote shen.make_mu_application))
(begin (register-function-arity (quote shen.mu_reduction) 2) (define (kl:shen.mu_reduction V1837 V1838) (cond ((and (pair? V1837) (and (pair? (car V1837)) (and (eq? (quote shen.mu) (car (car V1837))) (and (pair? (cdr (car V1837))) (and (pair? (car (cdr (car V1837)))) (and (eq? (quote mode) (car (car (cdr (car V1837))))) (and (pair? (cdr (car (cdr (car V1837))))) (and (pair? (cdr (cdr (car (cdr (car V1837)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1837))))))) (and (pair? (cdr (cdr (car V1837)))) (and (null? (cdr (cdr (cdr (car V1837))))) (and (pair? (cdr V1837)) (null? (cdr (cdr V1837))))))))))))))) (kl:shen.mu_reduction (cons (cons (quote shen.mu) (cons (car (cdr (car (cdr (car V1837))))) (cdr (cdr (car V1837))))) (cdr V1837)) (car (cdr (cdr (car (cdr (car V1837)))))))) ((and (pair? V1837) (and (pair? (car V1837)) (and (eq? (quote shen.mu) (car (car V1837))) (and (pair? (cdr (car V1837))) (and (pair? (cdr (cdr (car V1837)))) (and (null? (cdr (cdr (cdr (car V1837))))) (and (pair? (cdr V1837)) (and (null? (cdr (cdr V1837))) (eq? (quote _) (car (cdr (car V1837)))))))))))) (kl:shen.mu_reduction (car (cdr (cdr (car V1837)))) V1838)) ((and (pair? V1837) (and (pair? (car V1837)) (and (eq? (quote shen.mu) (car (car V1837))) (and (pair? (cdr (car V1837))) (and (pair? (cdr (cdr (car V1837)))) (and (null? (cdr (cdr (cdr (car V1837))))) (and (pair? (cdr V1837)) (and (null? (cdr (cdr V1837))) (assert-boolean (kl:shen.ephemeral_variable? (car (cdr (car V1837))) (car (cdr V1837)))))))))))) (kl:subst (car (cdr V1837)) (car (cdr (car V1837))) (kl:shen.mu_reduction (car (cdr (cdr (car V1837)))) V1838))) ((and (pair? V1837) (and (pair? (car V1837)) (and (eq? (quote shen.mu) (car (car V1837))) (and (pair? (cdr (car V1837))) (and (pair? (cdr (cdr (car V1837)))) (and (null? (cdr (cdr (cdr (car V1837))))) (and (pair? (cdr V1837)) (and (null? (cdr (cdr V1837))) (kl:variable? (car (cdr (car V1837)))))))))))) (cons (quote let) (cons (car (cdr (car V1837))) (cons (quote shen.be) (cons (car (cdr V1837)) (cons (quote in) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1837)))) V1838) (quote ())))))))) ((and (pair? V1837) (and (pair? (car V1837)) (and (eq? (quote shen.mu) (car (car V1837))) (and (pair? (cdr (car V1837))) (and (pair? (cdr (cdr (car V1837)))) (and (null? (cdr (cdr (cdr (car V1837))))) (and (pair? (cdr V1837)) (and (null? (cdr (cdr V1837))) (and (eq? (quote -) V1838) (assert-boolean (kl:shen.prolog_constant? (car (cdr (car V1837)))))))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V1837))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote identical) (cons (quote shen.to) (cons (car (cdr (car V1837))) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1837)))) (quote -)) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))))) ((and (pair? V1837) (and (pair? (car V1837)) (and (eq? (quote shen.mu) (car (car V1837))) (and (pair? (cdr (car V1837))) (and (pair? (cdr (cdr (car V1837)))) (and (null? (cdr (cdr (cdr (car V1837))))) (and (pair? (cdr V1837)) (and (null? (cdr (cdr V1837))) (and (eq? (quote +) V1838) (assert-boolean (kl:shen.prolog_constant? (car (cdr (car V1837)))))))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V1837))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote identical) (cons (quote shen.to) (cons (car (cdr (car V1837))) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1837)))) (quote +)) (cons (quote shen.else) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.variable) (quote ()))))) (cons (quote shen.then) (cons (cons (quote bind) (cons Z (cons (quote shen.to) (cons (car (cdr (car V1837))) (cons (quote in) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1837)))) (quote +)) (quote ()))))))) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))) (quote ()))))))))) ((and (pair? V1837) (and (pair? (car V1837)) (and (eq? (quote shen.mu) (car (car V1837))) (and (pair? (cdr (car V1837))) (and (pair? (car (cdr (car V1837)))) (and (pair? (cdr (cdr (car V1837)))) (and (null? (cdr (cdr (cdr (car V1837))))) (and (pair? (cdr V1837)) (and (null? (cdr (cdr V1837))) (eq? (quote -) V1838)))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V1837))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.non-empty) (cons (quote list) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (cons (cons (quote shen.mu) (cons (car (car (cdr (car V1837)))) (cons (cons (cons (quote shen.mu) (cons (cdr (car (cdr (car V1837)))) (cdr (cdr (car V1837))))) (cons (cons (quote shen.the) (cons (quote tail) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote ())))) (cons (cons (quote shen.the) (cons (quote head) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote -)) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))))) ((and (pair? V1837) (and (pair? (car V1837)) (and (eq? (quote shen.mu) (car (car V1837))) (and (pair? (cdr (car V1837))) (and (pair? (car (cdr (car V1837)))) (and (pair? (cdr (cdr (car V1837)))) (and (null? (cdr (cdr (cdr (car V1837))))) (and (pair? (cdr V1837)) (and (null? (cdr (cdr V1837))) (eq? (quote +) V1838)))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V1837))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.non-empty) (cons (quote list) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (cons (cons (quote shen.mu) (cons (car (car (cdr (car V1837)))) (cons (cons (cons (quote shen.mu) (cons (cdr (car (cdr (car V1837)))) (cdr (cdr (car V1837))))) (cons (cons (quote shen.the) (cons (quote tail) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote ())))) (cons (cons (quote shen.the) (cons (quote head) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote +)) (cons (quote shen.else) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.variable) (quote ()))))) (cons (quote shen.then) (cons (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons (kl:shen.extract_vars (car (cdr (car V1837)))) (cons (quote and) (cons (quote shen.then) (cons (cons (quote bind) (cons Z (cons (quote shen.to) (cons (kl:shen.rcons_form (kl:shen.remove_modes (car (cdr (car V1837))))) (cons (quote in) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1837)))) (quote +)) (quote ()))))))) (quote ()))))))))) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))) (quote ()))))))))) (#t V1837))) (quote shen.mu_reduction))
(begin (register-function-arity (quote shen.rcons_form) 1) (define (kl:shen.rcons_form V1840) (cond ((pair? V1840) (cons (quote cons) (cons (kl:shen.rcons_form (car V1840)) (cons (kl:shen.rcons_form (cdr V1840)) (quote ()))))) (#t V1840))) (quote shen.rcons_form))
(begin (register-function-arity (quote shen.remove_modes) 1) (define (kl:shen.remove_modes V1842) (cond ((and (pair? V1842) (and (eq? (quote mode) (car V1842)) (and (pair? (cdr V1842)) (and (pair? (cdr (cdr V1842))) (and (eq? (quote +) (car (cdr (cdr V1842)))) (null? (cdr (cdr (cdr V1842))))))))) (kl:shen.remove_modes (car (cdr V1842)))) ((and (pair? V1842) (and (eq? (quote mode) (car V1842)) (and (pair? (cdr V1842)) (and (pair? (cdr (cdr V1842))) (and (eq? (quote -) (car (cdr (cdr V1842)))) (null? (cdr (cdr (cdr V1842))))))))) (kl:shen.remove_modes (car (cdr V1842)))) ((pair? V1842) (cons (kl:shen.remove_modes (car V1842)) (kl:shen.remove_modes (cdr V1842)))) (#t V1842))) (quote shen.remove_modes))
(begin (register-function-arity (quote shen.ephemeral_variable?) 2) (define (kl:shen.ephemeral_variable? V1845 V1846) (and (kl:variable? V1845) (kl:variable? V1846))) (quote shen.ephemeral_variable?))
(begin (register-function-arity (quote shen.prolog_constant?) 1) (define (kl:shen.prolog_constant? V1856) (cond ((pair? V1856) #f) (#t #t))) (quote shen.prolog_constant?))
(begin (register-function-arity (quote shen.aum_to_shen) 1) (define (kl:shen.aum_to_shen V1858) (cond ((and (pair? V1858) (and (eq? (quote let) (car V1858)) (and (pair? (cdr V1858)) (and (pair? (cdr (cdr V1858))) (and (eq? (quote shen.be) (car (cdr (cdr V1858)))) (and (pair? (cdr (cdr (cdr V1858)))) (and (pair? (cdr (cdr (cdr (cdr V1858))))) (and (eq? (quote in) (car (cdr (cdr (cdr (cdr V1858)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1858)))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr V1858)))))))))))))))) (cons (quote let) (cons (car (cdr V1858)) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr V1858))))) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr V1858))))))) (quote ())))))) ((and (pair? V1858) (and (eq? (quote shen.the) (car V1858)) (and (pair? (cdr V1858)) (and (eq? (quote shen.result) (car (cdr V1858))) (and (pair? (cdr (cdr V1858))) (and (eq? (quote shen.of) (car (cdr (cdr V1858)))) (and (pair? (cdr (cdr (cdr V1858)))) (and (eq? (quote shen.dereferencing) (car (cdr (cdr (cdr V1858))))) (and (pair? (cdr (cdr (cdr (cdr V1858))))) (null? (cdr (cdr (cdr (cdr (cdr V1858))))))))))))))) (cons (quote shen.lazyderef) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr V1858)))))) (cons (quote ProcessN) (quote ()))))) ((and (pair? V1858) (and (eq? (quote if) (car V1858)) (and (pair? (cdr V1858)) (and (pair? (cdr (cdr V1858))) (and (eq? (quote shen.then) (car (cdr (cdr V1858)))) (and (pair? (cdr (cdr (cdr V1858)))) (and (pair? (cdr (cdr (cdr (cdr V1858))))) (and (eq? (quote shen.else) (car (cdr (cdr (cdr (cdr V1858)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1858)))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr V1858)))))))))))))))) (cons (quote if) (cons (kl:shen.aum_to_shen (car (cdr V1858))) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr V1858))))) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr V1858))))))) (quote ())))))) ((and (pair? V1858) (and (pair? (cdr V1858)) (and (eq? (quote is) (car (cdr V1858))) (and (pair? (cdr (cdr V1858))) (and (eq? (quote shen.a) (car (cdr (cdr V1858)))) (and (pair? (cdr (cdr (cdr V1858)))) (and (eq? (quote shen.variable) (car (cdr (cdr (cdr V1858))))) (null? (cdr (cdr (cdr (cdr V1858)))))))))))) (cons (quote shen.pvar?) (cons (car V1858) (quote ())))) ((and (pair? V1858) (and (pair? (cdr V1858)) (and (eq? (quote is) (car (cdr V1858))) (and (pair? (cdr (cdr V1858))) (and (eq? (quote shen.a) (car (cdr (cdr V1858)))) (and (pair? (cdr (cdr (cdr V1858)))) (and (eq? (quote shen.non-empty) (car (cdr (cdr (cdr V1858))))) (and (pair? (cdr (cdr (cdr (cdr V1858))))) (and (eq? (quote list) (car (cdr (cdr (cdr (cdr V1858)))))) (null? (cdr (cdr (cdr (cdr (cdr V1858))))))))))))))) (cons (quote cons?) (cons (car V1858) (quote ())))) ((and (pair? V1858) (and (eq? (quote shen.rename) (car V1858)) (and (pair? (cdr V1858)) (and (eq? (quote shen.the) (car (cdr V1858))) (and (pair? (cdr (cdr V1858))) (and (eq? (quote shen.variables) (car (cdr (cdr V1858)))) (and (pair? (cdr (cdr (cdr V1858)))) (and (eq? (quote in) (car (cdr (cdr (cdr V1858))))) (and (pair? (cdr (cdr (cdr (cdr V1858))))) (and (null? (car (cdr (cdr (cdr (cdr V1858)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1858)))))) (and (eq? (quote and) (car (cdr (cdr (cdr (cdr (cdr V1858))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr V1858))))))) (and (eq? (quote shen.then) (car (cdr (cdr (cdr (cdr (cdr (cdr V1858)))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1858)))))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1858)))))))))))))))))))))))) (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1858)))))))))) ((and (pair? V1858) (and (eq? (quote shen.rename) (car V1858)) (and (pair? (cdr V1858)) (and (eq? (quote shen.the) (car (cdr V1858))) (and (pair? (cdr (cdr V1858))) (and (eq? (quote shen.variables) (car (cdr (cdr V1858)))) (and (pair? (cdr (cdr (cdr V1858)))) (and (eq? (quote in) (car (cdr (cdr (cdr V1858))))) (and (pair? (cdr (cdr (cdr (cdr V1858))))) (and (pair? (car (cdr (cdr (cdr (cdr V1858)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1858)))))) (and (eq? (quote and) (car (cdr (cdr (cdr (cdr (cdr V1858))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr V1858))))))) (and (eq? (quote shen.then) (car (cdr (cdr (cdr (cdr (cdr (cdr V1858)))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1858)))))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1858)))))))))))))))))))))))) (cons (quote let) (cons (car (car (cdr (cdr (cdr (cdr V1858)))))) (cons (cons (quote shen.newpv) (cons (quote ProcessN) (quote ()))) (cons (kl:shen.aum_to_shen (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons (cdr (car (cdr (cdr (cdr (cdr V1858)))))) (cdr (cdr (cdr (cdr (cdr V1858))))))))))) (quote ())))))) ((and (pair? V1858) (and (eq? (quote bind) (car V1858)) (and (pair? (cdr V1858)) (and (pair? (cdr (cdr V1858))) (and (eq? (quote shen.to) (car (cdr (cdr V1858)))) (and (pair? (cdr (cdr (cdr V1858)))) (and (pair? (cdr (cdr (cdr (cdr V1858))))) (and (eq? (quote in) (car (cdr (cdr (cdr (cdr V1858)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1858)))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr V1858)))))))))))))))) (cons (quote do) (cons (cons (quote shen.bindv) (cons (car (cdr V1858)) (cons (kl:shen.chwild (car (cdr (cdr (cdr V1858))))) (cons (quote ProcessN) (quote ()))))) (cons (cons (quote let) (cons (quote Result) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr V1858))))))) (cons (cons (quote do) (cons (cons (quote shen.unbindv) (cons (car (cdr V1858)) (cons (quote ProcessN) (quote ())))) (cons (quote Result) (quote ())))) (quote ()))))) (quote ()))))) ((and (pair? V1858) (and (pair? (cdr V1858)) (and (eq? (quote is) (car (cdr V1858))) (and (pair? (cdr (cdr V1858))) (and (eq? (quote identical) (car (cdr (cdr V1858)))) (and (pair? (cdr (cdr (cdr V1858)))) (and (eq? (quote shen.to) (car (cdr (cdr (cdr V1858))))) (and (pair? (cdr (cdr (cdr (cdr V1858))))) (null? (cdr (cdr (cdr (cdr (cdr V1858)))))))))))))) (cons (quote =) (cons (car (cdr (cdr (cdr (cdr V1858))))) (cons (car V1858) (quote ()))))) ((eq? (quote shen.failed!) V1858) #f) ((and (pair? V1858) (and (eq? (quote shen.the) (car V1858)) (and (pair? (cdr V1858)) (and (eq? (quote head) (car (cdr V1858))) (and (pair? (cdr (cdr V1858))) (and (eq? (quote shen.of) (car (cdr (cdr V1858)))) (and (pair? (cdr (cdr (cdr V1858)))) (null? (cdr (cdr (cdr (cdr V1858)))))))))))) (cons (quote hd) (cdr (cdr (cdr V1858))))) ((and (pair? V1858) (and (eq? (quote shen.the) (car V1858)) (and (pair? (cdr V1858)) (and (eq? (quote tail) (car (cdr V1858))) (and (pair? (cdr (cdr V1858))) (and (eq? (quote shen.of) (car (cdr (cdr V1858)))) (and (pair? (cdr (cdr (cdr V1858)))) (null? (cdr (cdr (cdr (cdr V1858)))))))))))) (cons (quote tl) (cdr (cdr (cdr V1858))))) ((and (pair? V1858) (and (eq? (quote shen.pop) (car V1858)) (and (pair? (cdr V1858)) (and (eq? (quote shen.the) (car (cdr V1858))) (and (pair? (cdr (cdr V1858))) (and (eq? (quote shen.stack) (car (cdr (cdr V1858)))) (null? (cdr (cdr (cdr V1858)))))))))) (cons (quote do) (cons (cons (quote shen.incinfs) (quote ())) (cons (cons (quote thaw) (cons (quote Continuation) (quote ()))) (quote ()))))) ((and (pair? V1858) (and (eq? (quote call) (car V1858)) (and (pair? (cdr V1858)) (and (eq? (quote shen.the) (car (cdr V1858))) (and (pair? (cdr (cdr V1858))) (and (eq? (quote shen.continuation) (car (cdr (cdr V1858)))) (and (pair? (cdr (cdr (cdr V1858)))) (null? (cdr (cdr (cdr (cdr V1858)))))))))))) (cons (quote do) (cons (cons (quote shen.incinfs) (quote ())) (cons (kl:shen.call_the_continuation (kl:shen.chwild (car (cdr (cdr (cdr V1858))))) (quote ProcessN) (quote Continuation)) (quote ()))))) (#t V1858))) (quote shen.aum_to_shen))
(begin (register-function-arity (quote shen.chwild) 1) (define (kl:shen.chwild V1860) (cond ((eq? V1860 (quote _)) (cons (quote shen.newpv) (cons (quote ProcessN) (quote ())))) ((pair? V1860) (kl:map (lambda (Z) (kl:shen.chwild Z)) V1860)) (#t V1860))) (quote shen.chwild))
(begin (register-function-arity (quote shen.newpv) 1) (define (kl:shen.newpv V1862) (let ((Count+1 (+ (vector-ref (kl:value (quote shen.*varcounter*)) V1862) 1))) (let ((IncVar (let ((_tmp (kl:value (quote shen.*varcounter*)))) (vector-set! _tmp V1862 Count+1) _tmp))) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V1862))) (let ((ResizeVectorIfNeeded (if (kl:= Count+1 (kl:limit Vector)) (kl:shen.resizeprocessvector V1862 Count+1) (quote shen.skip)))) (kl:shen.mk-pvar Count+1)))))) (quote shen.newpv))
(begin (register-function-arity (quote shen.resizeprocessvector) 2) (define (kl:shen.resizeprocessvector V1865 V1866) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V1865))) (let ((BigVector (kl:shen.resize-vector Vector (+ V1866 V1866) (quote shen.-null-)))) (let ((_tmp (kl:value (quote shen.*prologvectors*)))) (vector-set! _tmp V1865 BigVector) _tmp)))) (quote shen.resizeprocessvector))
(begin (register-function-arity (quote shen.resize-vector) 3) (define (kl:shen.resize-vector V1870 V1871 V1872) (let ((BigVector (let ((_tmp (make-vector (+ 1 V1871) (quote (quote shen.fail!))))) (vector-set! _tmp 0 V1871) _tmp))) (kl:shen.copy-vector V1870 BigVector (kl:limit V1870) V1871 V1872))) (quote shen.resize-vector))
(begin (register-function-arity (quote shen.copy-vector) 5) (define (kl:shen.copy-vector V1878 V1879 V1880 V1881 V1882) (kl:shen.copy-vector-stage-2 (+ 1 V1880) (+ V1881 1) V1882 (kl:shen.copy-vector-stage-1 1 V1878 V1879 (+ 1 V1880)))) (quote shen.copy-vector))
(begin (register-function-arity (quote shen.copy-vector-stage-1) 4) (define (kl:shen.copy-vector-stage-1 V1890 V1891 V1892 V1893) (cond ((kl:= V1893 V1890) V1892) (#t (kl:shen.copy-vector-stage-1 (+ 1 V1890) V1891 (let ((_tmp V1892)) (vector-set! _tmp V1890 (vector-ref V1891 V1890)) _tmp) V1893)))) (quote shen.copy-vector-stage-1))
(begin (register-function-arity (quote shen.copy-vector-stage-2) 4) (define (kl:shen.copy-vector-stage-2 V1901 V1902 V1903 V1904) (cond ((kl:= V1902 V1901) V1904) (#t (kl:shen.copy-vector-stage-2 (+ V1901 1) V1902 V1903 (let ((_tmp V1904)) (vector-set! _tmp V1901 V1903) _tmp))))) (quote shen.copy-vector-stage-2))
(begin (register-function-arity (quote shen.mk-pvar) 1) (define (kl:shen.mk-pvar V1906) (let ((_tmp (let ((_tmp (make-vector 2 (quote (quote shen.fail!))))) (vector-set! _tmp 0 (quote shen.pvar)) _tmp))) (vector-set! _tmp 1 V1906) _tmp)) (quote shen.mk-pvar))
(begin (register-function-arity (quote shen.pvar?) 1) (define (kl:shen.pvar? V1908) (guard (lambda (E) #f) (and (vector? V1908) (eq? (vector-ref V1908 0) (quote shen.pvar))))) (quote shen.pvar?))
(begin (register-function-arity (quote shen.bindv) 3) (define (kl:shen.bindv V1912 V1913 V1914) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V1914))) (let ((_tmp Vector)) (vector-set! _tmp (vector-ref V1912 1) V1913) _tmp))) (quote shen.bindv))
(begin (register-function-arity (quote shen.unbindv) 2) (define (kl:shen.unbindv V1917 V1918) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V1918))) (let ((_tmp Vector)) (vector-set! _tmp (vector-ref V1917 1) (quote shen.-null-)) _tmp))) (quote shen.unbindv))
(begin (register-function-arity (quote shen.incinfs) 0) (define (kl:shen.incinfs) (kl:set (quote shen.*infs*) (+ 1 (kl:value (quote shen.*infs*))))) (quote shen.incinfs))
(begin (register-function-arity (quote shen.call_the_continuation) 3) (define (kl:shen.call_the_continuation V1922 V1923 V1924) (cond ((and (pair? V1922) (and (pair? (car V1922)) (null? (cdr V1922)))) (cons (car (car V1922)) (kl:append (cdr (car V1922)) (cons V1923 (cons V1924 (quote ())))))) ((and (pair? V1922) (pair? (car V1922))) (let ((NewContinuation (kl:shen.newcontinuation (cdr V1922) V1923 V1924))) (cons (car (car V1922)) (kl:append (cdr (car V1922)) (cons V1923 (cons NewContinuation (quote ()))))))) (#t (kl:shen.f_error (quote shen.call_the_continuation))))) (quote shen.call_the_continuation))
(begin (register-function-arity (quote shen.newcontinuation) 3) (define (kl:shen.newcontinuation V1928 V1929 V1930) (cond ((null? V1928) V1930) ((and (pair? V1928) (pair? (car V1928))) (cons (quote freeze) (cons (cons (car (car V1928)) (kl:append (cdr (car V1928)) (cons V1929 (cons (kl:shen.newcontinuation (cdr V1928) V1929 V1930) (quote ()))))) (quote ())))) (#t (kl:shen.f_error (quote shen.newcontinuation))))) (quote shen.newcontinuation))
(begin (register-function-arity (quote return) 3) (define (kl:return V1938 V1939 V1940) (kl:shen.deref V1938 V1939)) (quote return))
(begin (register-function-arity (quote shen.measure&return) 3) (define (kl:shen.measure&return V1948 V1949 V1950) (begin (kl:shen.prhush (kl:shen.app (kl:value (quote shen.*infs*)) " inferences\n" (quote shen.a)) (kl:stoutput)) (kl:shen.deref V1948 V1949))) (quote shen.measure&return))
(begin (register-function-arity (quote unify) 4) (define (kl:unify V1955 V1956 V1957 V1958) (kl:shen.lzy= (kl:shen.lazyderef V1955 V1957) (kl:shen.lazyderef V1956 V1957) V1957 V1958)) (quote unify))
(begin (register-function-arity (quote shen.lzy=) 4) (define (kl:shen.lzy= V1980 V1981 V1982 V1983) (cond ((kl:= V1981 V1980) (kl:thaw V1983)) ((assert-boolean (kl:shen.pvar? V1980)) (kl:bind V1980 V1981 V1982 V1983)) ((assert-boolean (kl:shen.pvar? V1981)) (kl:bind V1981 V1980 V1982 V1983)) ((and (pair? V1980) (pair? V1981)) (kl:shen.lzy= (kl:shen.lazyderef (car V1980) V1982) (kl:shen.lazyderef (car V1981) V1982) V1982 (lambda () (kl:shen.lzy= (kl:shen.lazyderef (cdr V1980) V1982) (kl:shen.lazyderef (cdr V1981) V1982) V1982 V1983)))) (#t #f))) (quote shen.lzy=))
(begin (register-function-arity (quote shen.deref) 2) (define (kl:shen.deref V1986 V1987) (cond ((pair? V1986) (cons (kl:shen.deref (car V1986) V1987) (kl:shen.deref (cdr V1986) V1987))) (#t (if (assert-boolean (kl:shen.pvar? V1986)) (let ((Value (kl:shen.valvector V1986 V1987))) (if (eq? Value (quote shen.-null-)) V1986 (kl:shen.deref Value V1987))) V1986)))) (quote shen.deref))
(begin (register-function-arity (quote shen.lazyderef) 2) (define (kl:shen.lazyderef V1990 V1991) (if (assert-boolean (kl:shen.pvar? V1990)) (let ((Value (kl:shen.valvector V1990 V1991))) (if (eq? Value (quote shen.-null-)) V1990 (kl:shen.lazyderef Value V1991))) V1990)) (quote shen.lazyderef))
(begin (register-function-arity (quote shen.valvector) 2) (define (kl:shen.valvector V1994 V1995) (vector-ref (vector-ref (kl:value (quote shen.*prologvectors*)) V1995) (vector-ref V1994 1))) (quote shen.valvector))
(begin (register-function-arity (quote unify!) 4) (define (kl:unify! V2000 V2001 V2002 V2003) (kl:shen.lzy=! (kl:shen.lazyderef V2000 V2002) (kl:shen.lazyderef V2001 V2002) V2002 V2003)) (quote unify!))
(begin (register-function-arity (quote shen.lzy=!) 4) (define (kl:shen.lzy=! V2025 V2026 V2027 V2028) (cond ((kl:= V2026 V2025) (kl:thaw V2028)) ((and (assert-boolean (kl:shen.pvar? V2025)) (kl:not (kl:shen.occurs? V2025 (kl:shen.deref V2026 V2027)))) (kl:bind V2025 V2026 V2027 V2028)) ((and (assert-boolean (kl:shen.pvar? V2026)) (kl:not (kl:shen.occurs? V2026 (kl:shen.deref V2025 V2027)))) (kl:bind V2026 V2025 V2027 V2028)) ((and (pair? V2025) (pair? V2026)) (kl:shen.lzy=! (kl:shen.lazyderef (car V2025) V2027) (kl:shen.lazyderef (car V2026) V2027) V2027 (lambda () (kl:shen.lzy=! (kl:shen.lazyderef (cdr V2025) V2027) (kl:shen.lazyderef (cdr V2026) V2027) V2027 V2028)))) (#t #f))) (quote shen.lzy=!))
(begin (register-function-arity (quote shen.occurs?) 2) (define (kl:shen.occurs? V2040 V2041) (cond ((kl:= V2041 V2040) #t) ((pair? V2041) (or (assert-boolean (kl:shen.occurs? V2040 (car V2041))) (assert-boolean (kl:shen.occurs? V2040 (cdr V2041))))) (#t #f))) (quote shen.occurs?))
(begin (register-function-arity (quote identical) 4) (define (kl:identical V2046 V2047 V2048 V2049) (kl:shen.lzy== (kl:shen.lazyderef V2046 V2048) (kl:shen.lazyderef V2047 V2048) V2048 V2049)) (quote identical))
(begin (register-function-arity (quote shen.lzy==) 4) (define (kl:shen.lzy== V2071 V2072 V2073 V2074) (cond ((kl:= V2072 V2071) (kl:thaw V2074)) ((and (pair? V2071) (pair? V2072)) (kl:shen.lzy== (kl:shen.lazyderef (car V2071) V2073) (kl:shen.lazyderef (car V2072) V2073) V2073 (lambda () (kl:shen.lzy== (cdr V2071) (cdr V2072) V2073 V2074)))) (#t #f))) (quote shen.lzy==))
(begin (register-function-arity (quote shen.pvar) 1) (define (kl:shen.pvar V2076) (string-append "Var" (kl:shen.app (vector-ref V2076 1) "" (quote shen.a)))) (quote shen.pvar))
(begin (register-function-arity (quote bind) 4) (define (kl:bind V2081 V2082 V2083 V2084) (begin (kl:shen.bindv V2081 V2082 V2083) (let ((Result (kl:thaw V2084))) (begin (kl:shen.unbindv V2081 V2083) Result)))) (quote bind))
(begin (register-function-arity (quote fwhen) 3) (define (kl:fwhen V2102 V2103 V2104) (cond ((kl:= #t V2102) (kl:thaw V2104)) ((kl:= #f V2102) #f) (#t (simple-error (string-append "fwhen expects a boolean: not " (kl:shen.app V2102 "%" (quote shen.s))))))) (quote fwhen))
(begin (register-function-arity (quote call) 3) (define (kl:call V2120 V2121 V2122) (cond ((pair? V2120) (kl:shen.call-help (kl:function (kl:shen.lazyderef (car V2120) V2121)) (cdr V2120) V2121 V2122)) (#t #f))) (quote call))
(begin (register-function-arity (quote shen.call-help) 4) (define (kl:shen.call-help V2127 V2128 V2129 V2130) (cond ((null? V2128) ((V2127 V2129) V2130)) ((pair? V2128) (kl:shen.call-help (V2127 (car V2128)) (cdr V2128) V2129 V2130)) (#t (kl:shen.f_error (quote shen.call-help))))) (quote shen.call-help))
(begin (register-function-arity (quote shen.intprolog) 1) (define (kl:shen.intprolog V2132) (cond ((and (pair? V2132) (pair? (car V2132))) (let ((ProcessN (kl:shen.start-new-prolog-process))) (kl:shen.intprolog-help (car (car V2132)) (kl:shen.insert-prolog-variables (cons (cdr (car V2132)) (cons (cdr V2132) (quote ()))) ProcessN) ProcessN))) (#t (kl:shen.f_error (quote shen.intprolog))))) (quote shen.intprolog))
(begin (register-function-arity (quote shen.intprolog-help) 3) (define (kl:shen.intprolog-help V2136 V2137 V2138) (cond ((and (pair? V2137) (and (pair? (cdr V2137)) (null? (cdr (cdr V2137))))) (kl:shen.intprolog-help-help V2136 (car V2137) (car (cdr V2137)) V2138)) (#t (kl:shen.f_error (quote shen.intprolog-help))))) (quote shen.intprolog-help))
(begin (register-function-arity (quote shen.intprolog-help-help) 4) (define (kl:shen.intprolog-help-help V2143 V2144 V2145 V2146) (cond ((null? V2144) ((V2143 V2146) (lambda () (kl:shen.call-rest V2145 V2146)))) ((pair? V2144) (kl:shen.intprolog-help-help (V2143 (car V2144)) (cdr V2144) V2145 V2146)) (#t (kl:shen.f_error (quote shen.intprolog-help-help))))) (quote shen.intprolog-help-help))
(begin (register-function-arity (quote shen.call-rest) 2) (define (kl:shen.call-rest V2151 V2152) (cond ((null? V2151) #t) ((and (pair? V2151) (and (pair? (car V2151)) (pair? (cdr (car V2151))))) (kl:shen.call-rest (cons (cons ((car (car V2151)) (car (cdr (car V2151)))) (cdr (cdr (car V2151)))) (cdr V2151)) V2152)) ((and (pair? V2151) (and (pair? (car V2151)) (null? (cdr (car V2151))))) (((car (car V2151)) V2152) (lambda () (kl:shen.call-rest (cdr V2151) V2152)))) (#t (kl:shen.f_error (quote shen.call-rest))))) (quote shen.call-rest))
(begin (register-function-arity (quote shen.start-new-prolog-process) 0) (define (kl:shen.start-new-prolog-process) (let ((IncrementProcessCounter (kl:set (quote shen.*process-counter*) (+ 1 (kl:value (quote shen.*process-counter*)))))) (kl:shen.initialise-prolog IncrementProcessCounter))) (quote shen.start-new-prolog-process))
(begin (register-function-arity (quote shen.insert-prolog-variables) 2) (define (kl:shen.insert-prolog-variables V2155 V2156) (kl:shen.insert-prolog-variables-help V2155 (kl:shen.flatten V2155) V2156)) (quote shen.insert-prolog-variables))
(begin (register-function-arity (quote shen.insert-prolog-variables-help) 3) (define (kl:shen.insert-prolog-variables-help V2164 V2165 V2166) (cond ((null? V2165) V2164) ((and (pair? V2165) (kl:variable? (car V2165))) (let ((V (kl:shen.newpv V2166))) (let ((XV/Y (kl:subst V (car V2165) V2164))) (let ((Z-Y (kl:remove (car V2165) (cdr V2165)))) (kl:shen.insert-prolog-variables-help XV/Y Z-Y V2166))))) ((pair? V2165) (kl:shen.insert-prolog-variables-help V2164 (cdr V2165) V2166)) (#t (kl:shen.f_error (quote shen.insert-prolog-variables-help))))) (quote shen.insert-prolog-variables-help))
(begin (register-function-arity (quote shen.initialise-prolog) 1) (define (kl:shen.initialise-prolog V2168) (let ((Vector (let ((_tmp (kl:value (quote shen.*prologvectors*)))) (vector-set! _tmp V2168 (kl:shen.fillvector (kl:vector 10) 1 10 (quote shen.-null-))) _tmp))) (let ((Counter (let ((_tmp (kl:value (quote shen.*varcounter*)))) (vector-set! _tmp V2168 1) _tmp))) V2168))) (quote shen.initialise-prolog))
