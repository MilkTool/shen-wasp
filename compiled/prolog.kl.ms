"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.<defprolog>) 1) (define (kl:shen.<defprolog> V1618) (let ((Parse_shen.<predicate*> (kl:shen.<predicate*> V1618))) (if (kl:not (kl:= (kl:fail) Parse_shen.<predicate*>)) (let ((Parse_shen.<clauses*> (kl:shen.<clauses*> Parse_shen.<predicate*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<clauses*>)) (kl:shen.pair (car Parse_shen.<clauses*>) (car (kl:shen.prolog->shen (kl:map (lambda (Parse_X) (kl:shen.insert-predicate (kl:shen.hdtl Parse_shen.<predicate*>) Parse_X)) (kl:shen.hdtl Parse_shen.<clauses*>))))) (kl:fail))) (kl:fail)))) (quote shen.<defprolog>))
(begin (register-function-arity (quote shen.prolog-error) 2) (define (kl:shen.prolog-error V1627 V1628) (cond ((and (pair? V1628) (and (pair? (cdr V1628)) (null? (cdr (cdr V1628))))) (simple-error (string-append "prolog syntax error in " (kl:shen.app V1627 (string-append " here:\n\n " (kl:shen.app (kl:shen.next-50 50 (car V1628)) "\n" (quote shen.a))) (quote shen.a))))) (#t (simple-error (string-append "prolog syntax error in " (kl:shen.app V1627 "\n" (quote shen.a))))))) (quote shen.prolog-error))
(begin (register-function-arity (quote shen.next-50) 2) (define (kl:shen.next-50 V1635 V1636) (cond ((null? V1636) "") ((kl:= 0 V1635) "") ((pair? V1636) (string-append (kl:shen.decons-string (car V1636)) (kl:shen.next-50 (- V1635 1) (cdr V1636)))) (#t (kl:shen.f_error (quote shen.next-50))))) (quote shen.next-50))
(begin (register-function-arity (quote shen.decons-string) 1) (define (kl:shen.decons-string V1638) (cond ((and (pair? V1638) (and (eq? (quote cons) (car V1638)) (and (pair? (cdr V1638)) (and (pair? (cdr (cdr V1638))) (null? (cdr (cdr (cdr V1638)))))))) (kl:shen.app (kl:shen.eval-cons V1638) " " (quote shen.s))) (#t (kl:shen.app V1638 " " (quote shen.r))))) (quote shen.decons-string))
(begin (register-function-arity (quote shen.insert-predicate) 2) (define (kl:shen.insert-predicate V1641 V1642) (cond ((and (pair? V1642) (and (pair? (cdr V1642)) (null? (cdr (cdr V1642))))) (cons (cons V1641 (car V1642)) (cons (quote :-) (cdr V1642)))) (#t (kl:shen.f_error (quote shen.insert-predicate))))) (quote shen.insert-predicate))
(begin (register-function-arity (quote shen.<predicate*>) 1) (define (kl:shen.<predicate*> V1644) (if (pair? (car V1644)) (let ((Parse_X (car (car V1644)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1644)) (kl:shen.hdtl V1644))) Parse_X)) (kl:fail))) (quote shen.<predicate*>))
(begin (register-function-arity (quote shen.<clauses*>) 1) (define (kl:shen.<clauses*> V1646) (let ((YaccParse (let ((Parse_shen.<clause*> (kl:shen.<clause*> V1646))) (if (kl:not (kl:= (kl:fail) Parse_shen.<clause*>)) (let ((Parse_shen.<clauses*> (kl:shen.<clauses*> Parse_shen.<clause*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<clauses*>)) (kl:shen.pair (car Parse_shen.<clauses*>) (cons (kl:shen.hdtl Parse_shen.<clause*>) (kl:shen.hdtl Parse_shen.<clauses*>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1646))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<clauses*>))
(begin (register-function-arity (quote shen.<clause*>) 1) (define (kl:shen.<clause*> V1648) (let ((Parse_shen.<head*> (kl:shen.<head*> V1648))) (if (kl:not (kl:= (kl:fail) Parse_shen.<head*>)) (if (and (pair? (car Parse_shen.<head*>)) (eq? (quote <--) (car (car Parse_shen.<head*>)))) (let ((Parse_shen.<body*> (kl:shen.<body*> (kl:shen.pair (cdr (car Parse_shen.<head*>)) (kl:shen.hdtl Parse_shen.<head*>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<body*>)) (let ((Parse_shen.<end*> (kl:shen.<end*> Parse_shen.<body*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<end*>)) (kl:shen.pair (car Parse_shen.<end*>) (cons (kl:shen.hdtl Parse_shen.<head*>) (cons (kl:shen.hdtl Parse_shen.<body*>) (quote ())))) (kl:fail))) (kl:fail))) (kl:fail)) (kl:fail)))) (quote shen.<clause*>))
(begin (register-function-arity (quote shen.<head*>) 1) (define (kl:shen.<head*> V1650) (let ((YaccParse (let ((Parse_shen.<term*> (kl:shen.<term*> V1650))) (if (kl:not (kl:= (kl:fail) Parse_shen.<term*>)) (let ((Parse_shen.<head*> (kl:shen.<head*> Parse_shen.<term*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<head*>)) (kl:shen.pair (car Parse_shen.<head*>) (cons (kl:shen.hdtl Parse_shen.<term*>) (kl:shen.hdtl Parse_shen.<head*>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1650))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<head*>))
(begin (register-function-arity (quote shen.<term*>) 1) (define (kl:shen.<term*> V1652) (if (pair? (car V1652)) (let ((Parse_X (car (car V1652)))) (if (and (kl:not (eq? (quote <--) Parse_X)) (assert-boolean (kl:shen.legitimate-term? Parse_X))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1652)) (kl:shen.hdtl V1652))) (kl:shen.eval-cons Parse_X)) (kl:fail))) (kl:fail))) (quote shen.<term*>))
(begin (register-function-arity (quote shen.legitimate-term?) 1) (define (kl:shen.legitimate-term? V1658) (cond ((and (pair? V1658) (and (eq? (quote cons) (car V1658)) (and (pair? (cdr V1658)) (and (pair? (cdr (cdr V1658))) (null? (cdr (cdr (cdr V1658)))))))) (and (assert-boolean (kl:shen.legitimate-term? (car (cdr V1658)))) (assert-boolean (kl:shen.legitimate-term? (car (cdr (cdr V1658))))))) ((and (pair? V1658) (and (eq? (quote mode) (car V1658)) (and (pair? (cdr V1658)) (and (pair? (cdr (cdr V1658))) (and (eq? (quote +) (car (cdr (cdr V1658)))) (null? (cdr (cdr (cdr V1658))))))))) (kl:shen.legitimate-term? (car (cdr V1658)))) ((and (pair? V1658) (and (eq? (quote mode) (car V1658)) (and (pair? (cdr V1658)) (and (pair? (cdr (cdr V1658))) (and (eq? (quote -) (car (cdr (cdr V1658)))) (null? (cdr (cdr (cdr V1658))))))))) (kl:shen.legitimate-term? (car (cdr V1658)))) ((pair? V1658) #f) (#t #t))) (quote shen.legitimate-term?))
(begin (register-function-arity (quote shen.eval-cons) 1) (define (kl:shen.eval-cons V1660) (cond ((and (pair? V1660) (and (eq? (quote cons) (car V1660)) (and (pair? (cdr V1660)) (and (pair? (cdr (cdr V1660))) (null? (cdr (cdr (cdr V1660)))))))) (cons (kl:shen.eval-cons (car (cdr V1660))) (kl:shen.eval-cons (car (cdr (cdr V1660)))))) ((and (pair? V1660) (and (eq? (quote mode) (car V1660)) (and (pair? (cdr V1660)) (and (pair? (cdr (cdr V1660))) (null? (cdr (cdr (cdr V1660)))))))) (cons (quote mode) (cons (kl:shen.eval-cons (car (cdr V1660))) (cdr (cdr V1660))))) (#t V1660))) (quote shen.eval-cons))
(begin (register-function-arity (quote shen.<body*>) 1) (define (kl:shen.<body*> V1662) (let ((YaccParse (let ((Parse_shen.<literal*> (kl:shen.<literal*> V1662))) (if (kl:not (kl:= (kl:fail) Parse_shen.<literal*>)) (let ((Parse_shen.<body*> (kl:shen.<body*> Parse_shen.<literal*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<body*>)) (kl:shen.pair (car Parse_shen.<body*>) (cons (kl:shen.hdtl Parse_shen.<literal*>) (kl:shen.hdtl Parse_shen.<body*>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1662))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<body*>))
(begin (register-function-arity (quote shen.<literal*>) 1) (define (kl:shen.<literal*> V1664) (let ((YaccParse (if (and (pair? (car V1664)) (eq? (quote !) (car (car V1664)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1664)) (kl:shen.hdtl V1664))) (cons (quote cut) (cons (kl:intern "Throwcontrol") (quote ())))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (if (pair? (car V1664)) (let ((Parse_X (car (car V1664)))) (if (pair? Parse_X) (kl:shen.pair (car (kl:shen.pair (cdr (car V1664)) (kl:shen.hdtl V1664))) Parse_X) (kl:fail))) (kl:fail)) YaccParse))) (quote shen.<literal*>))
(begin (register-function-arity (quote shen.<end*>) 1) (define (kl:shen.<end*> V1666) (if (pair? (car V1666)) (let ((Parse_X (car (car V1666)))) (if (eq? Parse_X (quote _waspvm_sc_)) (kl:shen.pair (car (kl:shen.pair (cdr (car V1666)) (kl:shen.hdtl V1666))) Parse_X) (kl:fail))) (kl:fail))) (quote shen.<end*>))
(begin (register-function-arity (quote cut) 3) (define (kl:cut V1670 V1671 V1672) (let ((Result (kl:thaw V1672))) (if (kl:= Result #f) V1670 Result))) (quote cut))
(begin (register-function-arity (quote shen.insert_modes) 1) (define (kl:shen.insert_modes V1674) (cond ((and (pair? V1674) (and (eq? (quote mode) (car V1674)) (and (pair? (cdr V1674)) (and (pair? (cdr (cdr V1674))) (null? (cdr (cdr (cdr V1674)))))))) V1674) ((null? V1674) (quote ())) ((pair? V1674) (cons (cons (quote mode) (cons (car V1674) (cons (quote +) (quote ())))) (cons (quote mode) (cons (kl:shen.insert_modes (cdr V1674)) (cons (quote -) (quote ())))))) (#t V1674))) (quote shen.insert_modes))
(begin (register-function-arity (quote shen.s-prolog) 1) (define (kl:shen.s-prolog V1676) (kl:map (lambda (X) (kl:eval X)) (kl:shen.prolog->shen V1676))) (quote shen.s-prolog))
(begin (register-function-arity (quote shen.prolog->shen) 1) (define (kl:shen.prolog->shen V1678) (kl:map (lambda (X) (kl:shen.compile_prolog_procedure X)) (kl:shen.group_clauses (kl:map (lambda (X) (kl:shen.s-prolog_clause X)) (kl:mapcan (lambda (X) (kl:shen.head_abstraction X)) V1678))))) (quote shen.prolog->shen))
(begin (register-function-arity (quote shen.s-prolog_clause) 1) (define (kl:shen.s-prolog_clause V1680) (cond ((and (pair? V1680) (and (pair? (cdr V1680)) (and (eq? (quote :-) (car (cdr V1680))) (and (pair? (cdr (cdr V1680))) (null? (cdr (cdr (cdr V1680)))))))) (cons (car V1680) (cons (quote :-) (cons (kl:map (lambda (X) (kl:shen.s-prolog_literal X)) (car (cdr (cdr V1680)))) (quote ()))))) (#t (kl:shen.f_error (quote shen.s-prolog_clause))))) (quote shen.s-prolog_clause))
(begin (register-function-arity (quote shen.head_abstraction) 1) (define (kl:shen.head_abstraction V1682) (cond ((and (pair? V1682) (and (pair? (cdr V1682)) (and (eq? (quote :-) (car (cdr V1682))) (and (pair? (cdr (cdr V1682))) (and (null? (cdr (cdr (cdr V1682)))) (< (kl:shen.complexity_head (car V1682)) (kl:value (quote shen.*maxcomplexity*)))))))) (cons V1682 (quote ()))) ((and (pair? V1682) (and (pair? (car V1682)) (and (pair? (cdr V1682)) (and (eq? (quote :-) (car (cdr V1682))) (and (pair? (cdr (cdr V1682))) (null? (cdr (cdr (cdr V1682))))))))) (let ((Terms (kl:map (lambda (Y) (kl:gensym (quote V))) (cdr (car V1682))))) (let ((XTerms (kl:shen.rcons_form (kl:shen.remove_modes (cdr (car V1682)))))) (let ((Literal (cons (quote unify) (cons (kl:shen.cons_form Terms) (cons XTerms (quote ())))))) (let ((Clause (cons (cons (car (car V1682)) Terms) (cons (quote :-) (cons (cons Literal (car (cdr (cdr V1682)))) (quote ())))))) (cons Clause (quote ()))))))) (#t (kl:shen.f_error (quote shen.head_abstraction))))) (quote shen.head_abstraction))
(begin (register-function-arity (quote shen.complexity_head) 1) (define (kl:shen.complexity_head V1688) (cond ((pair? V1688) (kl:shen.product (kl:map (lambda (X) (kl:shen.complexity X)) (cdr V1688)))) (#t (kl:shen.f_error (quote shen.complexity_head))))) (quote shen.complexity_head))
(begin (register-function-arity (quote shen.complexity) 1) (define (kl:shen.complexity V1697) (cond ((and (pair? V1697) (and (eq? (quote mode) (car V1697)) (and (pair? (cdr V1697)) (and (pair? (car (cdr V1697))) (and (eq? (quote mode) (car (car (cdr V1697)))) (and (pair? (cdr (car (cdr V1697)))) (and (pair? (cdr (cdr (car (cdr V1697))))) (and (null? (cdr (cdr (cdr (car (cdr V1697)))))) (and (pair? (cdr (cdr V1697))) (null? (cdr (cdr (cdr V1697))))))))))))) (kl:shen.complexity (car (cdr V1697)))) ((and (pair? V1697) (and (eq? (quote mode) (car V1697)) (and (pair? (cdr V1697)) (and (pair? (car (cdr V1697))) (and (pair? (cdr (cdr V1697))) (and (eq? (quote +) (car (cdr (cdr V1697)))) (null? (cdr (cdr (cdr V1697)))))))))) (* 2 (* (kl:shen.complexity (cons (quote mode) (cons (car (car (cdr V1697))) (cdr (cdr V1697))))) (kl:shen.complexity (cons (quote mode) (cons (cdr (car (cdr V1697))) (cdr (cdr V1697)))))))) ((and (pair? V1697) (and (eq? (quote mode) (car V1697)) (and (pair? (cdr V1697)) (and (pair? (car (cdr V1697))) (and (pair? (cdr (cdr V1697))) (and (eq? (quote -) (car (cdr (cdr V1697)))) (null? (cdr (cdr (cdr V1697)))))))))) (* (kl:shen.complexity (cons (quote mode) (cons (car (car (cdr V1697))) (cdr (cdr V1697))))) (kl:shen.complexity (cons (quote mode) (cons (cdr (car (cdr V1697))) (cdr (cdr V1697))))))) ((and (pair? V1697) (and (eq? (quote mode) (car V1697)) (and (pair? (cdr V1697)) (and (pair? (cdr (cdr V1697))) (and (null? (cdr (cdr (cdr V1697)))) (kl:variable? (car (cdr V1697)))))))) 1) ((and (pair? V1697) (and (eq? (quote mode) (car V1697)) (and (pair? (cdr V1697)) (and (pair? (cdr (cdr V1697))) (and (eq? (quote +) (car (cdr (cdr V1697)))) (null? (cdr (cdr (cdr V1697))))))))) 2) ((and (pair? V1697) (and (eq? (quote mode) (car V1697)) (and (pair? (cdr V1697)) (and (pair? (cdr (cdr V1697))) (and (eq? (quote -) (car (cdr (cdr V1697)))) (null? (cdr (cdr (cdr V1697))))))))) 1) (#t (kl:shen.complexity (cons (quote mode) (cons V1697 (cons (quote +) (quote ())))))))) (quote shen.complexity))
(begin (register-function-arity (quote shen.product) 1) (define (kl:shen.product V1699) (cond ((null? V1699) 1) ((pair? V1699) (* (car V1699) (kl:shen.product (cdr V1699)))) (#t (kl:shen.f_error (quote shen.product))))) (quote shen.product))
(begin (register-function-arity (quote shen.s-prolog_literal) 1) (define (kl:shen.s-prolog_literal V1701) (cond ((and (pair? V1701) (and (eq? (quote is) (car V1701)) (and (pair? (cdr V1701)) (and (pair? (cdr (cdr V1701))) (null? (cdr (cdr (cdr V1701)))))))) (cons (quote bind) (cons (car (cdr V1701)) (cons (kl:shen.insert_deref (car (cdr (cdr V1701)))) (quote ()))))) ((and (pair? V1701) (and (eq? (quote when) (car V1701)) (and (pair? (cdr V1701)) (null? (cdr (cdr V1701)))))) (cons (quote fwhen) (cons (kl:shen.insert_deref (car (cdr V1701))) (quote ())))) ((and (pair? V1701) (and (eq? (quote bind) (car V1701)) (and (pair? (cdr V1701)) (and (pair? (cdr (cdr V1701))) (null? (cdr (cdr (cdr V1701)))))))) (cons (quote bind) (cons (car (cdr V1701)) (cons (kl:shen.insert_lazyderef (car (cdr (cdr V1701)))) (quote ()))))) ((and (pair? V1701) (and (eq? (quote fwhen) (car V1701)) (and (pair? (cdr V1701)) (null? (cdr (cdr V1701)))))) (cons (quote fwhen) (cons (kl:shen.insert_lazyderef (car (cdr V1701))) (quote ())))) ((pair? V1701) V1701) (#t (kl:shen.f_error (quote shen.s-prolog_literal))))) (quote shen.s-prolog_literal))
(begin (register-function-arity (quote shen.insert_deref) 1) (define (kl:shen.insert_deref V1703) (cond ((kl:variable? V1703) (cons (quote shen.deref) (cons V1703 (cons (quote ProcessN) (quote ()))))) ((pair? V1703) (cons (kl:shen.insert_deref (car V1703)) (kl:shen.insert_deref (cdr V1703)))) (#t V1703))) (quote shen.insert_deref))
(begin (register-function-arity (quote shen.insert_lazyderef) 1) (define (kl:shen.insert_lazyderef V1705) (cond ((kl:variable? V1705) (cons (quote shen.lazyderef) (cons V1705 (cons (quote ProcessN) (quote ()))))) ((pair? V1705) (cons (kl:shen.insert_lazyderef (car V1705)) (kl:shen.insert_lazyderef (cdr V1705)))) (#t V1705))) (quote shen.insert_lazyderef))
(begin (register-function-arity (quote shen.group_clauses) 1) (define (kl:shen.group_clauses V1707) (cond ((null? V1707) (quote ())) ((pair? V1707) (let ((Group (kl:shen.collect (lambda (X) (kl:shen.same_predicate? (car V1707) X)) V1707))) (let ((Rest (kl:difference V1707 Group))) (cons Group (kl:shen.group_clauses Rest))))) (#t (kl:shen.f_error (quote shen.group_clauses))))) (quote shen.group_clauses))
(begin (register-function-arity (quote shen.collect) 2) (define (kl:shen.collect V1712 V1713) (cond ((null? V1713) (quote ())) ((pair? V1713) (if (assert-boolean (V1712 (car V1713))) (cons (car V1713) (kl:shen.collect V1712 (cdr V1713))) (kl:shen.collect V1712 (cdr V1713)))) (#t (kl:shen.f_error (quote shen.collect))))) (quote shen.collect))
(begin (register-function-arity (quote shen.same_predicate?) 2) (define (kl:shen.same_predicate? V1732 V1733) (cond ((and (pair? V1732) (and (pair? (car V1732)) (and (pair? V1733) (pair? (car V1733))))) (kl:= (car (car V1732)) (car (car V1733)))) (#t (kl:shen.f_error (quote shen.same_predicate?))))) (quote shen.same_predicate?))
(begin (register-function-arity (quote shen.compile_prolog_procedure) 1) (define (kl:shen.compile_prolog_procedure V1735) (let ((F (kl:shen.procedure_name V1735))) (let ((Shen (kl:shen.clauses-to-shen F V1735))) Shen))) (quote shen.compile_prolog_procedure))
(begin (register-function-arity (quote shen.procedure_name) 1) (define (kl:shen.procedure_name V1749) (cond ((and (pair? V1749) (and (pair? (car V1749)) (pair? (car (car V1749))))) (car (car (car V1749)))) (#t (kl:shen.f_error (quote shen.procedure_name))))) (quote shen.procedure_name))
(begin (register-function-arity (quote shen.clauses-to-shen) 2) (define (kl:shen.clauses-to-shen V1752 V1753) (let ((Linear (kl:map (lambda (X) (kl:shen.linearise-clause X)) V1753))) (let ((Arity (kl:shen.prolog-aritycheck V1752 (kl:map (lambda (X) (kl:head X)) V1753)))) (let ((Parameters (kl:shen.parameters Arity))) (let ((AUM_instructions (kl:map (lambda (X) (kl:shen.aum X Parameters)) Linear))) (let ((Code (kl:shen.catch-cut (kl:shen.nest-disjunct (kl:map (lambda (X) (kl:shen.aum_to_shen X)) AUM_instructions))))) (let ((ShenDef (cons (quote define) (cons V1752 (kl:append Parameters (kl:append (cons (quote ProcessN) (cons (quote Continuation) (quote ()))) (cons (quote ->) (cons Code (quote ()))))))))) ShenDef))))))) (quote shen.clauses-to-shen))
(begin (register-function-arity (quote shen.catch-cut) 1) (define (kl:shen.catch-cut V1755) (cond ((kl:not (kl:shen.occurs? (quote cut) V1755)) V1755) (#t (cons (quote let) (cons (quote Throwcontrol) (cons (cons (quote shen.catchpoint) (quote ())) (cons (cons (quote shen.cutpoint) (cons (quote Throwcontrol) (cons V1755 (quote ())))) (quote ())))))))) (quote shen.catch-cut))
(begin (register-function-arity (quote shen.catchpoint) 0) (define (kl:shen.catchpoint) (kl:set (quote shen.*catch*) (+ 1 (kl:value (quote shen.*catch*))))) (quote shen.catchpoint))
(begin (register-function-arity (quote shen.cutpoint) 2) (define (kl:shen.cutpoint V1763 V1764) (cond ((kl:= V1764 V1763) #f) (#t V1764))) (quote shen.cutpoint))
(begin (register-function-arity (quote shen.nest-disjunct) 1) (define (kl:shen.nest-disjunct V1766) (cond ((and (pair? V1766) (null? (cdr V1766))) (car V1766)) ((pair? V1766) (kl:shen.lisp-or (car V1766) (kl:shen.nest-disjunct (cdr V1766)))) (#t (kl:shen.f_error (quote shen.nest-disjunct))))) (quote shen.nest-disjunct))
(begin (register-function-arity (quote shen.lisp-or) 2) (define (kl:shen.lisp-or V1769 V1770) (cons (quote let) (cons (quote Case) (cons V1769 (cons (cons (quote if) (cons (cons (quote =) (cons (quote Case) (cons #f (quote ())))) (cons V1770 (cons (quote Case) (quote ()))))) (quote ())))))) (quote shen.lisp-or))
(begin (register-function-arity (quote shen.prolog-aritycheck) 2) (define (kl:shen.prolog-aritycheck V1775 V1776) (cond ((and (pair? V1776) (null? (cdr V1776))) (- (kl:length (car V1776)) 1)) ((and (pair? V1776) (pair? (cdr V1776))) (if (kl:= (kl:length (car V1776)) (kl:length (car (cdr V1776)))) (kl:shen.prolog-aritycheck V1775 (cdr V1776)) (simple-error (string-append "arity error in prolog procedure " (kl:shen.app (cons V1775 (quote ())) "\n" (quote shen.a)))))) (#t (kl:shen.f_error (quote shen.prolog-aritycheck))))) (quote shen.prolog-aritycheck))
(begin (register-function-arity (quote shen.linearise-clause) 1) (define (kl:shen.linearise-clause V1778) (cond ((and (pair? V1778) (and (pair? (cdr V1778)) (and (eq? (quote :-) (car (cdr V1778))) (and (pair? (cdr (cdr V1778))) (null? (cdr (cdr (cdr V1778)))))))) (let ((Linear (kl:shen.linearise (cons (car V1778) (cdr (cdr V1778)))))) (kl:shen.clause_form Linear))) (#t (kl:shen.f_error (quote shen.linearise-clause))))) (quote shen.linearise-clause))
(begin (register-function-arity (quote shen.clause_form) 1) (define (kl:shen.clause_form V1780) (cond ((and (pair? V1780) (and (pair? (cdr V1780)) (null? (cdr (cdr V1780))))) (cons (kl:shen.explicit_modes (car V1780)) (cons (quote :-) (cons (kl:shen.cf_help (car (cdr V1780))) (quote ()))))) (#t (kl:shen.f_error (quote shen.clause_form))))) (quote shen.clause_form))
(begin (register-function-arity (quote shen.explicit_modes) 1) (define (kl:shen.explicit_modes V1782) (cond ((pair? V1782) (cons (car V1782) (kl:map (lambda (X) (kl:shen.em_help X)) (cdr V1782)))) (#t (kl:shen.f_error (quote shen.explicit_modes))))) (quote shen.explicit_modes))
(begin (register-function-arity (quote shen.em_help) 1) (define (kl:shen.em_help V1784) (cond ((and (pair? V1784) (and (eq? (quote mode) (car V1784)) (and (pair? (cdr V1784)) (and (pair? (cdr (cdr V1784))) (null? (cdr (cdr (cdr V1784)))))))) V1784) (#t (cons (quote mode) (cons V1784 (cons (quote +) (quote ()))))))) (quote shen.em_help))
(begin (register-function-arity (quote shen.cf_help) 1) (define (kl:shen.cf_help V1786) (cond ((and (pair? V1786) (and (eq? (quote where) (car V1786)) (and (pair? (cdr V1786)) (and (pair? (car (cdr V1786))) (and (eq? (quote =) (car (car (cdr V1786)))) (and (pair? (cdr (car (cdr V1786)))) (and (pair? (cdr (cdr (car (cdr V1786))))) (and (null? (cdr (cdr (cdr (car (cdr V1786)))))) (and (pair? (cdr (cdr V1786))) (null? (cdr (cdr (cdr V1786))))))))))))) (cons (cons (if (assert-boolean (kl:value (quote shen.*occurs*))) (quote unify!) (quote unify)) (cdr (car (cdr V1786)))) (kl:shen.cf_help (car (cdr (cdr V1786)))))) (#t V1786))) (quote shen.cf_help))
(begin (register-function-arity (quote occurs-check) 1) (define (kl:occurs-check V1792) (cond ((eq? (quote +) V1792) (kl:set (quote shen.*occurs*) #t)) ((eq? (quote -) V1792) (kl:set (quote shen.*occurs*) #f)) (#t (simple-error "occurs-check expects + or -\n")))) (quote occurs-check))
(begin (register-function-arity (quote shen.aum) 2) (define (kl:shen.aum V1795 V1796) (cond ((and (pair? V1795) (and (pair? (car V1795)) (and (pair? (cdr V1795)) (and (eq? (quote :-) (car (cdr V1795))) (and (pair? (cdr (cdr V1795))) (null? (cdr (cdr (cdr V1795))))))))) (let ((MuApplication (kl:shen.make_mu_application (cons (quote shen.mu) (cons (cdr (car V1795)) (cons (kl:shen.continuation_call (cdr (car V1795)) (car (cdr (cdr V1795)))) (quote ())))) V1796))) (kl:shen.mu_reduction MuApplication (quote +)))) (#t (kl:shen.f_error (quote shen.aum))))) (quote shen.aum))
(begin (register-function-arity (quote shen.continuation_call) 2) (define (kl:shen.continuation_call V1799 V1800) (let ((VTerms (cons (quote ProcessN) (kl:shen.extract_vars V1799)))) (let ((VBody (kl:shen.extract_vars V1800))) (let ((Free (kl:remove (quote Throwcontrol) (kl:difference VBody VTerms)))) (kl:shen.cc_help Free V1800))))) (quote shen.continuation_call))
(begin (register-function-arity (quote remove) 2) (define (kl:remove V1803 V1804) (kl:shen.remove-h V1803 V1804 (quote ()))) (quote remove))
(begin (register-function-arity (quote shen.remove-h) 3) (define (kl:shen.remove-h V1811 V1812 V1813) (cond ((null? V1812) (kl:reverse V1813)) ((and (pair? V1812) (kl:= (car V1812) V1811)) (kl:shen.remove-h (car V1812) (cdr V1812) V1813)) ((pair? V1812) (kl:shen.remove-h V1811 (cdr V1812) (cons (car V1812) V1813))) (#t (kl:shen.f_error (quote shen.remove-h))))) (quote shen.remove-h))
(begin (register-function-arity (quote shen.cc_help) 2) (define (kl:shen.cc_help V1816 V1817) (cond ((and (null? V1816) (null? V1817)) (cons (quote shen.pop) (cons (quote shen.the) (cons (quote shen.stack) (quote ()))))) ((null? V1817) (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons V1816 (cons (quote and) (cons (quote shen.then) (cons (cons (quote shen.pop) (cons (quote shen.the) (cons (quote shen.stack) (quote ())))) (quote ())))))))))) ((null? V1816) (cons (quote call) (cons (quote shen.the) (cons (quote shen.continuation) (cons V1817 (quote ())))))) (#t (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons V1816 (cons (quote and) (cons (quote shen.then) (cons (cons (quote call) (cons (quote shen.the) (cons (quote shen.continuation) (cons V1817 (quote ()))))) (quote ())))))))))))) (quote shen.cc_help))
(begin (register-function-arity (quote shen.make_mu_application) 2) (define (kl:shen.make_mu_application V1820 V1821) (cond ((and (pair? V1820) (and (eq? (quote shen.mu) (car V1820)) (and (pair? (cdr V1820)) (and (null? (car (cdr V1820))) (and (pair? (cdr (cdr V1820))) (and (null? (cdr (cdr (cdr V1820)))) (null? V1821))))))) (car (cdr (cdr V1820)))) ((and (pair? V1820) (and (eq? (quote shen.mu) (car V1820)) (and (pair? (cdr V1820)) (and (pair? (car (cdr V1820))) (and (pair? (cdr (cdr V1820))) (and (null? (cdr (cdr (cdr V1820)))) (pair? V1821))))))) (cons (cons (quote shen.mu) (cons (car (car (cdr V1820))) (cons (kl:shen.make_mu_application (cons (quote shen.mu) (cons (cdr (car (cdr V1820))) (cdr (cdr V1820)))) (cdr V1821)) (quote ())))) (cons (car V1821) (quote ())))) (#t (kl:shen.f_error (quote shen.make_mu_application))))) (quote shen.make_mu_application))
(begin (register-function-arity (quote shen.mu_reduction) 2) (define (kl:shen.mu_reduction V1830 V1831) (cond ((and (pair? V1830) (and (pair? (car V1830)) (and (eq? (quote shen.mu) (car (car V1830))) (and (pair? (cdr (car V1830))) (and (pair? (car (cdr (car V1830)))) (and (eq? (quote mode) (car (car (cdr (car V1830))))) (and (pair? (cdr (car (cdr (car V1830))))) (and (pair? (cdr (cdr (car (cdr (car V1830)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1830))))))) (and (pair? (cdr (cdr (car V1830)))) (and (null? (cdr (cdr (cdr (car V1830))))) (and (pair? (cdr V1830)) (null? (cdr (cdr V1830))))))))))))))) (kl:shen.mu_reduction (cons (cons (quote shen.mu) (cons (car (cdr (car (cdr (car V1830))))) (cdr (cdr (car V1830))))) (cdr V1830)) (car (cdr (cdr (car (cdr (car V1830)))))))) ((and (pair? V1830) (and (pair? (car V1830)) (and (eq? (quote shen.mu) (car (car V1830))) (and (pair? (cdr (car V1830))) (and (pair? (cdr (cdr (car V1830)))) (and (null? (cdr (cdr (cdr (car V1830))))) (and (pair? (cdr V1830)) (and (null? (cdr (cdr V1830))) (eq? (quote _) (car (cdr (car V1830)))))))))))) (kl:shen.mu_reduction (car (cdr (cdr (car V1830)))) V1831)) ((and (pair? V1830) (and (pair? (car V1830)) (and (eq? (quote shen.mu) (car (car V1830))) (and (pair? (cdr (car V1830))) (and (pair? (cdr (cdr (car V1830)))) (and (null? (cdr (cdr (cdr (car V1830))))) (and (pair? (cdr V1830)) (and (null? (cdr (cdr V1830))) (assert-boolean (kl:shen.ephemeral_variable? (car (cdr (car V1830))) (car (cdr V1830)))))))))))) (kl:subst (car (cdr V1830)) (car (cdr (car V1830))) (kl:shen.mu_reduction (car (cdr (cdr (car V1830)))) V1831))) ((and (pair? V1830) (and (pair? (car V1830)) (and (eq? (quote shen.mu) (car (car V1830))) (and (pair? (cdr (car V1830))) (and (pair? (cdr (cdr (car V1830)))) (and (null? (cdr (cdr (cdr (car V1830))))) (and (pair? (cdr V1830)) (and (null? (cdr (cdr V1830))) (kl:variable? (car (cdr (car V1830)))))))))))) (cons (quote let) (cons (car (cdr (car V1830))) (cons (quote shen.be) (cons (car (cdr V1830)) (cons (quote in) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1830)))) V1831) (quote ())))))))) ((and (pair? V1830) (and (pair? (car V1830)) (and (eq? (quote shen.mu) (car (car V1830))) (and (pair? (cdr (car V1830))) (and (pair? (cdr (cdr (car V1830)))) (and (null? (cdr (cdr (cdr (car V1830))))) (and (pair? (cdr V1830)) (and (null? (cdr (cdr V1830))) (and (eq? (quote -) V1831) (assert-boolean (kl:shen.prolog_constant? (car (cdr (car V1830)))))))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V1830))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote identical) (cons (quote shen.to) (cons (car (cdr (car V1830))) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1830)))) (quote -)) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))))) ((and (pair? V1830) (and (pair? (car V1830)) (and (eq? (quote shen.mu) (car (car V1830))) (and (pair? (cdr (car V1830))) (and (pair? (cdr (cdr (car V1830)))) (and (null? (cdr (cdr (cdr (car V1830))))) (and (pair? (cdr V1830)) (and (null? (cdr (cdr V1830))) (and (eq? (quote +) V1831) (assert-boolean (kl:shen.prolog_constant? (car (cdr (car V1830)))))))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V1830))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote identical) (cons (quote shen.to) (cons (car (cdr (car V1830))) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1830)))) (quote +)) (cons (quote shen.else) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.variable) (quote ()))))) (cons (quote shen.then) (cons (cons (quote bind) (cons Z (cons (quote shen.to) (cons (car (cdr (car V1830))) (cons (quote in) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1830)))) (quote +)) (quote ()))))))) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))) (quote ()))))))))) ((and (pair? V1830) (and (pair? (car V1830)) (and (eq? (quote shen.mu) (car (car V1830))) (and (pair? (cdr (car V1830))) (and (pair? (car (cdr (car V1830)))) (and (pair? (cdr (cdr (car V1830)))) (and (null? (cdr (cdr (cdr (car V1830))))) (and (pair? (cdr V1830)) (and (null? (cdr (cdr V1830))) (eq? (quote -) V1831)))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V1830))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.non-empty) (cons (quote list) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (cons (cons (quote shen.mu) (cons (car (car (cdr (car V1830)))) (cons (cons (cons (quote shen.mu) (cons (cdr (car (cdr (car V1830)))) (cdr (cdr (car V1830))))) (cons (cons (quote shen.the) (cons (quote tail) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote ())))) (cons (cons (quote shen.the) (cons (quote head) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote -)) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))))) ((and (pair? V1830) (and (pair? (car V1830)) (and (eq? (quote shen.mu) (car (car V1830))) (and (pair? (cdr (car V1830))) (and (pair? (car (cdr (car V1830)))) (and (pair? (cdr (cdr (car V1830)))) (and (null? (cdr (cdr (cdr (car V1830))))) (and (pair? (cdr V1830)) (and (null? (cdr (cdr V1830))) (eq? (quote +) V1831)))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V1830))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.non-empty) (cons (quote list) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (cons (cons (quote shen.mu) (cons (car (car (cdr (car V1830)))) (cons (cons (cons (quote shen.mu) (cons (cdr (car (cdr (car V1830)))) (cdr (cdr (car V1830))))) (cons (cons (quote shen.the) (cons (quote tail) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote ())))) (cons (cons (quote shen.the) (cons (quote head) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote +)) (cons (quote shen.else) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.variable) (quote ()))))) (cons (quote shen.then) (cons (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons (kl:shen.extract_vars (car (cdr (car V1830)))) (cons (quote and) (cons (quote shen.then) (cons (cons (quote bind) (cons Z (cons (quote shen.to) (cons (kl:shen.rcons_form (kl:shen.remove_modes (car (cdr (car V1830))))) (cons (quote in) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1830)))) (quote +)) (quote ()))))))) (quote ()))))))))) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))) (quote ()))))))))) (#t V1830))) (quote shen.mu_reduction))
(begin (register-function-arity (quote shen.rcons_form) 1) (define (kl:shen.rcons_form V1833) (cond ((pair? V1833) (cons (quote cons) (cons (kl:shen.rcons_form (car V1833)) (cons (kl:shen.rcons_form (cdr V1833)) (quote ()))))) (#t V1833))) (quote shen.rcons_form))
(begin (register-function-arity (quote shen.remove_modes) 1) (define (kl:shen.remove_modes V1835) (cond ((and (pair? V1835) (and (eq? (quote mode) (car V1835)) (and (pair? (cdr V1835)) (and (pair? (cdr (cdr V1835))) (and (eq? (quote +) (car (cdr (cdr V1835)))) (null? (cdr (cdr (cdr V1835))))))))) (kl:shen.remove_modes (car (cdr V1835)))) ((and (pair? V1835) (and (eq? (quote mode) (car V1835)) (and (pair? (cdr V1835)) (and (pair? (cdr (cdr V1835))) (and (eq? (quote -) (car (cdr (cdr V1835)))) (null? (cdr (cdr (cdr V1835))))))))) (kl:shen.remove_modes (car (cdr V1835)))) ((pair? V1835) (cons (kl:shen.remove_modes (car V1835)) (kl:shen.remove_modes (cdr V1835)))) (#t V1835))) (quote shen.remove_modes))
(begin (register-function-arity (quote shen.ephemeral_variable?) 2) (define (kl:shen.ephemeral_variable? V1838 V1839) (and (kl:variable? V1838) (kl:variable? V1839))) (quote shen.ephemeral_variable?))
(begin (register-function-arity (quote shen.prolog_constant?) 1) (define (kl:shen.prolog_constant? V1849) (cond ((pair? V1849) #f) (#t #t))) (quote shen.prolog_constant?))
(begin (register-function-arity (quote shen.aum_to_shen) 1) (define (kl:shen.aum_to_shen V1851) (cond ((and (pair? V1851) (and (eq? (quote let) (car V1851)) (and (pair? (cdr V1851)) (and (pair? (cdr (cdr V1851))) (and (eq? (quote shen.be) (car (cdr (cdr V1851)))) (and (pair? (cdr (cdr (cdr V1851)))) (and (pair? (cdr (cdr (cdr (cdr V1851))))) (and (eq? (quote in) (car (cdr (cdr (cdr (cdr V1851)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1851)))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr V1851)))))))))))))))) (cons (quote let) (cons (car (cdr V1851)) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr V1851))))) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr V1851))))))) (quote ())))))) ((and (pair? V1851) (and (eq? (quote shen.the) (car V1851)) (and (pair? (cdr V1851)) (and (eq? (quote shen.result) (car (cdr V1851))) (and (pair? (cdr (cdr V1851))) (and (eq? (quote shen.of) (car (cdr (cdr V1851)))) (and (pair? (cdr (cdr (cdr V1851)))) (and (eq? (quote shen.dereferencing) (car (cdr (cdr (cdr V1851))))) (and (pair? (cdr (cdr (cdr (cdr V1851))))) (null? (cdr (cdr (cdr (cdr (cdr V1851))))))))))))))) (cons (quote shen.lazyderef) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr V1851)))))) (cons (quote ProcessN) (quote ()))))) ((and (pair? V1851) (and (eq? (quote if) (car V1851)) (and (pair? (cdr V1851)) (and (pair? (cdr (cdr V1851))) (and (eq? (quote shen.then) (car (cdr (cdr V1851)))) (and (pair? (cdr (cdr (cdr V1851)))) (and (pair? (cdr (cdr (cdr (cdr V1851))))) (and (eq? (quote shen.else) (car (cdr (cdr (cdr (cdr V1851)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1851)))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr V1851)))))))))))))))) (cons (quote if) (cons (kl:shen.aum_to_shen (car (cdr V1851))) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr V1851))))) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr V1851))))))) (quote ())))))) ((and (pair? V1851) (and (pair? (cdr V1851)) (and (eq? (quote is) (car (cdr V1851))) (and (pair? (cdr (cdr V1851))) (and (eq? (quote shen.a) (car (cdr (cdr V1851)))) (and (pair? (cdr (cdr (cdr V1851)))) (and (eq? (quote shen.variable) (car (cdr (cdr (cdr V1851))))) (null? (cdr (cdr (cdr (cdr V1851)))))))))))) (cons (quote shen.pvar?) (cons (car V1851) (quote ())))) ((and (pair? V1851) (and (pair? (cdr V1851)) (and (eq? (quote is) (car (cdr V1851))) (and (pair? (cdr (cdr V1851))) (and (eq? (quote shen.a) (car (cdr (cdr V1851)))) (and (pair? (cdr (cdr (cdr V1851)))) (and (eq? (quote shen.non-empty) (car (cdr (cdr (cdr V1851))))) (and (pair? (cdr (cdr (cdr (cdr V1851))))) (and (eq? (quote list) (car (cdr (cdr (cdr (cdr V1851)))))) (null? (cdr (cdr (cdr (cdr (cdr V1851))))))))))))))) (cons (quote cons?) (cons (car V1851) (quote ())))) ((and (pair? V1851) (and (eq? (quote shen.rename) (car V1851)) (and (pair? (cdr V1851)) (and (eq? (quote shen.the) (car (cdr V1851))) (and (pair? (cdr (cdr V1851))) (and (eq? (quote shen.variables) (car (cdr (cdr V1851)))) (and (pair? (cdr (cdr (cdr V1851)))) (and (eq? (quote in) (car (cdr (cdr (cdr V1851))))) (and (pair? (cdr (cdr (cdr (cdr V1851))))) (and (null? (car (cdr (cdr (cdr (cdr V1851)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1851)))))) (and (eq? (quote and) (car (cdr (cdr (cdr (cdr (cdr V1851))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr V1851))))))) (and (eq? (quote shen.then) (car (cdr (cdr (cdr (cdr (cdr (cdr V1851)))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1851)))))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1851)))))))))))))))))))))))) (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1851)))))))))) ((and (pair? V1851) (and (eq? (quote shen.rename) (car V1851)) (and (pair? (cdr V1851)) (and (eq? (quote shen.the) (car (cdr V1851))) (and (pair? (cdr (cdr V1851))) (and (eq? (quote shen.variables) (car (cdr (cdr V1851)))) (and (pair? (cdr (cdr (cdr V1851)))) (and (eq? (quote in) (car (cdr (cdr (cdr V1851))))) (and (pair? (cdr (cdr (cdr (cdr V1851))))) (and (pair? (car (cdr (cdr (cdr (cdr V1851)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1851)))))) (and (eq? (quote and) (car (cdr (cdr (cdr (cdr (cdr V1851))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr V1851))))))) (and (eq? (quote shen.then) (car (cdr (cdr (cdr (cdr (cdr (cdr V1851)))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1851)))))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1851)))))))))))))))))))))))) (cons (quote let) (cons (car (car (cdr (cdr (cdr (cdr V1851)))))) (cons (cons (quote shen.newpv) (cons (quote ProcessN) (quote ()))) (cons (kl:shen.aum_to_shen (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons (cdr (car (cdr (cdr (cdr (cdr V1851)))))) (cdr (cdr (cdr (cdr (cdr V1851))))))))))) (quote ())))))) ((and (pair? V1851) (and (eq? (quote bind) (car V1851)) (and (pair? (cdr V1851)) (and (pair? (cdr (cdr V1851))) (and (eq? (quote shen.to) (car (cdr (cdr V1851)))) (and (pair? (cdr (cdr (cdr V1851)))) (and (pair? (cdr (cdr (cdr (cdr V1851))))) (and (eq? (quote in) (car (cdr (cdr (cdr (cdr V1851)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1851)))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr V1851)))))))))))))))) (cons (quote do) (cons (cons (quote shen.bindv) (cons (car (cdr V1851)) (cons (kl:shen.chwild (car (cdr (cdr (cdr V1851))))) (cons (quote ProcessN) (quote ()))))) (cons (cons (quote let) (cons (quote Result) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr V1851))))))) (cons (cons (quote do) (cons (cons (quote shen.unbindv) (cons (car (cdr V1851)) (cons (quote ProcessN) (quote ())))) (cons (quote Result) (quote ())))) (quote ()))))) (quote ()))))) ((and (pair? V1851) (and (pair? (cdr V1851)) (and (eq? (quote is) (car (cdr V1851))) (and (pair? (cdr (cdr V1851))) (and (eq? (quote identical) (car (cdr (cdr V1851)))) (and (pair? (cdr (cdr (cdr V1851)))) (and (eq? (quote shen.to) (car (cdr (cdr (cdr V1851))))) (and (pair? (cdr (cdr (cdr (cdr V1851))))) (null? (cdr (cdr (cdr (cdr (cdr V1851)))))))))))))) (cons (quote =) (cons (car (cdr (cdr (cdr (cdr V1851))))) (cons (car V1851) (quote ()))))) ((eq? (quote shen.failed!) V1851) #f) ((and (pair? V1851) (and (eq? (quote shen.the) (car V1851)) (and (pair? (cdr V1851)) (and (eq? (quote head) (car (cdr V1851))) (and (pair? (cdr (cdr V1851))) (and (eq? (quote shen.of) (car (cdr (cdr V1851)))) (and (pair? (cdr (cdr (cdr V1851)))) (null? (cdr (cdr (cdr (cdr V1851)))))))))))) (cons (quote hd) (cdr (cdr (cdr V1851))))) ((and (pair? V1851) (and (eq? (quote shen.the) (car V1851)) (and (pair? (cdr V1851)) (and (eq? (quote tail) (car (cdr V1851))) (and (pair? (cdr (cdr V1851))) (and (eq? (quote shen.of) (car (cdr (cdr V1851)))) (and (pair? (cdr (cdr (cdr V1851)))) (null? (cdr (cdr (cdr (cdr V1851)))))))))))) (cons (quote tl) (cdr (cdr (cdr V1851))))) ((and (pair? V1851) (and (eq? (quote shen.pop) (car V1851)) (and (pair? (cdr V1851)) (and (eq? (quote shen.the) (car (cdr V1851))) (and (pair? (cdr (cdr V1851))) (and (eq? (quote shen.stack) (car (cdr (cdr V1851)))) (null? (cdr (cdr (cdr V1851)))))))))) (cons (quote do) (cons (cons (quote shen.incinfs) (quote ())) (cons (cons (quote thaw) (cons (quote Continuation) (quote ()))) (quote ()))))) ((and (pair? V1851) (and (eq? (quote call) (car V1851)) (and (pair? (cdr V1851)) (and (eq? (quote shen.the) (car (cdr V1851))) (and (pair? (cdr (cdr V1851))) (and (eq? (quote shen.continuation) (car (cdr (cdr V1851)))) (and (pair? (cdr (cdr (cdr V1851)))) (null? (cdr (cdr (cdr (cdr V1851)))))))))))) (cons (quote do) (cons (cons (quote shen.incinfs) (quote ())) (cons (kl:shen.call_the_continuation (kl:shen.chwild (car (cdr (cdr (cdr V1851))))) (quote ProcessN) (quote Continuation)) (quote ()))))) (#t V1851))) (quote shen.aum_to_shen))
(begin (register-function-arity (quote shen.chwild) 1) (define (kl:shen.chwild V1853) (cond ((eq? V1853 (quote _)) (cons (quote shen.newpv) (cons (quote ProcessN) (quote ())))) ((pair? V1853) (kl:map (lambda (Z) (kl:shen.chwild Z)) V1853)) (#t V1853))) (quote shen.chwild))
(begin (register-function-arity (quote shen.newpv) 1) (define (kl:shen.newpv V1855) (let ((Count+1 (+ (vector-ref (kl:value (quote shen.*varcounter*)) V1855) 1))) (let ((IncVar (let ((_tmp (kl:value (quote shen.*varcounter*)))) (vector-set! _tmp V1855 Count+1) _tmp))) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V1855))) (let ((ResizeVectorIfNeeded (if (kl:= Count+1 (kl:limit Vector)) (kl:shen.resizeprocessvector V1855 Count+1) (quote shen.skip)))) (kl:shen.mk-pvar Count+1)))))) (quote shen.newpv))
(begin (register-function-arity (quote shen.resizeprocessvector) 2) (define (kl:shen.resizeprocessvector V1858 V1859) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V1858))) (let ((BigVector (kl:shen.resize-vector Vector (+ V1859 V1859) (quote shen.-null-)))) (let ((_tmp (kl:value (quote shen.*prologvectors*)))) (vector-set! _tmp V1858 BigVector) _tmp)))) (quote shen.resizeprocessvector))
(begin (register-function-arity (quote shen.resize-vector) 3) (define (kl:shen.resize-vector V1863 V1864 V1865) (let ((BigVector (let ((_tmp (make-vector (+ 1 V1864) (quote (quote shen.fail!))))) (vector-set! _tmp 0 V1864) _tmp))) (kl:shen.copy-vector V1863 BigVector (kl:limit V1863) V1864 V1865))) (quote shen.resize-vector))
(begin (register-function-arity (quote shen.copy-vector) 5) (define (kl:shen.copy-vector V1871 V1872 V1873 V1874 V1875) (kl:shen.copy-vector-stage-2 (+ 1 V1873) (+ V1874 1) V1875 (kl:shen.copy-vector-stage-1 1 V1871 V1872 (+ 1 V1873)))) (quote shen.copy-vector))
(begin (register-function-arity (quote shen.copy-vector-stage-1) 4) (define (kl:shen.copy-vector-stage-1 V1883 V1884 V1885 V1886) (cond ((kl:= V1886 V1883) V1885) (#t (kl:shen.copy-vector-stage-1 (+ 1 V1883) V1884 (let ((_tmp V1885)) (vector-set! _tmp V1883 (vector-ref V1884 V1883)) _tmp) V1886)))) (quote shen.copy-vector-stage-1))
(begin (register-function-arity (quote shen.copy-vector-stage-2) 4) (define (kl:shen.copy-vector-stage-2 V1894 V1895 V1896 V1897) (cond ((kl:= V1895 V1894) V1897) (#t (kl:shen.copy-vector-stage-2 (+ V1894 1) V1895 V1896 (let ((_tmp V1897)) (vector-set! _tmp V1894 V1896) _tmp))))) (quote shen.copy-vector-stage-2))
(begin (register-function-arity (quote shen.mk-pvar) 1) (define (kl:shen.mk-pvar V1899) (let ((_tmp (let ((_tmp (make-vector 2 (quote (quote shen.fail!))))) (vector-set! _tmp 0 (quote shen.pvar)) _tmp))) (vector-set! _tmp 1 V1899) _tmp)) (quote shen.mk-pvar))
(begin (register-function-arity (quote shen.pvar?) 1) (define (kl:shen.pvar? V1901) (and (vector? V1901) (eq? (kl:<-address/or V1901 0 (lambda () (quote shen.not-pvar))) (quote shen.pvar)))) (quote shen.pvar?))
(begin (register-function-arity (quote shen.bindv) 3) (define (kl:shen.bindv V1905 V1906 V1907) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V1907))) (let ((_tmp Vector)) (vector-set! _tmp (vector-ref V1905 1) V1906) _tmp))) (quote shen.bindv))
(begin (register-function-arity (quote shen.unbindv) 2) (define (kl:shen.unbindv V1910 V1911) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V1911))) (let ((_tmp Vector)) (vector-set! _tmp (vector-ref V1910 1) (quote shen.-null-)) _tmp))) (quote shen.unbindv))
(begin (register-function-arity (quote shen.incinfs) 0) (define (kl:shen.incinfs) (kl:set (quote shen.*infs*) (+ 1 (kl:value (quote shen.*infs*))))) (quote shen.incinfs))
(begin (register-function-arity (quote shen.call_the_continuation) 3) (define (kl:shen.call_the_continuation V1915 V1916 V1917) (cond ((and (pair? V1915) (and (pair? (car V1915)) (null? (cdr V1915)))) (cons (car (car V1915)) (kl:append (cdr (car V1915)) (cons V1916 (cons V1917 (quote ())))))) ((and (pair? V1915) (pair? (car V1915))) (let ((NewContinuation (kl:shen.newcontinuation (cdr V1915) V1916 V1917))) (cons (car (car V1915)) (kl:append (cdr (car V1915)) (cons V1916 (cons NewContinuation (quote ()))))))) (#t (kl:shen.f_error (quote shen.call_the_continuation))))) (quote shen.call_the_continuation))
(begin (register-function-arity (quote shen.newcontinuation) 3) (define (kl:shen.newcontinuation V1921 V1922 V1923) (cond ((null? V1921) V1923) ((and (pair? V1921) (pair? (car V1921))) (cons (quote freeze) (cons (cons (car (car V1921)) (kl:append (cdr (car V1921)) (cons V1922 (cons (kl:shen.newcontinuation (cdr V1921) V1922 V1923) (quote ()))))) (quote ())))) (#t (kl:shen.f_error (quote shen.newcontinuation))))) (quote shen.newcontinuation))
(begin (register-function-arity (quote return) 3) (define (kl:return V1931 V1932 V1933) (kl:shen.deref V1931 V1932)) (quote return))
(begin (register-function-arity (quote shen.measure&return) 3) (define (kl:shen.measure&return V1941 V1942 V1943) (begin (kl:shen.prhush (kl:shen.app (kl:value (quote shen.*infs*)) " inferences\n" (quote shen.a)) (kl:stoutput)) (kl:shen.deref V1941 V1942))) (quote shen.measure&return))
(begin (register-function-arity (quote unify) 4) (define (kl:unify V1948 V1949 V1950 V1951) (kl:shen.lzy= (kl:shen.lazyderef V1948 V1950) (kl:shen.lazyderef V1949 V1950) V1950 V1951)) (quote unify))
(begin (register-function-arity (quote shen.lzy=) 4) (define (kl:shen.lzy= V1973 V1974 V1975 V1976) (cond ((kl:= V1974 V1973) (kl:thaw V1976)) ((assert-boolean (kl:shen.pvar? V1973)) (kl:bind V1973 V1974 V1975 V1976)) ((assert-boolean (kl:shen.pvar? V1974)) (kl:bind V1974 V1973 V1975 V1976)) ((and (pair? V1973) (pair? V1974)) (kl:shen.lzy= (kl:shen.lazyderef (car V1973) V1975) (kl:shen.lazyderef (car V1974) V1975) V1975 (lambda () (kl:shen.lzy= (kl:shen.lazyderef (cdr V1973) V1975) (kl:shen.lazyderef (cdr V1974) V1975) V1975 V1976)))) (#t #f))) (quote shen.lzy=))
(begin (register-function-arity (quote shen.deref) 2) (define (kl:shen.deref V1979 V1980) (cond ((pair? V1979) (cons (kl:shen.deref (car V1979) V1980) (kl:shen.deref (cdr V1979) V1980))) (#t (if (assert-boolean (kl:shen.pvar? V1979)) (let ((Value (kl:shen.valvector V1979 V1980))) (if (eq? Value (quote shen.-null-)) V1979 (kl:shen.deref Value V1980))) V1979)))) (quote shen.deref))
(begin (register-function-arity (quote shen.lazyderef) 2) (define (kl:shen.lazyderef V1983 V1984) (if (assert-boolean (kl:shen.pvar? V1983)) (let ((Value (kl:shen.valvector V1983 V1984))) (if (eq? Value (quote shen.-null-)) V1983 (kl:shen.lazyderef Value V1984))) V1983)) (quote shen.lazyderef))
(begin (register-function-arity (quote shen.valvector) 2) (define (kl:shen.valvector V1987 V1988) (vector-ref (vector-ref (kl:value (quote shen.*prologvectors*)) V1988) (vector-ref V1987 1))) (quote shen.valvector))
(begin (register-function-arity (quote unify!) 4) (define (kl:unify! V1993 V1994 V1995 V1996) (kl:shen.lzy=! (kl:shen.lazyderef V1993 V1995) (kl:shen.lazyderef V1994 V1995) V1995 V1996)) (quote unify!))
(begin (register-function-arity (quote shen.lzy=!) 4) (define (kl:shen.lzy=! V2018 V2019 V2020 V2021) (cond ((kl:= V2019 V2018) (kl:thaw V2021)) ((and (assert-boolean (kl:shen.pvar? V2018)) (kl:not (kl:shen.occurs? V2018 (kl:shen.deref V2019 V2020)))) (kl:bind V2018 V2019 V2020 V2021)) ((and (assert-boolean (kl:shen.pvar? V2019)) (kl:not (kl:shen.occurs? V2019 (kl:shen.deref V2018 V2020)))) (kl:bind V2019 V2018 V2020 V2021)) ((and (pair? V2018) (pair? V2019)) (kl:shen.lzy=! (kl:shen.lazyderef (car V2018) V2020) (kl:shen.lazyderef (car V2019) V2020) V2020 (lambda () (kl:shen.lzy=! (kl:shen.lazyderef (cdr V2018) V2020) (kl:shen.lazyderef (cdr V2019) V2020) V2020 V2021)))) (#t #f))) (quote shen.lzy=!))
(begin (register-function-arity (quote shen.occurs?) 2) (define (kl:shen.occurs? V2033 V2034) (cond ((kl:= V2034 V2033) #t) ((pair? V2034) (or (assert-boolean (kl:shen.occurs? V2033 (car V2034))) (assert-boolean (kl:shen.occurs? V2033 (cdr V2034))))) (#t #f))) (quote shen.occurs?))
(begin (register-function-arity (quote identical) 4) (define (kl:identical V2039 V2040 V2041 V2042) (kl:shen.lzy== (kl:shen.lazyderef V2039 V2041) (kl:shen.lazyderef V2040 V2041) V2041 V2042)) (quote identical))
(begin (register-function-arity (quote shen.lzy==) 4) (define (kl:shen.lzy== V2064 V2065 V2066 V2067) (cond ((kl:= V2065 V2064) (kl:thaw V2067)) ((and (pair? V2064) (pair? V2065)) (kl:shen.lzy== (kl:shen.lazyderef (car V2064) V2066) (kl:shen.lazyderef (car V2065) V2066) V2066 (lambda () (kl:shen.lzy== (cdr V2064) (cdr V2065) V2066 V2067)))) (#t #f))) (quote shen.lzy==))
(begin (register-function-arity (quote shen.pvar) 1) (define (kl:shen.pvar V2069) (string-append "Var" (kl:shen.app (vector-ref V2069 1) "" (quote shen.a)))) (quote shen.pvar))
(begin (register-function-arity (quote bind) 4) (define (kl:bind V2074 V2075 V2076 V2077) (begin (kl:shen.bindv V2074 V2075 V2076) (let ((Result (kl:thaw V2077))) (begin (kl:shen.unbindv V2074 V2076) Result)))) (quote bind))
(begin (register-function-arity (quote fwhen) 3) (define (kl:fwhen V2095 V2096 V2097) (cond ((kl:= #t V2095) (kl:thaw V2097)) ((kl:= #f V2095) #f) (#t (simple-error (string-append "fwhen expects a boolean: not " (kl:shen.app V2095 "%" (quote shen.s))))))) (quote fwhen))
(begin (register-function-arity (quote call) 3) (define (kl:call V2113 V2114 V2115) (cond ((pair? V2113) (kl:shen.call-help (kl:function (kl:shen.lazyderef (car V2113) V2114)) (cdr V2113) V2114 V2115)) (#t #f))) (quote call))
(begin (register-function-arity (quote shen.call-help) 4) (define (kl:shen.call-help V2120 V2121 V2122 V2123) (cond ((null? V2121) ((V2120 V2122) V2123)) ((pair? V2121) (kl:shen.call-help (V2120 (car V2121)) (cdr V2121) V2122 V2123)) (#t (kl:shen.f_error (quote shen.call-help))))) (quote shen.call-help))
(begin (register-function-arity (quote shen.intprolog) 1) (define (kl:shen.intprolog V2125) (cond ((and (pair? V2125) (pair? (car V2125))) (let ((ProcessN (kl:shen.start-new-prolog-process))) (kl:shen.intprolog-help (car (car V2125)) (kl:shen.insert-prolog-variables (cons (cdr (car V2125)) (cons (cdr V2125) (quote ()))) ProcessN) ProcessN))) (#t (kl:shen.f_error (quote shen.intprolog))))) (quote shen.intprolog))
(begin (register-function-arity (quote shen.intprolog-help) 3) (define (kl:shen.intprolog-help V2129 V2130 V2131) (cond ((and (pair? V2130) (and (pair? (cdr V2130)) (null? (cdr (cdr V2130))))) (kl:shen.intprolog-help-help V2129 (car V2130) (car (cdr V2130)) V2131)) (#t (kl:shen.f_error (quote shen.intprolog-help))))) (quote shen.intprolog-help))
(begin (register-function-arity (quote shen.intprolog-help-help) 4) (define (kl:shen.intprolog-help-help V2136 V2137 V2138 V2139) (cond ((null? V2137) ((V2136 V2139) (lambda () (kl:shen.call-rest V2138 V2139)))) ((pair? V2137) (kl:shen.intprolog-help-help (V2136 (car V2137)) (cdr V2137) V2138 V2139)) (#t (kl:shen.f_error (quote shen.intprolog-help-help))))) (quote shen.intprolog-help-help))
(begin (register-function-arity (quote shen.call-rest) 2) (define (kl:shen.call-rest V2144 V2145) (cond ((null? V2144) #t) ((and (pair? V2144) (and (pair? (car V2144)) (pair? (cdr (car V2144))))) (kl:shen.call-rest (cons (cons ((car (car V2144)) (car (cdr (car V2144)))) (cdr (cdr (car V2144)))) (cdr V2144)) V2145)) ((and (pair? V2144) (and (pair? (car V2144)) (null? (cdr (car V2144))))) (((car (car V2144)) V2145) (lambda () (kl:shen.call-rest (cdr V2144) V2145)))) (#t (kl:shen.f_error (quote shen.call-rest))))) (quote shen.call-rest))
(begin (register-function-arity (quote shen.start-new-prolog-process) 0) (define (kl:shen.start-new-prolog-process) (let ((IncrementProcessCounter (kl:set (quote shen.*process-counter*) (+ 1 (kl:value (quote shen.*process-counter*)))))) (kl:shen.initialise-prolog IncrementProcessCounter))) (quote shen.start-new-prolog-process))
(begin (register-function-arity (quote shen.insert-prolog-variables) 2) (define (kl:shen.insert-prolog-variables V2148 V2149) (kl:shen.insert-prolog-variables-help V2148 (kl:shen.flatten V2148) V2149)) (quote shen.insert-prolog-variables))
(begin (register-function-arity (quote shen.insert-prolog-variables-help) 3) (define (kl:shen.insert-prolog-variables-help V2157 V2158 V2159) (cond ((null? V2158) V2157) ((and (pair? V2158) (kl:variable? (car V2158))) (let ((V (kl:shen.newpv V2159))) (let ((XV/Y (kl:subst V (car V2158) V2157))) (let ((Z-Y (kl:remove (car V2158) (cdr V2158)))) (kl:shen.insert-prolog-variables-help XV/Y Z-Y V2159))))) ((pair? V2158) (kl:shen.insert-prolog-variables-help V2157 (cdr V2158) V2159)) (#t (kl:shen.f_error (quote shen.insert-prolog-variables-help))))) (quote shen.insert-prolog-variables-help))
(begin (register-function-arity (quote shen.initialise-prolog) 1) (define (kl:shen.initialise-prolog V2161) (let ((Vector (let ((_tmp (kl:value (quote shen.*prologvectors*)))) (vector-set! _tmp V2161 (kl:shen.fillvector (kl:vector 10) 1 10 (quote shen.-null-))) _tmp))) (let ((Counter (let ((_tmp (kl:value (quote shen.*varcounter*)))) (vector-set! _tmp V2161 1) _tmp))) V2161))) (quote shen.initialise-prolog))
