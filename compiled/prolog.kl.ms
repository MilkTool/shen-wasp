"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.<defprolog>) 1) (define (kl:shen.<defprolog> V1787) (let ((Parse_shen.<predicate*> (kl:shen.<predicate*> V1787))) (if (kl:not (kl:= (kl:fail) Parse_shen.<predicate*>)) (let ((Parse_shen.<clauses*> (kl:shen.<clauses*> Parse_shen.<predicate*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<clauses*>)) (kl:shen.pair (car Parse_shen.<clauses*>) (car (kl:shen.prolog->shen (kl:map (lambda (Parse_X) (kl:shen.insert-predicate (kl:shen.hdtl Parse_shen.<predicate*>) Parse_X)) (kl:shen.hdtl Parse_shen.<clauses*>))))) (kl:fail))) (kl:fail)))) (quote shen.<defprolog>))
(begin (register-function-arity (quote shen.prolog-error) 2) (define (kl:shen.prolog-error V1796 V1797) (cond ((and (pair? V1797) (and (pair? (cdr V1797)) (null? (cdr (cdr V1797))))) (simple-error (string-append "prolog syntax error in " (kl:shen.app V1796 (string-append " here:\n\n " (kl:shen.app (kl:shen.next-50 50 (car V1797)) "\n" (quote shen.a))) (quote shen.a))))) (#t (simple-error (string-append "prolog syntax error in " (kl:shen.app V1796 "\n" (quote shen.a))))))) (quote shen.prolog-error))
(begin (register-function-arity (quote shen.next-50) 2) (define (kl:shen.next-50 V1804 V1805) (cond ((null? V1805) "") ((kl:= 0 V1804) "") ((pair? V1805) (string-append (kl:shen.decons-string (car V1805)) (kl:shen.next-50 (- V1804 1) (cdr V1805)))) (#t (kl:shen.f_error (quote shen.next-50))))) (quote shen.next-50))
(begin (register-function-arity (quote shen.decons-string) 1) (define (kl:shen.decons-string V1807) (cond ((and (pair? V1807) (and (eq? (quote cons) (car V1807)) (and (pair? (cdr V1807)) (and (pair? (cdr (cdr V1807))) (null? (cdr (cdr (cdr V1807)))))))) (kl:shen.app (kl:shen.eval-cons V1807) " " (quote shen.s))) (#t (kl:shen.app V1807 " " (quote shen.r))))) (quote shen.decons-string))
(begin (register-function-arity (quote shen.insert-predicate) 2) (define (kl:shen.insert-predicate V1810 V1811) (cond ((and (pair? V1811) (and (pair? (cdr V1811)) (null? (cdr (cdr V1811))))) (cons (cons V1810 (car V1811)) (cons (quote :-) (cdr V1811)))) (#t (kl:shen.f_error (quote shen.insert-predicate))))) (quote shen.insert-predicate))
(begin (register-function-arity (quote shen.<predicate*>) 1) (define (kl:shen.<predicate*> V1813) (if (pair? (car V1813)) (let ((Parse_X (car (car V1813)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1813)) (kl:shen.hdtl V1813))) Parse_X)) (kl:fail))) (quote shen.<predicate*>))
(begin (register-function-arity (quote shen.<clauses*>) 1) (define (kl:shen.<clauses*> V1815) (let ((YaccParse (let ((Parse_shen.<clause*> (kl:shen.<clause*> V1815))) (if (kl:not (kl:= (kl:fail) Parse_shen.<clause*>)) (let ((Parse_shen.<clauses*> (kl:shen.<clauses*> Parse_shen.<clause*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<clauses*>)) (kl:shen.pair (car Parse_shen.<clauses*>) (cons (kl:shen.hdtl Parse_shen.<clause*>) (kl:shen.hdtl Parse_shen.<clauses*>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1815))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<clauses*>))
(begin (register-function-arity (quote shen.<clause*>) 1) (define (kl:shen.<clause*> V1817) (let ((Parse_shen.<head*> (kl:shen.<head*> V1817))) (if (kl:not (kl:= (kl:fail) Parse_shen.<head*>)) (if (and (pair? (car Parse_shen.<head*>)) (eq? (quote <--) (car (car Parse_shen.<head*>)))) (let ((Parse_shen.<body*> (kl:shen.<body*> (kl:shen.pair (cdr (car Parse_shen.<head*>)) (kl:shen.hdtl Parse_shen.<head*>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<body*>)) (let ((Parse_shen.<end*> (kl:shen.<end*> Parse_shen.<body*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<end*>)) (kl:shen.pair (car Parse_shen.<end*>) (cons (kl:shen.hdtl Parse_shen.<head*>) (cons (kl:shen.hdtl Parse_shen.<body*>) (quote ())))) (kl:fail))) (kl:fail))) (kl:fail)) (kl:fail)))) (quote shen.<clause*>))
(begin (register-function-arity (quote shen.<head*>) 1) (define (kl:shen.<head*> V1819) (let ((YaccParse (let ((Parse_shen.<term*> (kl:shen.<term*> V1819))) (if (kl:not (kl:= (kl:fail) Parse_shen.<term*>)) (let ((Parse_shen.<head*> (kl:shen.<head*> Parse_shen.<term*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<head*>)) (kl:shen.pair (car Parse_shen.<head*>) (cons (kl:shen.hdtl Parse_shen.<term*>) (kl:shen.hdtl Parse_shen.<head*>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1819))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<head*>))
(begin (register-function-arity (quote shen.<term*>) 1) (define (kl:shen.<term*> V1821) (if (pair? (car V1821)) (let ((Parse_X (car (car V1821)))) (if (and (kl:not (eq? (quote <--) Parse_X)) (assert-boolean (kl:shen.legitimate-term? Parse_X))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1821)) (kl:shen.hdtl V1821))) (kl:shen.eval-cons Parse_X)) (kl:fail))) (kl:fail))) (quote shen.<term*>))
(begin (register-function-arity (quote shen.legitimate-term?) 1) (define (kl:shen.legitimate-term? V1827) (cond ((and (pair? V1827) (and (eq? (quote cons) (car V1827)) (and (pair? (cdr V1827)) (and (pair? (cdr (cdr V1827))) (null? (cdr (cdr (cdr V1827)))))))) (and (assert-boolean (kl:shen.legitimate-term? (car (cdr V1827)))) (assert-boolean (kl:shen.legitimate-term? (car (cdr (cdr V1827))))))) ((and (pair? V1827) (and (eq? (quote mode) (car V1827)) (and (pair? (cdr V1827)) (and (pair? (cdr (cdr V1827))) (and (eq? (quote +) (car (cdr (cdr V1827)))) (null? (cdr (cdr (cdr V1827))))))))) (kl:shen.legitimate-term? (car (cdr V1827)))) ((and (pair? V1827) (and (eq? (quote mode) (car V1827)) (and (pair? (cdr V1827)) (and (pair? (cdr (cdr V1827))) (and (eq? (quote -) (car (cdr (cdr V1827)))) (null? (cdr (cdr (cdr V1827))))))))) (kl:shen.legitimate-term? (car (cdr V1827)))) ((pair? V1827) #f) (#t #t))) (quote shen.legitimate-term?))
(begin (register-function-arity (quote shen.eval-cons) 1) (define (kl:shen.eval-cons V1829) (cond ((and (pair? V1829) (and (eq? (quote cons) (car V1829)) (and (pair? (cdr V1829)) (and (pair? (cdr (cdr V1829))) (null? (cdr (cdr (cdr V1829)))))))) (cons (kl:shen.eval-cons (car (cdr V1829))) (kl:shen.eval-cons (car (cdr (cdr V1829)))))) ((and (pair? V1829) (and (eq? (quote mode) (car V1829)) (and (pair? (cdr V1829)) (and (pair? (cdr (cdr V1829))) (null? (cdr (cdr (cdr V1829)))))))) (cons (quote mode) (cons (kl:shen.eval-cons (car (cdr V1829))) (cdr (cdr V1829))))) (#t V1829))) (quote shen.eval-cons))
(begin (register-function-arity (quote shen.<body*>) 1) (define (kl:shen.<body*> V1831) (let ((YaccParse (let ((Parse_shen.<literal*> (kl:shen.<literal*> V1831))) (if (kl:not (kl:= (kl:fail) Parse_shen.<literal*>)) (let ((Parse_shen.<body*> (kl:shen.<body*> Parse_shen.<literal*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<body*>)) (kl:shen.pair (car Parse_shen.<body*>) (cons (kl:shen.hdtl Parse_shen.<literal*>) (kl:shen.hdtl Parse_shen.<body*>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1831))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<body*>))
(begin (register-function-arity (quote shen.<literal*>) 1) (define (kl:shen.<literal*> V1833) (let ((YaccParse (if (and (pair? (car V1833)) (eq? (quote !) (car (car V1833)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1833)) (kl:shen.hdtl V1833))) (cons (quote cut) (cons (kl:intern "Throwcontrol") (quote ())))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (if (pair? (car V1833)) (let ((Parse_X (car (car V1833)))) (if (pair? Parse_X) (kl:shen.pair (car (kl:shen.pair (cdr (car V1833)) (kl:shen.hdtl V1833))) Parse_X) (kl:fail))) (kl:fail)) YaccParse))) (quote shen.<literal*>))
(begin (register-function-arity (quote shen.<end*>) 1) (define (kl:shen.<end*> V1835) (if (pair? (car V1835)) (let ((Parse_X (car (car V1835)))) (if (eq? Parse_X (quote _waspvm_sc_)) (kl:shen.pair (car (kl:shen.pair (cdr (car V1835)) (kl:shen.hdtl V1835))) Parse_X) (kl:fail))) (kl:fail))) (quote shen.<end*>))
(begin (register-function-arity (quote cut) 3) (define (kl:cut V1839 V1840 V1841) (let ((Result (kl:thaw V1841))) (if (kl:= Result #f) V1839 Result))) (quote cut))
(begin (register-function-arity (quote shen.insert_modes) 1) (define (kl:shen.insert_modes V1843) (cond ((and (pair? V1843) (and (eq? (quote mode) (car V1843)) (and (pair? (cdr V1843)) (and (pair? (cdr (cdr V1843))) (null? (cdr (cdr (cdr V1843)))))))) V1843) ((null? V1843) (quote ())) ((pair? V1843) (cons (cons (quote mode) (cons (car V1843) (cons (quote +) (quote ())))) (cons (quote mode) (cons (kl:shen.insert_modes (cdr V1843)) (cons (quote -) (quote ())))))) (#t V1843))) (quote shen.insert_modes))
(begin (register-function-arity (quote shen.s-prolog) 1) (define (kl:shen.s-prolog V1845) (kl:map (lambda (X) (kl:eval X)) (kl:shen.prolog->shen V1845))) (quote shen.s-prolog))
(begin (register-function-arity (quote shen.prolog->shen) 1) (define (kl:shen.prolog->shen V1847) (kl:map (lambda (X) (kl:shen.compile_prolog_procedure X)) (kl:shen.group_clauses (kl:map (lambda (X) (kl:shen.s-prolog_clause X)) (kl:mapcan (lambda (X) (kl:shen.head_abstraction X)) V1847))))) (quote shen.prolog->shen))
(begin (register-function-arity (quote shen.s-prolog_clause) 1) (define (kl:shen.s-prolog_clause V1849) (cond ((and (pair? V1849) (and (pair? (cdr V1849)) (and (eq? (quote :-) (car (cdr V1849))) (and (pair? (cdr (cdr V1849))) (null? (cdr (cdr (cdr V1849)))))))) (cons (car V1849) (cons (quote :-) (cons (kl:map (lambda (X) (kl:shen.s-prolog_literal X)) (car (cdr (cdr V1849)))) (quote ()))))) (#t (kl:shen.f_error (quote shen.s-prolog_clause))))) (quote shen.s-prolog_clause))
(begin (register-function-arity (quote shen.head_abstraction) 1) (define (kl:shen.head_abstraction V1851) (cond ((and (pair? V1851) (and (pair? (cdr V1851)) (and (eq? (quote :-) (car (cdr V1851))) (and (pair? (cdr (cdr V1851))) (and (null? (cdr (cdr (cdr V1851)))) (assert-boolean (guard (lambda (_) #f) (< (kl:shen.complexity_head (car V1851)) (kl:value (quote shen.*maxcomplexity*)))))))))) (cons V1851 (quote ()))) ((and (pair? V1851) (and (pair? (car V1851)) (and (pair? (cdr V1851)) (and (eq? (quote :-) (car (cdr V1851))) (and (pair? (cdr (cdr V1851))) (null? (cdr (cdr (cdr V1851))))))))) (let ((Terms (kl:map (lambda (Y) (kl:gensym (quote V))) (cdr (car V1851))))) (let ((XTerms (kl:shen.rcons_form (kl:shen.remove_modes (cdr (car V1851)))))) (let ((Literal (cons (quote unify) (cons (kl:shen.cons_form Terms) (cons XTerms (quote ())))))) (let ((Clause (cons (cons (car (car V1851)) Terms) (cons (quote :-) (cons (cons Literal (car (cdr (cdr V1851)))) (quote ())))))) (cons Clause (quote ()))))))) (#t (kl:shen.f_error (quote shen.head_abstraction))))) (quote shen.head_abstraction))
(begin (register-function-arity (quote shen.complexity_head) 1) (define (kl:shen.complexity_head V1857) (cond ((pair? V1857) (kl:shen.product (kl:map (lambda (X) (kl:shen.complexity X)) (cdr V1857)))) (#t (kl:shen.f_error (quote shen.complexity_head))))) (quote shen.complexity_head))
(begin (register-function-arity (quote shen.safe-*) 2) (define (kl:shen.safe-* V1860 V1861) (let ((M (* V1860 V1861))) (if (and (kl:not (kl:= V1860 0)) (kl:not (kl:= (/ M V1860) V1861))) (simple-error "Integer overflow in safe-*") M))) (quote shen.safe-*))
(begin (register-function-arity (quote shen.complexity) 1) (define (kl:shen.complexity V1870) (cond ((and (pair? V1870) (and (eq? (quote mode) (car V1870)) (and (pair? (cdr V1870)) (and (pair? (car (cdr V1870))) (and (eq? (quote mode) (car (car (cdr V1870)))) (and (pair? (cdr (car (cdr V1870)))) (and (pair? (cdr (cdr (car (cdr V1870))))) (and (null? (cdr (cdr (cdr (car (cdr V1870)))))) (and (pair? (cdr (cdr V1870))) (null? (cdr (cdr (cdr V1870))))))))))))) (kl:shen.complexity (car (cdr V1870)))) ((and (pair? V1870) (and (eq? (quote mode) (car V1870)) (and (pair? (cdr V1870)) (and (pair? (car (cdr V1870))) (and (pair? (cdr (cdr V1870))) (and (eq? (quote +) (car (cdr (cdr V1870)))) (null? (cdr (cdr (cdr V1870)))))))))) (kl:shen.safe-* 2 (kl:shen.safe-* (kl:shen.complexity (cons (quote mode) (cons (car (car (cdr V1870))) (cdr (cdr V1870))))) (kl:shen.complexity (cons (quote mode) (cons (cdr (car (cdr V1870))) (cdr (cdr V1870)))))))) ((and (pair? V1870) (and (eq? (quote mode) (car V1870)) (and (pair? (cdr V1870)) (and (pair? (car (cdr V1870))) (and (pair? (cdr (cdr V1870))) (and (eq? (quote -) (car (cdr (cdr V1870)))) (null? (cdr (cdr (cdr V1870)))))))))) (kl:shen.safe-* (kl:shen.complexity (cons (quote mode) (cons (car (car (cdr V1870))) (cdr (cdr V1870))))) (kl:shen.complexity (cons (quote mode) (cons (cdr (car (cdr V1870))) (cdr (cdr V1870))))))) ((and (pair? V1870) (and (eq? (quote mode) (car V1870)) (and (pair? (cdr V1870)) (and (pair? (cdr (cdr V1870))) (and (null? (cdr (cdr (cdr V1870)))) (kl:variable? (car (cdr V1870)))))))) 1) ((and (pair? V1870) (and (eq? (quote mode) (car V1870)) (and (pair? (cdr V1870)) (and (pair? (cdr (cdr V1870))) (and (eq? (quote +) (car (cdr (cdr V1870)))) (null? (cdr (cdr (cdr V1870))))))))) 2) ((and (pair? V1870) (and (eq? (quote mode) (car V1870)) (and (pair? (cdr V1870)) (and (pair? (cdr (cdr V1870))) (and (eq? (quote -) (car (cdr (cdr V1870)))) (null? (cdr (cdr (cdr V1870))))))))) 1) (#t (kl:shen.complexity (cons (quote mode) (cons V1870 (cons (quote +) (quote ())))))))) (quote shen.complexity))
(begin (register-function-arity (quote shen.product) 1) (define (kl:shen.product V1872) (cond ((null? V1872) 1) ((pair? V1872) (kl:shen.safe-* (car V1872) (kl:shen.product (cdr V1872)))) (#t (kl:shen.f_error (quote shen.product))))) (quote shen.product))
(begin (register-function-arity (quote shen.s-prolog_literal) 1) (define (kl:shen.s-prolog_literal V1874) (cond ((and (pair? V1874) (and (eq? (quote is) (car V1874)) (and (pair? (cdr V1874)) (and (pair? (cdr (cdr V1874))) (null? (cdr (cdr (cdr V1874)))))))) (cons (quote bind) (cons (car (cdr V1874)) (cons (kl:shen.insert_deref (car (cdr (cdr V1874)))) (quote ()))))) ((and (pair? V1874) (and (eq? (quote when) (car V1874)) (and (pair? (cdr V1874)) (null? (cdr (cdr V1874)))))) (cons (quote fwhen) (cons (kl:shen.insert_deref (car (cdr V1874))) (quote ())))) ((and (pair? V1874) (and (eq? (quote bind) (car V1874)) (and (pair? (cdr V1874)) (and (pair? (cdr (cdr V1874))) (null? (cdr (cdr (cdr V1874)))))))) (cons (quote bind) (cons (car (cdr V1874)) (cons (kl:shen.insert_lazyderef (car (cdr (cdr V1874)))) (quote ()))))) ((and (pair? V1874) (and (eq? (quote fwhen) (car V1874)) (and (pair? (cdr V1874)) (null? (cdr (cdr V1874)))))) (cons (quote fwhen) (cons (kl:shen.insert_lazyderef (car (cdr V1874))) (quote ())))) ((pair? V1874) V1874) (#t (kl:shen.f_error (quote shen.s-prolog_literal))))) (quote shen.s-prolog_literal))
(begin (register-function-arity (quote shen.insert_deref) 1) (define (kl:shen.insert_deref V1876) (cond ((kl:variable? V1876) (cons (quote shen.deref) (cons V1876 (cons (quote ProcessN) (quote ()))))) ((pair? V1876) (cons (kl:shen.insert_deref (car V1876)) (kl:shen.insert_deref (cdr V1876)))) (#t V1876))) (quote shen.insert_deref))
(begin (register-function-arity (quote shen.insert_lazyderef) 1) (define (kl:shen.insert_lazyderef V1878) (cond ((kl:variable? V1878) (cons (quote shen.lazyderef) (cons V1878 (cons (quote ProcessN) (quote ()))))) ((pair? V1878) (cons (kl:shen.insert_lazyderef (car V1878)) (kl:shen.insert_lazyderef (cdr V1878)))) (#t V1878))) (quote shen.insert_lazyderef))
(begin (register-function-arity (quote shen.group_clauses) 1) (define (kl:shen.group_clauses V1880) (cond ((null? V1880) (quote ())) ((pair? V1880) (let ((Group (kl:shen.collect (lambda (X) (kl:shen.same_predicate? (car V1880) X)) V1880))) (let ((Rest (kl:difference V1880 Group))) (cons Group (kl:shen.group_clauses Rest))))) (#t (kl:shen.f_error (quote shen.group_clauses))))) (quote shen.group_clauses))
(begin (register-function-arity (quote shen.collect) 2) (define (kl:shen.collect V1885 V1886) (cond ((null? V1886) (quote ())) ((pair? V1886) (if (assert-boolean (V1885 (car V1886))) (cons (car V1886) (kl:shen.collect V1885 (cdr V1886))) (kl:shen.collect V1885 (cdr V1886)))) (#t (kl:shen.f_error (quote shen.collect))))) (quote shen.collect))
(begin (register-function-arity (quote shen.same_predicate?) 2) (define (kl:shen.same_predicate? V1905 V1906) (cond ((and (pair? V1905) (and (pair? (car V1905)) (and (pair? V1906) (pair? (car V1906))))) (kl:= (car (car V1905)) (car (car V1906)))) (#t (kl:shen.f_error (quote shen.same_predicate?))))) (quote shen.same_predicate?))
(begin (register-function-arity (quote shen.compile_prolog_procedure) 1) (define (kl:shen.compile_prolog_procedure V1908) (let ((F (kl:shen.procedure_name V1908))) (let ((Shen (kl:shen.clauses-to-shen F V1908))) Shen))) (quote shen.compile_prolog_procedure))
(begin (register-function-arity (quote shen.procedure_name) 1) (define (kl:shen.procedure_name V1922) (cond ((and (pair? V1922) (and (pair? (car V1922)) (pair? (car (car V1922))))) (car (car (car V1922)))) (#t (kl:shen.f_error (quote shen.procedure_name))))) (quote shen.procedure_name))
(begin (register-function-arity (quote shen.clauses-to-shen) 2) (define (kl:shen.clauses-to-shen V1925 V1926) (let ((Linear (kl:map (lambda (X) (kl:shen.linearise-clause X)) V1926))) (let ((Arity (kl:shen.prolog-aritycheck V1925 (kl:map (lambda (X) (kl:head X)) V1926)))) (let ((Parameters (kl:shen.parameters Arity))) (let ((AUM_instructions (kl:map (lambda (X) (kl:shen.aum X Parameters)) Linear))) (let ((Code (kl:shen.catch-cut (kl:shen.nest-disjunct (kl:map (lambda (X) (kl:shen.aum_to_shen X)) AUM_instructions))))) (let ((ShenDef (cons (quote define) (cons V1925 (kl:append Parameters (kl:append (cons (quote ProcessN) (cons (quote Continuation) (quote ()))) (cons (quote ->) (cons Code (quote ()))))))))) ShenDef))))))) (quote shen.clauses-to-shen))
(begin (register-function-arity (quote shen.catch-cut) 1) (define (kl:shen.catch-cut V1928) (cond ((kl:not (kl:shen.occurs? (quote cut) V1928)) V1928) (#t (cons (quote let) (cons (quote Throwcontrol) (cons (cons (quote shen.catchpoint) (quote ())) (cons (cons (quote shen.cutpoint) (cons (quote Throwcontrol) (cons V1928 (quote ())))) (quote ())))))))) (quote shen.catch-cut))
(begin (register-function-arity (quote shen.catchpoint) 0) (define (kl:shen.catchpoint) (kl:set (quote shen.*catch*) (+ 1 (kl:value (quote shen.*catch*))))) (quote shen.catchpoint))
(begin (register-function-arity (quote shen.cutpoint) 2) (define (kl:shen.cutpoint V1936 V1937) (cond ((kl:= V1937 V1936) #f) (#t V1937))) (quote shen.cutpoint))
(begin (register-function-arity (quote shen.nest-disjunct) 1) (define (kl:shen.nest-disjunct V1939) (cond ((and (pair? V1939) (null? (cdr V1939))) (car V1939)) ((pair? V1939) (kl:shen.lisp-or (car V1939) (kl:shen.nest-disjunct (cdr V1939)))) (#t (kl:shen.f_error (quote shen.nest-disjunct))))) (quote shen.nest-disjunct))
(begin (register-function-arity (quote shen.lisp-or) 2) (define (kl:shen.lisp-or V1942 V1943) (cons (quote let) (cons (quote Case) (cons V1942 (cons (cons (quote if) (cons (cons (quote =) (cons (quote Case) (cons #f (quote ())))) (cons V1943 (cons (quote Case) (quote ()))))) (quote ())))))) (quote shen.lisp-or))
(begin (register-function-arity (quote shen.prolog-aritycheck) 2) (define (kl:shen.prolog-aritycheck V1948 V1949) (cond ((and (pair? V1949) (null? (cdr V1949))) (- (kl:length (car V1949)) 1)) ((and (pair? V1949) (pair? (cdr V1949))) (if (kl:= (kl:length (car V1949)) (kl:length (car (cdr V1949)))) (kl:shen.prolog-aritycheck V1948 (cdr V1949)) (simple-error (string-append "arity error in prolog procedure " (kl:shen.app (cons V1948 (quote ())) "\n" (quote shen.a)))))) (#t (kl:shen.f_error (quote shen.prolog-aritycheck))))) (quote shen.prolog-aritycheck))
(begin (register-function-arity (quote shen.linearise-clause) 1) (define (kl:shen.linearise-clause V1951) (cond ((and (pair? V1951) (and (pair? (cdr V1951)) (and (eq? (quote :-) (car (cdr V1951))) (and (pair? (cdr (cdr V1951))) (null? (cdr (cdr (cdr V1951)))))))) (let ((Linear (kl:shen.linearise (cons (car V1951) (cdr (cdr V1951)))))) (kl:shen.clause_form Linear))) (#t (kl:shen.f_error (quote shen.linearise-clause))))) (quote shen.linearise-clause))
(begin (register-function-arity (quote shen.clause_form) 1) (define (kl:shen.clause_form V1953) (cond ((and (pair? V1953) (and (pair? (cdr V1953)) (null? (cdr (cdr V1953))))) (cons (kl:shen.explicit_modes (car V1953)) (cons (quote :-) (cons (kl:shen.cf_help (car (cdr V1953))) (quote ()))))) (#t (kl:shen.f_error (quote shen.clause_form))))) (quote shen.clause_form))
(begin (register-function-arity (quote shen.explicit_modes) 1) (define (kl:shen.explicit_modes V1955) (cond ((pair? V1955) (cons (car V1955) (kl:map (lambda (X) (kl:shen.em_help X)) (cdr V1955)))) (#t (kl:shen.f_error (quote shen.explicit_modes))))) (quote shen.explicit_modes))
(begin (register-function-arity (quote shen.em_help) 1) (define (kl:shen.em_help V1957) (cond ((and (pair? V1957) (and (eq? (quote mode) (car V1957)) (and (pair? (cdr V1957)) (and (pair? (cdr (cdr V1957))) (null? (cdr (cdr (cdr V1957)))))))) V1957) (#t (cons (quote mode) (cons V1957 (cons (quote +) (quote ()))))))) (quote shen.em_help))
(begin (register-function-arity (quote shen.cf_help) 1) (define (kl:shen.cf_help V1959) (cond ((and (pair? V1959) (and (eq? (quote where) (car V1959)) (and (pair? (cdr V1959)) (and (pair? (car (cdr V1959))) (and (eq? (quote =) (car (car (cdr V1959)))) (and (pair? (cdr (car (cdr V1959)))) (and (pair? (cdr (cdr (car (cdr V1959))))) (and (null? (cdr (cdr (cdr (car (cdr V1959)))))) (and (pair? (cdr (cdr V1959))) (null? (cdr (cdr (cdr V1959))))))))))))) (cons (cons (if (assert-boolean (kl:value (quote shen.*occurs*))) (quote unify!) (quote unify)) (cdr (car (cdr V1959)))) (kl:shen.cf_help (car (cdr (cdr V1959)))))) (#t V1959))) (quote shen.cf_help))
(begin (register-function-arity (quote occurs-check) 1) (define (kl:occurs-check V1965) (cond ((eq? (quote +) V1965) (kl:set (quote shen.*occurs*) #t)) ((eq? (quote -) V1965) (kl:set (quote shen.*occurs*) #f)) (#t (simple-error "occurs-check expects + or -\n")))) (quote occurs-check))
(begin (register-function-arity (quote shen.aum) 2) (define (kl:shen.aum V1968 V1969) (cond ((and (pair? V1968) (and (pair? (car V1968)) (and (pair? (cdr V1968)) (and (eq? (quote :-) (car (cdr V1968))) (and (pair? (cdr (cdr V1968))) (null? (cdr (cdr (cdr V1968))))))))) (let ((MuApplication (kl:shen.make_mu_application (cons (quote shen.mu) (cons (cdr (car V1968)) (cons (kl:shen.continuation_call (cdr (car V1968)) (car (cdr (cdr V1968)))) (quote ())))) V1969))) (kl:shen.mu_reduction MuApplication (quote +)))) (#t (kl:shen.f_error (quote shen.aum))))) (quote shen.aum))
(begin (register-function-arity (quote shen.continuation_call) 2) (define (kl:shen.continuation_call V1972 V1973) (let ((VTerms (cons (quote ProcessN) (kl:shen.extract_vars V1972)))) (let ((VBody (kl:shen.extract_vars V1973))) (let ((Free (kl:remove (quote Throwcontrol) (kl:difference VBody VTerms)))) (kl:shen.cc_help Free V1973))))) (quote shen.continuation_call))
(begin (register-function-arity (quote remove) 2) (define (kl:remove V1976 V1977) (kl:shen.remove-h V1976 V1977 (quote ()))) (quote remove))
(begin (register-function-arity (quote shen.remove-h) 3) (define (kl:shen.remove-h V1984 V1985 V1986) (cond ((null? V1985) (kl:reverse V1986)) ((and (pair? V1985) (kl:= (car V1985) V1984)) (kl:shen.remove-h (car V1985) (cdr V1985) V1986)) ((pair? V1985) (kl:shen.remove-h V1984 (cdr V1985) (cons (car V1985) V1986))) (#t (kl:shen.f_error (quote shen.remove-h))))) (quote shen.remove-h))
(begin (register-function-arity (quote shen.cc_help) 2) (define (kl:shen.cc_help V1989 V1990) (cond ((and (null? V1989) (null? V1990)) (cons (quote shen.pop) (cons (quote shen.the) (cons (quote shen.stack) (quote ()))))) ((null? V1990) (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons V1989 (cons (quote and) (cons (quote shen.then) (cons (cons (quote shen.pop) (cons (quote shen.the) (cons (quote shen.stack) (quote ())))) (quote ())))))))))) ((null? V1989) (cons (quote call) (cons (quote shen.the) (cons (quote shen.continuation) (cons V1990 (quote ())))))) (#t (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons V1989 (cons (quote and) (cons (quote shen.then) (cons (cons (quote call) (cons (quote shen.the) (cons (quote shen.continuation) (cons V1990 (quote ()))))) (quote ())))))))))))) (quote shen.cc_help))
(begin (register-function-arity (quote shen.make_mu_application) 2) (define (kl:shen.make_mu_application V1993 V1994) (cond ((and (pair? V1993) (and (eq? (quote shen.mu) (car V1993)) (and (pair? (cdr V1993)) (and (null? (car (cdr V1993))) (and (pair? (cdr (cdr V1993))) (and (null? (cdr (cdr (cdr V1993)))) (null? V1994))))))) (car (cdr (cdr V1993)))) ((and (pair? V1993) (and (eq? (quote shen.mu) (car V1993)) (and (pair? (cdr V1993)) (and (pair? (car (cdr V1993))) (and (pair? (cdr (cdr V1993))) (and (null? (cdr (cdr (cdr V1993)))) (pair? V1994))))))) (cons (cons (quote shen.mu) (cons (car (car (cdr V1993))) (cons (kl:shen.make_mu_application (cons (quote shen.mu) (cons (cdr (car (cdr V1993))) (cdr (cdr V1993)))) (cdr V1994)) (quote ())))) (cons (car V1994) (quote ())))) (#t (kl:shen.f_error (quote shen.make_mu_application))))) (quote shen.make_mu_application))
(begin (register-function-arity (quote shen.mu_reduction) 2) (define (kl:shen.mu_reduction V2003 V2004) (cond ((and (pair? V2003) (and (pair? (car V2003)) (and (eq? (quote shen.mu) (car (car V2003))) (and (pair? (cdr (car V2003))) (and (pair? (car (cdr (car V2003)))) (and (eq? (quote mode) (car (car (cdr (car V2003))))) (and (pair? (cdr (car (cdr (car V2003))))) (and (pair? (cdr (cdr (car (cdr (car V2003)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V2003))))))) (and (pair? (cdr (cdr (car V2003)))) (and (null? (cdr (cdr (cdr (car V2003))))) (and (pair? (cdr V2003)) (null? (cdr (cdr V2003))))))))))))))) (kl:shen.mu_reduction (cons (cons (quote shen.mu) (cons (car (cdr (car (cdr (car V2003))))) (cdr (cdr (car V2003))))) (cdr V2003)) (car (cdr (cdr (car (cdr (car V2003)))))))) ((and (pair? V2003) (and (pair? (car V2003)) (and (eq? (quote shen.mu) (car (car V2003))) (and (pair? (cdr (car V2003))) (and (pair? (cdr (cdr (car V2003)))) (and (null? (cdr (cdr (cdr (car V2003))))) (and (pair? (cdr V2003)) (and (null? (cdr (cdr V2003))) (eq? (quote _) (car (cdr (car V2003)))))))))))) (kl:shen.mu_reduction (car (cdr (cdr (car V2003)))) V2004)) ((and (pair? V2003) (and (pair? (car V2003)) (and (eq? (quote shen.mu) (car (car V2003))) (and (pair? (cdr (car V2003))) (and (pair? (cdr (cdr (car V2003)))) (and (null? (cdr (cdr (cdr (car V2003))))) (and (pair? (cdr V2003)) (and (null? (cdr (cdr V2003))) (assert-boolean (kl:shen.ephemeral_variable? (car (cdr (car V2003))) (car (cdr V2003)))))))))))) (kl:subst (car (cdr V2003)) (car (cdr (car V2003))) (kl:shen.mu_reduction (car (cdr (cdr (car V2003)))) V2004))) ((and (pair? V2003) (and (pair? (car V2003)) (and (eq? (quote shen.mu) (car (car V2003))) (and (pair? (cdr (car V2003))) (and (pair? (cdr (cdr (car V2003)))) (and (null? (cdr (cdr (cdr (car V2003))))) (and (pair? (cdr V2003)) (and (null? (cdr (cdr V2003))) (kl:variable? (car (cdr (car V2003)))))))))))) (cons (quote let) (cons (car (cdr (car V2003))) (cons (quote shen.be) (cons (car (cdr V2003)) (cons (quote in) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V2003)))) V2004) (quote ())))))))) ((and (pair? V2003) (and (pair? (car V2003)) (and (eq? (quote shen.mu) (car (car V2003))) (and (pair? (cdr (car V2003))) (and (pair? (cdr (cdr (car V2003)))) (and (null? (cdr (cdr (cdr (car V2003))))) (and (pair? (cdr V2003)) (and (null? (cdr (cdr V2003))) (and (eq? (quote -) V2004) (assert-boolean (kl:shen.prolog_constant? (car (cdr (car V2003)))))))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V2003))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote identical) (cons (quote shen.to) (cons (car (cdr (car V2003))) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V2003)))) (quote -)) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))))) ((and (pair? V2003) (and (pair? (car V2003)) (and (eq? (quote shen.mu) (car (car V2003))) (and (pair? (cdr (car V2003))) (and (pair? (cdr (cdr (car V2003)))) (and (null? (cdr (cdr (cdr (car V2003))))) (and (pair? (cdr V2003)) (and (null? (cdr (cdr V2003))) (and (eq? (quote +) V2004) (assert-boolean (kl:shen.prolog_constant? (car (cdr (car V2003)))))))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V2003))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote identical) (cons (quote shen.to) (cons (car (cdr (car V2003))) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V2003)))) (quote +)) (cons (quote shen.else) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.variable) (quote ()))))) (cons (quote shen.then) (cons (cons (quote bind) (cons Z (cons (quote shen.to) (cons (car (cdr (car V2003))) (cons (quote in) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V2003)))) (quote +)) (quote ()))))))) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))) (quote ()))))))))) ((and (pair? V2003) (and (pair? (car V2003)) (and (eq? (quote shen.mu) (car (car V2003))) (and (pair? (cdr (car V2003))) (and (pair? (car (cdr (car V2003)))) (and (pair? (cdr (cdr (car V2003)))) (and (null? (cdr (cdr (cdr (car V2003))))) (and (pair? (cdr V2003)) (and (null? (cdr (cdr V2003))) (eq? (quote -) V2004)))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V2003))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.non-empty) (cons (quote list) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (cons (cons (quote shen.mu) (cons (car (car (cdr (car V2003)))) (cons (cons (cons (quote shen.mu) (cons (cdr (car (cdr (car V2003)))) (cdr (cdr (car V2003))))) (cons (cons (quote shen.the) (cons (quote tail) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote ())))) (cons (cons (quote shen.the) (cons (quote head) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote -)) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))))) ((and (pair? V2003) (and (pair? (car V2003)) (and (eq? (quote shen.mu) (car (car V2003))) (and (pair? (cdr (car V2003))) (and (pair? (car (cdr (car V2003)))) (and (pair? (cdr (cdr (car V2003)))) (and (null? (cdr (cdr (cdr (car V2003))))) (and (pair? (cdr V2003)) (and (null? (cdr (cdr V2003))) (eq? (quote +) V2004)))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V2003))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.non-empty) (cons (quote list) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (cons (cons (quote shen.mu) (cons (car (car (cdr (car V2003)))) (cons (cons (cons (quote shen.mu) (cons (cdr (car (cdr (car V2003)))) (cdr (cdr (car V2003))))) (cons (cons (quote shen.the) (cons (quote tail) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote ())))) (cons (cons (quote shen.the) (cons (quote head) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote +)) (cons (quote shen.else) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.variable) (quote ()))))) (cons (quote shen.then) (cons (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons (kl:shen.extract_vars (car (cdr (car V2003)))) (cons (quote and) (cons (quote shen.then) (cons (cons (quote bind) (cons Z (cons (quote shen.to) (cons (kl:shen.rcons_form (kl:shen.remove_modes (car (cdr (car V2003))))) (cons (quote in) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V2003)))) (quote +)) (quote ()))))))) (quote ()))))))))) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))) (quote ()))))))))) (#t V2003))) (quote shen.mu_reduction))
(begin (register-function-arity (quote shen.rcons_form) 1) (define (kl:shen.rcons_form V2006) (cond ((pair? V2006) (cons (quote cons) (cons (kl:shen.rcons_form (car V2006)) (cons (kl:shen.rcons_form (cdr V2006)) (quote ()))))) (#t V2006))) (quote shen.rcons_form))
(begin (register-function-arity (quote shen.remove_modes) 1) (define (kl:shen.remove_modes V2008) (cond ((and (pair? V2008) (and (eq? (quote mode) (car V2008)) (and (pair? (cdr V2008)) (and (pair? (cdr (cdr V2008))) (and (eq? (quote +) (car (cdr (cdr V2008)))) (null? (cdr (cdr (cdr V2008))))))))) (kl:shen.remove_modes (car (cdr V2008)))) ((and (pair? V2008) (and (eq? (quote mode) (car V2008)) (and (pair? (cdr V2008)) (and (pair? (cdr (cdr V2008))) (and (eq? (quote -) (car (cdr (cdr V2008)))) (null? (cdr (cdr (cdr V2008))))))))) (kl:shen.remove_modes (car (cdr V2008)))) ((pair? V2008) (cons (kl:shen.remove_modes (car V2008)) (kl:shen.remove_modes (cdr V2008)))) (#t V2008))) (quote shen.remove_modes))
(begin (register-function-arity (quote shen.ephemeral_variable?) 2) (define (kl:shen.ephemeral_variable? V2011 V2012) (and (kl:variable? V2011) (kl:variable? V2012))) (quote shen.ephemeral_variable?))
(begin (register-function-arity (quote shen.prolog_constant?) 1) (define (kl:shen.prolog_constant? V2022) (cond ((pair? V2022) #f) (#t #t))) (quote shen.prolog_constant?))
(begin (register-function-arity (quote shen.aum_to_shen) 1) (define (kl:shen.aum_to_shen V2024) (cond ((and (pair? V2024) (and (eq? (quote let) (car V2024)) (and (pair? (cdr V2024)) (and (pair? (cdr (cdr V2024))) (and (eq? (quote shen.be) (car (cdr (cdr V2024)))) (and (pair? (cdr (cdr (cdr V2024)))) (and (pair? (cdr (cdr (cdr (cdr V2024))))) (and (eq? (quote in) (car (cdr (cdr (cdr (cdr V2024)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V2024)))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr V2024)))))))))))))))) (cons (quote let) (cons (car (cdr V2024)) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr V2024))))) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr V2024))))))) (quote ())))))) ((and (pair? V2024) (and (eq? (quote shen.the) (car V2024)) (and (pair? (cdr V2024)) (and (eq? (quote shen.result) (car (cdr V2024))) (and (pair? (cdr (cdr V2024))) (and (eq? (quote shen.of) (car (cdr (cdr V2024)))) (and (pair? (cdr (cdr (cdr V2024)))) (and (eq? (quote shen.dereferencing) (car (cdr (cdr (cdr V2024))))) (and (pair? (cdr (cdr (cdr (cdr V2024))))) (null? (cdr (cdr (cdr (cdr (cdr V2024))))))))))))))) (cons (quote shen.lazyderef) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr V2024)))))) (cons (quote ProcessN) (quote ()))))) ((and (pair? V2024) (and (eq? (quote if) (car V2024)) (and (pair? (cdr V2024)) (and (pair? (cdr (cdr V2024))) (and (eq? (quote shen.then) (car (cdr (cdr V2024)))) (and (pair? (cdr (cdr (cdr V2024)))) (and (pair? (cdr (cdr (cdr (cdr V2024))))) (and (eq? (quote shen.else) (car (cdr (cdr (cdr (cdr V2024)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V2024)))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr V2024)))))))))))))))) (cons (quote if) (cons (kl:shen.aum_to_shen (car (cdr V2024))) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr V2024))))) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr V2024))))))) (quote ())))))) ((and (pair? V2024) (and (pair? (cdr V2024)) (and (eq? (quote is) (car (cdr V2024))) (and (pair? (cdr (cdr V2024))) (and (eq? (quote shen.a) (car (cdr (cdr V2024)))) (and (pair? (cdr (cdr (cdr V2024)))) (and (eq? (quote shen.variable) (car (cdr (cdr (cdr V2024))))) (null? (cdr (cdr (cdr (cdr V2024)))))))))))) (cons (quote shen.pvar?) (cons (car V2024) (quote ())))) ((and (pair? V2024) (and (pair? (cdr V2024)) (and (eq? (quote is) (car (cdr V2024))) (and (pair? (cdr (cdr V2024))) (and (eq? (quote shen.a) (car (cdr (cdr V2024)))) (and (pair? (cdr (cdr (cdr V2024)))) (and (eq? (quote shen.non-empty) (car (cdr (cdr (cdr V2024))))) (and (pair? (cdr (cdr (cdr (cdr V2024))))) (and (eq? (quote list) (car (cdr (cdr (cdr (cdr V2024)))))) (null? (cdr (cdr (cdr (cdr (cdr V2024))))))))))))))) (cons (quote cons?) (cons (car V2024) (quote ())))) ((and (pair? V2024) (and (eq? (quote shen.rename) (car V2024)) (and (pair? (cdr V2024)) (and (eq? (quote shen.the) (car (cdr V2024))) (and (pair? (cdr (cdr V2024))) (and (eq? (quote shen.variables) (car (cdr (cdr V2024)))) (and (pair? (cdr (cdr (cdr V2024)))) (and (eq? (quote in) (car (cdr (cdr (cdr V2024))))) (and (pair? (cdr (cdr (cdr (cdr V2024))))) (and (null? (car (cdr (cdr (cdr (cdr V2024)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V2024)))))) (and (eq? (quote and) (car (cdr (cdr (cdr (cdr (cdr V2024))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr V2024))))))) (and (eq? (quote shen.then) (car (cdr (cdr (cdr (cdr (cdr (cdr V2024)))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr (cdr V2024)))))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr V2024)))))))))))))))))))))))) (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr V2024)))))))))) ((and (pair? V2024) (and (eq? (quote shen.rename) (car V2024)) (and (pair? (cdr V2024)) (and (eq? (quote shen.the) (car (cdr V2024))) (and (pair? (cdr (cdr V2024))) (and (eq? (quote shen.variables) (car (cdr (cdr V2024)))) (and (pair? (cdr (cdr (cdr V2024)))) (and (eq? (quote in) (car (cdr (cdr (cdr V2024))))) (and (pair? (cdr (cdr (cdr (cdr V2024))))) (and (pair? (car (cdr (cdr (cdr (cdr V2024)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V2024)))))) (and (eq? (quote and) (car (cdr (cdr (cdr (cdr (cdr V2024))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr V2024))))))) (and (eq? (quote shen.then) (car (cdr (cdr (cdr (cdr (cdr (cdr V2024)))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr (cdr V2024)))))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr V2024)))))))))))))))))))))))) (cons (quote let) (cons (car (car (cdr (cdr (cdr (cdr V2024)))))) (cons (cons (quote shen.newpv) (cons (quote ProcessN) (quote ()))) (cons (kl:shen.aum_to_shen (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons (cdr (car (cdr (cdr (cdr (cdr V2024)))))) (cdr (cdr (cdr (cdr (cdr V2024))))))))))) (quote ())))))) ((and (pair? V2024) (and (eq? (quote bind) (car V2024)) (and (pair? (cdr V2024)) (and (pair? (cdr (cdr V2024))) (and (eq? (quote shen.to) (car (cdr (cdr V2024)))) (and (pair? (cdr (cdr (cdr V2024)))) (and (pair? (cdr (cdr (cdr (cdr V2024))))) (and (eq? (quote in) (car (cdr (cdr (cdr (cdr V2024)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V2024)))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr V2024)))))))))))))))) (cons (quote do) (cons (cons (quote shen.bindv) (cons (car (cdr V2024)) (cons (kl:shen.chwild (car (cdr (cdr (cdr V2024))))) (cons (quote ProcessN) (quote ()))))) (cons (cons (quote let) (cons (quote Result) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr V2024))))))) (cons (cons (quote do) (cons (cons (quote shen.unbindv) (cons (car (cdr V2024)) (cons (quote ProcessN) (quote ())))) (cons (quote Result) (quote ())))) (quote ()))))) (quote ()))))) ((and (pair? V2024) (and (pair? (cdr V2024)) (and (eq? (quote is) (car (cdr V2024))) (and (pair? (cdr (cdr V2024))) (and (eq? (quote identical) (car (cdr (cdr V2024)))) (and (pair? (cdr (cdr (cdr V2024)))) (and (eq? (quote shen.to) (car (cdr (cdr (cdr V2024))))) (and (pair? (cdr (cdr (cdr (cdr V2024))))) (null? (cdr (cdr (cdr (cdr (cdr V2024)))))))))))))) (cons (quote =) (cons (car (cdr (cdr (cdr (cdr V2024))))) (cons (car V2024) (quote ()))))) ((eq? (quote shen.failed!) V2024) #f) ((and (pair? V2024) (and (eq? (quote shen.the) (car V2024)) (and (pair? (cdr V2024)) (and (eq? (quote head) (car (cdr V2024))) (and (pair? (cdr (cdr V2024))) (and (eq? (quote shen.of) (car (cdr (cdr V2024)))) (and (pair? (cdr (cdr (cdr V2024)))) (null? (cdr (cdr (cdr (cdr V2024)))))))))))) (cons (quote hd) (cdr (cdr (cdr V2024))))) ((and (pair? V2024) (and (eq? (quote shen.the) (car V2024)) (and (pair? (cdr V2024)) (and (eq? (quote tail) (car (cdr V2024))) (and (pair? (cdr (cdr V2024))) (and (eq? (quote shen.of) (car (cdr (cdr V2024)))) (and (pair? (cdr (cdr (cdr V2024)))) (null? (cdr (cdr (cdr (cdr V2024)))))))))))) (cons (quote tl) (cdr (cdr (cdr V2024))))) ((and (pair? V2024) (and (eq? (quote shen.pop) (car V2024)) (and (pair? (cdr V2024)) (and (eq? (quote shen.the) (car (cdr V2024))) (and (pair? (cdr (cdr V2024))) (and (eq? (quote shen.stack) (car (cdr (cdr V2024)))) (null? (cdr (cdr (cdr V2024)))))))))) (cons (quote do) (cons (cons (quote shen.incinfs) (quote ())) (cons (cons (quote thaw) (cons (quote Continuation) (quote ()))) (quote ()))))) ((and (pair? V2024) (and (eq? (quote call) (car V2024)) (and (pair? (cdr V2024)) (and (eq? (quote shen.the) (car (cdr V2024))) (and (pair? (cdr (cdr V2024))) (and (eq? (quote shen.continuation) (car (cdr (cdr V2024)))) (and (pair? (cdr (cdr (cdr V2024)))) (null? (cdr (cdr (cdr (cdr V2024)))))))))))) (cons (quote do) (cons (cons (quote shen.incinfs) (quote ())) (cons (kl:shen.call_the_continuation (kl:shen.chwild (car (cdr (cdr (cdr V2024))))) (quote ProcessN) (quote Continuation)) (quote ()))))) (#t V2024))) (quote shen.aum_to_shen))
(begin (register-function-arity (quote shen.chwild) 1) (define (kl:shen.chwild V2026) (cond ((eq? V2026 (quote _)) (cons (quote shen.newpv) (cons (quote ProcessN) (quote ())))) ((pair? V2026) (kl:map (lambda (Z) (kl:shen.chwild Z)) V2026)) (#t V2026))) (quote shen.chwild))
(begin (register-function-arity (quote shen.newpv) 1) (define (kl:shen.newpv V2028) (let ((Count+1 (+ (vector-ref (kl:value (quote shen.*varcounter*)) V2028) 1))) (let ((IncVar (let ((_tmp (kl:value (quote shen.*varcounter*)))) (vector-set! _tmp V2028 Count+1) _tmp))) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V2028))) (let ((ResizeVectorIfNeeded (if (kl:= Count+1 (kl:limit Vector)) (kl:shen.resizeprocessvector V2028 Count+1) (quote shen.skip)))) (kl:shen.mk-pvar Count+1)))))) (quote shen.newpv))
(begin (register-function-arity (quote shen.resizeprocessvector) 2) (define (kl:shen.resizeprocessvector V2031 V2032) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V2031))) (let ((BigVector (kl:shen.resize-vector Vector (+ V2032 V2032) (quote shen.-null-)))) (let ((_tmp (kl:value (quote shen.*prologvectors*)))) (vector-set! _tmp V2031 BigVector) _tmp)))) (quote shen.resizeprocessvector))
(begin (register-function-arity (quote shen.resize-vector) 3) (define (kl:shen.resize-vector V2036 V2037 V2038) (let ((BigVector (let ((_tmp (make-vector (+ 1 V2037) (quote (quote shen.fail!))))) (vector-set! _tmp 0 V2037) _tmp))) (kl:shen.copy-vector V2036 BigVector (kl:limit V2036) V2037 V2038))) (quote shen.resize-vector))
(begin (register-function-arity (quote shen.copy-vector) 5) (define (kl:shen.copy-vector V2044 V2045 V2046 V2047 V2048) (kl:shen.copy-vector-stage-2 (+ 1 V2046) (+ V2047 1) V2048 (kl:shen.copy-vector-stage-1 1 V2044 V2045 (+ 1 V2046)))) (quote shen.copy-vector))
(begin (register-function-arity (quote shen.copy-vector-stage-1) 4) (define (kl:shen.copy-vector-stage-1 V2056 V2057 V2058 V2059) (cond ((kl:= V2059 V2056) V2058) (#t (kl:shen.copy-vector-stage-1 (+ 1 V2056) V2057 (let ((_tmp V2058)) (vector-set! _tmp V2056 (vector-ref V2057 V2056)) _tmp) V2059)))) (quote shen.copy-vector-stage-1))
(begin (register-function-arity (quote shen.copy-vector-stage-2) 4) (define (kl:shen.copy-vector-stage-2 V2067 V2068 V2069 V2070) (cond ((kl:= V2068 V2067) V2070) (#t (kl:shen.copy-vector-stage-2 (+ V2067 1) V2068 V2069 (let ((_tmp V2070)) (vector-set! _tmp V2067 V2069) _tmp))))) (quote shen.copy-vector-stage-2))
(begin (register-function-arity (quote shen.mk-pvar) 1) (define (kl:shen.mk-pvar V2072) (let ((_tmp (let ((_tmp (make-vector 2 (quote (quote shen.fail!))))) (vector-set! _tmp 0 (quote shen.pvar)) _tmp))) (vector-set! _tmp 1 V2072) _tmp)) (quote shen.mk-pvar))
(begin (register-function-arity (quote shen.pvar?) 1) (define (kl:shen.pvar? V2074) (and (vector? V2074) (eq? (kl:<-address/or V2074 0 (lambda () (quote shen.not-pvar))) (quote shen.pvar)))) (quote shen.pvar?))
(begin (register-function-arity (quote shen.bindv) 3) (define (kl:shen.bindv V2078 V2079 V2080) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V2080))) (let ((_tmp Vector)) (vector-set! _tmp (vector-ref V2078 1) V2079) _tmp))) (quote shen.bindv))
(begin (register-function-arity (quote shen.unbindv) 2) (define (kl:shen.unbindv V2083 V2084) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V2084))) (let ((_tmp Vector)) (vector-set! _tmp (vector-ref V2083 1) (quote shen.-null-)) _tmp))) (quote shen.unbindv))
(begin (register-function-arity (quote shen.incinfs) 0) (define (kl:shen.incinfs) (kl:set (quote shen.*infs*) (+ 1 (kl:value (quote shen.*infs*))))) (quote shen.incinfs))
(begin (register-function-arity (quote shen.call_the_continuation) 3) (define (kl:shen.call_the_continuation V2088 V2089 V2090) (cond ((and (pair? V2088) (and (pair? (car V2088)) (null? (cdr V2088)))) (cons (car (car V2088)) (kl:append (cdr (car V2088)) (cons V2089 (cons V2090 (quote ())))))) ((and (pair? V2088) (pair? (car V2088))) (let ((NewContinuation (kl:shen.newcontinuation (cdr V2088) V2089 V2090))) (cons (car (car V2088)) (kl:append (cdr (car V2088)) (cons V2089 (cons NewContinuation (quote ()))))))) (#t (kl:shen.f_error (quote shen.call_the_continuation))))) (quote shen.call_the_continuation))
(begin (register-function-arity (quote shen.newcontinuation) 3) (define (kl:shen.newcontinuation V2094 V2095 V2096) (cond ((null? V2094) V2096) ((and (pair? V2094) (pair? (car V2094))) (cons (quote freeze) (cons (cons (car (car V2094)) (kl:append (cdr (car V2094)) (cons V2095 (cons (kl:shen.newcontinuation (cdr V2094) V2095 V2096) (quote ()))))) (quote ())))) (#t (kl:shen.f_error (quote shen.newcontinuation))))) (quote shen.newcontinuation))
(begin (register-function-arity (quote return) 3) (define (kl:return V2104 V2105 V2106) (kl:shen.deref V2104 V2105)) (quote return))
(begin (register-function-arity (quote shen.measure&return) 3) (define (kl:shen.measure&return V2114 V2115 V2116) (begin (kl:shen.prhush (kl:shen.app (kl:value (quote shen.*infs*)) " inferences\n" (quote shen.a)) (kl:stoutput)) (kl:shen.deref V2114 V2115))) (quote shen.measure&return))
(begin (register-function-arity (quote unify) 4) (define (kl:unify V2121 V2122 V2123 V2124) (kl:shen.lzy= (kl:shen.lazyderef V2121 V2123) (kl:shen.lazyderef V2122 V2123) V2123 V2124)) (quote unify))
(begin (register-function-arity (quote shen.lzy=) 4) (define (kl:shen.lzy= V2146 V2147 V2148 V2149) (cond ((kl:= V2147 V2146) (kl:thaw V2149)) ((kl:shen.pvar? V2146) (kl:bind V2146 V2147 V2148 V2149)) ((kl:shen.pvar? V2147) (kl:bind V2147 V2146 V2148 V2149)) ((and (pair? V2146) (pair? V2147)) (kl:shen.lzy= (kl:shen.lazyderef (car V2146) V2148) (kl:shen.lazyderef (car V2147) V2148) V2148 (lambda () (kl:shen.lzy= (kl:shen.lazyderef (cdr V2146) V2148) (kl:shen.lazyderef (cdr V2147) V2148) V2148 V2149)))) (#t #f))) (quote shen.lzy=))
(begin (register-function-arity (quote shen.deref) 2) (define (kl:shen.deref V2152 V2153) (cond ((pair? V2152) (cons (kl:shen.deref (car V2152) V2153) (kl:shen.deref (cdr V2152) V2153))) (#t (if (kl:shen.pvar? V2152) (let ((Value (kl:shen.valvector V2152 V2153))) (if (eq? Value (quote shen.-null-)) V2152 (kl:shen.deref Value V2153))) V2152)))) (quote shen.deref))
(begin (register-function-arity (quote shen.lazyderef) 2) (define (kl:shen.lazyderef V2156 V2157) (if (kl:shen.pvar? V2156) (let ((Value (kl:shen.valvector V2156 V2157))) (if (eq? Value (quote shen.-null-)) V2156 (kl:shen.lazyderef Value V2157))) V2156)) (quote shen.lazyderef))
(begin (register-function-arity (quote shen.valvector) 2) (define (kl:shen.valvector V2160 V2161) (vector-ref (vector-ref (kl:value (quote shen.*prologvectors*)) V2161) (vector-ref V2160 1))) (quote shen.valvector))
(begin (register-function-arity (quote unify!) 4) (define (kl:unify! V2166 V2167 V2168 V2169) (kl:shen.lzy=! (kl:shen.lazyderef V2166 V2168) (kl:shen.lazyderef V2167 V2168) V2168 V2169)) (quote unify!))
(begin (register-function-arity (quote shen.lzy=!) 4) (define (kl:shen.lzy=! V2191 V2192 V2193 V2194) (cond ((kl:= V2192 V2191) (kl:thaw V2194)) ((and (kl:shen.pvar? V2191) (kl:not (kl:shen.occurs? V2191 (kl:shen.deref V2192 V2193)))) (kl:bind V2191 V2192 V2193 V2194)) ((and (kl:shen.pvar? V2192) (kl:not (kl:shen.occurs? V2192 (kl:shen.deref V2191 V2193)))) (kl:bind V2192 V2191 V2193 V2194)) ((and (pair? V2191) (pair? V2192)) (kl:shen.lzy=! (kl:shen.lazyderef (car V2191) V2193) (kl:shen.lazyderef (car V2192) V2193) V2193 (lambda () (kl:shen.lzy=! (kl:shen.lazyderef (cdr V2191) V2193) (kl:shen.lazyderef (cdr V2192) V2193) V2193 V2194)))) (#t #f))) (quote shen.lzy=!))
(begin (register-function-arity (quote shen.occurs?) 2) (define (kl:shen.occurs? V2206 V2207) (cond ((kl:= V2207 V2206) #t) ((pair? V2207) (or (assert-boolean (kl:shen.occurs? V2206 (car V2207))) (assert-boolean (kl:shen.occurs? V2206 (cdr V2207))))) (#t #f))) (quote shen.occurs?))
(begin (register-function-arity (quote identical) 4) (define (kl:identical V2212 V2213 V2214 V2215) (kl:shen.lzy== (kl:shen.lazyderef V2212 V2214) (kl:shen.lazyderef V2213 V2214) V2214 V2215)) (quote identical))
(begin (register-function-arity (quote shen.lzy==) 4) (define (kl:shen.lzy== V2237 V2238 V2239 V2240) (cond ((kl:= V2238 V2237) (kl:thaw V2240)) ((and (pair? V2237) (pair? V2238)) (kl:shen.lzy== (kl:shen.lazyderef (car V2237) V2239) (kl:shen.lazyderef (car V2238) V2239) V2239 (lambda () (kl:shen.lzy== (cdr V2237) (cdr V2238) V2239 V2240)))) (#t #f))) (quote shen.lzy==))
(begin (register-function-arity (quote shen.pvar) 1) (define (kl:shen.pvar V2242) (string-append "Var" (kl:shen.app (vector-ref V2242 1) "" (quote shen.a)))) (quote shen.pvar))
(begin (register-function-arity (quote bind) 4) (define (kl:bind V2247 V2248 V2249 V2250) (begin (kl:shen.bindv V2247 V2248 V2249) (let ((Result (kl:thaw V2250))) (begin (kl:shen.unbindv V2247 V2249) Result)))) (quote bind))
(begin (register-function-arity (quote fwhen) 3) (define (kl:fwhen V2268 V2269 V2270) (cond ((kl:= #t V2268) (kl:thaw V2270)) ((kl:= #f V2268) #f) (#t (simple-error (string-append "fwhen expects a boolean: not " (kl:shen.app V2268 "%" (quote shen.s))))))) (quote fwhen))
(begin (register-function-arity (quote call) 3) (define (kl:call V2286 V2287 V2288) (cond ((pair? V2286) (kl:shen.call-help (kl:function (kl:shen.lazyderef (car V2286) V2287)) (cdr V2286) V2287 V2288)) (#t #f))) (quote call))
(begin (register-function-arity (quote shen.call-help) 4) (define (kl:shen.call-help V2293 V2294 V2295 V2296) (cond ((null? V2294) ((V2293 V2295) V2296)) ((pair? V2294) (kl:shen.call-help (V2293 (car V2294)) (cdr V2294) V2295 V2296)) (#t (kl:shen.f_error (quote shen.call-help))))) (quote shen.call-help))
(begin (register-function-arity (quote shen.intprolog) 1) (define (kl:shen.intprolog V2298) (cond ((and (pair? V2298) (pair? (car V2298))) (let ((ProcessN (kl:shen.start-new-prolog-process))) (kl:shen.intprolog-help (car (car V2298)) (kl:shen.insert-prolog-variables (cons (cdr (car V2298)) (cons (cdr V2298) (quote ()))) ProcessN) ProcessN))) (#t (kl:shen.f_error (quote shen.intprolog))))) (quote shen.intprolog))
(begin (register-function-arity (quote shen.intprolog-help) 3) (define (kl:shen.intprolog-help V2302 V2303 V2304) (cond ((and (pair? V2303) (and (pair? (cdr V2303)) (null? (cdr (cdr V2303))))) (kl:shen.intprolog-help-help V2302 (car V2303) (car (cdr V2303)) V2304)) (#t (kl:shen.f_error (quote shen.intprolog-help))))) (quote shen.intprolog-help))
(begin (register-function-arity (quote shen.intprolog-help-help) 4) (define (kl:shen.intprolog-help-help V2309 V2310 V2311 V2312) (cond ((null? V2310) ((V2309 V2312) (lambda () (kl:shen.call-rest V2311 V2312)))) ((pair? V2310) (kl:shen.intprolog-help-help (V2309 (car V2310)) (cdr V2310) V2311 V2312)) (#t (kl:shen.f_error (quote shen.intprolog-help-help))))) (quote shen.intprolog-help-help))
(begin (register-function-arity (quote shen.call-rest) 2) (define (kl:shen.call-rest V2317 V2318) (cond ((null? V2317) #t) ((and (pair? V2317) (and (pair? (car V2317)) (pair? (cdr (car V2317))))) (kl:shen.call-rest (cons (cons ((car (car V2317)) (car (cdr (car V2317)))) (cdr (cdr (car V2317)))) (cdr V2317)) V2318)) ((and (pair? V2317) (and (pair? (car V2317)) (null? (cdr (car V2317))))) (((car (car V2317)) V2318) (lambda () (kl:shen.call-rest (cdr V2317) V2318)))) (#t (kl:shen.f_error (quote shen.call-rest))))) (quote shen.call-rest))
(begin (register-function-arity (quote shen.start-new-prolog-process) 0) (define (kl:shen.start-new-prolog-process) (let ((IncrementProcessCounter (kl:set (quote shen.*process-counter*) (+ 1 (kl:value (quote shen.*process-counter*)))))) (kl:shen.initialise-prolog IncrementProcessCounter))) (quote shen.start-new-prolog-process))
(begin (register-function-arity (quote shen.insert-prolog-variables) 2) (define (kl:shen.insert-prolog-variables V2321 V2322) (kl:shen.insert-prolog-variables-help V2321 (kl:shen.flatten V2321) V2322)) (quote shen.insert-prolog-variables))
(begin (register-function-arity (quote shen.insert-prolog-variables-help) 3) (define (kl:shen.insert-prolog-variables-help V2330 V2331 V2332) (cond ((null? V2331) V2330) ((and (pair? V2331) (kl:variable? (car V2331))) (let ((V (kl:shen.newpv V2332))) (let ((XV/Y (kl:subst V (car V2331) V2330))) (let ((Z-Y (kl:remove (car V2331) (cdr V2331)))) (kl:shen.insert-prolog-variables-help XV/Y Z-Y V2332))))) ((pair? V2331) (kl:shen.insert-prolog-variables-help V2330 (cdr V2331) V2332)) (#t (kl:shen.f_error (quote shen.insert-prolog-variables-help))))) (quote shen.insert-prolog-variables-help))
(begin (register-function-arity (quote shen.initialise-prolog) 1) (define (kl:shen.initialise-prolog V2334) (let ((Vector (let ((_tmp (kl:value (quote shen.*prologvectors*)))) (vector-set! _tmp V2334 (kl:shen.fillvector (kl:vector 10) 1 10 (quote shen.-null-))) _tmp))) (let ((Counter (let ((_tmp (kl:value (quote shen.*varcounter*)))) (vector-set! _tmp V2334 1) _tmp))) V2334))) (quote shen.initialise-prolog))
