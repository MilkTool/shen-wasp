(module "compiled/prolog.kl")
"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.<defprolog>) 1) (define (kl:shen.<defprolog> V1664) (let ((Parse_shen.<predicate*> (kl:shen.<predicate*> V1664))) (if (kl:not (kl:= (kl:fail) Parse_shen.<predicate*>)) (let ((Parse_shen.<clauses*> (kl:shen.<clauses*> Parse_shen.<predicate*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<clauses*>)) (kl:shen.pair (car Parse_shen.<clauses*>) (car (kl:shen.prolog->shen (kl:map (lambda (Parse_X) (kl:shen.insert-predicate (kl:shen.hdtl Parse_shen.<predicate*>) Parse_X)) (kl:shen.hdtl Parse_shen.<clauses*>))))) (kl:fail))) (kl:fail)))) (export shen.<defprolog>) (quote shen.<defprolog>))
(begin (register-function-arity (quote shen.prolog-error) 2) (define (kl:shen.prolog-error V1673 V1674) (cond ((and (pair? V1674) (and (pair? (cdr V1674)) (null? (cdr (cdr V1674))))) (simple-error (string-append "prolog syntax error in " (kl:shen.app V1673 (string-append " here:\n\n " (kl:shen.app (kl:shen.next-50 50 (car V1674)) "\n" (quote shen.a))) (quote shen.a))))) (#t (simple-error (string-append "prolog syntax error in " (kl:shen.app V1673 "\n" (quote shen.a))))))) (export shen.prolog-error) (quote shen.prolog-error))
(begin (register-function-arity (quote shen.next-50) 2) (define (kl:shen.next-50 V1681 V1682) (cond ((null? V1682) "") ((kl:= 0 V1681) "") ((pair? V1682) (string-append (kl:shen.decons-string (car V1682)) (kl:shen.next-50 (- V1681 1) (cdr V1682)))) (#t (kl:shen.f_error (quote shen.next-50))))) (export shen.next-50) (quote shen.next-50))
(begin (register-function-arity (quote shen.decons-string) 1) (define (kl:shen.decons-string V1684) (cond ((and (pair? V1684) (and (eq? (quote cons) (car V1684)) (and (pair? (cdr V1684)) (and (pair? (cdr (cdr V1684))) (null? (cdr (cdr (cdr V1684)))))))) (kl:shen.app (kl:shen.eval-cons V1684) " " (quote shen.s))) (#t (kl:shen.app V1684 " " (quote shen.r))))) (export shen.decons-string) (quote shen.decons-string))
(begin (register-function-arity (quote shen.insert-predicate) 2) (define (kl:shen.insert-predicate V1687 V1688) (cond ((and (pair? V1688) (and (pair? (cdr V1688)) (null? (cdr (cdr V1688))))) (cons (cons V1687 (car V1688)) (cons (quote :-) (cdr V1688)))) (#t (kl:shen.f_error (quote shen.insert-predicate))))) (export shen.insert-predicate) (quote shen.insert-predicate))
(begin (register-function-arity (quote shen.<predicate*>) 1) (define (kl:shen.<predicate*> V1690) (if (pair? (car V1690)) (let ((Parse_X (kl:shen.hdhd V1690))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1690) (kl:shen.hdtl V1690))) Parse_X)) (kl:fail))) (export shen.<predicate*>) (quote shen.<predicate*>))
(begin (register-function-arity (quote shen.<clauses*>) 1) (define (kl:shen.<clauses*> V1692) (let ((YaccParse (let ((Parse_shen.<clause*> (kl:shen.<clause*> V1692))) (if (kl:not (kl:= (kl:fail) Parse_shen.<clause*>)) (let ((Parse_shen.<clauses*> (kl:shen.<clauses*> Parse_shen.<clause*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<clauses*>)) (kl:shen.pair (car Parse_shen.<clauses*>) (cons (kl:shen.hdtl Parse_shen.<clause*>) (kl:shen.hdtl Parse_shen.<clauses*>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1692))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<clauses*>) (quote shen.<clauses*>))
(begin (register-function-arity (quote shen.<clause*>) 1) (define (kl:shen.<clause*> V1695) (let ((Parse_shen.<head*> (kl:shen.<head*> V1695))) (if (kl:not (kl:= (kl:fail) Parse_shen.<head*>)) (if (and (pair? (car Parse_shen.<head*>)) (eq? (quote <--) (kl:shen.hdhd Parse_shen.<head*>))) (let ((NewStream1693 (kl:shen.pair (kl:shen.tlhd Parse_shen.<head*>) (kl:shen.hdtl Parse_shen.<head*>)))) (let ((Parse_shen.<body*> (kl:shen.<body*> NewStream1693))) (if (kl:not (kl:= (kl:fail) Parse_shen.<body*>)) (let ((Parse_shen.<end*> (kl:shen.<end*> Parse_shen.<body*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<end*>)) (kl:shen.pair (car Parse_shen.<end*>) (cons (kl:shen.hdtl Parse_shen.<head*>) (cons (kl:shen.hdtl Parse_shen.<body*>) (quote ())))) (kl:fail))) (kl:fail)))) (kl:fail)) (kl:fail)))) (export shen.<clause*>) (quote shen.<clause*>))
(begin (register-function-arity (quote shen.<head*>) 1) (define (kl:shen.<head*> V1697) (let ((YaccParse (let ((Parse_shen.<term*> (kl:shen.<term*> V1697))) (if (kl:not (kl:= (kl:fail) Parse_shen.<term*>)) (let ((Parse_shen.<head*> (kl:shen.<head*> Parse_shen.<term*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<head*>)) (kl:shen.pair (car Parse_shen.<head*>) (cons (kl:shen.hdtl Parse_shen.<term*>) (kl:shen.hdtl Parse_shen.<head*>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1697))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<head*>) (quote shen.<head*>))
(begin (register-function-arity (quote shen.<term*>) 1) (define (kl:shen.<term*> V1699) (if (pair? (car V1699)) (let ((Parse_X (kl:shen.hdhd V1699))) (if (and (kl:not (eq? (quote <--) Parse_X)) (assert-boolean (kl:shen.legitimate-term? Parse_X))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1699) (kl:shen.hdtl V1699))) (kl:shen.eval-cons Parse_X)) (kl:fail))) (kl:fail))) (export shen.<term*>) (quote shen.<term*>))
(begin (register-function-arity (quote shen.legitimate-term?) 1) (define (kl:shen.legitimate-term? V1705) (cond ((and (pair? V1705) (and (eq? (quote cons) (car V1705)) (and (pair? (cdr V1705)) (and (pair? (cdr (cdr V1705))) (null? (cdr (cdr (cdr V1705)))))))) (and (assert-boolean (kl:shen.legitimate-term? (car (cdr V1705)))) (assert-boolean (kl:shen.legitimate-term? (car (cdr (cdr V1705))))))) ((and (pair? V1705) (and (eq? (quote mode) (car V1705)) (and (pair? (cdr V1705)) (and (pair? (cdr (cdr V1705))) (and (eq? (quote +) (car (cdr (cdr V1705)))) (null? (cdr (cdr (cdr V1705))))))))) (kl:shen.legitimate-term? (car (cdr V1705)))) ((and (pair? V1705) (and (eq? (quote mode) (car V1705)) (and (pair? (cdr V1705)) (and (pair? (cdr (cdr V1705))) (and (eq? (quote -) (car (cdr (cdr V1705)))) (null? (cdr (cdr (cdr V1705))))))))) (kl:shen.legitimate-term? (car (cdr V1705)))) ((pair? V1705) #f) (#t #t))) (export shen.legitimate-term?) (quote shen.legitimate-term?))
(begin (register-function-arity (quote shen.eval-cons) 1) (define (kl:shen.eval-cons V1707) (cond ((and (pair? V1707) (and (eq? (quote cons) (car V1707)) (and (pair? (cdr V1707)) (and (pair? (cdr (cdr V1707))) (null? (cdr (cdr (cdr V1707)))))))) (cons (kl:shen.eval-cons (car (cdr V1707))) (kl:shen.eval-cons (car (cdr (cdr V1707)))))) ((and (pair? V1707) (and (eq? (quote mode) (car V1707)) (and (pair? (cdr V1707)) (and (pair? (cdr (cdr V1707))) (null? (cdr (cdr (cdr V1707)))))))) (cons (quote mode) (cons (kl:shen.eval-cons (car (cdr V1707))) (cdr (cdr V1707))))) (#t V1707))) (export shen.eval-cons) (quote shen.eval-cons))
(begin (register-function-arity (quote shen.<body*>) 1) (define (kl:shen.<body*> V1709) (let ((YaccParse (let ((Parse_shen.<literal*> (kl:shen.<literal*> V1709))) (if (kl:not (kl:= (kl:fail) Parse_shen.<literal*>)) (let ((Parse_shen.<body*> (kl:shen.<body*> Parse_shen.<literal*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<body*>)) (kl:shen.pair (car Parse_shen.<body*>) (cons (kl:shen.hdtl Parse_shen.<literal*>) (kl:shen.hdtl Parse_shen.<body*>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1709))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<body*>) (quote shen.<body*>))
(begin (register-function-arity (quote shen.<literal*>) 1) (define (kl:shen.<literal*> V1712) (let ((YaccParse (if (and (pair? (car V1712)) (eq? (quote !) (kl:shen.hdhd V1712))) (let ((NewStream1710 (kl:shen.pair (kl:shen.tlhd V1712) (kl:shen.hdtl V1712)))) (kl:shen.pair (car NewStream1710) (cons (quote cut) (cons (kl:intern "Throwcontrol") (quote ()))))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (if (pair? (car V1712)) (let ((Parse_X (kl:shen.hdhd V1712))) (if (pair? Parse_X) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1712) (kl:shen.hdtl V1712))) Parse_X) (kl:fail))) (kl:fail)) YaccParse))) (export shen.<literal*>) (quote shen.<literal*>))
(begin (register-function-arity (quote shen.<end*>) 1) (define (kl:shen.<end*> V1714) (if (pair? (car V1714)) (let ((Parse_X (kl:shen.hdhd V1714))) (if (eq? Parse_X (quote _waspvm_sc_)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1714) (kl:shen.hdtl V1714))) Parse_X) (kl:fail))) (kl:fail))) (export shen.<end*>) (quote shen.<end*>))
(begin (register-function-arity (quote cut) 3) (define (kl:cut V1718 V1719 V1720) (let ((Result (kl:thaw V1720))) (if (kl:= Result #f) V1718 Result))) (export cut) (quote cut))
(begin (register-function-arity (quote shen.insert_modes) 1) (define (kl:shen.insert_modes V1722) (cond ((and (pair? V1722) (and (eq? (quote mode) (car V1722)) (and (pair? (cdr V1722)) (and (pair? (cdr (cdr V1722))) (null? (cdr (cdr (cdr V1722)))))))) V1722) ((null? V1722) (quote ())) ((pair? V1722) (cons (cons (quote mode) (cons (car V1722) (cons (quote +) (quote ())))) (cons (quote mode) (cons (kl:shen.insert_modes (cdr V1722)) (cons (quote -) (quote ())))))) (#t V1722))) (export shen.insert_modes) (quote shen.insert_modes))
(begin (register-function-arity (quote shen.s-prolog) 1) (define (kl:shen.s-prolog V1724) (kl:map (lambda (X) (kl:eval X)) (kl:shen.prolog->shen V1724))) (export shen.s-prolog) (quote shen.s-prolog))
(begin (register-function-arity (quote shen.prolog->shen) 1) (define (kl:shen.prolog->shen V1726) (kl:map (lambda (X) (kl:shen.compile_prolog_procedure X)) (kl:shen.group_clauses (kl:map (lambda (X) (kl:shen.s-prolog_clause X)) (kl:mapcan (lambda (X) (kl:shen.head_abstraction X)) V1726))))) (export shen.prolog->shen) (quote shen.prolog->shen))
(begin (register-function-arity (quote shen.s-prolog_clause) 1) (define (kl:shen.s-prolog_clause V1728) (cond ((and (pair? V1728) (and (pair? (cdr V1728)) (and (eq? (quote :-) (car (cdr V1728))) (and (pair? (cdr (cdr V1728))) (null? (cdr (cdr (cdr V1728)))))))) (cons (car V1728) (cons (quote :-) (cons (kl:map (lambda (X) (kl:shen.s-prolog_literal X)) (car (cdr (cdr V1728)))) (quote ()))))) (#t (kl:shen.f_error (quote shen.s-prolog_clause))))) (export shen.s-prolog_clause) (quote shen.s-prolog_clause))
(begin (register-function-arity (quote shen.head_abstraction) 1) (define (kl:shen.head_abstraction V1730) (cond ((and (pair? V1730) (and (pair? (cdr V1730)) (and (eq? (quote :-) (car (cdr V1730))) (and (pair? (cdr (cdr V1730))) (and (null? (cdr (cdr (cdr V1730)))) (assert-boolean (guard (lambda (_) #f) (< (kl:shen.complexity_head (car V1730)) (kl:value (quote shen.*maxcomplexity*)))))))))) (cons V1730 (quote ()))) ((and (pair? V1730) (and (pair? (car V1730)) (and (pair? (cdr V1730)) (and (eq? (quote :-) (car (cdr V1730))) (and (pair? (cdr (cdr V1730))) (null? (cdr (cdr (cdr V1730))))))))) (let ((Terms (kl:map (lambda (Y) (kl:gensym (quote V))) (cdr (car V1730))))) (let ((XTerms (kl:shen.rcons_form (kl:shen.remove_modes (cdr (car V1730)))))) (let ((Literal (cons (quote unify) (cons (kl:shen.cons_form Terms) (cons XTerms (quote ())))))) (let ((Clause (cons (cons (car (car V1730)) Terms) (cons (quote :-) (cons (cons Literal (car (cdr (cdr V1730)))) (quote ())))))) (cons Clause (quote ()))))))) (#t (kl:shen.f_error (quote shen.head_abstraction))))) (export shen.head_abstraction) (quote shen.head_abstraction))
(begin (register-function-arity (quote shen.complexity_head) 1) (define (kl:shen.complexity_head V1736) (cond ((pair? V1736) (kl:shen.safe-product (kl:map (lambda (X) (kl:shen.complexity X)) (cdr V1736)))) (#t (kl:shen.f_error (quote shen.complexity_head))))) (export shen.complexity_head) (quote shen.complexity_head))
(begin (register-function-arity (quote shen.safe-multiply) 2) (define (kl:shen.safe-multiply V1739 V1740) (* V1739 V1740)) (export shen.safe-multiply) (quote shen.safe-multiply))
(begin (register-function-arity (quote shen.complexity) 1) (define (kl:shen.complexity V1749) (cond ((and (pair? V1749) (and (eq? (quote mode) (car V1749)) (and (pair? (cdr V1749)) (and (pair? (car (cdr V1749))) (and (eq? (quote mode) (car (car (cdr V1749)))) (and (pair? (cdr (car (cdr V1749)))) (and (pair? (cdr (cdr (car (cdr V1749))))) (and (null? (cdr (cdr (cdr (car (cdr V1749)))))) (and (pair? (cdr (cdr V1749))) (null? (cdr (cdr (cdr V1749))))))))))))) (kl:shen.complexity (car (cdr V1749)))) ((and (pair? V1749) (and (eq? (quote mode) (car V1749)) (and (pair? (cdr V1749)) (and (pair? (car (cdr V1749))) (and (pair? (cdr (cdr V1749))) (and (eq? (quote +) (car (cdr (cdr V1749)))) (null? (cdr (cdr (cdr V1749)))))))))) (kl:shen.safe-multiply 2 (kl:shen.safe-multiply (kl:shen.complexity (cons (quote mode) (cons (car (car (cdr V1749))) (cdr (cdr V1749))))) (kl:shen.complexity (cons (quote mode) (cons (cdr (car (cdr V1749))) (cdr (cdr V1749)))))))) ((and (pair? V1749) (and (eq? (quote mode) (car V1749)) (and (pair? (cdr V1749)) (and (pair? (car (cdr V1749))) (and (pair? (cdr (cdr V1749))) (and (eq? (quote -) (car (cdr (cdr V1749)))) (null? (cdr (cdr (cdr V1749)))))))))) (kl:shen.safe-multiply (kl:shen.complexity (cons (quote mode) (cons (car (car (cdr V1749))) (cdr (cdr V1749))))) (kl:shen.complexity (cons (quote mode) (cons (cdr (car (cdr V1749))) (cdr (cdr V1749))))))) ((and (pair? V1749) (and (eq? (quote mode) (car V1749)) (and (pair? (cdr V1749)) (and (pair? (cdr (cdr V1749))) (and (null? (cdr (cdr (cdr V1749)))) (kl:variable? (car (cdr V1749)))))))) 1) ((and (pair? V1749) (and (eq? (quote mode) (car V1749)) (and (pair? (cdr V1749)) (and (pair? (cdr (cdr V1749))) (and (eq? (quote +) (car (cdr (cdr V1749)))) (null? (cdr (cdr (cdr V1749))))))))) 2) ((and (pair? V1749) (and (eq? (quote mode) (car V1749)) (and (pair? (cdr V1749)) (and (pair? (cdr (cdr V1749))) (and (eq? (quote -) (car (cdr (cdr V1749)))) (null? (cdr (cdr (cdr V1749))))))))) 1) (#t (kl:shen.complexity (cons (quote mode) (cons V1749 (cons (quote +) (quote ())))))))) (export shen.complexity) (quote shen.complexity))
(begin (register-function-arity (quote shen.safe-product) 1) (define (kl:shen.safe-product V1751) (cond ((null? V1751) 1) ((pair? V1751) (kl:shen.safe-multiply (car V1751) (kl:shen.safe-product (cdr V1751)))) (#t (kl:shen.f_error (quote shen.safe-product))))) (export shen.safe-product) (quote shen.safe-product))
(begin (register-function-arity (quote shen.s-prolog_literal) 1) (define (kl:shen.s-prolog_literal V1753) (cond ((and (pair? V1753) (and (eq? (quote is) (car V1753)) (and (pair? (cdr V1753)) (and (pair? (cdr (cdr V1753))) (null? (cdr (cdr (cdr V1753)))))))) (cons (quote bind) (cons (car (cdr V1753)) (cons (kl:shen.insert-deref (car (cdr (cdr V1753))) (quote ProcessN)) (quote ()))))) ((and (pair? V1753) (and (eq? (quote when) (car V1753)) (and (pair? (cdr V1753)) (null? (cdr (cdr V1753)))))) (cons (quote fwhen) (cons (kl:shen.insert-deref (car (cdr V1753)) (quote ProcessN)) (quote ())))) ((and (pair? V1753) (and (eq? (quote bind) (car V1753)) (and (pair? (cdr V1753)) (and (pair? (cdr (cdr V1753))) (null? (cdr (cdr (cdr V1753)))))))) (cons (quote bind) (cons (car (cdr V1753)) (cons (kl:shen.insert-lazyderef (car (cdr (cdr V1753))) (quote ProcessN)) (quote ()))))) ((and (pair? V1753) (and (eq? (quote fwhen) (car V1753)) (and (pair? (cdr V1753)) (null? (cdr (cdr V1753)))))) (cons (quote fwhen) (cons (kl:shen.insert-lazyderef (car (cdr V1753)) (quote ProcessN)) (quote ())))) ((pair? V1753) V1753) (#t (kl:shen.f_error (quote shen.s-prolog_literal))))) (export shen.s-prolog_literal) (quote shen.s-prolog_literal))
(begin (register-function-arity (quote shen.insert-deref) 2) (define (kl:shen.insert-deref V1760 V1761) (cond ((kl:variable? V1760) (cons (quote shen.deref) (cons V1760 (cons V1761 (quote ()))))) ((and (pair? V1760) (and (eq? (quote lambda) (car V1760)) (and (pair? (cdr V1760)) (and (pair? (cdr (cdr V1760))) (null? (cdr (cdr (cdr V1760)))))))) (cons (quote lambda) (cons (car (cdr V1760)) (cons (kl:shen.insert-deref (car (cdr (cdr V1760))) V1761) (quote ()))))) ((and (pair? V1760) (and (eq? (quote let) (car V1760)) (and (pair? (cdr V1760)) (and (pair? (cdr (cdr V1760))) (and (pair? (cdr (cdr (cdr V1760)))) (null? (cdr (cdr (cdr (cdr V1760)))))))))) (cons (quote let) (cons (car (cdr V1760)) (cons (kl:shen.insert-deref (car (cdr (cdr V1760))) V1761) (cons (kl:shen.insert-deref (car (cdr (cdr (cdr V1760)))) V1761) (quote ())))))) ((pair? V1760) (cons (kl:shen.insert-deref (car V1760) V1761) (kl:shen.insert-deref (cdr V1760) V1761))) (#t V1760))) (export shen.insert-deref) (quote shen.insert-deref))
(begin (register-function-arity (quote shen.insert-lazyderef) 2) (define (kl:shen.insert-lazyderef V1768 V1769) (cond ((kl:variable? V1768) (cons (quote shen.lazyderef) (cons V1768 (cons V1769 (quote ()))))) ((and (pair? V1768) (and (eq? (quote lambda) (car V1768)) (and (pair? (cdr V1768)) (and (pair? (cdr (cdr V1768))) (null? (cdr (cdr (cdr V1768)))))))) (cons (quote lambda) (cons (car (cdr V1768)) (cons (kl:shen.insert-lazyderef (car (cdr (cdr V1768))) V1769) (quote ()))))) ((and (pair? V1768) (and (eq? (quote let) (car V1768)) (and (pair? (cdr V1768)) (and (pair? (cdr (cdr V1768))) (and (pair? (cdr (cdr (cdr V1768)))) (null? (cdr (cdr (cdr (cdr V1768)))))))))) (cons (quote let) (cons (car (cdr V1768)) (cons (kl:shen.insert-lazyderef (car (cdr (cdr V1768))) V1769) (cons (kl:shen.insert-lazyderef (car (cdr (cdr (cdr V1768)))) V1769) (quote ())))))) ((pair? V1768) (cons (kl:shen.insert-lazyderef (car V1768) V1769) (kl:shen.insert-lazyderef (cdr V1768) V1769))) (#t V1768))) (export shen.insert-lazyderef) (quote shen.insert-lazyderef))
(begin (register-function-arity (quote shen.group_clauses) 1) (define (kl:shen.group_clauses V1771) (cond ((null? V1771) (quote ())) ((pair? V1771) (let ((Group (kl:shen.collect (lambda (X) (kl:shen.same_predicate? (car V1771) X)) V1771))) (let ((Rest (kl:difference V1771 Group))) (cons Group (kl:shen.group_clauses Rest))))) (#t (kl:shen.f_error (quote shen.group_clauses))))) (export shen.group_clauses) (quote shen.group_clauses))
(begin (register-function-arity (quote shen.collect) 2) (define (kl:shen.collect V1776 V1777) (cond ((null? V1777) (quote ())) ((pair? V1777) (if (assert-boolean (V1776 (car V1777))) (cons (car V1777) (kl:shen.collect V1776 (cdr V1777))) (kl:shen.collect V1776 (cdr V1777)))) (#t (kl:shen.f_error (quote shen.collect))))) (export shen.collect) (quote shen.collect))
(begin (register-function-arity (quote shen.same_predicate?) 2) (define (kl:shen.same_predicate? V1796 V1797) (cond ((and (pair? V1796) (and (pair? (car V1796)) (and (pair? V1797) (pair? (car V1797))))) (kl:= (car (car V1796)) (car (car V1797)))) (#t (kl:shen.f_error (quote shen.same_predicate?))))) (export shen.same_predicate?) (quote shen.same_predicate?))
(begin (register-function-arity (quote shen.compile_prolog_procedure) 1) (define (kl:shen.compile_prolog_procedure V1799) (let ((F (kl:shen.procedure_name V1799))) (let ((Shen (kl:shen.clauses-to-shen F V1799))) Shen))) (export shen.compile_prolog_procedure) (quote shen.compile_prolog_procedure))
(begin (register-function-arity (quote shen.procedure_name) 1) (define (kl:shen.procedure_name V1813) (cond ((and (pair? V1813) (and (pair? (car V1813)) (pair? (car (car V1813))))) (car (car (car V1813)))) (#t (kl:shen.f_error (quote shen.procedure_name))))) (export shen.procedure_name) (quote shen.procedure_name))
(begin (register-function-arity (quote shen.clauses-to-shen) 2) (define (kl:shen.clauses-to-shen V1816 V1817) (let ((Linear (kl:map (lambda (X) (kl:shen.linearise-clause X)) V1817))) (let ((Arity (kl:shen.prolog-aritycheck V1816 (kl:map (lambda (X) (kl:head X)) V1817)))) (let ((Parameters (kl:shen.parameters Arity))) (let ((AUM_instructions (kl:map (lambda (X) (kl:shen.aum X Parameters)) Linear))) (let ((Code (kl:shen.catch-cut (kl:shen.nest-disjunct (kl:map (lambda (X) (kl:shen.aum_to_shen X)) AUM_instructions))))) (let ((ShenDef (cons (quote define) (cons V1816 (kl:append Parameters (kl:append (cons (quote ProcessN) (cons (quote Continuation) (quote ()))) (cons (quote ->) (cons Code (quote ()))))))))) ShenDef))))))) (export shen.clauses-to-shen) (quote shen.clauses-to-shen))
(begin (register-function-arity (quote shen.catch-cut) 1) (define (kl:shen.catch-cut V1819) (cond ((kl:not (kl:shen.occurs? (quote cut) V1819)) V1819) (#t (cons (quote let) (cons (quote Throwcontrol) (cons (cons (quote shen.catchpoint) (quote ())) (cons (cons (quote shen.cutpoint) (cons (quote Throwcontrol) (cons V1819 (quote ())))) (quote ())))))))) (export shen.catch-cut) (quote shen.catch-cut))
(begin (register-function-arity (quote shen.catchpoint) 0) (define (kl:shen.catchpoint) (kl:set (quote shen.*catch*) (+ 1 (kl:value (quote shen.*catch*))))) (export shen.catchpoint) (quote shen.catchpoint))
(begin (register-function-arity (quote shen.cutpoint) 2) (define (kl:shen.cutpoint V1827 V1828) (cond ((kl:= V1828 V1827) #f) (#t V1828))) (export shen.cutpoint) (quote shen.cutpoint))
(begin (register-function-arity (quote shen.nest-disjunct) 1) (define (kl:shen.nest-disjunct V1830) (cond ((and (pair? V1830) (null? (cdr V1830))) (car V1830)) ((pair? V1830) (kl:shen.lisp-or (car V1830) (kl:shen.nest-disjunct (cdr V1830)))) (#t (kl:shen.f_error (quote shen.nest-disjunct))))) (export shen.nest-disjunct) (quote shen.nest-disjunct))
(begin (register-function-arity (quote shen.lisp-or) 2) (define (kl:shen.lisp-or V1833 V1834) (cons (quote let) (cons (quote Case) (cons V1833 (cons (cons (quote if) (cons (cons (quote =) (cons (quote Case) (cons #f (quote ())))) (cons V1834 (cons (quote Case) (quote ()))))) (quote ())))))) (export shen.lisp-or) (quote shen.lisp-or))
(begin (register-function-arity (quote shen.prolog-aritycheck) 2) (define (kl:shen.prolog-aritycheck V1839 V1840) (cond ((and (pair? V1840) (null? (cdr V1840))) (- (kl:length (car V1840)) 1)) ((and (pair? V1840) (pair? (cdr V1840))) (if (kl:= (kl:length (car V1840)) (kl:length (car (cdr V1840)))) (kl:shen.prolog-aritycheck V1839 (cdr V1840)) (simple-error (string-append "arity error in prolog procedure " (kl:shen.app (cons V1839 (quote ())) "\n" (quote shen.a)))))) (#t (kl:shen.f_error (quote shen.prolog-aritycheck))))) (export shen.prolog-aritycheck) (quote shen.prolog-aritycheck))
(begin (register-function-arity (quote shen.linearise-clause) 1) (define (kl:shen.linearise-clause V1842) (cond ((and (pair? V1842) (and (pair? (cdr V1842)) (and (eq? (quote :-) (car (cdr V1842))) (and (pair? (cdr (cdr V1842))) (null? (cdr (cdr (cdr V1842)))))))) (let ((Linear (kl:shen.linearise (cons (car V1842) (cdr (cdr V1842)))))) (kl:shen.clause_form Linear))) (#t (kl:shen.f_error (quote shen.linearise-clause))))) (export shen.linearise-clause) (quote shen.linearise-clause))
(begin (register-function-arity (quote shen.clause_form) 1) (define (kl:shen.clause_form V1844) (cond ((and (pair? V1844) (and (pair? (cdr V1844)) (null? (cdr (cdr V1844))))) (cons (kl:shen.explicit_modes (car V1844)) (cons (quote :-) (cons (kl:shen.cf_help (car (cdr V1844))) (quote ()))))) (#t (kl:shen.f_error (quote shen.clause_form))))) (export shen.clause_form) (quote shen.clause_form))
(begin (register-function-arity (quote shen.explicit_modes) 1) (define (kl:shen.explicit_modes V1846) (cond ((pair? V1846) (cons (car V1846) (kl:map (lambda (X) (kl:shen.em_help X)) (cdr V1846)))) (#t (kl:shen.f_error (quote shen.explicit_modes))))) (export shen.explicit_modes) (quote shen.explicit_modes))
(begin (register-function-arity (quote shen.em_help) 1) (define (kl:shen.em_help V1848) (cond ((and (pair? V1848) (and (eq? (quote mode) (car V1848)) (and (pair? (cdr V1848)) (and (pair? (cdr (cdr V1848))) (null? (cdr (cdr (cdr V1848)))))))) V1848) (#t (cons (quote mode) (cons V1848 (cons (quote +) (quote ()))))))) (export shen.em_help) (quote shen.em_help))
(begin (register-function-arity (quote shen.cf_help) 1) (define (kl:shen.cf_help V1850) (cond ((and (pair? V1850) (and (eq? (quote where) (car V1850)) (and (pair? (cdr V1850)) (and (pair? (car (cdr V1850))) (and (eq? (quote =) (car (car (cdr V1850)))) (and (pair? (cdr (car (cdr V1850)))) (and (pair? (cdr (cdr (car (cdr V1850))))) (and (null? (cdr (cdr (cdr (car (cdr V1850)))))) (and (pair? (cdr (cdr V1850))) (null? (cdr (cdr (cdr V1850))))))))))))) (cons (cons (if (assert-boolean (kl:value (quote shen.*occurs*))) (quote unify!) (quote unify)) (cdr (car (cdr V1850)))) (kl:shen.cf_help (car (cdr (cdr V1850)))))) (#t V1850))) (export shen.cf_help) (quote shen.cf_help))
(begin (register-function-arity (quote occurs-check) 1) (define (kl:occurs-check V1856) (cond ((eq? (quote +) V1856) (kl:set (quote shen.*occurs*) #t)) ((eq? (quote -) V1856) (kl:set (quote shen.*occurs*) #f)) (#t (simple-error "occurs-check expects + or -\n")))) (export occurs-check) (quote occurs-check))
(begin (register-function-arity (quote shen.aum) 2) (define (kl:shen.aum V1859 V1860) (cond ((and (pair? V1859) (and (pair? (car V1859)) (and (pair? (cdr V1859)) (and (eq? (quote :-) (car (cdr V1859))) (and (pair? (cdr (cdr V1859))) (null? (cdr (cdr (cdr V1859))))))))) (let ((MuApplication (kl:shen.make_mu_application (cons (quote shen.mu) (cons (cdr (car V1859)) (cons (kl:shen.continuation_call (cdr (car V1859)) (car (cdr (cdr V1859)))) (quote ())))) V1860))) (kl:shen.mu_reduction MuApplication (quote +)))) (#t (kl:shen.f_error (quote shen.aum))))) (export shen.aum) (quote shen.aum))
(begin (register-function-arity (quote shen.continuation_call) 2) (define (kl:shen.continuation_call V1863 V1864) (let ((VTerms (cons (quote ProcessN) (kl:shen.extract_vars V1863)))) (let ((VBody (kl:shen.extract_vars V1864))) (let ((Free (kl:remove (quote Throwcontrol) (kl:difference VBody VTerms)))) (kl:shen.cc_help Free V1864))))) (export shen.continuation_call) (quote shen.continuation_call))
(begin (register-function-arity (quote remove) 2) (define (kl:remove V1867 V1868) (kl:shen.remove-h V1867 V1868 (quote ()))) (export remove) (quote remove))
(begin (register-function-arity (quote shen.remove-h) 3) (define (kl:shen.remove-h V1875 V1876 V1877) (cond ((null? V1876) (kl:reverse V1877)) ((and (pair? V1876) (kl:= (car V1876) V1875)) (kl:shen.remove-h (car V1876) (cdr V1876) V1877)) ((pair? V1876) (kl:shen.remove-h V1875 (cdr V1876) (cons (car V1876) V1877))) (#t (kl:shen.f_error (quote shen.remove-h))))) (export shen.remove-h) (quote shen.remove-h))
(begin (register-function-arity (quote shen.cc_help) 2) (define (kl:shen.cc_help V1880 V1881) (cond ((and (null? V1880) (null? V1881)) (cons (quote shen.pop) (cons (quote shen.the) (cons (quote shen.stack) (quote ()))))) ((null? V1881) (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons V1880 (cons (quote and) (cons (quote shen.then) (cons (cons (quote shen.pop) (cons (quote shen.the) (cons (quote shen.stack) (quote ())))) (quote ())))))))))) ((null? V1880) (cons (quote call) (cons (quote shen.the) (cons (quote shen.continuation) (cons V1881 (quote ())))))) (#t (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons V1880 (cons (quote and) (cons (quote shen.then) (cons (cons (quote call) (cons (quote shen.the) (cons (quote shen.continuation) (cons V1881 (quote ()))))) (quote ())))))))))))) (export shen.cc_help) (quote shen.cc_help))
(begin (register-function-arity (quote shen.make_mu_application) 2) (define (kl:shen.make_mu_application V1884 V1885) (cond ((and (pair? V1884) (and (eq? (quote shen.mu) (car V1884)) (and (pair? (cdr V1884)) (and (null? (car (cdr V1884))) (and (pair? (cdr (cdr V1884))) (and (null? (cdr (cdr (cdr V1884)))) (null? V1885))))))) (car (cdr (cdr V1884)))) ((and (pair? V1884) (and (eq? (quote shen.mu) (car V1884)) (and (pair? (cdr V1884)) (and (pair? (car (cdr V1884))) (and (pair? (cdr (cdr V1884))) (and (null? (cdr (cdr (cdr V1884)))) (pair? V1885))))))) (cons (cons (quote shen.mu) (cons (car (car (cdr V1884))) (cons (kl:shen.make_mu_application (cons (quote shen.mu) (cons (cdr (car (cdr V1884))) (cdr (cdr V1884)))) (cdr V1885)) (quote ())))) (cons (car V1885) (quote ())))) (#t (kl:shen.f_error (quote shen.make_mu_application))))) (export shen.make_mu_application) (quote shen.make_mu_application))
(begin (register-function-arity (quote shen.mu_reduction) 2) (define (kl:shen.mu_reduction V1894 V1895) (cond ((and (pair? V1894) (and (pair? (car V1894)) (and (eq? (quote shen.mu) (car (car V1894))) (and (pair? (cdr (car V1894))) (and (pair? (car (cdr (car V1894)))) (and (eq? (quote mode) (car (car (cdr (car V1894))))) (and (pair? (cdr (car (cdr (car V1894))))) (and (pair? (cdr (cdr (car (cdr (car V1894)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1894))))))) (and (pair? (cdr (cdr (car V1894)))) (and (null? (cdr (cdr (cdr (car V1894))))) (and (pair? (cdr V1894)) (null? (cdr (cdr V1894))))))))))))))) (kl:shen.mu_reduction (cons (cons (quote shen.mu) (cons (car (cdr (car (cdr (car V1894))))) (cdr (cdr (car V1894))))) (cdr V1894)) (car (cdr (cdr (car (cdr (car V1894)))))))) ((and (pair? V1894) (and (pair? (car V1894)) (and (eq? (quote shen.mu) (car (car V1894))) (and (pair? (cdr (car V1894))) (and (pair? (cdr (cdr (car V1894)))) (and (null? (cdr (cdr (cdr (car V1894))))) (and (pair? (cdr V1894)) (and (null? (cdr (cdr V1894))) (eq? (quote _) (car (cdr (car V1894)))))))))))) (kl:shen.mu_reduction (car (cdr (cdr (car V1894)))) V1895)) ((and (pair? V1894) (and (pair? (car V1894)) (and (eq? (quote shen.mu) (car (car V1894))) (and (pair? (cdr (car V1894))) (and (pair? (cdr (cdr (car V1894)))) (and (null? (cdr (cdr (cdr (car V1894))))) (and (pair? (cdr V1894)) (and (null? (cdr (cdr V1894))) (assert-boolean (kl:shen.ephemeral_variable? (car (cdr (car V1894))) (car (cdr V1894)))))))))))) (kl:subst (car (cdr V1894)) (car (cdr (car V1894))) (kl:shen.mu_reduction (car (cdr (cdr (car V1894)))) V1895))) ((and (pair? V1894) (and (pair? (car V1894)) (and (eq? (quote shen.mu) (car (car V1894))) (and (pair? (cdr (car V1894))) (and (pair? (cdr (cdr (car V1894)))) (and (null? (cdr (cdr (cdr (car V1894))))) (and (pair? (cdr V1894)) (and (null? (cdr (cdr V1894))) (kl:variable? (car (cdr (car V1894)))))))))))) (cons (quote let) (cons (car (cdr (car V1894))) (cons (quote shen.be) (cons (car (cdr V1894)) (cons (quote in) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1894)))) V1895) (quote ())))))))) ((and (pair? V1894) (and (pair? (car V1894)) (and (eq? (quote shen.mu) (car (car V1894))) (and (pair? (cdr (car V1894))) (and (pair? (cdr (cdr (car V1894)))) (and (null? (cdr (cdr (cdr (car V1894))))) (and (pair? (cdr V1894)) (and (null? (cdr (cdr V1894))) (and (eq? (quote -) V1895) (assert-boolean (kl:shen.prolog_constant? (car (cdr (car V1894)))))))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V1894))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote identical) (cons (quote shen.to) (cons (car (cdr (car V1894))) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1894)))) (quote -)) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))))) ((and (pair? V1894) (and (pair? (car V1894)) (and (eq? (quote shen.mu) (car (car V1894))) (and (pair? (cdr (car V1894))) (and (pair? (cdr (cdr (car V1894)))) (and (null? (cdr (cdr (cdr (car V1894))))) (and (pair? (cdr V1894)) (and (null? (cdr (cdr V1894))) (and (eq? (quote +) V1895) (assert-boolean (kl:shen.prolog_constant? (car (cdr (car V1894)))))))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V1894))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote identical) (cons (quote shen.to) (cons (car (cdr (car V1894))) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1894)))) (quote +)) (cons (quote shen.else) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.variable) (quote ()))))) (cons (quote shen.then) (cons (cons (quote bind) (cons Z (cons (quote shen.to) (cons (car (cdr (car V1894))) (cons (quote in) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1894)))) (quote +)) (quote ()))))))) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))) (quote ()))))))))) ((and (pair? V1894) (and (pair? (car V1894)) (and (eq? (quote shen.mu) (car (car V1894))) (and (pair? (cdr (car V1894))) (and (pair? (car (cdr (car V1894)))) (and (pair? (cdr (cdr (car V1894)))) (and (null? (cdr (cdr (cdr (car V1894))))) (and (pair? (cdr V1894)) (and (null? (cdr (cdr V1894))) (eq? (quote -) V1895)))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V1894))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.non-empty) (cons (quote list) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (cons (cons (quote shen.mu) (cons (car (car (cdr (car V1894)))) (cons (cons (cons (quote shen.mu) (cons (cdr (car (cdr (car V1894)))) (cdr (cdr (car V1894))))) (cons (cons (quote shen.the) (cons (quote tail) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote ())))) (cons (cons (quote shen.the) (cons (quote head) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote -)) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))))) ((and (pair? V1894) (and (pair? (car V1894)) (and (eq? (quote shen.mu) (car (car V1894))) (and (pair? (cdr (car V1894))) (and (pair? (car (cdr (car V1894)))) (and (pair? (cdr (cdr (car V1894)))) (and (null? (cdr (cdr (cdr (car V1894))))) (and (pair? (cdr V1894)) (and (null? (cdr (cdr V1894))) (eq? (quote +) V1895)))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V1894))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.non-empty) (cons (quote list) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (cons (cons (quote shen.mu) (cons (car (car (cdr (car V1894)))) (cons (cons (cons (quote shen.mu) (cons (cdr (car (cdr (car V1894)))) (cdr (cdr (car V1894))))) (cons (cons (quote shen.the) (cons (quote tail) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote ())))) (cons (cons (quote shen.the) (cons (quote head) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote +)) (cons (quote shen.else) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.variable) (quote ()))))) (cons (quote shen.then) (cons (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons (kl:shen.extract_vars (car (cdr (car V1894)))) (cons (quote and) (cons (quote shen.then) (cons (cons (quote bind) (cons Z (cons (quote shen.to) (cons (kl:shen.rcons_form (kl:shen.remove_modes (car (cdr (car V1894))))) (cons (quote in) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1894)))) (quote +)) (quote ()))))))) (quote ()))))))))) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))) (quote ()))))))))) (#t V1894))) (export shen.mu_reduction) (quote shen.mu_reduction))
(begin (register-function-arity (quote shen.rcons_form) 1) (define (kl:shen.rcons_form V1897) (cond ((pair? V1897) (cons (quote cons) (cons (kl:shen.rcons_form (car V1897)) (cons (kl:shen.rcons_form (cdr V1897)) (quote ()))))) (#t V1897))) (export shen.rcons_form) (quote shen.rcons_form))
(begin (register-function-arity (quote shen.remove_modes) 1) (define (kl:shen.remove_modes V1899) (cond ((and (pair? V1899) (and (eq? (quote mode) (car V1899)) (and (pair? (cdr V1899)) (and (pair? (cdr (cdr V1899))) (and (eq? (quote +) (car (cdr (cdr V1899)))) (null? (cdr (cdr (cdr V1899))))))))) (kl:shen.remove_modes (car (cdr V1899)))) ((and (pair? V1899) (and (eq? (quote mode) (car V1899)) (and (pair? (cdr V1899)) (and (pair? (cdr (cdr V1899))) (and (eq? (quote -) (car (cdr (cdr V1899)))) (null? (cdr (cdr (cdr V1899))))))))) (kl:shen.remove_modes (car (cdr V1899)))) ((pair? V1899) (cons (kl:shen.remove_modes (car V1899)) (kl:shen.remove_modes (cdr V1899)))) (#t V1899))) (export shen.remove_modes) (quote shen.remove_modes))
(begin (register-function-arity (quote shen.ephemeral_variable?) 2) (define (kl:shen.ephemeral_variable? V1902 V1903) (and (kl:variable? V1902) (kl:variable? V1903))) (export shen.ephemeral_variable?) (quote shen.ephemeral_variable?))
(begin (register-function-arity (quote shen.prolog_constant?) 1) (define (kl:shen.prolog_constant? V1913) (cond ((pair? V1913) #f) (#t #t))) (export shen.prolog_constant?) (quote shen.prolog_constant?))
(begin (register-function-arity (quote shen.aum_to_shen) 1) (define (kl:shen.aum_to_shen V1915) (cond ((and (pair? V1915) (and (eq? (quote let) (car V1915)) (and (pair? (cdr V1915)) (and (pair? (cdr (cdr V1915))) (and (eq? (quote shen.be) (car (cdr (cdr V1915)))) (and (pair? (cdr (cdr (cdr V1915)))) (and (pair? (cdr (cdr (cdr (cdr V1915))))) (and (eq? (quote in) (car (cdr (cdr (cdr (cdr V1915)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1915)))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr V1915)))))))))))))))) (cons (quote let) (cons (car (cdr V1915)) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr V1915))))) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr V1915))))))) (quote ())))))) ((and (pair? V1915) (and (eq? (quote shen.the) (car V1915)) (and (pair? (cdr V1915)) (and (eq? (quote shen.result) (car (cdr V1915))) (and (pair? (cdr (cdr V1915))) (and (eq? (quote shen.of) (car (cdr (cdr V1915)))) (and (pair? (cdr (cdr (cdr V1915)))) (and (eq? (quote shen.dereferencing) (car (cdr (cdr (cdr V1915))))) (and (pair? (cdr (cdr (cdr (cdr V1915))))) (null? (cdr (cdr (cdr (cdr (cdr V1915))))))))))))))) (cons (quote shen.lazyderef) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr V1915)))))) (cons (quote ProcessN) (quote ()))))) ((and (pair? V1915) (and (eq? (quote if) (car V1915)) (and (pair? (cdr V1915)) (and (pair? (cdr (cdr V1915))) (and (eq? (quote shen.then) (car (cdr (cdr V1915)))) (and (pair? (cdr (cdr (cdr V1915)))) (and (pair? (cdr (cdr (cdr (cdr V1915))))) (and (eq? (quote shen.else) (car (cdr (cdr (cdr (cdr V1915)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1915)))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr V1915)))))))))))))))) (cons (quote if) (cons (kl:shen.aum_to_shen (car (cdr V1915))) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr V1915))))) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr V1915))))))) (quote ())))))) ((and (pair? V1915) (and (pair? (cdr V1915)) (and (eq? (quote is) (car (cdr V1915))) (and (pair? (cdr (cdr V1915))) (and (eq? (quote shen.a) (car (cdr (cdr V1915)))) (and (pair? (cdr (cdr (cdr V1915)))) (and (eq? (quote shen.variable) (car (cdr (cdr (cdr V1915))))) (null? (cdr (cdr (cdr (cdr V1915)))))))))))) (cons (quote shen.pvar?) (cons (car V1915) (quote ())))) ((and (pair? V1915) (and (pair? (cdr V1915)) (and (eq? (quote is) (car (cdr V1915))) (and (pair? (cdr (cdr V1915))) (and (eq? (quote shen.a) (car (cdr (cdr V1915)))) (and (pair? (cdr (cdr (cdr V1915)))) (and (eq? (quote shen.non-empty) (car (cdr (cdr (cdr V1915))))) (and (pair? (cdr (cdr (cdr (cdr V1915))))) (and (eq? (quote list) (car (cdr (cdr (cdr (cdr V1915)))))) (null? (cdr (cdr (cdr (cdr (cdr V1915))))))))))))))) (cons (quote cons?) (cons (car V1915) (quote ())))) ((and (pair? V1915) (and (eq? (quote shen.rename) (car V1915)) (and (pair? (cdr V1915)) (and (eq? (quote shen.the) (car (cdr V1915))) (and (pair? (cdr (cdr V1915))) (and (eq? (quote shen.variables) (car (cdr (cdr V1915)))) (and (pair? (cdr (cdr (cdr V1915)))) (and (eq? (quote in) (car (cdr (cdr (cdr V1915))))) (and (pair? (cdr (cdr (cdr (cdr V1915))))) (and (null? (car (cdr (cdr (cdr (cdr V1915)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1915)))))) (and (eq? (quote and) (car (cdr (cdr (cdr (cdr (cdr V1915))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr V1915))))))) (and (eq? (quote shen.then) (car (cdr (cdr (cdr (cdr (cdr (cdr V1915)))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1915)))))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1915)))))))))))))))))))))))) (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1915)))))))))) ((and (pair? V1915) (and (eq? (quote shen.rename) (car V1915)) (and (pair? (cdr V1915)) (and (eq? (quote shen.the) (car (cdr V1915))) (and (pair? (cdr (cdr V1915))) (and (eq? (quote shen.variables) (car (cdr (cdr V1915)))) (and (pair? (cdr (cdr (cdr V1915)))) (and (eq? (quote in) (car (cdr (cdr (cdr V1915))))) (and (pair? (cdr (cdr (cdr (cdr V1915))))) (and (pair? (car (cdr (cdr (cdr (cdr V1915)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1915)))))) (and (eq? (quote and) (car (cdr (cdr (cdr (cdr (cdr V1915))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr V1915))))))) (and (eq? (quote shen.then) (car (cdr (cdr (cdr (cdr (cdr (cdr V1915)))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1915)))))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1915)))))))))))))))))))))))) (cons (quote let) (cons (car (car (cdr (cdr (cdr (cdr V1915)))))) (cons (cons (quote shen.newpv) (cons (quote ProcessN) (quote ()))) (cons (kl:shen.aum_to_shen (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons (cdr (car (cdr (cdr (cdr (cdr V1915)))))) (cdr (cdr (cdr (cdr (cdr V1915))))))))))) (quote ())))))) ((and (pair? V1915) (and (eq? (quote bind) (car V1915)) (and (pair? (cdr V1915)) (and (pair? (cdr (cdr V1915))) (and (eq? (quote shen.to) (car (cdr (cdr V1915)))) (and (pair? (cdr (cdr (cdr V1915)))) (and (pair? (cdr (cdr (cdr (cdr V1915))))) (and (eq? (quote in) (car (cdr (cdr (cdr (cdr V1915)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1915)))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr V1915)))))))))))))))) (cons (quote do) (cons (cons (quote shen.bindv) (cons (car (cdr V1915)) (cons (kl:shen.chwild (car (cdr (cdr (cdr V1915))))) (cons (quote ProcessN) (quote ()))))) (cons (cons (quote let) (cons (quote Result) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr V1915))))))) (cons (cons (quote do) (cons (cons (quote shen.unbindv) (cons (car (cdr V1915)) (cons (quote ProcessN) (quote ())))) (cons (quote Result) (quote ())))) (quote ()))))) (quote ()))))) ((and (pair? V1915) (and (pair? (cdr V1915)) (and (eq? (quote is) (car (cdr V1915))) (and (pair? (cdr (cdr V1915))) (and (eq? (quote identical) (car (cdr (cdr V1915)))) (and (pair? (cdr (cdr (cdr V1915)))) (and (eq? (quote shen.to) (car (cdr (cdr (cdr V1915))))) (and (pair? (cdr (cdr (cdr (cdr V1915))))) (null? (cdr (cdr (cdr (cdr (cdr V1915)))))))))))))) (cons (quote =) (cons (car (cdr (cdr (cdr (cdr V1915))))) (cons (car V1915) (quote ()))))) ((eq? (quote shen.failed!) V1915) #f) ((and (pair? V1915) (and (eq? (quote shen.the) (car V1915)) (and (pair? (cdr V1915)) (and (eq? (quote head) (car (cdr V1915))) (and (pair? (cdr (cdr V1915))) (and (eq? (quote shen.of) (car (cdr (cdr V1915)))) (and (pair? (cdr (cdr (cdr V1915)))) (null? (cdr (cdr (cdr (cdr V1915)))))))))))) (cons (quote hd) (cdr (cdr (cdr V1915))))) ((and (pair? V1915) (and (eq? (quote shen.the) (car V1915)) (and (pair? (cdr V1915)) (and (eq? (quote tail) (car (cdr V1915))) (and (pair? (cdr (cdr V1915))) (and (eq? (quote shen.of) (car (cdr (cdr V1915)))) (and (pair? (cdr (cdr (cdr V1915)))) (null? (cdr (cdr (cdr (cdr V1915)))))))))))) (cons (quote tl) (cdr (cdr (cdr V1915))))) ((and (pair? V1915) (and (eq? (quote shen.pop) (car V1915)) (and (pair? (cdr V1915)) (and (eq? (quote shen.the) (car (cdr V1915))) (and (pair? (cdr (cdr V1915))) (and (eq? (quote shen.stack) (car (cdr (cdr V1915)))) (null? (cdr (cdr (cdr V1915)))))))))) (cons (quote do) (cons (cons (quote shen.incinfs) (quote ())) (cons (cons (quote thaw) (cons (quote Continuation) (quote ()))) (quote ()))))) ((and (pair? V1915) (and (eq? (quote call) (car V1915)) (and (pair? (cdr V1915)) (and (eq? (quote shen.the) (car (cdr V1915))) (and (pair? (cdr (cdr V1915))) (and (eq? (quote shen.continuation) (car (cdr (cdr V1915)))) (and (pair? (cdr (cdr (cdr V1915)))) (null? (cdr (cdr (cdr (cdr V1915)))))))))))) (cons (quote do) (cons (cons (quote shen.incinfs) (quote ())) (cons (kl:shen.call_the_continuation (kl:shen.chwild (car (cdr (cdr (cdr V1915))))) (quote ProcessN) (quote Continuation)) (quote ()))))) (#t V1915))) (export shen.aum_to_shen) (quote shen.aum_to_shen))
(begin (register-function-arity (quote shen.chwild) 1) (define (kl:shen.chwild V1917) (cond ((eq? V1917 (quote _)) (cons (quote shen.newpv) (cons (quote ProcessN) (quote ())))) ((pair? V1917) (kl:map (lambda (Z) (kl:shen.chwild Z)) V1917)) (#t V1917))) (export shen.chwild) (quote shen.chwild))
(begin (register-function-arity (quote shen.newpv) 1) (define (kl:shen.newpv V1919) (let ((Count+1 (+ (vector-ref (kl:value (quote shen.*varcounter*)) V1919) 1))) (let ((IncVar (let ((_tmp (kl:value (quote shen.*varcounter*)))) (vector-set! _tmp V1919 Count+1) _tmp))) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V1919))) (let ((ResizeVectorIfNeeded (if (kl:= Count+1 (kl:limit Vector)) (kl:shen.resizeprocessvector V1919 Count+1) (quote shen.skip)))) (kl:shen.mk-pvar Count+1)))))) (export shen.newpv) (quote shen.newpv))
(begin (register-function-arity (quote shen.resizeprocessvector) 2) (define (kl:shen.resizeprocessvector V1922 V1923) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V1922))) (let ((BigVector (kl:shen.resize-vector Vector (+ V1923 V1923) (quote shen.-null-)))) (let ((_tmp (kl:value (quote shen.*prologvectors*)))) (vector-set! _tmp V1922 BigVector) _tmp)))) (export shen.resizeprocessvector) (quote shen.resizeprocessvector))
(begin (register-function-arity (quote shen.resize-vector) 3) (define (kl:shen.resize-vector V1927 V1928 V1929) (let ((BigVector (let ((_tmp (make-vector (+ 1 V1928) (quote (quote shen.fail!))))) (vector-set! _tmp 0 V1928) _tmp))) (kl:shen.copy-vector V1927 BigVector (kl:limit V1927) V1928 V1929))) (export shen.resize-vector) (quote shen.resize-vector))
(begin (register-function-arity (quote shen.copy-vector) 5) (define (kl:shen.copy-vector V1935 V1936 V1937 V1938 V1939) (kl:shen.copy-vector-stage-2 (+ 1 V1937) (+ V1938 1) V1939 (kl:shen.copy-vector-stage-1 1 V1935 V1936 (+ 1 V1937)))) (export shen.copy-vector) (quote shen.copy-vector))
(begin (register-function-arity (quote shen.copy-vector-stage-1) 4) (define (kl:shen.copy-vector-stage-1 V1947 V1948 V1949 V1950) (cond ((kl:= V1950 V1947) V1949) (#t (kl:shen.copy-vector-stage-1 (+ 1 V1947) V1948 (let ((_tmp V1949)) (vector-set! _tmp V1947 (vector-ref V1948 V1947)) _tmp) V1950)))) (export shen.copy-vector-stage-1) (quote shen.copy-vector-stage-1))
(begin (register-function-arity (quote shen.copy-vector-stage-2) 4) (define (kl:shen.copy-vector-stage-2 V1958 V1959 V1960 V1961) (cond ((kl:= V1959 V1958) V1961) (#t (kl:shen.copy-vector-stage-2 (+ V1958 1) V1959 V1960 (let ((_tmp V1961)) (vector-set! _tmp V1958 V1960) _tmp))))) (export shen.copy-vector-stage-2) (quote shen.copy-vector-stage-2))
(begin (register-function-arity (quote shen.mk-pvar) 1) (define (kl:shen.mk-pvar V1963) (let ((_tmp (let ((_tmp (make-vector 2 (quote (quote shen.fail!))))) (vector-set! _tmp 0 (quote shen.pvar)) _tmp))) (vector-set! _tmp 1 V1963) _tmp)) (export shen.mk-pvar) (quote shen.mk-pvar))
(begin (register-function-arity (quote shen.pvar?) 1) (define (kl:shen.pvar? V1965) (and (vector? V1965) (eq? (guard (lambda (E) (quote shen.not-pvar)) (vector-ref V1965 0)) (quote shen.pvar)))) (export shen.pvar?) (quote shen.pvar?))
(begin (register-function-arity (quote shen.bindv) 3) (define (kl:shen.bindv V1969 V1970 V1971) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V1971))) (let ((_tmp Vector)) (vector-set! _tmp (vector-ref V1969 1) V1970) _tmp))) (export shen.bindv) (quote shen.bindv))
(begin (register-function-arity (quote shen.unbindv) 2) (define (kl:shen.unbindv V1974 V1975) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V1975))) (let ((_tmp Vector)) (vector-set! _tmp (vector-ref V1974 1) (quote shen.-null-)) _tmp))) (export shen.unbindv) (quote shen.unbindv))
(begin (register-function-arity (quote shen.incinfs) 0) (define (kl:shen.incinfs) (kl:set (quote shen.*infs*) (+ 1 (kl:value (quote shen.*infs*))))) (export shen.incinfs) (quote shen.incinfs))
(begin (register-function-arity (quote shen.call_the_continuation) 3) (define (kl:shen.call_the_continuation V1979 V1980 V1981) (cond ((and (pair? V1979) (and (pair? (car V1979)) (null? (cdr V1979)))) (cons (car (car V1979)) (kl:append (cdr (car V1979)) (cons V1980 (cons V1981 (quote ())))))) ((and (pair? V1979) (pair? (car V1979))) (let ((NewContinuation (kl:shen.newcontinuation (cdr V1979) V1980 V1981))) (cons (car (car V1979)) (kl:append (cdr (car V1979)) (cons V1980 (cons NewContinuation (quote ()))))))) (#t (kl:shen.f_error (quote shen.call_the_continuation))))) (export shen.call_the_continuation) (quote shen.call_the_continuation))
(begin (register-function-arity (quote shen.newcontinuation) 3) (define (kl:shen.newcontinuation V1985 V1986 V1987) (cond ((null? V1985) V1987) ((and (pair? V1985) (pair? (car V1985))) (cons (quote freeze) (cons (cons (car (car V1985)) (kl:append (cdr (car V1985)) (cons V1986 (cons (kl:shen.newcontinuation (cdr V1985) V1986 V1987) (quote ()))))) (quote ())))) (#t (kl:shen.f_error (quote shen.newcontinuation))))) (export shen.newcontinuation) (quote shen.newcontinuation))
(begin (register-function-arity (quote return) 3) (define (kl:return V1995 V1996 V1997) (kl:shen.deref V1995 V1996)) (export return) (quote return))
(begin (register-function-arity (quote shen.measure&return) 3) (define (kl:shen.measure&return V2005 V2006 V2007) (begin (kl:shen.prhush (kl:shen.app (kl:value (quote shen.*infs*)) " inferences\n" (quote shen.a)) (kl:stoutput)) (kl:shen.deref V2005 V2006))) (export shen.measure&return) (quote shen.measure&return))
(begin (register-function-arity (quote unify) 4) (define (kl:unify V2012 V2013 V2014 V2015) (kl:shen.lzy= (kl:shen.lazyderef V2012 V2014) (kl:shen.lazyderef V2013 V2014) V2014 V2015)) (export unify) (quote unify))
(begin (register-function-arity (quote shen.lzy=) 4) (define (kl:shen.lzy= V2037 V2038 V2039 V2040) (cond ((kl:= V2038 V2037) (kl:thaw V2040)) ((kl:shen.pvar? V2037) (kl:bind V2037 V2038 V2039 V2040)) ((kl:shen.pvar? V2038) (kl:bind V2038 V2037 V2039 V2040)) ((and (pair? V2037) (pair? V2038)) (kl:shen.lzy= (kl:shen.lazyderef (car V2037) V2039) (kl:shen.lazyderef (car V2038) V2039) V2039 (lambda () (kl:shen.lzy= (kl:shen.lazyderef (cdr V2037) V2039) (kl:shen.lazyderef (cdr V2038) V2039) V2039 V2040)))) (#t #f))) (export shen.lzy=) (quote shen.lzy=))
(begin (register-function-arity (quote shen.deref) 2) (define (kl:shen.deref V2043 V2044) (cond ((pair? V2043) (cons (kl:shen.deref (car V2043) V2044) (kl:shen.deref (cdr V2043) V2044))) (#t (if (kl:shen.pvar? V2043) (let ((Value (kl:shen.valvector V2043 V2044))) (if (eq? Value (quote shen.-null-)) V2043 (kl:shen.deref Value V2044))) V2043)))) (export shen.deref) (quote shen.deref))
(begin (register-function-arity (quote shen.lazyderef) 2) (define (kl:shen.lazyderef V2047 V2048) (if (kl:shen.pvar? V2047) (let ((Value (kl:shen.valvector V2047 V2048))) (if (eq? Value (quote shen.-null-)) V2047 (kl:shen.lazyderef Value V2048))) V2047)) (export shen.lazyderef) (quote shen.lazyderef))
(begin (register-function-arity (quote shen.valvector) 2) (define (kl:shen.valvector V2051 V2052) (vector-ref (vector-ref (kl:value (quote shen.*prologvectors*)) V2052) (vector-ref V2051 1))) (export shen.valvector) (quote shen.valvector))
(begin (register-function-arity (quote unify!) 4) (define (kl:unify! V2057 V2058 V2059 V2060) (kl:shen.lzy=! (kl:shen.lazyderef V2057 V2059) (kl:shen.lazyderef V2058 V2059) V2059 V2060)) (export unify!) (quote unify!))
(begin (register-function-arity (quote shen.lzy=!) 4) (define (kl:shen.lzy=! V2082 V2083 V2084 V2085) (cond ((kl:= V2083 V2082) (kl:thaw V2085)) ((and (kl:shen.pvar? V2082) (kl:not (kl:shen.occurs? V2082 (kl:shen.deref V2083 V2084)))) (kl:bind V2082 V2083 V2084 V2085)) ((and (kl:shen.pvar? V2083) (kl:not (kl:shen.occurs? V2083 (kl:shen.deref V2082 V2084)))) (kl:bind V2083 V2082 V2084 V2085)) ((and (pair? V2082) (pair? V2083)) (kl:shen.lzy=! (kl:shen.lazyderef (car V2082) V2084) (kl:shen.lazyderef (car V2083) V2084) V2084 (lambda () (kl:shen.lzy=! (kl:shen.lazyderef (cdr V2082) V2084) (kl:shen.lazyderef (cdr V2083) V2084) V2084 V2085)))) (#t #f))) (export shen.lzy=!) (quote shen.lzy=!))
(begin (register-function-arity (quote shen.occurs?) 2) (define (kl:shen.occurs? V2097 V2098) (cond ((kl:= V2098 V2097) #t) ((pair? V2098) (or (assert-boolean (kl:shen.occurs? V2097 (car V2098))) (assert-boolean (kl:shen.occurs? V2097 (cdr V2098))))) (#t #f))) (export shen.occurs?) (quote shen.occurs?))
(begin (register-function-arity (quote identical) 4) (define (kl:identical V2103 V2104 V2105 V2106) (kl:shen.lzy== (kl:shen.lazyderef V2103 V2105) (kl:shen.lazyderef V2104 V2105) V2105 V2106)) (export identical) (quote identical))
(begin (register-function-arity (quote shen.lzy==) 4) (define (kl:shen.lzy== V2128 V2129 V2130 V2131) (cond ((kl:= V2129 V2128) (kl:thaw V2131)) ((and (pair? V2128) (pair? V2129)) (kl:shen.lzy== (kl:shen.lazyderef (car V2128) V2130) (kl:shen.lazyderef (car V2129) V2130) V2130 (lambda () (kl:shen.lzy== (cdr V2128) (cdr V2129) V2130 V2131)))) (#t #f))) (export shen.lzy==) (quote shen.lzy==))
(begin (register-function-arity (quote shen.pvar) 1) (define (kl:shen.pvar V2133) (string-append "Var" (kl:shen.app (vector-ref V2133 1) "" (quote shen.a)))) (export shen.pvar) (quote shen.pvar))
(begin (register-function-arity (quote bind) 4) (define (kl:bind V2138 V2139 V2140 V2141) (begin (kl:shen.bindv V2138 V2139 V2140) (let ((Result (kl:thaw V2141))) (begin (kl:shen.unbindv V2138 V2140) Result)))) (export bind) (quote bind))
(begin (register-function-arity (quote fwhen) 3) (define (kl:fwhen V2159 V2160 V2161) (cond ((kl:= #t V2159) (kl:thaw V2161)) ((kl:= #f V2159) #f) (#t (simple-error (string-append "fwhen expects a boolean: not " (kl:shen.app V2159 "%" (quote shen.s))))))) (export fwhen) (quote fwhen))
(begin (register-function-arity (quote call) 3) (define (kl:call V2177 V2178 V2179) (cond ((pair? V2177) (kl:shen.call-help (kl:function (kl:shen.lazyderef (car V2177) V2178)) (cdr V2177) V2178 V2179)) ((kl:shen.pvar? V2177) (kl:call (kl:shen.lazyderef V2177 V2178) V2178 V2179)) (#t #f))) (export call) (quote call))
(begin (register-function-arity (quote shen.call-help) 4) (define (kl:shen.call-help V2184 V2185 V2186 V2187) (cond ((null? V2185) ((V2184 V2186) V2187)) ((pair? V2185) (kl:shen.call-help (V2184 (car V2185)) (cdr V2185) V2186 V2187)) (#t (kl:shen.f_error (quote shen.call-help))))) (export shen.call-help) (quote shen.call-help))
(begin (register-function-arity (quote shen.intprolog) 1) (define (kl:shen.intprolog V2189) (cond ((and (pair? V2189) (pair? (car V2189))) (let ((ProcessN (kl:shen.start-new-prolog-process))) (kl:shen.intprolog-help (car (car V2189)) (kl:shen.insert-prolog-variables (cons (cdr (car V2189)) (cons (cdr V2189) (quote ()))) ProcessN) ProcessN))) (#t (kl:shen.f_error (quote shen.intprolog))))) (export shen.intprolog) (quote shen.intprolog))
(begin (register-function-arity (quote shen.intprolog-help) 3) (define (kl:shen.intprolog-help V2193 V2194 V2195) (cond ((and (pair? V2194) (and (pair? (cdr V2194)) (null? (cdr (cdr V2194))))) (kl:shen.intprolog-help-help V2193 (car V2194) (car (cdr V2194)) V2195)) (#t (kl:shen.f_error (quote shen.intprolog-help))))) (export shen.intprolog-help) (quote shen.intprolog-help))
(begin (register-function-arity (quote shen.intprolog-help-help) 4) (define (kl:shen.intprolog-help-help V2200 V2201 V2202 V2203) (cond ((null? V2201) ((V2200 V2203) (lambda () (kl:shen.call-rest V2202 V2203)))) ((pair? V2201) (kl:shen.intprolog-help-help (V2200 (car V2201)) (cdr V2201) V2202 V2203)) (#t (kl:shen.f_error (quote shen.intprolog-help-help))))) (export shen.intprolog-help-help) (quote shen.intprolog-help-help))
(begin (register-function-arity (quote shen.call-rest) 2) (define (kl:shen.call-rest V2208 V2209) (cond ((null? V2208) #t) ((and (pair? V2208) (and (pair? (car V2208)) (pair? (cdr (car V2208))))) (kl:shen.call-rest (cons (cons ((car (car V2208)) (car (cdr (car V2208)))) (cdr (cdr (car V2208)))) (cdr V2208)) V2209)) ((and (pair? V2208) (and (pair? (car V2208)) (null? (cdr (car V2208))))) (((car (car V2208)) V2209) (lambda () (kl:shen.call-rest (cdr V2208) V2209)))) (#t (kl:shen.f_error (quote shen.call-rest))))) (export shen.call-rest) (quote shen.call-rest))
(begin (register-function-arity (quote shen.start-new-prolog-process) 0) (define (kl:shen.start-new-prolog-process) (let ((IncrementProcessCounter (kl:set (quote shen.*process-counter*) (+ 1 (kl:value (quote shen.*process-counter*)))))) (kl:shen.initialise-prolog IncrementProcessCounter))) (export shen.start-new-prolog-process) (quote shen.start-new-prolog-process))
(begin (register-function-arity (quote shen.insert-prolog-variables) 2) (define (kl:shen.insert-prolog-variables V2212 V2213) (kl:shen.insert-prolog-variables-help V2212 (kl:shen.flatten V2212) V2213)) (export shen.insert-prolog-variables) (quote shen.insert-prolog-variables))
(begin (register-function-arity (quote shen.insert-prolog-variables-help) 3) (define (kl:shen.insert-prolog-variables-help V2221 V2222 V2223) (cond ((null? V2222) V2221) ((and (pair? V2222) (kl:variable? (car V2222))) (let ((V (kl:shen.newpv V2223))) (let ((XV/Y (kl:subst V (car V2222) V2221))) (let ((Z-Y (kl:remove (car V2222) (cdr V2222)))) (kl:shen.insert-prolog-variables-help XV/Y Z-Y V2223))))) ((pair? V2222) (kl:shen.insert-prolog-variables-help V2221 (cdr V2222) V2223)) (#t (kl:shen.f_error (quote shen.insert-prolog-variables-help))))) (export shen.insert-prolog-variables-help) (quote shen.insert-prolog-variables-help))
(begin (register-function-arity (quote shen.initialise-prolog) 1) (define (kl:shen.initialise-prolog V2225) (let ((Vector (let ((_tmp (kl:value (quote shen.*prologvectors*)))) (vector-set! _tmp V2225 (kl:shen.fillvector (kl:vector 10) 1 10 (quote shen.-null-))) _tmp))) (let ((Counter (let ((_tmp (kl:value (quote shen.*varcounter*)))) (vector-set! _tmp V2225 1) _tmp))) V2225))) (export shen.initialise-prolog) (quote shen.initialise-prolog))
