(module "compiled/yacc.kl")
"Copyright (c) 2010-2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
(begin (register-function-arity (quote shen.yacc) 1) (define (kl:shen.yacc V5827) (cond ((and (pair? V5827) (and (eq? (quote defcc) (car V5827)) (pair? (cdr V5827)))) (kl:shen.yacc->shen (car (cdr V5827)) (cdr (cdr V5827)))) (#t (kl:shen.f_error (quote shen.yacc))))) (export shen.yacc) (quote shen.yacc))
(begin (register-function-arity (quote shen.yacc->shen) 2) (define (kl:shen.yacc->shen V5830 V5831) (let ((CCRules (kl:shen.split_cc_rules #t V5831 (quote ())))) (let ((CCBody (kl:map (lambda (X) (kl:shen.cc_body X)) CCRules))) (let ((YaccCases (kl:shen.yacc_cases CCBody))) (cons (quote define) (cons V5830 (cons (quote Stream) (cons (quote ->) (cons (kl:shen.kill-code YaccCases) (quote ())))))))))) (export shen.yacc->shen) (quote shen.yacc->shen))
(begin (register-function-arity (quote shen.kill-code) 1) (define (kl:shen.kill-code V5833) (cond ((> (kl:occurrences (quote kill) V5833) 0) (cons (quote trap-error) (cons V5833 (cons (cons (quote lambda) (cons (quote E) (cons (cons (quote shen.analyse-kill) (cons (quote E) (quote ()))) (quote ())))) (quote ()))))) (#t V5833))) (export shen.kill-code) (quote shen.kill-code))
(begin (register-function-arity (quote kill) 0) (define (kl:kill) (simple-error "yacc kill")) (export kill) (quote kill))
(begin (register-function-arity (quote shen.analyse-kill) 1) (define (kl:shen.analyse-kill V5835) (let ((String (kl:error-to-string V5835))) (if (equal? String "yacc kill") (kl:fail) V5835))) (export shen.analyse-kill) (quote shen.analyse-kill))
(begin (register-function-arity (quote shen.split_cc_rules) 3) (define (kl:shen.split_cc_rules V5841 V5842 V5843) (cond ((and (null? V5842) (null? V5843)) (quote ())) ((null? V5842) (cons (kl:shen.split_cc_rule V5841 (kl:reverse V5843) (quote ())) (quote ()))) ((and (pair? V5842) (eq? (quote _waspvm_sc_) (car V5842))) (cons (kl:shen.split_cc_rule V5841 (kl:reverse V5843) (quote ())) (kl:shen.split_cc_rules V5841 (cdr V5842) (quote ())))) ((pair? V5842) (kl:shen.split_cc_rules V5841 (cdr V5842) (cons (car V5842) V5843))) (#t (kl:shen.f_error (quote shen.split_cc_rules))))) (export shen.split_cc_rules) (quote shen.split_cc_rules))
(begin (register-function-arity (quote shen.split_cc_rule) 3) (define (kl:shen.split_cc_rule V5851 V5852 V5853) (cond ((and (pair? V5852) (and (eq? (quote :=) (car V5852)) (and (pair? (cdr V5852)) (null? (cdr (cdr V5852)))))) (cons (kl:reverse V5853) (cdr V5852))) ((and (pair? V5852) (and (eq? (quote :=) (car V5852)) (and (pair? (cdr V5852)) (and (pair? (cdr (cdr V5852))) (and (eq? (quote where) (car (cdr (cdr V5852)))) (and (pair? (cdr (cdr (cdr V5852)))) (null? (cdr (cdr (cdr (cdr V5852))))))))))) (cons (kl:reverse V5853) (cons (cons (quote where) (cons (car (cdr (cdr (cdr V5852)))) (cons (car (cdr V5852)) (quote ())))) (quote ())))) ((null? V5852) (begin (kl:shen.semantic-completion-warning V5851 V5853) (kl:shen.split_cc_rule V5851 (cons (quote :=) (cons (kl:shen.default_semantics (kl:reverse V5853)) (quote ()))) V5853))) ((pair? V5852) (kl:shen.split_cc_rule V5851 (cdr V5852) (cons (car V5852) V5853))) (#t (kl:shen.f_error (quote shen.split_cc_rule))))) (export shen.split_cc_rule) (quote shen.split_cc_rule))
(begin (register-function-arity (quote shen.semantic-completion-warning) 2) (define (kl:shen.semantic-completion-warning V5864 V5865) (cond ((kl:= #t V5864) (begin (kl:shen.prhush "warning: " (kl:stoutput)) (begin (kl:shen.for-each (lambda (X) (kl:shen.prhush (kl:shen.app X " " (quote shen.a)) (kl:stoutput))) (kl:reverse V5865)) (kl:shen.prhush "has no semantics.\n" (kl:stoutput))))) (#t (quote shen.skip)))) (export shen.semantic-completion-warning) (quote shen.semantic-completion-warning))
(begin (register-function-arity (quote shen.default_semantics) 1) (define (kl:shen.default_semantics V5867) (cond ((null? V5867) (quote ())) ((and (pair? V5867) (and (null? (cdr V5867)) (assert-boolean (kl:shen.grammar_symbol? (car V5867))))) (car V5867)) ((and (pair? V5867) (assert-boolean (kl:shen.grammar_symbol? (car V5867)))) (cons (quote append) (cons (car V5867) (cons (kl:shen.default_semantics (cdr V5867)) (quote ()))))) ((pair? V5867) (cons (quote cons) (cons (car V5867) (cons (kl:shen.default_semantics (cdr V5867)) (quote ()))))) (#t (kl:shen.f_error (quote shen.default_semantics))))) (export shen.default_semantics) (quote shen.default_semantics))
(begin (register-function-arity (quote shen.grammar_symbol?) 1) (define (kl:shen.grammar_symbol? V5869) (and (kl:symbol? V5869) (assert-boolean (let ((Cs (kl:shen.strip-pathname (kl:explode V5869)))) (and (equal? (car Cs) "<") (equal? (car (kl:reverse Cs)) ">")))))) (export shen.grammar_symbol?) (quote shen.grammar_symbol?))
(begin (register-function-arity (quote shen.yacc_cases) 1) (define (kl:shen.yacc_cases V5871) (cond ((and (pair? V5871) (null? (cdr V5871))) (car V5871)) ((pair? V5871) (let ((P (quote YaccParse))) (cons (quote let) (cons P (cons (car V5871) (cons (cons (quote if) (cons (cons (quote =) (cons P (cons (cons (quote fail) (quote ())) (quote ())))) (cons (kl:shen.yacc_cases (cdr V5871)) (cons P (quote ()))))) (quote ()))))))) (#t (kl:shen.f_error (quote shen.yacc_cases))))) (export shen.yacc_cases) (quote shen.yacc_cases))
(begin (register-function-arity (quote shen.cc_body) 1) (define (kl:shen.cc_body V5873) (cond ((and (pair? V5873) (and (pair? (cdr V5873)) (null? (cdr (cdr V5873))))) (kl:shen.syntax (car V5873) (quote Stream) (car (cdr V5873)))) (#t (kl:shen.f_error (quote shen.cc_body))))) (export shen.cc_body) (quote shen.cc_body))
(begin (register-function-arity (quote shen.syntax) 3) (define (kl:shen.syntax V5877 V5878 V5879) (cond ((and (null? V5877) (and (pair? V5879) (and (eq? (quote where) (car V5879)) (and (pair? (cdr V5879)) (and (pair? (cdr (cdr V5879))) (null? (cdr (cdr (cdr V5879))))))))) (cons (quote if) (cons (kl:shen.semantics (car (cdr V5879))) (cons (cons (quote shen.pair) (cons (cons (quote hd) (cons V5878 (quote ()))) (cons (kl:shen.semantics (car (cdr (cdr V5879)))) (quote ())))) (cons (cons (quote fail) (quote ())) (quote ())))))) ((null? V5877) (cons (quote shen.pair) (cons (cons (quote hd) (cons V5878 (quote ()))) (cons (kl:shen.semantics V5879) (quote ()))))) ((pair? V5877) (if (assert-boolean (kl:shen.grammar_symbol? (car V5877))) (kl:shen.recursive_descent V5877 V5878 V5879) (if (kl:variable? (car V5877)) (kl:shen.variable-match V5877 V5878 V5879) (if (assert-boolean (kl:shen.jump_stream? (car V5877))) (kl:shen.jump_stream V5877 V5878 V5879) (if (assert-boolean (kl:shen.terminal? (car V5877))) (kl:shen.check_stream V5877 V5878 V5879) (if (pair? (car V5877)) (kl:shen.list-stream (kl:shen.decons (car V5877)) (cdr V5877) V5878 V5879) (simple-error (kl:shen.app (car V5877) " is not legal syntax\n" (quote shen.a))))))))) (#t (kl:shen.f_error (quote shen.syntax))))) (export shen.syntax) (quote shen.syntax))
(begin (register-function-arity (quote shen.list-stream) 4) (define (kl:shen.list-stream V5884 V5885 V5886 V5887) (let ((Test (cons (quote and) (cons (cons (quote cons?) (cons (cons (quote hd) (cons V5886 (quote ()))) (quote ()))) (cons (cons (quote cons?) (cons (cons (quote shen.hdhd) (cons V5886 (quote ()))) (quote ()))) (quote ())))))) (let ((Placeholder (kl:gensym (quote shen.place)))) (let ((RunOn (kl:shen.syntax V5885 (cons (quote shen.pair) (cons (cons (quote shen.tlhd) (cons V5886 (quote ()))) (cons (cons (quote shen.hdtl) (cons V5886 (quote ()))) (quote ())))) V5887))) (let ((Action (kl:shen.insert-runon RunOn Placeholder (kl:shen.syntax V5884 (cons (quote shen.pair) (cons (cons (quote shen.hdhd) (cons V5886 (quote ()))) (cons (cons (quote shen.hdtl) (cons V5886 (quote ()))) (quote ())))) Placeholder)))) (cons (quote if) (cons Test (cons Action (cons (cons (quote fail) (quote ())) (quote ())))))))))) (export shen.list-stream) (quote shen.list-stream))
(begin (register-function-arity (quote shen.decons) 1) (define (kl:shen.decons V5889) (cond ((and (pair? V5889) (and (eq? (quote cons) (car V5889)) (and (pair? (cdr V5889)) (and (pair? (cdr (cdr V5889))) (and (null? (car (cdr (cdr V5889)))) (null? (cdr (cdr (cdr V5889))))))))) (cons (car (cdr V5889)) (quote ()))) ((and (pair? V5889) (and (eq? (quote cons) (car V5889)) (and (pair? (cdr V5889)) (and (pair? (cdr (cdr V5889))) (null? (cdr (cdr (cdr V5889)))))))) (cons (car (cdr V5889)) (kl:shen.decons (car (cdr (cdr V5889)))))) (#t V5889))) (export shen.decons) (quote shen.decons))
(begin (register-function-arity (quote shen.insert-runon) 3) (define (kl:shen.insert-runon V5904 V5905 V5906) (cond ((and (pair? V5906) (and (eq? (quote shen.pair) (car V5906)) (and (pair? (cdr V5906)) (and (pair? (cdr (cdr V5906))) (and (null? (cdr (cdr (cdr V5906)))) (kl:= (car (cdr (cdr V5906))) V5905)))))) V5904) ((pair? V5906) (kl:map (lambda (Z) (kl:shen.insert-runon V5904 V5905 Z)) V5906)) (#t V5906))) (export shen.insert-runon) (quote shen.insert-runon))
(begin (register-function-arity (quote shen.strip-pathname) 1) (define (kl:shen.strip-pathname V5912) (cond ((kl:not (kl:element? "." V5912)) V5912) ((pair? V5912) (kl:shen.strip-pathname (cdr V5912))) (#t (kl:shen.f_error (quote shen.strip-pathname))))) (export shen.strip-pathname) (quote shen.strip-pathname))
(begin (register-function-arity (quote shen.recursive_descent) 3) (define (kl:shen.recursive_descent V5916 V5917 V5918) (cond ((pair? V5916) (let ((Test (cons (car V5916) (cons V5917 (quote ()))))) (let ((Action (kl:shen.syntax (cdr V5916) (kl:concat (quote Parse_) (car V5916)) V5918))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote let) (cons (kl:concat (quote Parse_) (car V5916)) (cons Test (cons (cons (quote if) (cons (cons (quote not) (cons (cons (quote =) (cons (cons (quote fail) (quote ())) (cons (kl:concat (quote Parse_) (car V5916)) (quote ())))) (quote ()))) (cons Action (cons Else (quote ()))))) (quote ()))))))))) (#t (kl:shen.f_error (quote shen.recursive_descent))))) (export shen.recursive_descent) (quote shen.recursive_descent))
(begin (register-function-arity (quote shen.variable-match) 3) (define (kl:shen.variable-match V5922 V5923 V5924) (cond ((pair? V5922) (let ((Test (cons (quote cons?) (cons (cons (quote hd) (cons V5923 (quote ()))) (quote ()))))) (let ((Action (cons (quote let) (cons (kl:concat (quote Parse_) (car V5922)) (cons (cons (quote shen.hdhd) (cons V5923 (quote ()))) (cons (kl:shen.syntax (cdr V5922) (cons (quote shen.pair) (cons (cons (quote shen.tlhd) (cons V5923 (quote ()))) (cons (cons (quote shen.hdtl) (cons V5923 (quote ()))) (quote ())))) V5924) (quote ()))))))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote if) (cons Test (cons Action (cons Else (quote ()))))))))) (#t (kl:shen.f_error (quote shen.variable-match))))) (export shen.variable-match) (quote shen.variable-match))
(begin (register-function-arity (quote shen.terminal?) 1) (define (kl:shen.terminal? V5934) (cond ((pair? V5934) #f) ((kl:variable? V5934) #f) (#t #t))) (export shen.terminal?) (quote shen.terminal?))
(begin (register-function-arity (quote shen.jump_stream?) 1) (define (kl:shen.jump_stream? V5940) (cond ((eq? V5940 (quote _)) #t) (#t #f))) (export shen.jump_stream?) (quote shen.jump_stream?))
(begin (register-function-arity (quote shen.check_stream) 3) (define (kl:shen.check_stream V5944 V5945 V5946) (cond ((pair? V5944) (let ((Test (cons (quote and) (cons (cons (quote cons?) (cons (cons (quote hd) (cons V5945 (quote ()))) (quote ()))) (cons (cons (quote =) (cons (car V5944) (cons (cons (quote shen.hdhd) (cons V5945 (quote ()))) (quote ())))) (quote ())))))) (let ((NewStr (kl:gensym (quote NewStream)))) (let ((Action (cons (quote let) (cons NewStr (cons (cons (quote shen.pair) (cons (cons (quote shen.tlhd) (cons V5945 (quote ()))) (cons (cons (quote shen.hdtl) (cons V5945 (quote ()))) (quote ())))) (cons (kl:shen.syntax (cdr V5944) NewStr V5946) (quote ()))))))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote if) (cons Test (cons Action (cons Else (quote ())))))))))) (#t (kl:shen.f_error (quote shen.check_stream))))) (export shen.check_stream) (quote shen.check_stream))
(begin (register-function-arity (quote shen.jump_stream) 3) (define (kl:shen.jump_stream V5950 V5951 V5952) (cond ((pair? V5950) (let ((Test (cons (quote cons?) (cons (cons (quote hd) (cons V5951 (quote ()))) (quote ()))))) (let ((Action (kl:shen.syntax (cdr V5950) (cons (quote shen.pair) (cons (cons (quote shen.tlhd) (cons V5951 (quote ()))) (cons (cons (quote shen.hdtl) (cons V5951 (quote ()))) (quote ())))) V5952))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote if) (cons Test (cons Action (cons Else (quote ()))))))))) (#t (kl:shen.f_error (quote shen.jump_stream))))) (export shen.jump_stream) (quote shen.jump_stream))
(begin (register-function-arity (quote shen.semantics) 1) (define (kl:shen.semantics V5954) (cond ((null? V5954) (quote ())) ((assert-boolean (kl:shen.grammar_symbol? V5954)) (cons (quote shen.hdtl) (cons (kl:concat (quote Parse_) V5954) (quote ())))) ((kl:variable? V5954) (kl:concat (quote Parse_) V5954)) ((pair? V5954) (kl:map (lambda (Z) (kl:shen.semantics Z)) V5954)) (#t V5954))) (export shen.semantics) (quote shen.semantics))
(begin (register-function-arity (quote shen.pair) 2) (define (kl:shen.pair V5957 V5958) (cons V5957 (cons V5958 (quote ())))) (export shen.pair) (quote shen.pair))
(begin (register-function-arity (quote shen.hdtl) 1) (define (kl:shen.hdtl V5960) (car (cdr V5960))) (export shen.hdtl) (quote shen.hdtl))
(begin (register-function-arity (quote shen.hdhd) 1) (define (kl:shen.hdhd V5962) (car (car V5962))) (export shen.hdhd) (quote shen.hdhd))
(begin (register-function-arity (quote shen.tlhd) 1) (define (kl:shen.tlhd V5964) (cdr (car V5964))) (export shen.tlhd) (quote shen.tlhd))
(begin (register-function-arity (quote shen.snd-or-fail) 1) (define (kl:shen.snd-or-fail V5972) (cond ((and (pair? V5972) (and (pair? (cdr V5972)) (null? (cdr (cdr V5972))))) (car (cdr V5972))) (#t (kl:fail)))) (export shen.snd-or-fail) (quote shen.snd-or-fail))
(begin (register-function-arity (quote fail) 0) (define (kl:fail) (quote shen.fail!)) (export fail) (quote fail))
(begin (register-function-arity (quote <!>) 1) (define (kl:<!> V5980) (cond ((and (pair? V5980) (and (pair? (cdr V5980)) (null? (cdr (cdr V5980))))) (cons (quote ()) (cons (car V5980) (quote ())))) (#t (kl:fail)))) (export <!>) (quote <!>))
(begin (register-function-arity (quote <e>) 1) (define (kl:<e> V5986) (cond ((and (pair? V5986) (and (pair? (cdr V5986)) (null? (cdr (cdr V5986))))) (cons (car V5986) (cons (quote ()) (quote ())))) (#t (kl:shen.f_error (quote <e>))))) (export <e>) (quote <e>))
