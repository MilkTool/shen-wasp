"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.yacc) 1) (define (kl:shen.yacc V4119) (cond ((and (pair? V4119) (and (eq? (quote defcc) (car V4119)) (pair? (cdr V4119)))) (kl:shen.yacc->shen (car (cdr V4119)) (cdr (cdr V4119)))) (#t (kl:shen.f_error (quote shen.yacc))))) (quote shen.yacc))
(begin (register-function-arity (quote shen.yacc->shen) 2) (define (kl:shen.yacc->shen V4122 V4123) (let ((CCRules (kl:shen.split_cc_rules #t V4123 (quote ())))) (let ((CCBody (kl:map (lambda (X) (kl:shen.cc_body X)) CCRules))) (let ((YaccCases (kl:shen.yacc_cases CCBody))) (cons (quote define) (cons V4122 (cons (quote Stream) (cons (quote ->) (cons (kl:shen.kill-code YaccCases) (quote ())))))))))) (quote shen.yacc->shen))
(begin (register-function-arity (quote shen.kill-code) 1) (define (kl:shen.kill-code V4125) (cond ((> (kl:occurrences (quote kill) V4125) 0) (cons (quote trap-error) (cons V4125 (cons (cons (quote lambda) (cons (quote E) (cons (cons (quote shen.analyse-kill) (cons (quote E) (quote ()))) (quote ())))) (quote ()))))) (#t V4125))) (quote shen.kill-code))
(begin (register-function-arity (quote kill) 0) (define (kl:kill) (simple-error "yacc kill")) (quote kill))
(begin (register-function-arity (quote shen.analyse-kill) 1) (define (kl:shen.analyse-kill V4127) (let ((String (kl:error-to-string V4127))) (if (equal? String "yacc kill") (kl:fail) V4127))) (quote shen.analyse-kill))
(begin (register-function-arity (quote shen.split_cc_rules) 3) (define (kl:shen.split_cc_rules V4133 V4134 V4135) (cond ((and (null? V4134) (null? V4135)) (quote ())) ((null? V4134) (cons (kl:shen.split_cc_rule V4133 (kl:reverse V4135) (quote ())) (quote ()))) ((and (pair? V4134) (eq? (quote _waspvm_sc_) (car V4134))) (cons (kl:shen.split_cc_rule V4133 (kl:reverse V4135) (quote ())) (kl:shen.split_cc_rules V4133 (cdr V4134) (quote ())))) ((pair? V4134) (kl:shen.split_cc_rules V4133 (cdr V4134) (cons (car V4134) V4135))) (#t (kl:shen.f_error (quote shen.split_cc_rules))))) (quote shen.split_cc_rules))
(begin (register-function-arity (quote shen.split_cc_rule) 3) (define (kl:shen.split_cc_rule V4143 V4144 V4145) (cond ((and (pair? V4144) (and (eq? (quote :=) (car V4144)) (and (pair? (cdr V4144)) (null? (cdr (cdr V4144)))))) (cons (kl:reverse V4145) (cdr V4144))) ((and (pair? V4144) (and (eq? (quote :=) (car V4144)) (and (pair? (cdr V4144)) (and (pair? (cdr (cdr V4144))) (and (eq? (quote where) (car (cdr (cdr V4144)))) (and (pair? (cdr (cdr (cdr V4144)))) (null? (cdr (cdr (cdr (cdr V4144))))))))))) (cons (kl:reverse V4145) (cons (cons (quote where) (cons (car (cdr (cdr (cdr V4144)))) (cons (car (cdr V4144)) (quote ())))) (quote ())))) ((null? V4144) (begin (kl:shen.semantic-completion-warning V4143 V4145) (kl:shen.split_cc_rule V4143 (cons (quote :=) (cons (kl:shen.default_semantics (kl:reverse V4145)) (quote ()))) V4145))) ((pair? V4144) (kl:shen.split_cc_rule V4143 (cdr V4144) (cons (car V4144) V4145))) (#t (kl:shen.f_error (quote shen.split_cc_rule))))) (quote shen.split_cc_rule))
(begin (register-function-arity (quote shen.semantic-completion-warning) 2) (define (kl:shen.semantic-completion-warning V4156 V4157) (cond ((kl:= #t V4156) (begin (kl:shen.prhush "warning: " (kl:stoutput)) (begin (kl:shen.for-each (lambda (X) (kl:shen.prhush (kl:shen.app X " " (quote shen.a)) (kl:stoutput))) (kl:reverse V4157)) (kl:shen.prhush "has no semantics.\n" (kl:stoutput))))) (#t (quote shen.skip)))) (quote shen.semantic-completion-warning))
(begin (register-function-arity (quote shen.default_semantics) 1) (define (kl:shen.default_semantics V4159) (cond ((null? V4159) (quote ())) ((and (pair? V4159) (and (null? (cdr V4159)) (assert-boolean (kl:shen.grammar_symbol? (car V4159))))) (car V4159)) ((and (pair? V4159) (assert-boolean (kl:shen.grammar_symbol? (car V4159)))) (cons (quote append) (cons (car V4159) (cons (kl:shen.default_semantics (cdr V4159)) (quote ()))))) ((pair? V4159) (cons (quote cons) (cons (car V4159) (cons (kl:shen.default_semantics (cdr V4159)) (quote ()))))) (#t (kl:shen.f_error (quote shen.default_semantics))))) (quote shen.default_semantics))
(begin (register-function-arity (quote shen.grammar_symbol?) 1) (define (kl:shen.grammar_symbol? V4161) (and (kl:symbol? V4161) (assert-boolean (let ((Cs (kl:shen.strip-pathname (kl:explode V4161)))) (and (equal? (car Cs) "<") (equal? (car (kl:reverse Cs)) ">")))))) (quote shen.grammar_symbol?))
(begin (register-function-arity (quote shen.yacc_cases) 1) (define (kl:shen.yacc_cases V4163) (cond ((and (pair? V4163) (null? (cdr V4163))) (car V4163)) ((pair? V4163) (let ((P (quote YaccParse))) (cons (quote let) (cons P (cons (car V4163) (cons (cons (quote if) (cons (cons (quote =) (cons P (cons (cons (quote fail) (quote ())) (quote ())))) (cons (kl:shen.yacc_cases (cdr V4163)) (cons P (quote ()))))) (quote ()))))))) (#t (kl:shen.f_error (quote shen.yacc_cases))))) (quote shen.yacc_cases))
(begin (register-function-arity (quote shen.cc_body) 1) (define (kl:shen.cc_body V4165) (cond ((and (pair? V4165) (and (pair? (cdr V4165)) (null? (cdr (cdr V4165))))) (kl:shen.syntax (car V4165) (quote Stream) (car (cdr V4165)))) (#t (kl:shen.f_error (quote shen.cc_body))))) (quote shen.cc_body))
(begin (register-function-arity (quote shen.syntax) 3) (define (kl:shen.syntax V4169 V4170 V4171) (cond ((and (null? V4169) (and (pair? V4171) (and (eq? (quote where) (car V4171)) (and (pair? (cdr V4171)) (and (pair? (cdr (cdr V4171))) (null? (cdr (cdr (cdr V4171))))))))) (cons (quote if) (cons (kl:shen.semantics (car (cdr V4171))) (cons (cons (quote shen.pair) (cons (cons (quote hd) (cons V4170 (quote ()))) (cons (kl:shen.semantics (car (cdr (cdr V4171)))) (quote ())))) (cons (cons (quote fail) (quote ())) (quote ())))))) ((null? V4169) (cons (quote shen.pair) (cons (cons (quote hd) (cons V4170 (quote ()))) (cons (kl:shen.semantics V4171) (quote ()))))) ((pair? V4169) (if (assert-boolean (kl:shen.grammar_symbol? (car V4169))) (kl:shen.recursive_descent V4169 V4170 V4171) (if (kl:variable? (car V4169)) (kl:shen.variable-match V4169 V4170 V4171) (if (assert-boolean (kl:shen.jump_stream? (car V4169))) (kl:shen.jump_stream V4169 V4170 V4171) (if (assert-boolean (kl:shen.terminal? (car V4169))) (kl:shen.check_stream V4169 V4170 V4171) (if (pair? (car V4169)) (kl:shen.list-stream (kl:shen.decons (car V4169)) (cdr V4169) V4170 V4171) (simple-error (kl:shen.app (car V4169) " is not legal syntax\n" (quote shen.a))))))))) (#t (kl:shen.f_error (quote shen.syntax))))) (quote shen.syntax))
(begin (register-function-arity (quote shen.list-stream) 4) (define (kl:shen.list-stream V4176 V4177 V4178 V4179) (let ((Test (cons (quote and) (cons (cons (quote cons?) (cons (cons (quote hd) (cons V4178 (quote ()))) (quote ()))) (cons (cons (quote cons?) (cons (cons (quote shen.hdhd) (cons V4178 (quote ()))) (quote ()))) (quote ())))))) (let ((Placeholder (kl:gensym (quote shen.place)))) (let ((RunOn (kl:shen.syntax V4177 (cons (quote shen.pair) (cons (cons (quote shen.tlhd) (cons V4178 (quote ()))) (cons (cons (quote shen.hdtl) (cons V4178 (quote ()))) (quote ())))) V4179))) (let ((Action (kl:shen.insert-runon RunOn Placeholder (kl:shen.syntax V4176 (cons (quote shen.pair) (cons (cons (quote shen.hdhd) (cons V4178 (quote ()))) (cons (cons (quote shen.hdtl) (cons V4178 (quote ()))) (quote ())))) Placeholder)))) (cons (quote if) (cons Test (cons Action (cons (cons (quote fail) (quote ())) (quote ())))))))))) (quote shen.list-stream))
(begin (register-function-arity (quote shen.decons) 1) (define (kl:shen.decons V4181) (cond ((and (pair? V4181) (and (eq? (quote cons) (car V4181)) (and (pair? (cdr V4181)) (and (pair? (cdr (cdr V4181))) (and (null? (car (cdr (cdr V4181)))) (null? (cdr (cdr (cdr V4181))))))))) (cons (car (cdr V4181)) (quote ()))) ((and (pair? V4181) (and (eq? (quote cons) (car V4181)) (and (pair? (cdr V4181)) (and (pair? (cdr (cdr V4181))) (null? (cdr (cdr (cdr V4181)))))))) (cons (car (cdr V4181)) (kl:shen.decons (car (cdr (cdr V4181)))))) (#t V4181))) (quote shen.decons))
(begin (register-function-arity (quote shen.insert-runon) 3) (define (kl:shen.insert-runon V4196 V4197 V4198) (cond ((and (pair? V4198) (and (eq? (quote shen.pair) (car V4198)) (and (pair? (cdr V4198)) (and (pair? (cdr (cdr V4198))) (and (null? (cdr (cdr (cdr V4198)))) (kl:= (car (cdr (cdr V4198))) V4197)))))) V4196) ((pair? V4198) (kl:map (lambda (Z) (kl:shen.insert-runon V4196 V4197 Z)) V4198)) (#t V4198))) (quote shen.insert-runon))
(begin (register-function-arity (quote shen.strip-pathname) 1) (define (kl:shen.strip-pathname V4204) (cond ((kl:not (kl:element? "." V4204)) V4204) ((pair? V4204) (kl:shen.strip-pathname (cdr V4204))) (#t (kl:shen.f_error (quote shen.strip-pathname))))) (quote shen.strip-pathname))
(begin (register-function-arity (quote shen.recursive_descent) 3) (define (kl:shen.recursive_descent V4208 V4209 V4210) (cond ((pair? V4208) (let ((Test (cons (car V4208) (cons V4209 (quote ()))))) (let ((Action (kl:shen.syntax (cdr V4208) (kl:concat (quote Parse_) (car V4208)) V4210))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote let) (cons (kl:concat (quote Parse_) (car V4208)) (cons Test (cons (cons (quote if) (cons (cons (quote not) (cons (cons (quote =) (cons (cons (quote fail) (quote ())) (cons (kl:concat (quote Parse_) (car V4208)) (quote ())))) (quote ()))) (cons Action (cons Else (quote ()))))) (quote ()))))))))) (#t (kl:shen.f_error (quote shen.recursive_descent))))) (quote shen.recursive_descent))
(begin (register-function-arity (quote shen.variable-match) 3) (define (kl:shen.variable-match V4214 V4215 V4216) (cond ((pair? V4214) (let ((Test (cons (quote cons?) (cons (cons (quote hd) (cons V4215 (quote ()))) (quote ()))))) (let ((Action (cons (quote let) (cons (kl:concat (quote Parse_) (car V4214)) (cons (cons (quote shen.hdhd) (cons V4215 (quote ()))) (cons (kl:shen.syntax (cdr V4214) (cons (quote shen.pair) (cons (cons (quote shen.tlhd) (cons V4215 (quote ()))) (cons (cons (quote shen.hdtl) (cons V4215 (quote ()))) (quote ())))) V4216) (quote ()))))))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote if) (cons Test (cons Action (cons Else (quote ()))))))))) (#t (kl:shen.f_error (quote shen.variable-match))))) (quote shen.variable-match))
(begin (register-function-arity (quote shen.terminal?) 1) (define (kl:shen.terminal? V4226) (cond ((pair? V4226) #f) ((kl:variable? V4226) #f) (#t #t))) (quote shen.terminal?))
(begin (register-function-arity (quote shen.jump_stream?) 1) (define (kl:shen.jump_stream? V4232) (cond ((eq? V4232 (quote _)) #t) (#t #f))) (quote shen.jump_stream?))
(begin (register-function-arity (quote shen.check_stream) 3) (define (kl:shen.check_stream V4236 V4237 V4238) (cond ((pair? V4236) (let ((Test (cons (quote and) (cons (cons (quote cons?) (cons (cons (quote hd) (cons V4237 (quote ()))) (quote ()))) (cons (cons (quote =) (cons (car V4236) (cons (cons (quote shen.hdhd) (cons V4237 (quote ()))) (quote ())))) (quote ())))))) (let ((NewStr (kl:gensym (quote NewStream)))) (let ((Action (cons (quote let) (cons NewStr (cons (cons (quote shen.pair) (cons (cons (quote shen.tlhd) (cons V4237 (quote ()))) (cons (cons (quote shen.hdtl) (cons V4237 (quote ()))) (quote ())))) (cons (kl:shen.syntax (cdr V4236) NewStr V4238) (quote ()))))))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote if) (cons Test (cons Action (cons Else (quote ())))))))))) (#t (kl:shen.f_error (quote shen.check_stream))))) (quote shen.check_stream))
(begin (register-function-arity (quote shen.jump_stream) 3) (define (kl:shen.jump_stream V4242 V4243 V4244) (cond ((pair? V4242) (let ((Test (cons (quote cons?) (cons (cons (quote hd) (cons V4243 (quote ()))) (quote ()))))) (let ((Action (kl:shen.syntax (cdr V4242) (cons (quote shen.pair) (cons (cons (quote shen.tlhd) (cons V4243 (quote ()))) (cons (cons (quote shen.hdtl) (cons V4243 (quote ()))) (quote ())))) V4244))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote if) (cons Test (cons Action (cons Else (quote ()))))))))) (#t (kl:shen.f_error (quote shen.jump_stream))))) (quote shen.jump_stream))
(begin (register-function-arity (quote shen.semantics) 1) (define (kl:shen.semantics V4246) (cond ((null? V4246) (quote ())) ((assert-boolean (kl:shen.grammar_symbol? V4246)) (cons (quote shen.hdtl) (cons (kl:concat (quote Parse_) V4246) (quote ())))) ((kl:variable? V4246) (kl:concat (quote Parse_) V4246)) ((pair? V4246) (kl:map (lambda (Z) (kl:shen.semantics Z)) V4246)) (#t V4246))) (quote shen.semantics))
(begin (register-function-arity (quote shen.pair) 2) (define (kl:shen.pair V4249 V4250) (cons V4249 (cons V4250 (quote ())))) (quote shen.pair))
(begin (register-function-arity (quote shen.hdtl) 1) (define (kl:shen.hdtl V4252) (car (cdr V4252))) (quote shen.hdtl))
(begin (register-function-arity (quote shen.hdhd) 1) (define (kl:shen.hdhd V4254) (car (car V4254))) (quote shen.hdhd))
(begin (register-function-arity (quote shen.tlhd) 1) (define (kl:shen.tlhd V4256) (cdr (car V4256))) (quote shen.tlhd))
(begin (register-function-arity (quote shen.snd-or-fail) 1) (define (kl:shen.snd-or-fail V4264) (cond ((and (pair? V4264) (and (pair? (cdr V4264)) (null? (cdr (cdr V4264))))) (car (cdr V4264))) (#t (kl:fail)))) (quote shen.snd-or-fail))
(begin (register-function-arity (quote fail) 0) (define (kl:fail) (quote shen.fail!)) (quote fail))
(begin (register-function-arity (quote <!>) 1) (define (kl:<!> V4272) (cond ((and (pair? V4272) (and (pair? (cdr V4272)) (null? (cdr (cdr V4272))))) (cons (quote ()) (cons (car V4272) (quote ())))) (#t (kl:fail)))) (quote <!>))
(begin (register-function-arity (quote <e>) 1) (define (kl:<e> V4278) (cond ((and (pair? V4278) (and (pair? (cdr V4278)) (null? (cdr (cdr V4278))))) (cons (car V4278) (cons (quote ()) (quote ())))) (#t (kl:shen.f_error (quote <e>))))) (quote <e>))
