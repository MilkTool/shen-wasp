"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.yacc) 1) (define (kl:shen.yacc V4313) (cond ((and (pair? V4313) (and (eq? (quote defcc) (car V4313)) (pair? (cdr V4313)))) (kl:shen.yacc->shen (car (cdr V4313)) (cdr (cdr V4313)))) (#t (kl:shen.f_error (quote shen.yacc))))) (quote shen.yacc))
(begin (register-function-arity (quote shen.yacc->shen) 2) (define (kl:shen.yacc->shen V4316 V4317) (let ((CCRules (kl:shen.split_cc_rules #t V4317 (quote ())))) (let ((CCBody (kl:map (lambda (X) (kl:shen.cc_body X)) CCRules))) (let ((YaccCases (kl:shen.yacc_cases CCBody))) (cons (quote define) (cons V4316 (cons (quote Stream) (cons (quote ->) (cons (kl:shen.kill-code YaccCases) (quote ())))))))))) (quote shen.yacc->shen))
(begin (register-function-arity (quote shen.kill-code) 1) (define (kl:shen.kill-code V4319) (cond ((> (kl:occurrences (quote kill) V4319) 0) (cons (quote trap-error) (cons V4319 (cons (cons (quote lambda) (cons (quote E) (cons (cons (quote shen.analyse-kill) (cons (quote E) (quote ()))) (quote ())))) (quote ()))))) (#t V4319))) (quote shen.kill-code))
(begin (register-function-arity (quote kill) 0) (define (kl:kill) (simple-error "yacc kill")) (quote kill))
(begin (register-function-arity (quote shen.analyse-kill) 1) (define (kl:shen.analyse-kill V4321) (let ((String (kl:error-to-string V4321))) (if (equal? String "yacc kill") (kl:fail) V4321))) (quote shen.analyse-kill))
(begin (register-function-arity (quote shen.split_cc_rules) 3) (define (kl:shen.split_cc_rules V4327 V4328 V4329) (cond ((and (null? V4328) (null? V4329)) (quote ())) ((null? V4328) (cons (kl:shen.split_cc_rule V4327 (kl:reverse V4329) (quote ())) (quote ()))) ((and (pair? V4328) (eq? (quote _waspvm_sc_) (car V4328))) (cons (kl:shen.split_cc_rule V4327 (kl:reverse V4329) (quote ())) (kl:shen.split_cc_rules V4327 (cdr V4328) (quote ())))) ((pair? V4328) (kl:shen.split_cc_rules V4327 (cdr V4328) (cons (car V4328) V4329))) (#t (kl:shen.f_error (quote shen.split_cc_rules))))) (quote shen.split_cc_rules))
(begin (register-function-arity (quote shen.split_cc_rule) 3) (define (kl:shen.split_cc_rule V4337 V4338 V4339) (cond ((and (pair? V4338) (and (eq? (quote :=) (car V4338)) (and (pair? (cdr V4338)) (null? (cdr (cdr V4338)))))) (cons (kl:reverse V4339) (cdr V4338))) ((and (pair? V4338) (and (eq? (quote :=) (car V4338)) (and (pair? (cdr V4338)) (and (pair? (cdr (cdr V4338))) (and (eq? (quote where) (car (cdr (cdr V4338)))) (and (pair? (cdr (cdr (cdr V4338)))) (null? (cdr (cdr (cdr (cdr V4338))))))))))) (cons (kl:reverse V4339) (cons (cons (quote where) (cons (car (cdr (cdr (cdr V4338)))) (cons (car (cdr V4338)) (quote ())))) (quote ())))) ((null? V4338) (begin (kl:shen.semantic-completion-warning V4337 V4339) (kl:shen.split_cc_rule V4337 (cons (quote :=) (cons (kl:shen.default_semantics (kl:reverse V4339)) (quote ()))) V4339))) ((pair? V4338) (kl:shen.split_cc_rule V4337 (cdr V4338) (cons (car V4338) V4339))) (#t (kl:shen.f_error (quote shen.split_cc_rule))))) (quote shen.split_cc_rule))
(begin (register-function-arity (quote shen.semantic-completion-warning) 2) (define (kl:shen.semantic-completion-warning V4350 V4351) (cond ((kl:= #t V4350) (begin (kl:shen.prhush "warning: " (kl:stoutput)) (begin (kl:for-each (lambda (X) (kl:shen.prhush (kl:shen.app X " " (quote shen.a)) (kl:stoutput))) (kl:reverse V4351)) (kl:shen.prhush "has no semantics.\n" (kl:stoutput))))) (#t (quote shen.skip)))) (quote shen.semantic-completion-warning))
(begin (register-function-arity (quote shen.default_semantics) 1) (define (kl:shen.default_semantics V4353) (cond ((null? V4353) (quote ())) ((and (pair? V4353) (and (null? (cdr V4353)) (assert-boolean (kl:shen.grammar_symbol? (car V4353))))) (car V4353)) ((and (pair? V4353) (assert-boolean (kl:shen.grammar_symbol? (car V4353)))) (cons (quote append) (cons (car V4353) (cons (kl:shen.default_semantics (cdr V4353)) (quote ()))))) ((pair? V4353) (cons (quote cons) (cons (car V4353) (cons (kl:shen.default_semantics (cdr V4353)) (quote ()))))) (#t (kl:shen.f_error (quote shen.default_semantics))))) (quote shen.default_semantics))
(begin (register-function-arity (quote shen.grammar_symbol?) 1) (define (kl:shen.grammar_symbol? V4355) (and (kl:symbol? V4355) (assert-boolean (let ((Cs (kl:shen.strip-pathname (kl:explode V4355)))) (and (equal? (car Cs) "<") (equal? (car (kl:reverse Cs)) ">")))))) (quote shen.grammar_symbol?))
(begin (register-function-arity (quote shen.yacc_cases) 1) (define (kl:shen.yacc_cases V4357) (cond ((and (pair? V4357) (null? (cdr V4357))) (car V4357)) ((pair? V4357) (let ((P (quote YaccParse))) (cons (quote let) (cons P (cons (car V4357) (cons (cons (quote if) (cons (cons (quote =) (cons P (cons (cons (quote fail) (quote ())) (quote ())))) (cons (kl:shen.yacc_cases (cdr V4357)) (cons P (quote ()))))) (quote ()))))))) (#t (kl:shen.f_error (quote shen.yacc_cases))))) (quote shen.yacc_cases))
(begin (register-function-arity (quote shen.cc_body) 1) (define (kl:shen.cc_body V4359) (cond ((and (pair? V4359) (and (pair? (cdr V4359)) (null? (cdr (cdr V4359))))) (kl:shen.syntax (car V4359) (quote Stream) (car (cdr V4359)))) (#t (kl:shen.f_error (quote shen.cc_body))))) (quote shen.cc_body))
(begin (register-function-arity (quote shen.syntax) 3) (define (kl:shen.syntax V4363 V4364 V4365) (cond ((and (null? V4363) (and (pair? V4365) (and (eq? (quote where) (car V4365)) (and (pair? (cdr V4365)) (and (pair? (cdr (cdr V4365))) (null? (cdr (cdr (cdr V4365))))))))) (cons (quote if) (cons (kl:shen.semantics (car (cdr V4365))) (cons (cons (quote shen.pair) (cons (cons (quote hd) (cons V4364 (quote ()))) (cons (kl:shen.semantics (car (cdr (cdr V4365)))) (quote ())))) (cons (cons (quote fail) (quote ())) (quote ())))))) ((null? V4363) (cons (quote shen.pair) (cons (cons (quote hd) (cons V4364 (quote ()))) (cons (kl:shen.semantics V4365) (quote ()))))) ((pair? V4363) (if (assert-boolean (kl:shen.grammar_symbol? (car V4363))) (kl:shen.recursive_descent V4363 V4364 V4365) (if (kl:variable? (car V4363)) (kl:shen.variable-match V4363 V4364 V4365) (if (assert-boolean (kl:shen.jump_stream? (car V4363))) (kl:shen.jump_stream V4363 V4364 V4365) (if (assert-boolean (kl:shen.terminal? (car V4363))) (kl:shen.check_stream V4363 V4364 V4365) (if (pair? (car V4363)) (kl:shen.list-stream (kl:shen.decons (car V4363)) (cdr V4363) V4364 V4365) (simple-error (kl:shen.app (car V4363) " is not legal syntax\n" (quote shen.a))))))))) (#t (kl:shen.f_error (quote shen.syntax))))) (quote shen.syntax))
(begin (register-function-arity (quote shen.list-stream) 4) (define (kl:shen.list-stream V4370 V4371 V4372 V4373) (let ((Test (cons (quote and) (cons (cons (quote cons?) (cons (cons (quote hd) (cons V4372 (quote ()))) (quote ()))) (cons (cons (quote cons?) (cons (cons (quote hd) (cons (cons (quote hd) (cons V4372 (quote ()))) (quote ()))) (quote ()))) (quote ())))))) (let ((Placeholder (kl:gensym (quote shen.place)))) (let ((RunOn (kl:shen.syntax V4371 (cons (quote shen.pair) (cons (cons (quote tl) (cons (cons (quote hd) (cons V4372 (quote ()))) (quote ()))) (cons (cons (quote hd) (cons (cons (quote tl) (cons V4372 (quote ()))) (quote ()))) (quote ())))) V4373))) (let ((Action (kl:shen.insert-runon RunOn Placeholder (kl:shen.syntax V4370 (cons (quote shen.pair) (cons (cons (quote hd) (cons (cons (quote hd) (cons V4372 (quote ()))) (quote ()))) (cons (cons (quote hd) (cons (cons (quote tl) (cons V4372 (quote ()))) (quote ()))) (quote ())))) Placeholder)))) (cons (quote if) (cons Test (cons Action (cons (cons (quote fail) (quote ())) (quote ())))))))))) (quote shen.list-stream))
(begin (register-function-arity (quote shen.decons) 1) (define (kl:shen.decons V4375) (cond ((and (pair? V4375) (and (eq? (quote cons) (car V4375)) (and (pair? (cdr V4375)) (and (pair? (cdr (cdr V4375))) (and (null? (car (cdr (cdr V4375)))) (null? (cdr (cdr (cdr V4375))))))))) (cons (car (cdr V4375)) (quote ()))) ((and (pair? V4375) (and (eq? (quote cons) (car V4375)) (and (pair? (cdr V4375)) (and (pair? (cdr (cdr V4375))) (null? (cdr (cdr (cdr V4375)))))))) (cons (car (cdr V4375)) (kl:shen.decons (car (cdr (cdr V4375)))))) (#t V4375))) (quote shen.decons))
(begin (register-function-arity (quote shen.insert-runon) 3) (define (kl:shen.insert-runon V4390 V4391 V4392) (cond ((and (pair? V4392) (and (eq? (quote shen.pair) (car V4392)) (and (pair? (cdr V4392)) (and (pair? (cdr (cdr V4392))) (and (null? (cdr (cdr (cdr V4392)))) (kl:= (car (cdr (cdr V4392))) V4391)))))) V4390) ((pair? V4392) (kl:map (lambda (Z) (kl:shen.insert-runon V4390 V4391 Z)) V4392)) (#t V4392))) (quote shen.insert-runon))
(begin (register-function-arity (quote shen.strip-pathname) 1) (define (kl:shen.strip-pathname V4398) (cond ((kl:not (kl:element? "." V4398)) V4398) ((pair? V4398) (kl:shen.strip-pathname (cdr V4398))) (#t (kl:shen.f_error (quote shen.strip-pathname))))) (quote shen.strip-pathname))
(begin (register-function-arity (quote shen.recursive_descent) 3) (define (kl:shen.recursive_descent V4402 V4403 V4404) (cond ((pair? V4402) (let ((Test (cons (car V4402) (cons V4403 (quote ()))))) (let ((Action (kl:shen.syntax (cdr V4402) (kl:concat (quote Parse_) (car V4402)) V4404))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote let) (cons (kl:concat (quote Parse_) (car V4402)) (cons Test (cons (cons (quote if) (cons (cons (quote not) (cons (cons (quote =) (cons (cons (quote fail) (quote ())) (cons (kl:concat (quote Parse_) (car V4402)) (quote ())))) (quote ()))) (cons Action (cons Else (quote ()))))) (quote ()))))))))) (#t (kl:shen.f_error (quote shen.recursive_descent))))) (quote shen.recursive_descent))
(begin (register-function-arity (quote shen.variable-match) 3) (define (kl:shen.variable-match V4408 V4409 V4410) (cond ((pair? V4408) (let ((Test (cons (quote cons?) (cons (cons (quote hd) (cons V4409 (quote ()))) (quote ()))))) (let ((Action (cons (quote let) (cons (kl:concat (quote Parse_) (car V4408)) (cons (cons (quote hd) (cons (cons (quote hd) (cons V4409 (quote ()))) (quote ()))) (cons (kl:shen.syntax (cdr V4408) (cons (quote shen.pair) (cons (cons (quote tl) (cons (cons (quote hd) (cons V4409 (quote ()))) (quote ()))) (cons (cons (quote shen.hdtl) (cons V4409 (quote ()))) (quote ())))) V4410) (quote ()))))))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote if) (cons Test (cons Action (cons Else (quote ()))))))))) (#t (kl:shen.f_error (quote shen.variable-match))))) (quote shen.variable-match))
(begin (register-function-arity (quote shen.terminal?) 1) (define (kl:shen.terminal? V4420) (cond ((pair? V4420) #f) ((kl:variable? V4420) #f) (#t #t))) (quote shen.terminal?))
(begin (register-function-arity (quote shen.jump_stream?) 1) (define (kl:shen.jump_stream? V4426) (cond ((eq? V4426 (quote _)) #t) (#t #f))) (quote shen.jump_stream?))
(begin (register-function-arity (quote shen.check_stream) 3) (define (kl:shen.check_stream V4430 V4431 V4432) (cond ((pair? V4430) (let ((Test (cons (quote and) (cons (cons (quote cons?) (cons (cons (quote hd) (cons V4431 (quote ()))) (quote ()))) (cons (cons (quote =) (cons (car V4430) (cons (cons (quote hd) (cons (cons (quote hd) (cons V4431 (quote ()))) (quote ()))) (quote ())))) (quote ())))))) (let ((Action (kl:shen.syntax (cdr V4430) (cons (quote shen.pair) (cons (cons (quote tl) (cons (cons (quote hd) (cons V4431 (quote ()))) (quote ()))) (cons (cons (quote shen.hdtl) (cons V4431 (quote ()))) (quote ())))) V4432))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote if) (cons Test (cons Action (cons Else (quote ()))))))))) (#t (kl:shen.f_error (quote shen.check_stream))))) (quote shen.check_stream))
(begin (register-function-arity (quote shen.jump_stream) 3) (define (kl:shen.jump_stream V4436 V4437 V4438) (cond ((pair? V4436) (let ((Test (cons (quote cons?) (cons (cons (quote hd) (cons V4437 (quote ()))) (quote ()))))) (let ((Action (kl:shen.syntax (cdr V4436) (cons (quote shen.pair) (cons (cons (quote tl) (cons (cons (quote hd) (cons V4437 (quote ()))) (quote ()))) (cons (cons (quote shen.hdtl) (cons V4437 (quote ()))) (quote ())))) V4438))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote if) (cons Test (cons Action (cons Else (quote ()))))))))) (#t (kl:shen.f_error (quote shen.jump_stream))))) (quote shen.jump_stream))
(begin (register-function-arity (quote shen.semantics) 1) (define (kl:shen.semantics V4440) (cond ((null? V4440) (quote ())) ((assert-boolean (kl:shen.grammar_symbol? V4440)) (cons (quote shen.hdtl) (cons (kl:concat (quote Parse_) V4440) (quote ())))) ((kl:variable? V4440) (kl:concat (quote Parse_) V4440)) ((pair? V4440) (kl:map (lambda (Z) (kl:shen.semantics Z)) V4440)) (#t V4440))) (quote shen.semantics))
(begin (register-function-arity (quote shen.snd-or-fail) 1) (define (kl:shen.snd-or-fail V4448) (cond ((and (pair? V4448) (and (pair? (cdr V4448)) (null? (cdr (cdr V4448))))) (car (cdr V4448))) (#t (kl:fail)))) (quote shen.snd-or-fail))
(begin (register-function-arity (quote fail) 0) (define (kl:fail) (quote shen.fail!)) (quote fail))
(begin (register-function-arity (quote shen.pair) 2) (define (kl:shen.pair V4451 V4452) (cons V4451 (cons V4452 (quote ())))) (quote shen.pair))
(begin (register-function-arity (quote shen.hdtl) 1) (define (kl:shen.hdtl V4454) (car (cdr V4454))) (quote shen.hdtl))
(begin (register-function-arity (quote <!>) 1) (define (kl:<!> V4462) (cond ((and (pair? V4462) (and (pair? (cdr V4462)) (null? (cdr (cdr V4462))))) (cons (quote ()) (cons (car V4462) (quote ())))) (#t (kl:fail)))) (quote <!>))
(begin (register-function-arity (quote <e>) 1) (define (kl:<e> V4468) (cond ((and (pair? V4468) (and (pair? (cdr V4468)) (null? (cdr (cdr V4468))))) (cons (car V4468) (cons (quote ()) (quote ())))) (#t (kl:shen.f_error (quote <e>))))) (quote <e>))
