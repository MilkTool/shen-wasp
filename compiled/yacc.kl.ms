"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.yacc) 1) (define (kl:shen.yacc V4013) (cond ((and (pair? V4013) (and (eq? (quote defcc) (car V4013)) (pair? (cdr V4013)))) (kl:shen.yacc->shen (car (cdr V4013)) (cdr (cdr V4013)))) (#t (kl:shen.f_error (quote shen.yacc))))) (quote shen.yacc))
(begin (register-function-arity (quote shen.yacc->shen) 2) (define (kl:shen.yacc->shen V4016 V4017) (let ((CCRules (kl:shen.split_cc_rules #t V4017 (quote ())))) (let ((CCBody (kl:map (lambda (X) (kl:shen.cc_body X)) CCRules))) (let ((YaccCases (kl:shen.yacc_cases CCBody))) (cons (quote define) (cons V4016 (cons (quote Stream) (cons (quote ->) (cons (kl:shen.kill-code YaccCases) (quote ())))))))))) (quote shen.yacc->shen))
(begin (register-function-arity (quote shen.kill-code) 1) (define (kl:shen.kill-code V4019) (cond ((> (kl:occurrences (quote kill) V4019) 0) (cons (quote trap-error) (cons V4019 (cons (cons (quote lambda) (cons (quote E) (cons (cons (quote shen.analyse-kill) (cons (quote E) (quote ()))) (quote ())))) (quote ()))))) (#t V4019))) (quote shen.kill-code))
(begin (register-function-arity (quote kill) 0) (define (kl:kill) (simple-error "yacc kill")) (quote kill))
(begin (register-function-arity (quote shen.analyse-kill) 1) (define (kl:shen.analyse-kill V4021) (let ((String (kl:error-to-string V4021))) (if (equal? String "yacc kill") (kl:fail) V4021))) (quote shen.analyse-kill))
(begin (register-function-arity (quote shen.split_cc_rules) 3) (define (kl:shen.split_cc_rules V4027 V4028 V4029) (cond ((and (null? V4028) (null? V4029)) (quote ())) ((null? V4028) (cons (kl:shen.split_cc_rule V4027 (kl:reverse V4029) (quote ())) (quote ()))) ((and (pair? V4028) (eq? (quote _waspvm_sc_) (car V4028))) (cons (kl:shen.split_cc_rule V4027 (kl:reverse V4029) (quote ())) (kl:shen.split_cc_rules V4027 (cdr V4028) (quote ())))) ((pair? V4028) (kl:shen.split_cc_rules V4027 (cdr V4028) (cons (car V4028) V4029))) (#t (kl:shen.f_error (quote shen.split_cc_rules))))) (quote shen.split_cc_rules))
(begin (register-function-arity (quote shen.split_cc_rule) 3) (define (kl:shen.split_cc_rule V4037 V4038 V4039) (cond ((and (pair? V4038) (and (eq? (quote :=) (car V4038)) (and (pair? (cdr V4038)) (null? (cdr (cdr V4038)))))) (cons (kl:reverse V4039) (cdr V4038))) ((and (pair? V4038) (and (eq? (quote :=) (car V4038)) (and (pair? (cdr V4038)) (and (pair? (cdr (cdr V4038))) (and (eq? (quote where) (car (cdr (cdr V4038)))) (and (pair? (cdr (cdr (cdr V4038)))) (null? (cdr (cdr (cdr (cdr V4038))))))))))) (cons (kl:reverse V4039) (cons (cons (quote where) (cons (car (cdr (cdr (cdr V4038)))) (cons (car (cdr V4038)) (quote ())))) (quote ())))) ((null? V4038) (begin (kl:shen.semantic-completion-warning V4037 V4039) (kl:shen.split_cc_rule V4037 (cons (quote :=) (cons (kl:shen.default_semantics (kl:reverse V4039)) (quote ()))) V4039))) ((pair? V4038) (kl:shen.split_cc_rule V4037 (cdr V4038) (cons (car V4038) V4039))) (#t (kl:shen.f_error (quote shen.split_cc_rule))))) (quote shen.split_cc_rule))
(begin (register-function-arity (quote shen.semantic-completion-warning) 2) (define (kl:shen.semantic-completion-warning V4050 V4051) (cond ((kl:= #t V4050) (begin (kl:shen.prhush "warning: " (kl:stoutput)) (begin (kl:map (lambda (X) (kl:shen.prhush (kl:shen.app X " " (quote shen.a)) (kl:stoutput))) (kl:reverse V4051)) (kl:shen.prhush "has no semantics.\n" (kl:stoutput))))) (#t (quote shen.skip)))) (quote shen.semantic-completion-warning))
(begin (register-function-arity (quote shen.default_semantics) 1) (define (kl:shen.default_semantics V4053) (cond ((null? V4053) (quote ())) ((and (pair? V4053) (and (null? (cdr V4053)) (assert-boolean (kl:shen.grammar_symbol? (car V4053))))) (car V4053)) ((and (pair? V4053) (assert-boolean (kl:shen.grammar_symbol? (car V4053)))) (cons (quote append) (cons (car V4053) (cons (kl:shen.default_semantics (cdr V4053)) (quote ()))))) ((pair? V4053) (cons (quote cons) (cons (car V4053) (cons (kl:shen.default_semantics (cdr V4053)) (quote ()))))) (#t (kl:shen.f_error (quote shen.default_semantics))))) (quote shen.default_semantics))
(begin (register-function-arity (quote shen.grammar_symbol?) 1) (define (kl:shen.grammar_symbol? V4055) (and (kl:symbol? V4055) (assert-boolean (let ((Cs (kl:shen.strip-pathname (kl:explode V4055)))) (and (equal? (car Cs) "<") (equal? (car (kl:reverse Cs)) ">")))))) (quote shen.grammar_symbol?))
(begin (register-function-arity (quote shen.yacc_cases) 1) (define (kl:shen.yacc_cases V4057) (cond ((and (pair? V4057) (null? (cdr V4057))) (car V4057)) ((pair? V4057) (let ((P (quote YaccParse))) (cons (quote let) (cons P (cons (car V4057) (cons (cons (quote if) (cons (cons (quote =) (cons P (cons (cons (quote fail) (quote ())) (quote ())))) (cons (kl:shen.yacc_cases (cdr V4057)) (cons P (quote ()))))) (quote ()))))))) (#t (kl:shen.f_error (quote shen.yacc_cases))))) (quote shen.yacc_cases))
(begin (register-function-arity (quote shen.cc_body) 1) (define (kl:shen.cc_body V4059) (cond ((and (pair? V4059) (and (pair? (cdr V4059)) (null? (cdr (cdr V4059))))) (kl:shen.syntax (car V4059) (quote Stream) (car (cdr V4059)))) (#t (kl:shen.f_error (quote shen.cc_body))))) (quote shen.cc_body))
(begin (register-function-arity (quote shen.syntax) 3) (define (kl:shen.syntax V4063 V4064 V4065) (cond ((and (null? V4063) (and (pair? V4065) (and (eq? (quote where) (car V4065)) (and (pair? (cdr V4065)) (and (pair? (cdr (cdr V4065))) (null? (cdr (cdr (cdr V4065))))))))) (cons (quote if) (cons (kl:shen.semantics (car (cdr V4065))) (cons (cons (quote shen.pair) (cons (cons (quote hd) (cons V4064 (quote ()))) (cons (kl:shen.semantics (car (cdr (cdr V4065)))) (quote ())))) (cons (cons (quote fail) (quote ())) (quote ())))))) ((null? V4063) (cons (quote shen.pair) (cons (cons (quote hd) (cons V4064 (quote ()))) (cons (kl:shen.semantics V4065) (quote ()))))) ((pair? V4063) (if (assert-boolean (kl:shen.grammar_symbol? (car V4063))) (kl:shen.recursive_descent V4063 V4064 V4065) (if (kl:variable? (car V4063)) (kl:shen.variable-match V4063 V4064 V4065) (if (assert-boolean (kl:shen.jump_stream? (car V4063))) (kl:shen.jump_stream V4063 V4064 V4065) (if (assert-boolean (kl:shen.terminal? (car V4063))) (kl:shen.check_stream V4063 V4064 V4065) (if (pair? (car V4063)) (kl:shen.list-stream (kl:shen.decons (car V4063)) (cdr V4063) V4064 V4065) (simple-error (kl:shen.app (car V4063) " is not legal syntax\n" (quote shen.a))))))))) (#t (kl:shen.f_error (quote shen.syntax))))) (quote shen.syntax))
(begin (register-function-arity (quote shen.list-stream) 4) (define (kl:shen.list-stream V4070 V4071 V4072 V4073) (let ((Test (cons (quote and) (cons (cons (quote cons?) (cons (cons (quote hd) (cons V4072 (quote ()))) (quote ()))) (cons (cons (quote cons?) (cons (cons (quote hd) (cons (cons (quote hd) (cons V4072 (quote ()))) (quote ()))) (quote ()))) (quote ())))))) (let ((Placeholder (kl:gensym (quote shen.place)))) (let ((RunOn (kl:shen.syntax V4071 (cons (quote shen.pair) (cons (cons (quote tl) (cons (cons (quote hd) (cons V4072 (quote ()))) (quote ()))) (cons (cons (quote hd) (cons (cons (quote tl) (cons V4072 (quote ()))) (quote ()))) (quote ())))) V4073))) (let ((Action (kl:shen.insert-runon RunOn Placeholder (kl:shen.syntax V4070 (cons (quote shen.pair) (cons (cons (quote hd) (cons (cons (quote hd) (cons V4072 (quote ()))) (quote ()))) (cons (cons (quote hd) (cons (cons (quote tl) (cons V4072 (quote ()))) (quote ()))) (quote ())))) Placeholder)))) (cons (quote if) (cons Test (cons Action (cons (cons (quote fail) (quote ())) (quote ())))))))))) (quote shen.list-stream))
(begin (register-function-arity (quote shen.decons) 1) (define (kl:shen.decons V4075) (cond ((and (pair? V4075) (and (eq? (quote cons) (car V4075)) (and (pair? (cdr V4075)) (and (pair? (cdr (cdr V4075))) (and (null? (car (cdr (cdr V4075)))) (null? (cdr (cdr (cdr V4075))))))))) (cons (car (cdr V4075)) (quote ()))) ((and (pair? V4075) (and (eq? (quote cons) (car V4075)) (and (pair? (cdr V4075)) (and (pair? (cdr (cdr V4075))) (null? (cdr (cdr (cdr V4075)))))))) (cons (car (cdr V4075)) (kl:shen.decons (car (cdr (cdr V4075)))))) (#t V4075))) (quote shen.decons))
(begin (register-function-arity (quote shen.insert-runon) 3) (define (kl:shen.insert-runon V4090 V4091 V4092) (cond ((and (pair? V4092) (and (eq? (quote shen.pair) (car V4092)) (and (pair? (cdr V4092)) (and (pair? (cdr (cdr V4092))) (and (null? (cdr (cdr (cdr V4092)))) (kl:= (car (cdr (cdr V4092))) V4091)))))) V4090) ((pair? V4092) (kl:map (lambda (Z) (kl:shen.insert-runon V4090 V4091 Z)) V4092)) (#t V4092))) (quote shen.insert-runon))
(begin (register-function-arity (quote shen.strip-pathname) 1) (define (kl:shen.strip-pathname V4098) (cond ((kl:not (kl:element? "." V4098)) V4098) ((pair? V4098) (kl:shen.strip-pathname (cdr V4098))) (#t (kl:shen.f_error (quote shen.strip-pathname))))) (quote shen.strip-pathname))
(begin (register-function-arity (quote shen.recursive_descent) 3) (define (kl:shen.recursive_descent V4102 V4103 V4104) (cond ((pair? V4102) (let ((Test (cons (car V4102) (cons V4103 (quote ()))))) (let ((Action (kl:shen.syntax (cdr V4102) (kl:concat (quote Parse_) (car V4102)) V4104))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote let) (cons (kl:concat (quote Parse_) (car V4102)) (cons Test (cons (cons (quote if) (cons (cons (quote not) (cons (cons (quote =) (cons (cons (quote fail) (quote ())) (cons (kl:concat (quote Parse_) (car V4102)) (quote ())))) (quote ()))) (cons Action (cons Else (quote ()))))) (quote ()))))))))) (#t (kl:shen.f_error (quote shen.recursive_descent))))) (quote shen.recursive_descent))
(begin (register-function-arity (quote shen.variable-match) 3) (define (kl:shen.variable-match V4108 V4109 V4110) (cond ((pair? V4108) (let ((Test (cons (quote cons?) (cons (cons (quote hd) (cons V4109 (quote ()))) (quote ()))))) (let ((Action (cons (quote let) (cons (kl:concat (quote Parse_) (car V4108)) (cons (cons (quote hd) (cons (cons (quote hd) (cons V4109 (quote ()))) (quote ()))) (cons (kl:shen.syntax (cdr V4108) (cons (quote shen.pair) (cons (cons (quote tl) (cons (cons (quote hd) (cons V4109 (quote ()))) (quote ()))) (cons (cons (quote shen.hdtl) (cons V4109 (quote ()))) (quote ())))) V4110) (quote ()))))))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote if) (cons Test (cons Action (cons Else (quote ()))))))))) (#t (kl:shen.f_error (quote shen.variable-match))))) (quote shen.variable-match))
(begin (register-function-arity (quote shen.terminal?) 1) (define (kl:shen.terminal? V4120) (cond ((pair? V4120) #f) ((kl:variable? V4120) #f) (#t #t))) (quote shen.terminal?))
(begin (register-function-arity (quote shen.jump_stream?) 1) (define (kl:shen.jump_stream? V4126) (cond ((eq? V4126 (quote _)) #t) (#t #f))) (quote shen.jump_stream?))
(begin (register-function-arity (quote shen.check_stream) 3) (define (kl:shen.check_stream V4130 V4131 V4132) (cond ((pair? V4130) (let ((Test (cons (quote and) (cons (cons (quote cons?) (cons (cons (quote hd) (cons V4131 (quote ()))) (quote ()))) (cons (cons (quote =) (cons (car V4130) (cons (cons (quote hd) (cons (cons (quote hd) (cons V4131 (quote ()))) (quote ()))) (quote ())))) (quote ())))))) (let ((Action (kl:shen.syntax (cdr V4130) (cons (quote shen.pair) (cons (cons (quote tl) (cons (cons (quote hd) (cons V4131 (quote ()))) (quote ()))) (cons (cons (quote shen.hdtl) (cons V4131 (quote ()))) (quote ())))) V4132))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote if) (cons Test (cons Action (cons Else (quote ()))))))))) (#t (kl:shen.f_error (quote shen.check_stream))))) (quote shen.check_stream))
(begin (register-function-arity (quote shen.jump_stream) 3) (define (kl:shen.jump_stream V4136 V4137 V4138) (cond ((pair? V4136) (let ((Test (cons (quote cons?) (cons (cons (quote hd) (cons V4137 (quote ()))) (quote ()))))) (let ((Action (kl:shen.syntax (cdr V4136) (cons (quote shen.pair) (cons (cons (quote tl) (cons (cons (quote hd) (cons V4137 (quote ()))) (quote ()))) (cons (cons (quote shen.hdtl) (cons V4137 (quote ()))) (quote ())))) V4138))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote if) (cons Test (cons Action (cons Else (quote ()))))))))) (#t (kl:shen.f_error (quote shen.jump_stream))))) (quote shen.jump_stream))
(begin (register-function-arity (quote shen.semantics) 1) (define (kl:shen.semantics V4140) (cond ((null? V4140) (quote ())) ((assert-boolean (kl:shen.grammar_symbol? V4140)) (cons (quote shen.hdtl) (cons (kl:concat (quote Parse_) V4140) (quote ())))) ((kl:variable? V4140) (kl:concat (quote Parse_) V4140)) ((pair? V4140) (kl:map (lambda (Z) (kl:shen.semantics Z)) V4140)) (#t V4140))) (quote shen.semantics))
(begin (register-function-arity (quote shen.snd-or-fail) 1) (define (kl:shen.snd-or-fail V4148) (cond ((and (pair? V4148) (and (pair? (cdr V4148)) (null? (cdr (cdr V4148))))) (car (cdr V4148))) (#t (kl:fail)))) (quote shen.snd-or-fail))
(begin (register-function-arity (quote fail) 0) (define (kl:fail) (quote shen.fail!)) (quote fail))
(begin (register-function-arity (quote shen.pair) 2) (define (kl:shen.pair V4151 V4152) (cons V4151 (cons V4152 (quote ())))) (quote shen.pair))
(begin (register-function-arity (quote shen.hdtl) 1) (define (kl:shen.hdtl V4154) (car (cdr V4154))) (quote shen.hdtl))
(begin (register-function-arity (quote <!>) 1) (define (kl:<!> V4162) (cond ((and (pair? V4162) (and (pair? (cdr V4162)) (null? (cdr (cdr V4162))))) (cons (quote ()) (cons (car V4162) (quote ())))) (#t (kl:fail)))) (quote <!>))
(begin (register-function-arity (quote <e>) 1) (define (kl:<e> V4168) (cond ((and (pair? V4168) (and (pair? (cdr V4168)) (null? (cdr (cdr V4168))))) (cons (car V4168) (cons (quote ()) (quote ())))) (#t (kl:shen.f_error (quote <e>))))) (quote <e>))
