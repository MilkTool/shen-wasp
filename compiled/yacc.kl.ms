"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.yacc) 1) (define (kl:shen.yacc V4140) (cond ((and (pair? V4140) (and (eq? (quote defcc) (car V4140)) (pair? (cdr V4140)))) (kl:shen.yacc->shen (car (cdr V4140)) (cdr (cdr V4140)))) (#t (kl:shen.f_error (quote shen.yacc))))) (quote shen.yacc))
(begin (register-function-arity (quote shen.yacc->shen) 2) (define (kl:shen.yacc->shen V4143 V4144) (let ((CCRules (kl:shen.split_cc_rules #t V4144 (quote ())))) (let ((CCBody (kl:map (lambda (X) (kl:shen.cc_body X)) CCRules))) (let ((YaccCases (kl:shen.yacc_cases CCBody))) (cons (quote define) (cons V4143 (cons (quote Stream) (cons (quote ->) (cons (kl:shen.kill-code YaccCases) (quote ())))))))))) (quote shen.yacc->shen))
(begin (register-function-arity (quote shen.kill-code) 1) (define (kl:shen.kill-code V4146) (cond ((> (kl:occurrences (quote kill) V4146) 0) (cons (quote trap-error) (cons V4146 (cons (cons (quote lambda) (cons (quote E) (cons (cons (quote shen.analyse-kill) (cons (quote E) (quote ()))) (quote ())))) (quote ()))))) (#t V4146))) (quote shen.kill-code))
(begin (register-function-arity (quote kill) 0) (define (kl:kill) (simple-error "yacc kill")) (quote kill))
(begin (register-function-arity (quote shen.analyse-kill) 1) (define (kl:shen.analyse-kill V4148) (let ((String (kl:error-to-string V4148))) (if (equal? String "yacc kill") (kl:fail) V4148))) (quote shen.analyse-kill))
(begin (register-function-arity (quote shen.split_cc_rules) 3) (define (kl:shen.split_cc_rules V4154 V4155 V4156) (cond ((and (null? V4155) (null? V4156)) (quote ())) ((null? V4155) (cons (kl:shen.split_cc_rule V4154 (kl:reverse V4156) (quote ())) (quote ()))) ((and (pair? V4155) (eq? (quote _waspvm_sc_) (car V4155))) (cons (kl:shen.split_cc_rule V4154 (kl:reverse V4156) (quote ())) (kl:shen.split_cc_rules V4154 (cdr V4155) (quote ())))) ((pair? V4155) (kl:shen.split_cc_rules V4154 (cdr V4155) (cons (car V4155) V4156))) (#t (kl:shen.f_error (quote shen.split_cc_rules))))) (quote shen.split_cc_rules))
(begin (register-function-arity (quote shen.split_cc_rule) 3) (define (kl:shen.split_cc_rule V4164 V4165 V4166) (cond ((and (pair? V4165) (and (eq? (quote :=) (car V4165)) (and (pair? (cdr V4165)) (null? (cdr (cdr V4165)))))) (cons (kl:reverse V4166) (cdr V4165))) ((and (pair? V4165) (and (eq? (quote :=) (car V4165)) (and (pair? (cdr V4165)) (and (pair? (cdr (cdr V4165))) (and (eq? (quote where) (car (cdr (cdr V4165)))) (and (pair? (cdr (cdr (cdr V4165)))) (null? (cdr (cdr (cdr (cdr V4165))))))))))) (cons (kl:reverse V4166) (cons (cons (quote where) (cons (car (cdr (cdr (cdr V4165)))) (cons (car (cdr V4165)) (quote ())))) (quote ())))) ((null? V4165) (begin (kl:shen.semantic-completion-warning V4164 V4166) (kl:shen.split_cc_rule V4164 (cons (quote :=) (cons (kl:shen.default_semantics (kl:reverse V4166)) (quote ()))) V4166))) ((pair? V4165) (kl:shen.split_cc_rule V4164 (cdr V4165) (cons (car V4165) V4166))) (#t (kl:shen.f_error (quote shen.split_cc_rule))))) (quote shen.split_cc_rule))
(begin (register-function-arity (quote shen.semantic-completion-warning) 2) (define (kl:shen.semantic-completion-warning V4177 V4178) (cond ((kl:= #t V4177) (begin (kl:shen.prhush "warning: " (kl:stoutput)) (begin (kl:for-each (lambda (X) (kl:shen.prhush (kl:shen.app X " " (quote shen.a)) (kl:stoutput))) (kl:reverse V4178)) (kl:shen.prhush "has no semantics.\n" (kl:stoutput))))) (#t (quote shen.skip)))) (quote shen.semantic-completion-warning))
(begin (register-function-arity (quote shen.default_semantics) 1) (define (kl:shen.default_semantics V4180) (cond ((null? V4180) (quote ())) ((and (pair? V4180) (and (null? (cdr V4180)) (assert-boolean (kl:shen.grammar_symbol? (car V4180))))) (car V4180)) ((and (pair? V4180) (assert-boolean (kl:shen.grammar_symbol? (car V4180)))) (cons (quote append) (cons (car V4180) (cons (kl:shen.default_semantics (cdr V4180)) (quote ()))))) ((pair? V4180) (cons (quote cons) (cons (car V4180) (cons (kl:shen.default_semantics (cdr V4180)) (quote ()))))) (#t (kl:shen.f_error (quote shen.default_semantics))))) (quote shen.default_semantics))
(begin (register-function-arity (quote shen.grammar_symbol?) 1) (define (kl:shen.grammar_symbol? V4182) (and (kl:symbol? V4182) (assert-boolean (let ((Cs (kl:shen.strip-pathname (kl:explode V4182)))) (and (equal? (car Cs) "<") (equal? (car (kl:reverse Cs)) ">")))))) (quote shen.grammar_symbol?))
(begin (register-function-arity (quote shen.yacc_cases) 1) (define (kl:shen.yacc_cases V4184) (cond ((and (pair? V4184) (null? (cdr V4184))) (car V4184)) ((pair? V4184) (let ((P (quote YaccParse))) (cons (quote let) (cons P (cons (car V4184) (cons (cons (quote if) (cons (cons (quote =) (cons P (cons (cons (quote fail) (quote ())) (quote ())))) (cons (kl:shen.yacc_cases (cdr V4184)) (cons P (quote ()))))) (quote ()))))))) (#t (kl:shen.f_error (quote shen.yacc_cases))))) (quote shen.yacc_cases))
(begin (register-function-arity (quote shen.cc_body) 1) (define (kl:shen.cc_body V4186) (cond ((and (pair? V4186) (and (pair? (cdr V4186)) (null? (cdr (cdr V4186))))) (kl:shen.syntax (car V4186) (quote Stream) (car (cdr V4186)))) (#t (kl:shen.f_error (quote shen.cc_body))))) (quote shen.cc_body))
(begin (register-function-arity (quote shen.syntax) 3) (define (kl:shen.syntax V4190 V4191 V4192) (cond ((and (null? V4190) (and (pair? V4192) (and (eq? (quote where) (car V4192)) (and (pair? (cdr V4192)) (and (pair? (cdr (cdr V4192))) (null? (cdr (cdr (cdr V4192))))))))) (cons (quote if) (cons (kl:shen.semantics (car (cdr V4192))) (cons (cons (quote shen.pair) (cons (cons (quote hd) (cons V4191 (quote ()))) (cons (kl:shen.semantics (car (cdr (cdr V4192)))) (quote ())))) (cons (cons (quote fail) (quote ())) (quote ())))))) ((null? V4190) (cons (quote shen.pair) (cons (cons (quote hd) (cons V4191 (quote ()))) (cons (kl:shen.semantics V4192) (quote ()))))) ((pair? V4190) (if (assert-boolean (kl:shen.grammar_symbol? (car V4190))) (kl:shen.recursive_descent V4190 V4191 V4192) (if (kl:variable? (car V4190)) (kl:shen.variable-match V4190 V4191 V4192) (if (assert-boolean (kl:shen.jump_stream? (car V4190))) (kl:shen.jump_stream V4190 V4191 V4192) (if (assert-boolean (kl:shen.terminal? (car V4190))) (kl:shen.check_stream V4190 V4191 V4192) (if (pair? (car V4190)) (kl:shen.list-stream (kl:shen.decons (car V4190)) (cdr V4190) V4191 V4192) (simple-error (kl:shen.app (car V4190) " is not legal syntax\n" (quote shen.a))))))))) (#t (kl:shen.f_error (quote shen.syntax))))) (quote shen.syntax))
(begin (register-function-arity (quote shen.list-stream) 4) (define (kl:shen.list-stream V4197 V4198 V4199 V4200) (let ((Test (cons (quote and) (cons (cons (quote cons?) (cons (cons (quote hd) (cons V4199 (quote ()))) (quote ()))) (cons (cons (quote cons?) (cons (cons (quote hd) (cons (cons (quote hd) (cons V4199 (quote ()))) (quote ()))) (quote ()))) (quote ())))))) (let ((Placeholder (kl:gensym (quote shen.place)))) (let ((RunOn (kl:shen.syntax V4198 (cons (quote shen.pair) (cons (cons (quote tl) (cons (cons (quote hd) (cons V4199 (quote ()))) (quote ()))) (cons (cons (quote hd) (cons (cons (quote tl) (cons V4199 (quote ()))) (quote ()))) (quote ())))) V4200))) (let ((Action (kl:shen.insert-runon RunOn Placeholder (kl:shen.syntax V4197 (cons (quote shen.pair) (cons (cons (quote hd) (cons (cons (quote hd) (cons V4199 (quote ()))) (quote ()))) (cons (cons (quote hd) (cons (cons (quote tl) (cons V4199 (quote ()))) (quote ()))) (quote ())))) Placeholder)))) (cons (quote if) (cons Test (cons Action (cons (cons (quote fail) (quote ())) (quote ())))))))))) (quote shen.list-stream))
(begin (register-function-arity (quote shen.decons) 1) (define (kl:shen.decons V4202) (cond ((and (pair? V4202) (and (eq? (quote cons) (car V4202)) (and (pair? (cdr V4202)) (and (pair? (cdr (cdr V4202))) (and (null? (car (cdr (cdr V4202)))) (null? (cdr (cdr (cdr V4202))))))))) (cons (car (cdr V4202)) (quote ()))) ((and (pair? V4202) (and (eq? (quote cons) (car V4202)) (and (pair? (cdr V4202)) (and (pair? (cdr (cdr V4202))) (null? (cdr (cdr (cdr V4202)))))))) (cons (car (cdr V4202)) (kl:shen.decons (car (cdr (cdr V4202)))))) (#t V4202))) (quote shen.decons))
(begin (register-function-arity (quote shen.insert-runon) 3) (define (kl:shen.insert-runon V4217 V4218 V4219) (cond ((and (pair? V4219) (and (eq? (quote shen.pair) (car V4219)) (and (pair? (cdr V4219)) (and (pair? (cdr (cdr V4219))) (and (null? (cdr (cdr (cdr V4219)))) (kl:= (car (cdr (cdr V4219))) V4218)))))) V4217) ((pair? V4219) (kl:map (lambda (Z) (kl:shen.insert-runon V4217 V4218 Z)) V4219)) (#t V4219))) (quote shen.insert-runon))
(begin (register-function-arity (quote shen.strip-pathname) 1) (define (kl:shen.strip-pathname V4225) (cond ((kl:not (kl:element? "." V4225)) V4225) ((pair? V4225) (kl:shen.strip-pathname (cdr V4225))) (#t (kl:shen.f_error (quote shen.strip-pathname))))) (quote shen.strip-pathname))
(begin (register-function-arity (quote shen.recursive_descent) 3) (define (kl:shen.recursive_descent V4229 V4230 V4231) (cond ((pair? V4229) (let ((Test (cons (car V4229) (cons V4230 (quote ()))))) (let ((Action (kl:shen.syntax (cdr V4229) (kl:concat (quote Parse_) (car V4229)) V4231))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote let) (cons (kl:concat (quote Parse_) (car V4229)) (cons Test (cons (cons (quote if) (cons (cons (quote not) (cons (cons (quote =) (cons (cons (quote fail) (quote ())) (cons (kl:concat (quote Parse_) (car V4229)) (quote ())))) (quote ()))) (cons Action (cons Else (quote ()))))) (quote ()))))))))) (#t (kl:shen.f_error (quote shen.recursive_descent))))) (quote shen.recursive_descent))
(begin (register-function-arity (quote shen.variable-match) 3) (define (kl:shen.variable-match V4235 V4236 V4237) (cond ((pair? V4235) (let ((Test (cons (quote cons?) (cons (cons (quote hd) (cons V4236 (quote ()))) (quote ()))))) (let ((Action (cons (quote let) (cons (kl:concat (quote Parse_) (car V4235)) (cons (cons (quote hd) (cons (cons (quote hd) (cons V4236 (quote ()))) (quote ()))) (cons (kl:shen.syntax (cdr V4235) (cons (quote shen.pair) (cons (cons (quote tl) (cons (cons (quote hd) (cons V4236 (quote ()))) (quote ()))) (cons (cons (quote shen.hdtl) (cons V4236 (quote ()))) (quote ())))) V4237) (quote ()))))))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote if) (cons Test (cons Action (cons Else (quote ()))))))))) (#t (kl:shen.f_error (quote shen.variable-match))))) (quote shen.variable-match))
(begin (register-function-arity (quote shen.terminal?) 1) (define (kl:shen.terminal? V4247) (cond ((pair? V4247) #f) ((kl:variable? V4247) #f) (#t #t))) (quote shen.terminal?))
(begin (register-function-arity (quote shen.jump_stream?) 1) (define (kl:shen.jump_stream? V4253) (cond ((eq? V4253 (quote _)) #t) (#t #f))) (quote shen.jump_stream?))
(begin (register-function-arity (quote shen.check_stream) 3) (define (kl:shen.check_stream V4257 V4258 V4259) (cond ((pair? V4257) (let ((Test (cons (quote and) (cons (cons (quote cons?) (cons (cons (quote hd) (cons V4258 (quote ()))) (quote ()))) (cons (cons (quote =) (cons (car V4257) (cons (cons (quote hd) (cons (cons (quote hd) (cons V4258 (quote ()))) (quote ()))) (quote ())))) (quote ())))))) (let ((Action (kl:shen.syntax (cdr V4257) (cons (quote shen.pair) (cons (cons (quote tl) (cons (cons (quote hd) (cons V4258 (quote ()))) (quote ()))) (cons (cons (quote shen.hdtl) (cons V4258 (quote ()))) (quote ())))) V4259))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote if) (cons Test (cons Action (cons Else (quote ()))))))))) (#t (kl:shen.f_error (quote shen.check_stream))))) (quote shen.check_stream))
(begin (register-function-arity (quote shen.jump_stream) 3) (define (kl:shen.jump_stream V4263 V4264 V4265) (cond ((pair? V4263) (let ((Test (cons (quote cons?) (cons (cons (quote hd) (cons V4264 (quote ()))) (quote ()))))) (let ((Action (kl:shen.syntax (cdr V4263) (cons (quote shen.pair) (cons (cons (quote tl) (cons (cons (quote hd) (cons V4264 (quote ()))) (quote ()))) (cons (cons (quote shen.hdtl) (cons V4264 (quote ()))) (quote ())))) V4265))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote if) (cons Test (cons Action (cons Else (quote ()))))))))) (#t (kl:shen.f_error (quote shen.jump_stream))))) (quote shen.jump_stream))
(begin (register-function-arity (quote shen.semantics) 1) (define (kl:shen.semantics V4267) (cond ((null? V4267) (quote ())) ((assert-boolean (kl:shen.grammar_symbol? V4267)) (cons (quote shen.hdtl) (cons (kl:concat (quote Parse_) V4267) (quote ())))) ((kl:variable? V4267) (kl:concat (quote Parse_) V4267)) ((pair? V4267) (kl:map (lambda (Z) (kl:shen.semantics Z)) V4267)) (#t V4267))) (quote shen.semantics))
(begin (register-function-arity (quote shen.snd-or-fail) 1) (define (kl:shen.snd-or-fail V4275) (cond ((and (pair? V4275) (and (pair? (cdr V4275)) (null? (cdr (cdr V4275))))) (car (cdr V4275))) (#t (kl:fail)))) (quote shen.snd-or-fail))
(begin (register-function-arity (quote fail) 0) (define (kl:fail) (quote shen.fail!)) (quote fail))
(begin (register-function-arity (quote shen.pair) 2) (define (kl:shen.pair V4278 V4279) (cons V4278 (cons V4279 (quote ())))) (quote shen.pair))
(begin (register-function-arity (quote shen.hdtl) 1) (define (kl:shen.hdtl V4281) (car (cdr V4281))) (quote shen.hdtl))
(begin (register-function-arity (quote <!>) 1) (define (kl:<!> V4289) (cond ((and (pair? V4289) (and (pair? (cdr V4289)) (null? (cdr (cdr V4289))))) (cons (quote ()) (cons (car V4289) (quote ())))) (#t (kl:fail)))) (quote <!>))
(begin (register-function-arity (quote <e>) 1) (define (kl:<e> V4295) (cond ((and (pair? V4295) (and (pair? (cdr V4295)) (null? (cdr (cdr V4295))))) (cons (car V4295) (cons (quote ()) (quote ())))) (#t (kl:shen.f_error (quote <e>))))) (quote <e>))
