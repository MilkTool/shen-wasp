"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.datatype-error) 1) (define (kl:shen.datatype-error V2473) (cond ((and (pair? V2473) (and (pair? (cdr V2473)) (null? (cdr (cdr V2473))))) (simple-error (string-append "datatype syntax error here:\n\n " (kl:shen.app (kl:shen.next-50 50 (car V2473)) "\n" (quote shen.a))))) (#t (kl:shen.f_error (quote shen.datatype-error))))) (quote shen.datatype-error))
(begin (register-function-arity (quote shen.<datatype-rules>) 1) (define (kl:shen.<datatype-rules> V2475) (let ((YaccParse (let ((Parse_shen.<datatype-rule> (kl:shen.<datatype-rule> V2475))) (if (kl:not (kl:= (kl:fail) Parse_shen.<datatype-rule>)) (let ((Parse_shen.<datatype-rules> (kl:shen.<datatype-rules> Parse_shen.<datatype-rule>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<datatype-rules>)) (kl:shen.pair (car Parse_shen.<datatype-rules>) (cons (kl:shen.hdtl Parse_shen.<datatype-rule>) (kl:shen.hdtl Parse_shen.<datatype-rules>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2475))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<datatype-rules>))
(begin (register-function-arity (quote shen.<datatype-rule>) 1) (define (kl:shen.<datatype-rule> V2477) (let ((YaccParse (let ((Parse_shen.<side-conditions> (kl:shen.<side-conditions> V2477))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-conditions>)) (let ((Parse_shen.<premises> (kl:shen.<premises> Parse_shen.<side-conditions>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premises>)) (let ((Parse_shen.<singleunderline> (kl:shen.<singleunderline> Parse_shen.<premises>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<singleunderline>)) (let ((Parse_shen.<conclusion> (kl:shen.<conclusion> Parse_shen.<singleunderline>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<conclusion>)) (kl:shen.pair (car Parse_shen.<conclusion>) (kl:shen.sequent (quote shen.single) (cons (kl:shen.hdtl Parse_shen.<side-conditions>) (cons (kl:shen.hdtl Parse_shen.<premises>) (cons (kl:shen.hdtl Parse_shen.<conclusion>) (quote ())))))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<side-conditions> (kl:shen.<side-conditions> V2477))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-conditions>)) (let ((Parse_shen.<premises> (kl:shen.<premises> Parse_shen.<side-conditions>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premises>)) (let ((Parse_shen.<doubleunderline> (kl:shen.<doubleunderline> Parse_shen.<premises>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<doubleunderline>)) (let ((Parse_shen.<conclusion> (kl:shen.<conclusion> Parse_shen.<doubleunderline>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<conclusion>)) (kl:shen.pair (car Parse_shen.<conclusion>) (kl:shen.sequent (quote shen.double) (cons (kl:shen.hdtl Parse_shen.<side-conditions>) (cons (kl:shen.hdtl Parse_shen.<premises>) (cons (kl:shen.hdtl Parse_shen.<conclusion>) (quote ())))))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))) YaccParse))) (quote shen.<datatype-rule>))
(begin (register-function-arity (quote shen.<side-conditions>) 1) (define (kl:shen.<side-conditions> V2479) (let ((YaccParse (let ((Parse_shen.<side-condition> (kl:shen.<side-condition> V2479))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-condition>)) (let ((Parse_shen.<side-conditions> (kl:shen.<side-conditions> Parse_shen.<side-condition>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-conditions>)) (kl:shen.pair (car Parse_shen.<side-conditions>) (cons (kl:shen.hdtl Parse_shen.<side-condition>) (kl:shen.hdtl Parse_shen.<side-conditions>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2479))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<side-conditions>))
(begin (register-function-arity (quote shen.<side-condition>) 1) (define (kl:shen.<side-condition> V2483) (let ((YaccParse (if (and (pair? (car V2483)) (eq? (quote if) (kl:shen.hdhd V2483))) (let ((NewStream2480 (kl:shen.pair (kl:shen.tlhd V2483) (kl:shen.hdtl V2483)))) (let ((Parse_shen.<expr> (kl:shen.<expr> NewStream2480))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (cons (quote if) (cons (kl:shen.hdtl Parse_shen.<expr>) (quote ())))) (kl:fail)))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (if (and (pair? (car V2483)) (eq? (quote let) (kl:shen.hdhd V2483))) (let ((NewStream2481 (kl:shen.pair (kl:shen.tlhd V2483) (kl:shen.hdtl V2483)))) (let ((Parse_shen.<variable?> (kl:shen.<variable?> NewStream2481))) (if (kl:not (kl:= (kl:fail) Parse_shen.<variable?>)) (let ((Parse_shen.<expr> (kl:shen.<expr> Parse_shen.<variable?>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (cons (quote let) (cons (kl:shen.hdtl Parse_shen.<variable?>) (cons (kl:shen.hdtl Parse_shen.<expr>) (quote ()))))) (kl:fail))) (kl:fail)))) (kl:fail)) YaccParse))) (quote shen.<side-condition>))
(begin (register-function-arity (quote shen.<variable?>) 1) (define (kl:shen.<variable?> V2485) (if (pair? (car V2485)) (let ((Parse_X (kl:shen.hdhd V2485))) (if (kl:variable? Parse_X) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2485) (kl:shen.hdtl V2485))) Parse_X) (kl:fail))) (kl:fail))) (quote shen.<variable?>))
(begin (register-function-arity (quote shen.<expr>) 1) (define (kl:shen.<expr> V2487) (if (pair? (car V2487)) (let ((Parse_X (kl:shen.hdhd V2487))) (if (kl:not (or (kl:element? Parse_X (cons (quote >>) (cons (quote _waspvm_sc_) (quote ())))) (or (assert-boolean (kl:shen.singleunderline? Parse_X)) (assert-boolean (kl:shen.doubleunderline? Parse_X))))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2487) (kl:shen.hdtl V2487))) (kl:shen.remove-bar Parse_X)) (kl:fail))) (kl:fail))) (quote shen.<expr>))
(begin (register-function-arity (quote shen.remove-bar) 1) (define (kl:shen.remove-bar V2489) (cond ((and (pair? V2489) (and (pair? (cdr V2489)) (and (pair? (cdr (cdr V2489))) (and (null? (cdr (cdr (cdr V2489)))) (eq? (car (cdr V2489)) (quote bar!)))))) (cons (car V2489) (car (cdr (cdr V2489))))) ((pair? V2489) (cons (kl:shen.remove-bar (car V2489)) (kl:shen.remove-bar (cdr V2489)))) (#t V2489))) (quote shen.remove-bar))
(begin (register-function-arity (quote shen.<premises>) 1) (define (kl:shen.<premises> V2491) (let ((YaccParse (let ((Parse_shen.<premise> (kl:shen.<premise> V2491))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premise>)) (let ((Parse_shen.<semicolon-symbol> (kl:shen.<semicolon-symbol> Parse_shen.<premise>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon-symbol>)) (let ((Parse_shen.<premises> (kl:shen.<premises> Parse_shen.<semicolon-symbol>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premises>)) (kl:shen.pair (car Parse_shen.<premises>) (cons (kl:shen.hdtl Parse_shen.<premise>) (kl:shen.hdtl Parse_shen.<premises>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2491))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<premises>))
(begin (register-function-arity (quote shen.<semicolon-symbol>) 1) (define (kl:shen.<semicolon-symbol> V2493) (if (pair? (car V2493)) (let ((Parse_X (kl:shen.hdhd V2493))) (if (eq? Parse_X (quote _waspvm_sc_)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2493) (kl:shen.hdtl V2493))) (quote shen.skip)) (kl:fail))) (kl:fail))) (quote shen.<semicolon-symbol>))
(begin (register-function-arity (quote shen.<premise>) 1) (define (kl:shen.<premise> V2497) (let ((YaccParse (if (and (pair? (car V2497)) (eq? (quote !) (kl:shen.hdhd V2497))) (let ((NewStream2494 (kl:shen.pair (kl:shen.tlhd V2497) (kl:shen.hdtl V2497)))) (kl:shen.pair (car NewStream2494) (quote !))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<formulae> (kl:shen.<formulae> V2497))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formulae>)) (if (and (pair? (car Parse_shen.<formulae>)) (eq? (quote >>) (kl:shen.hdhd Parse_shen.<formulae>))) (let ((NewStream2495 (kl:shen.pair (kl:shen.tlhd Parse_shen.<formulae>) (kl:shen.hdtl Parse_shen.<formulae>)))) (let ((Parse_shen.<formula> (kl:shen.<formula> NewStream2495))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (kl:shen.pair (car Parse_shen.<formula>) (kl:shen.sequent (kl:shen.hdtl Parse_shen.<formulae>) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail)))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<formula> (kl:shen.<formula> V2497))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (kl:shen.pair (car Parse_shen.<formula>) (kl:shen.sequent (quote ()) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail))) YaccParse)) YaccParse))) (quote shen.<premise>))
(begin (register-function-arity (quote shen.<conclusion>) 1) (define (kl:shen.<conclusion> V2500) (let ((YaccParse (let ((Parse_shen.<formulae> (kl:shen.<formulae> V2500))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formulae>)) (if (and (pair? (car Parse_shen.<formulae>)) (eq? (quote >>) (kl:shen.hdhd Parse_shen.<formulae>))) (let ((NewStream2498 (kl:shen.pair (kl:shen.tlhd Parse_shen.<formulae>) (kl:shen.hdtl Parse_shen.<formulae>)))) (let ((Parse_shen.<formula> (kl:shen.<formula> NewStream2498))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (let ((Parse_shen.<semicolon-symbol> (kl:shen.<semicolon-symbol> Parse_shen.<formula>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon-symbol>)) (kl:shen.pair (car Parse_shen.<semicolon-symbol>) (kl:shen.sequent (kl:shen.hdtl Parse_shen.<formulae>) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail))) (kl:fail)))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<formula> (kl:shen.<formula> V2500))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (let ((Parse_shen.<semicolon-symbol> (kl:shen.<semicolon-symbol> Parse_shen.<formula>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon-symbol>)) (kl:shen.pair (car Parse_shen.<semicolon-symbol>) (kl:shen.sequent (quote ()) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail))) (kl:fail))) YaccParse))) (quote shen.<conclusion>))
(begin (register-function-arity (quote shen.sequent) 2) (define (kl:shen.sequent V2503 V2504) (kl:_waspvm_at_p V2503 V2504)) (quote shen.sequent))
(begin (register-function-arity (quote shen.<formulae>) 1) (define (kl:shen.<formulae> V2506) (let ((YaccParse (let ((Parse_shen.<formula> (kl:shen.<formula> V2506))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (let ((Parse_shen.<comma-symbol> (kl:shen.<comma-symbol> Parse_shen.<formula>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comma-symbol>)) (let ((Parse_shen.<formulae> (kl:shen.<formulae> Parse_shen.<comma-symbol>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formulae>)) (kl:shen.pair (car Parse_shen.<formulae>) (cons (kl:shen.hdtl Parse_shen.<formula>) (kl:shen.hdtl Parse_shen.<formulae>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<formula> (kl:shen.<formula> V2506))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (kl:shen.pair (car Parse_shen.<formula>) (cons (kl:shen.hdtl Parse_shen.<formula>) (quote ()))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2506))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse)) YaccParse))) (quote shen.<formulae>))
(begin (register-function-arity (quote shen.<comma-symbol>) 1) (define (kl:shen.<comma-symbol> V2508) (if (pair? (car V2508)) (let ((Parse_X (kl:shen.hdhd V2508))) (if (kl:= Parse_X (kl:intern ",")) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2508) (kl:shen.hdtl V2508))) (quote shen.skip)) (kl:fail))) (kl:fail))) (quote shen.<comma-symbol>))
(begin (register-function-arity (quote shen.<formula>) 1) (define (kl:shen.<formula> V2511) (let ((YaccParse (let ((Parse_shen.<expr> (kl:shen.<expr> V2511))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (if (and (pair? (car Parse_shen.<expr>)) (eq? (quote :) (kl:shen.hdhd Parse_shen.<expr>))) (let ((NewStream2509 (kl:shen.pair (kl:shen.tlhd Parse_shen.<expr>) (kl:shen.hdtl Parse_shen.<expr>)))) (let ((Parse_shen.<type> (kl:shen.<type> NewStream2509))) (if (kl:not (kl:= (kl:fail) Parse_shen.<type>)) (kl:shen.pair (car Parse_shen.<type>) (cons (kl:shen.curry (kl:shen.hdtl Parse_shen.<expr>)) (cons (quote :) (cons (kl:shen.demodulate (kl:shen.hdtl Parse_shen.<type>)) (quote ()))))) (kl:fail)))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<expr> (kl:shen.<expr> V2511))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (kl:shen.hdtl Parse_shen.<expr>)) (kl:fail))) YaccParse))) (quote shen.<formula>))
(begin (register-function-arity (quote shen.<type>) 1) (define (kl:shen.<type> V2513) (let ((Parse_shen.<expr> (kl:shen.<expr> V2513))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (kl:shen.curry-type (kl:shen.hdtl Parse_shen.<expr>))) (kl:fail)))) (quote shen.<type>))
(begin (register-function-arity (quote shen.<doubleunderline>) 1) (define (kl:shen.<doubleunderline> V2515) (if (pair? (car V2515)) (let ((Parse_X (kl:shen.hdhd V2515))) (if (assert-boolean (kl:shen.doubleunderline? Parse_X)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2515) (kl:shen.hdtl V2515))) Parse_X) (kl:fail))) (kl:fail))) (quote shen.<doubleunderline>))
(begin (register-function-arity (quote shen.<singleunderline>) 1) (define (kl:shen.<singleunderline> V2517) (if (pair? (car V2517)) (let ((Parse_X (kl:shen.hdhd V2517))) (if (assert-boolean (kl:shen.singleunderline? Parse_X)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2517) (kl:shen.hdtl V2517))) Parse_X) (kl:fail))) (kl:fail))) (quote shen.<singleunderline>))
(begin (register-function-arity (quote shen.singleunderline?) 1) (define (kl:shen.singleunderline? V2519) (and (kl:symbol? V2519) (assert-boolean (kl:shen.sh? (kl:str V2519))))) (quote shen.singleunderline?))
(begin (register-function-arity (quote shen.sh?) 1) (define (kl:shen.sh? V2521) (cond ((equal? "_" V2521) #t) (#t (and (equal? (make-string 1 (string-ref V2521 0)) "_") (assert-boolean (kl:shen.sh? (string-tail V2521 1))))))) (quote shen.sh?))
(begin (register-function-arity (quote shen.doubleunderline?) 1) (define (kl:shen.doubleunderline? V2523) (and (kl:symbol? V2523) (assert-boolean (kl:shen.dh? (kl:str V2523))))) (quote shen.doubleunderline?))
(begin (register-function-arity (quote shen.dh?) 1) (define (kl:shen.dh? V2525) (cond ((equal? "=" V2525) #t) (#t (and (equal? (make-string 1 (string-ref V2525 0)) "=") (assert-boolean (kl:shen.dh? (string-tail V2525 1))))))) (quote shen.dh?))
(begin (register-function-arity (quote shen.process-datatype) 2) (define (kl:shen.process-datatype V2528 V2529) (kl:shen.remember-datatype (kl:shen.s-prolog (kl:shen.rules->horn-clauses V2528 V2529)))) (quote shen.process-datatype))
(begin (register-function-arity (quote shen.remember-datatype) 1) (define (kl:shen.remember-datatype V2535) (cond ((pair? V2535) (begin (kl:set (quote shen.*datatypes*) (kl:adjoin (car V2535) (kl:value (quote shen.*datatypes*)))) (begin (kl:set (quote shen.*alldatatypes*) (kl:adjoin (car V2535) (kl:value (quote shen.*alldatatypes*)))) (car V2535)))) (#t (kl:shen.f_error (quote shen.remember-datatype))))) (quote shen.remember-datatype))
(begin (register-function-arity (quote shen.rules->horn-clauses) 2) (define (kl:shen.rules->horn-clauses V2540 V2541) (cond ((null? V2541) (quote ())) ((and (pair? V2541) (and (kl:tuple? (car V2541)) (eq? (quote shen.single) (kl:fst (car V2541))))) (cons (kl:shen.rule->horn-clause V2540 (kl:snd (car V2541))) (kl:shen.rules->horn-clauses V2540 (cdr V2541)))) ((and (pair? V2541) (and (kl:tuple? (car V2541)) (eq? (quote shen.double) (kl:fst (car V2541))))) (kl:shen.rules->horn-clauses V2540 (kl:append (kl:shen.double->singles (kl:snd (car V2541))) (cdr V2541)))) (#t (kl:shen.f_error (quote shen.rules->horn-clauses))))) (quote shen.rules->horn-clauses))
(begin (register-function-arity (quote shen.double->singles) 1) (define (kl:shen.double->singles V2543) (cons (kl:shen.right-rule V2543) (cons (kl:shen.left-rule V2543) (quote ())))) (quote shen.double->singles))
(begin (register-function-arity (quote shen.right-rule) 1) (define (kl:shen.right-rule V2545) (kl:_waspvm_at_p (quote shen.single) V2545)) (quote shen.right-rule))
(begin (register-function-arity (quote shen.left-rule) 1) (define (kl:shen.left-rule V2547) (cond ((and (pair? V2547) (and (pair? (cdr V2547)) (and (pair? (cdr (cdr V2547))) (and (kl:tuple? (car (cdr (cdr V2547)))) (and (null? (kl:fst (car (cdr (cdr V2547))))) (null? (cdr (cdr (cdr V2547))))))))) (let ((Q (kl:gensym (quote Qv)))) (let ((NewConclusion (kl:_waspvm_at_p (cons (kl:snd (car (cdr (cdr V2547)))) (quote ())) Q))) (let ((NewPremises (cons (kl:_waspvm_at_p (kl:map (lambda (X) (kl:shen.right->left X)) (car (cdr V2547))) Q) (quote ())))) (kl:_waspvm_at_p (quote shen.single) (cons (car V2547) (cons NewPremises (cons NewConclusion (quote ()))))))))) (#t (kl:shen.f_error (quote shen.left-rule))))) (quote shen.left-rule))
(begin (register-function-arity (quote shen.right->left) 1) (define (kl:shen.right->left V2553) (cond ((and (kl:tuple? V2553) (null? (kl:fst V2553))) (kl:snd V2553)) (#t (simple-error "syntax error with ==========\n")))) (quote shen.right->left))
(begin (register-function-arity (quote shen.rule->horn-clause) 2) (define (kl:shen.rule->horn-clause V2556 V2557) (cond ((and (pair? V2557) (and (pair? (cdr V2557)) (and (pair? (cdr (cdr V2557))) (and (kl:tuple? (car (cdr (cdr V2557)))) (null? (cdr (cdr (cdr V2557)))))))) (cons (kl:shen.rule->horn-clause-head V2556 (kl:snd (car (cdr (cdr V2557))))) (cons (quote :-) (cons (kl:shen.rule->horn-clause-body (car V2557) (car (cdr V2557)) (kl:fst (car (cdr (cdr V2557))))) (quote ()))))) (#t (kl:shen.f_error (quote shen.rule->horn-clause))))) (quote shen.rule->horn-clause))
(begin (register-function-arity (quote shen.rule->horn-clause-head) 2) (define (kl:shen.rule->horn-clause-head V2560 V2561) (cons V2560 (cons (kl:shen.mode-ify V2561) (cons (quote Context_1957) (quote ()))))) (quote shen.rule->horn-clause-head))
(begin (register-function-arity (quote shen.mode-ify) 1) (define (kl:shen.mode-ify V2563) (cond ((and (pair? V2563) (and (pair? (cdr V2563)) (and (eq? (quote :) (car (cdr V2563))) (and (pair? (cdr (cdr V2563))) (null? (cdr (cdr (cdr V2563)))))))) (cons (quote mode) (cons (cons (car V2563) (cons (quote :) (cons (cons (quote mode) (cons (car (cdr (cdr V2563))) (cons (quote +) (quote ())))) (quote ())))) (cons (quote -) (quote ()))))) (#t V2563))) (quote shen.mode-ify))
(begin (register-function-arity (quote shen.rule->horn-clause-body) 3) (define (kl:shen.rule->horn-clause-body V2567 V2568 V2569) (let ((Variables (kl:map (lambda (X) (kl:shen.extract_vars X)) V2569))) (let ((Predicates (kl:map (lambda (X) (kl:gensym (quote shen.cl))) V2569))) (let ((SearchLiterals (kl:shen.construct-search-literals Predicates Variables (quote Context_1957) (quote Context1_1957)))) (let ((SearchClauses (kl:shen.construct-search-clauses Predicates V2569 Variables))) (let ((SideLiterals (kl:shen.construct-side-literals V2567))) (let ((PremissLiterals (kl:map (lambda (X) (kl:shen.construct-premiss-literal X (kl:empty? V2569))) V2568))) (kl:append SearchLiterals (kl:append SideLiterals PremissLiterals))))))))) (quote shen.rule->horn-clause-body))
(begin (register-function-arity (quote shen.construct-search-literals) 4) (define (kl:shen.construct-search-literals V2578 V2579 V2580 V2581) (cond ((and (null? V2578) (null? V2579)) (quote ())) (#t (kl:shen.csl-help V2578 V2579 V2580 V2581)))) (quote shen.construct-search-literals))
(begin (register-function-arity (quote shen.csl-help) 4) (define (kl:shen.csl-help V2588 V2589 V2590 V2591) (cond ((and (null? V2588) (null? V2589)) (cons (cons (quote bind) (cons (quote ContextOut_1957) (cons V2590 (quote ())))) (quote ()))) ((and (pair? V2588) (pair? V2589)) (cons (cons (car V2588) (cons V2590 (cons V2591 (car V2589)))) (kl:shen.csl-help (cdr V2588) (cdr V2589) V2591 (kl:gensym (quote Context))))) (#t (kl:shen.f_error (quote shen.csl-help))))) (quote shen.csl-help))
(begin (register-function-arity (quote shen.construct-search-clauses) 3) (define (kl:shen.construct-search-clauses V2595 V2596 V2597) (cond ((and (null? V2595) (and (null? V2596) (null? V2597))) (quote shen.skip)) ((and (pair? V2595) (and (pair? V2596) (pair? V2597))) (begin (kl:shen.construct-search-clause (car V2595) (car V2596) (car V2597)) (kl:shen.construct-search-clauses (cdr V2595) (cdr V2596) (cdr V2597)))) (#t (kl:shen.f_error (quote shen.construct-search-clauses))))) (quote shen.construct-search-clauses))
(begin (register-function-arity (quote shen.construct-search-clause) 3) (define (kl:shen.construct-search-clause V2601 V2602 V2603) (kl:shen.s-prolog (cons (kl:shen.construct-base-search-clause V2601 V2602 V2603) (cons (kl:shen.construct-recursive-search-clause V2601 V2602 V2603) (quote ()))))) (quote shen.construct-search-clause))
(begin (register-function-arity (quote shen.construct-base-search-clause) 3) (define (kl:shen.construct-base-search-clause V2607 V2608 V2609) (cons (cons V2607 (cons (cons (kl:shen.mode-ify V2608) (quote In_1957)) (cons (quote In_1957) V2609))) (cons (quote :-) (cons (quote ()) (quote ()))))) (quote shen.construct-base-search-clause))
(begin (register-function-arity (quote shen.construct-recursive-search-clause) 3) (define (kl:shen.construct-recursive-search-clause V2613 V2614 V2615) (cons (cons V2613 (cons (cons (quote Assumption_1957) (quote Assumptions_1957)) (cons (cons (quote Assumption_1957) (quote Out_1957)) V2615))) (cons (quote :-) (cons (cons (cons V2613 (cons (quote Assumptions_1957) (cons (quote Out_1957) V2615))) (quote ())) (quote ()))))) (quote shen.construct-recursive-search-clause))
(begin (register-function-arity (quote shen.construct-side-literals) 1) (define (kl:shen.construct-side-literals V2621) (cond ((null? V2621) (quote ())) ((and (pair? V2621) (and (pair? (car V2621)) (and (eq? (quote if) (car (car V2621))) (and (pair? (cdr (car V2621))) (null? (cdr (cdr (car V2621)))))))) (cons (cons (quote when) (cdr (car V2621))) (kl:shen.construct-side-literals (cdr V2621)))) ((and (pair? V2621) (and (pair? (car V2621)) (and (eq? (quote let) (car (car V2621))) (and (pair? (cdr (car V2621))) (and (pair? (cdr (cdr (car V2621)))) (null? (cdr (cdr (cdr (car V2621)))))))))) (cons (cons (quote is) (cdr (car V2621))) (kl:shen.construct-side-literals (cdr V2621)))) ((pair? V2621) (kl:shen.construct-side-literals (cdr V2621))) (#t (kl:shen.f_error (quote shen.construct-side-literals))))) (quote shen.construct-side-literals))
(begin (register-function-arity (quote shen.construct-premiss-literal) 2) (define (kl:shen.construct-premiss-literal V2628 V2629) (cond ((kl:tuple? V2628) (cons (quote shen.t*) (cons (kl:shen.recursive_cons_form (kl:snd V2628)) (cons (kl:shen.construct-context V2629 (kl:fst V2628)) (quote ()))))) ((eq? (quote !) V2628) (cons (quote cut) (cons (quote Throwcontrol) (quote ())))) (#t (kl:shen.f_error (quote shen.construct-premiss-literal))))) (quote shen.construct-premiss-literal))
(begin (register-function-arity (quote shen.construct-context) 2) (define (kl:shen.construct-context V2632 V2633) (cond ((and (kl:= #t V2632) (null? V2633)) (quote Context_1957)) ((and (kl:= #f V2632) (null? V2633)) (quote ContextOut_1957)) ((pair? V2633) (cons (quote cons) (cons (kl:shen.recursive_cons_form (car V2633)) (cons (kl:shen.construct-context V2632 (cdr V2633)) (quote ()))))) (#t (kl:shen.f_error (quote shen.construct-context))))) (quote shen.construct-context))
(begin (register-function-arity (quote shen.recursive_cons_form) 1) (define (kl:shen.recursive_cons_form V2635) (cond ((pair? V2635) (cons (quote cons) (cons (kl:shen.recursive_cons_form (car V2635)) (cons (kl:shen.recursive_cons_form (cdr V2635)) (quote ()))))) (#t V2635))) (quote shen.recursive_cons_form))
(begin (register-function-arity (quote preclude) 1) (define (kl:preclude V2637) (kl:shen.preclude-h (kl:map (lambda (X) (kl:shen.intern-type X)) V2637))) (quote preclude))
(begin (register-function-arity (quote shen.preclude-h) 1) (define (kl:shen.preclude-h V2639) (let ((FilterDatatypes (kl:set (quote shen.*datatypes*) (kl:difference (kl:value (quote shen.*datatypes*)) V2639)))) (kl:value (quote shen.*datatypes*)))) (quote shen.preclude-h))
(begin (register-function-arity (quote include) 1) (define (kl:include V2641) (kl:shen.include-h (kl:map (lambda (X) (kl:shen.intern-type X)) V2641))) (quote include))
(begin (register-function-arity (quote shen.include-h) 1) (define (kl:shen.include-h V2643) (let ((ValidTypes (kl:intersection V2643 (kl:value (quote shen.*alldatatypes*))))) (let ((NewDatatypes (kl:set (quote shen.*datatypes*) (kl:union ValidTypes (kl:value (quote shen.*datatypes*)))))) (kl:value (quote shen.*datatypes*))))) (quote shen.include-h))
(begin (register-function-arity (quote preclude-all-but) 1) (define (kl:preclude-all-but V2645) (kl:shen.preclude-h (kl:difference (kl:value (quote shen.*alldatatypes*)) (kl:map (lambda (X) (kl:shen.intern-type X)) V2645)))) (quote preclude-all-but))
(begin (register-function-arity (quote include-all-but) 1) (define (kl:include-all-but V2647) (kl:shen.include-h (kl:difference (kl:value (quote shen.*alldatatypes*)) (kl:map (lambda (X) (kl:shen.intern-type X)) V2647)))) (quote include-all-but))
(begin (register-function-arity (quote shen.synonyms-help) 1) (define (kl:shen.synonyms-help V2653) (cond ((null? V2653) (kl:shen.update-demodulation-function (kl:value (quote shen.*tc*)) (kl:mapcan (lambda (X) (kl:shen.demod-rule X)) (kl:value (quote shen.*synonyms*))))) ((and (pair? V2653) (pair? (cdr V2653))) (let ((Vs (kl:difference (kl:shen.extract_vars (car (cdr V2653))) (kl:shen.extract_vars (car V2653))))) (if (kl:empty? Vs) (begin (kl:shen.pushnew (cons (car V2653) (cons (car (cdr V2653)) (quote ()))) (quote shen.*synonyms*)) (kl:shen.synonyms-help (cdr (cdr V2653)))) (kl:shen.free_variable_warnings (car (cdr V2653)) Vs)))) (#t (simple-error "odd number of synonyms\n")))) (quote shen.synonyms-help))
(begin (register-function-arity (quote shen.pushnew) 2) (define (kl:shen.pushnew V2656 V2657) (if (kl:element? V2656 (kl:value V2657)) (kl:value V2657) (kl:set V2657 (cons V2656 (kl:value V2657))))) (quote shen.pushnew))
(begin (register-function-arity (quote shen.demod-rule) 1) (define (kl:shen.demod-rule V2659) (cond ((and (pair? V2659) (and (pair? (cdr V2659)) (null? (cdr (cdr V2659))))) (cons (kl:shen.rcons_form (car V2659)) (cons (quote ->) (cons (kl:shen.rcons_form (car (cdr V2659))) (quote ()))))) (#t (kl:shen.f_error (quote shen.demod-rule))))) (quote shen.demod-rule))
(begin (register-function-arity (quote shen.lambda-of-defun) 1) (define (kl:shen.lambda-of-defun V2665) (cond ((and (pair? V2665) (and (eq? (quote defun) (car V2665)) (and (pair? (cdr V2665)) (and (pair? (cdr (cdr V2665))) (and (pair? (car (cdr (cdr V2665)))) (and (null? (cdr (car (cdr (cdr V2665))))) (and (pair? (cdr (cdr (cdr V2665)))) (null? (cdr (cdr (cdr (cdr V2665)))))))))))) (kl:eval (cons (quote /.) (cons (car (car (cdr (cdr V2665)))) (cdr (cdr (cdr V2665))))))) (#t (kl:shen.f_error (quote shen.lambda-of-defun))))) (quote shen.lambda-of-defun))
(begin (register-function-arity (quote shen.update-demodulation-function) 2) (define (kl:shen.update-demodulation-function V2668 V2669) (begin (kl:tc (quote -)) (begin (kl:set (quote shen.*demodulation-function*) (kl:shen.lambda-of-defun (kl:shen.elim-def (cons (quote define) (cons (quote shen.demod) (kl:append V2669 (kl:shen.default-rule))))))) (begin (if (assert-boolean V2668) (kl:tc (quote +)) (quote shen.skip)) (quote synonyms))))) (quote shen.update-demodulation-function))
(begin (register-function-arity (quote shen.default-rule) 0) (define (kl:shen.default-rule) (cons (quote X) (cons (quote ->) (cons (quote X) (quote ()))))) (quote shen.default-rule))
