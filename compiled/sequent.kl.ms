"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.datatype-error) 1) (define (kl:shen.datatype-error V2437) (cond ((and (pair? V2437) (and (pair? (cdr V2437)) (null? (cdr (cdr V2437))))) (simple-error (string-append "datatype syntax error here:\n\n " (kl:shen.app (kl:shen.next-50 50 (car V2437)) "\n" (quote shen.a))))) (#t (kl:shen.f_error (quote shen.datatype-error))))) (quote shen.datatype-error))
(begin (register-function-arity (quote shen.<datatype-rules>) 1) (define (kl:shen.<datatype-rules> V2439) (let ((YaccParse (let ((Parse_shen.<datatype-rule> (kl:shen.<datatype-rule> V2439))) (if (kl:not (kl:= (kl:fail) Parse_shen.<datatype-rule>)) (let ((Parse_shen.<datatype-rules> (kl:shen.<datatype-rules> Parse_shen.<datatype-rule>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<datatype-rules>)) (kl:shen.pair (car Parse_shen.<datatype-rules>) (cons (kl:shen.hdtl Parse_shen.<datatype-rule>) (kl:shen.hdtl Parse_shen.<datatype-rules>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2439))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<datatype-rules>))
(begin (register-function-arity (quote shen.<datatype-rule>) 1) (define (kl:shen.<datatype-rule> V2441) (let ((YaccParse (let ((Parse_shen.<side-conditions> (kl:shen.<side-conditions> V2441))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-conditions>)) (let ((Parse_shen.<premises> (kl:shen.<premises> Parse_shen.<side-conditions>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premises>)) (let ((Parse_shen.<singleunderline> (kl:shen.<singleunderline> Parse_shen.<premises>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<singleunderline>)) (let ((Parse_shen.<conclusion> (kl:shen.<conclusion> Parse_shen.<singleunderline>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<conclusion>)) (kl:shen.pair (car Parse_shen.<conclusion>) (kl:shen.sequent (quote shen.single) (cons (kl:shen.hdtl Parse_shen.<side-conditions>) (cons (kl:shen.hdtl Parse_shen.<premises>) (cons (kl:shen.hdtl Parse_shen.<conclusion>) (quote ())))))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<side-conditions> (kl:shen.<side-conditions> V2441))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-conditions>)) (let ((Parse_shen.<premises> (kl:shen.<premises> Parse_shen.<side-conditions>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premises>)) (let ((Parse_shen.<doubleunderline> (kl:shen.<doubleunderline> Parse_shen.<premises>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<doubleunderline>)) (let ((Parse_shen.<conclusion> (kl:shen.<conclusion> Parse_shen.<doubleunderline>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<conclusion>)) (kl:shen.pair (car Parse_shen.<conclusion>) (kl:shen.sequent (quote shen.double) (cons (kl:shen.hdtl Parse_shen.<side-conditions>) (cons (kl:shen.hdtl Parse_shen.<premises>) (cons (kl:shen.hdtl Parse_shen.<conclusion>) (quote ())))))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))) YaccParse))) (quote shen.<datatype-rule>))
(begin (register-function-arity (quote shen.<side-conditions>) 1) (define (kl:shen.<side-conditions> V2443) (let ((YaccParse (let ((Parse_shen.<side-condition> (kl:shen.<side-condition> V2443))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-condition>)) (let ((Parse_shen.<side-conditions> (kl:shen.<side-conditions> Parse_shen.<side-condition>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-conditions>)) (kl:shen.pair (car Parse_shen.<side-conditions>) (cons (kl:shen.hdtl Parse_shen.<side-condition>) (kl:shen.hdtl Parse_shen.<side-conditions>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2443))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<side-conditions>))
(begin (register-function-arity (quote shen.<side-condition>) 1) (define (kl:shen.<side-condition> V2445) (let ((YaccParse (if (and (pair? (car V2445)) (eq? (quote if) (car (car V2445)))) (let ((Parse_shen.<expr> (kl:shen.<expr> (kl:shen.pair (cdr (car V2445)) (kl:shen.hdtl V2445))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (cons (quote if) (cons (kl:shen.hdtl Parse_shen.<expr>) (quote ())))) (kl:fail))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (if (and (pair? (car V2445)) (eq? (quote let) (car (car V2445)))) (let ((Parse_shen.<variable?> (kl:shen.<variable?> (kl:shen.pair (cdr (car V2445)) (kl:shen.hdtl V2445))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<variable?>)) (let ((Parse_shen.<expr> (kl:shen.<expr> Parse_shen.<variable?>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (cons (quote let) (cons (kl:shen.hdtl Parse_shen.<variable?>) (cons (kl:shen.hdtl Parse_shen.<expr>) (quote ()))))) (kl:fail))) (kl:fail))) (kl:fail)) YaccParse))) (quote shen.<side-condition>))
(begin (register-function-arity (quote shen.<variable?>) 1) (define (kl:shen.<variable?> V2447) (if (pair? (car V2447)) (let ((Parse_X (car (car V2447)))) (if (kl:variable? Parse_X) (kl:shen.pair (car (kl:shen.pair (cdr (car V2447)) (kl:shen.hdtl V2447))) Parse_X) (kl:fail))) (kl:fail))) (quote shen.<variable?>))
(begin (register-function-arity (quote shen.<expr>) 1) (define (kl:shen.<expr> V2449) (if (pair? (car V2449)) (let ((Parse_X (car (car V2449)))) (if (kl:not (or (kl:element? Parse_X (cons (quote >>) (cons (quote _waspvm_sc_) (quote ())))) (or (assert-boolean (kl:shen.singleunderline? Parse_X)) (assert-boolean (kl:shen.doubleunderline? Parse_X))))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2449)) (kl:shen.hdtl V2449))) (kl:shen.remove-bar Parse_X)) (kl:fail))) (kl:fail))) (quote shen.<expr>))
(begin (register-function-arity (quote shen.remove-bar) 1) (define (kl:shen.remove-bar V2451) (cond ((and (pair? V2451) (and (pair? (cdr V2451)) (and (pair? (cdr (cdr V2451))) (and (null? (cdr (cdr (cdr V2451)))) (eq? (car (cdr V2451)) (quote bar!)))))) (cons (car V2451) (car (cdr (cdr V2451))))) ((pair? V2451) (cons (kl:shen.remove-bar (car V2451)) (kl:shen.remove-bar (cdr V2451)))) (#t V2451))) (quote shen.remove-bar))
(begin (register-function-arity (quote shen.<premises>) 1) (define (kl:shen.<premises> V2453) (let ((YaccParse (let ((Parse_shen.<premise> (kl:shen.<premise> V2453))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premise>)) (let ((Parse_shen.<semicolon-symbol> (kl:shen.<semicolon-symbol> Parse_shen.<premise>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon-symbol>)) (let ((Parse_shen.<premises> (kl:shen.<premises> Parse_shen.<semicolon-symbol>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premises>)) (kl:shen.pair (car Parse_shen.<premises>) (cons (kl:shen.hdtl Parse_shen.<premise>) (kl:shen.hdtl Parse_shen.<premises>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2453))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<premises>))
(begin (register-function-arity (quote shen.<semicolon-symbol>) 1) (define (kl:shen.<semicolon-symbol> V2455) (if (pair? (car V2455)) (let ((Parse_X (car (car V2455)))) (if (eq? Parse_X (quote _waspvm_sc_)) (kl:shen.pair (car (kl:shen.pair (cdr (car V2455)) (kl:shen.hdtl V2455))) (quote shen.skip)) (kl:fail))) (kl:fail))) (quote shen.<semicolon-symbol>))
(begin (register-function-arity (quote shen.<premise>) 1) (define (kl:shen.<premise> V2457) (let ((YaccParse (if (and (pair? (car V2457)) (eq? (quote !) (car (car V2457)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2457)) (kl:shen.hdtl V2457))) (quote !)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<formulae> (kl:shen.<formulae> V2457))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formulae>)) (if (and (pair? (car Parse_shen.<formulae>)) (eq? (quote >>) (car (car Parse_shen.<formulae>)))) (let ((Parse_shen.<formula> (kl:shen.<formula> (kl:shen.pair (cdr (car Parse_shen.<formulae>)) (kl:shen.hdtl Parse_shen.<formulae>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (kl:shen.pair (car Parse_shen.<formula>) (kl:shen.sequent (kl:shen.hdtl Parse_shen.<formulae>) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<formula> (kl:shen.<formula> V2457))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (kl:shen.pair (car Parse_shen.<formula>) (kl:shen.sequent (quote ()) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail))) YaccParse)) YaccParse))) (quote shen.<premise>))
(begin (register-function-arity (quote shen.<conclusion>) 1) (define (kl:shen.<conclusion> V2459) (let ((YaccParse (let ((Parse_shen.<formulae> (kl:shen.<formulae> V2459))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formulae>)) (if (and (pair? (car Parse_shen.<formulae>)) (eq? (quote >>) (car (car Parse_shen.<formulae>)))) (let ((Parse_shen.<formula> (kl:shen.<formula> (kl:shen.pair (cdr (car Parse_shen.<formulae>)) (kl:shen.hdtl Parse_shen.<formulae>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (let ((Parse_shen.<semicolon-symbol> (kl:shen.<semicolon-symbol> Parse_shen.<formula>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon-symbol>)) (kl:shen.pair (car Parse_shen.<semicolon-symbol>) (kl:shen.sequent (kl:shen.hdtl Parse_shen.<formulae>) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail))) (kl:fail))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<formula> (kl:shen.<formula> V2459))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (let ((Parse_shen.<semicolon-symbol> (kl:shen.<semicolon-symbol> Parse_shen.<formula>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon-symbol>)) (kl:shen.pair (car Parse_shen.<semicolon-symbol>) (kl:shen.sequent (quote ()) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail))) (kl:fail))) YaccParse))) (quote shen.<conclusion>))
(begin (register-function-arity (quote shen.sequent) 2) (define (kl:shen.sequent V2462 V2463) (kl:_waspvm_at_p V2462 V2463)) (quote shen.sequent))
(begin (register-function-arity (quote shen.<formulae>) 1) (define (kl:shen.<formulae> V2465) (let ((YaccParse (let ((Parse_shen.<formula> (kl:shen.<formula> V2465))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (let ((Parse_shen.<comma-symbol> (kl:shen.<comma-symbol> Parse_shen.<formula>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comma-symbol>)) (let ((Parse_shen.<formulae> (kl:shen.<formulae> Parse_shen.<comma-symbol>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formulae>)) (kl:shen.pair (car Parse_shen.<formulae>) (cons (kl:shen.hdtl Parse_shen.<formula>) (kl:shen.hdtl Parse_shen.<formulae>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<formula> (kl:shen.<formula> V2465))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (kl:shen.pair (car Parse_shen.<formula>) (cons (kl:shen.hdtl Parse_shen.<formula>) (quote ()))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2465))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse)) YaccParse))) (quote shen.<formulae>))
(begin (register-function-arity (quote shen.<comma-symbol>) 1) (define (kl:shen.<comma-symbol> V2467) (if (pair? (car V2467)) (let ((Parse_X (car (car V2467)))) (if (kl:= Parse_X (kl:intern ",")) (kl:shen.pair (car (kl:shen.pair (cdr (car V2467)) (kl:shen.hdtl V2467))) (quote shen.skip)) (kl:fail))) (kl:fail))) (quote shen.<comma-symbol>))
(begin (register-function-arity (quote shen.<formula>) 1) (define (kl:shen.<formula> V2469) (let ((YaccParse (let ((Parse_shen.<expr> (kl:shen.<expr> V2469))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (if (and (pair? (car Parse_shen.<expr>)) (eq? (quote :) (car (car Parse_shen.<expr>)))) (let ((Parse_shen.<type> (kl:shen.<type> (kl:shen.pair (cdr (car Parse_shen.<expr>)) (kl:shen.hdtl Parse_shen.<expr>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<type>)) (kl:shen.pair (car Parse_shen.<type>) (cons (kl:shen.curry (kl:shen.hdtl Parse_shen.<expr>)) (cons (quote :) (cons (kl:shen.demodulate (kl:shen.hdtl Parse_shen.<type>)) (quote ()))))) (kl:fail))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<expr> (kl:shen.<expr> V2469))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (kl:shen.hdtl Parse_shen.<expr>)) (kl:fail))) YaccParse))) (quote shen.<formula>))
(begin (register-function-arity (quote shen.<type>) 1) (define (kl:shen.<type> V2471) (let ((Parse_shen.<expr> (kl:shen.<expr> V2471))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (kl:shen.curry-type (kl:shen.hdtl Parse_shen.<expr>))) (kl:fail)))) (quote shen.<type>))
(begin (register-function-arity (quote shen.<doubleunderline>) 1) (define (kl:shen.<doubleunderline> V2473) (if (pair? (car V2473)) (let ((Parse_X (car (car V2473)))) (if (assert-boolean (kl:shen.doubleunderline? Parse_X)) (kl:shen.pair (car (kl:shen.pair (cdr (car V2473)) (kl:shen.hdtl V2473))) Parse_X) (kl:fail))) (kl:fail))) (quote shen.<doubleunderline>))
(begin (register-function-arity (quote shen.<singleunderline>) 1) (define (kl:shen.<singleunderline> V2475) (if (pair? (car V2475)) (let ((Parse_X (car (car V2475)))) (if (assert-boolean (kl:shen.singleunderline? Parse_X)) (kl:shen.pair (car (kl:shen.pair (cdr (car V2475)) (kl:shen.hdtl V2475))) Parse_X) (kl:fail))) (kl:fail))) (quote shen.<singleunderline>))
(begin (register-function-arity (quote shen.singleunderline?) 1) (define (kl:shen.singleunderline? V2477) (and (kl:symbol? V2477) (assert-boolean (kl:shen.sh? (kl:str V2477))))) (quote shen.singleunderline?))
(begin (register-function-arity (quote shen.sh?) 1) (define (kl:shen.sh? V2479) (cond ((equal? "_" V2479) #t) (#t (and (equal? (make-string 1 (string-ref V2479 0)) "_") (assert-boolean (kl:shen.sh? (string-tail V2479 1))))))) (quote shen.sh?))
(begin (register-function-arity (quote shen.doubleunderline?) 1) (define (kl:shen.doubleunderline? V2481) (and (kl:symbol? V2481) (assert-boolean (kl:shen.dh? (kl:str V2481))))) (quote shen.doubleunderline?))
(begin (register-function-arity (quote shen.dh?) 1) (define (kl:shen.dh? V2483) (cond ((equal? "=" V2483) #t) (#t (and (equal? (make-string 1 (string-ref V2483 0)) "=") (assert-boolean (kl:shen.dh? (string-tail V2483 1))))))) (quote shen.dh?))
(begin (register-function-arity (quote shen.process-datatype) 2) (define (kl:shen.process-datatype V2486 V2487) (kl:shen.remember-datatype (kl:shen.s-prolog (kl:shen.rules->horn-clauses V2486 V2487)))) (quote shen.process-datatype))
(begin (register-function-arity (quote shen.remember-datatype) 1) (define (kl:shen.remember-datatype V2493) (cond ((pair? V2493) (begin (kl:set (quote shen.*datatypes*) (kl:adjoin (car V2493) (kl:value (quote shen.*datatypes*)))) (begin (kl:set (quote shen.*alldatatypes*) (kl:adjoin (car V2493) (kl:value (quote shen.*alldatatypes*)))) (car V2493)))) (#t (kl:shen.f_error (quote shen.remember-datatype))))) (quote shen.remember-datatype))
(begin (register-function-arity (quote shen.rules->horn-clauses) 2) (define (kl:shen.rules->horn-clauses V2498 V2499) (cond ((null? V2499) (quote ())) ((and (pair? V2499) (and (kl:tuple? (car V2499)) (eq? (quote shen.single) (kl:fst (car V2499))))) (cons (kl:shen.rule->horn-clause V2498 (kl:snd (car V2499))) (kl:shen.rules->horn-clauses V2498 (cdr V2499)))) ((and (pair? V2499) (and (kl:tuple? (car V2499)) (eq? (quote shen.double) (kl:fst (car V2499))))) (kl:shen.rules->horn-clauses V2498 (kl:append (kl:shen.double->singles (kl:snd (car V2499))) (cdr V2499)))) (#t (kl:shen.f_error (quote shen.rules->horn-clauses))))) (quote shen.rules->horn-clauses))
(begin (register-function-arity (quote shen.double->singles) 1) (define (kl:shen.double->singles V2501) (cons (kl:shen.right-rule V2501) (cons (kl:shen.left-rule V2501) (quote ())))) (quote shen.double->singles))
(begin (register-function-arity (quote shen.right-rule) 1) (define (kl:shen.right-rule V2503) (kl:_waspvm_at_p (quote shen.single) V2503)) (quote shen.right-rule))
(begin (register-function-arity (quote shen.left-rule) 1) (define (kl:shen.left-rule V2505) (cond ((and (pair? V2505) (and (pair? (cdr V2505)) (and (pair? (cdr (cdr V2505))) (and (kl:tuple? (car (cdr (cdr V2505)))) (and (null? (kl:fst (car (cdr (cdr V2505))))) (null? (cdr (cdr (cdr V2505))))))))) (let ((Q (kl:gensym (quote Qv)))) (let ((NewConclusion (kl:_waspvm_at_p (cons (kl:snd (car (cdr (cdr V2505)))) (quote ())) Q))) (let ((NewPremises (cons (kl:_waspvm_at_p (kl:map (lambda (X) (kl:shen.right->left X)) (car (cdr V2505))) Q) (quote ())))) (kl:_waspvm_at_p (quote shen.single) (cons (car V2505) (cons NewPremises (cons NewConclusion (quote ()))))))))) (#t (kl:shen.f_error (quote shen.left-rule))))) (quote shen.left-rule))
(begin (register-function-arity (quote shen.right->left) 1) (define (kl:shen.right->left V2511) (cond ((and (kl:tuple? V2511) (null? (kl:fst V2511))) (kl:snd V2511)) (#t (simple-error "syntax error with ==========\n")))) (quote shen.right->left))
(begin (register-function-arity (quote shen.rule->horn-clause) 2) (define (kl:shen.rule->horn-clause V2514 V2515) (cond ((and (pair? V2515) (and (pair? (cdr V2515)) (and (pair? (cdr (cdr V2515))) (and (kl:tuple? (car (cdr (cdr V2515)))) (null? (cdr (cdr (cdr V2515)))))))) (cons (kl:shen.rule->horn-clause-head V2514 (kl:snd (car (cdr (cdr V2515))))) (cons (quote :-) (cons (kl:shen.rule->horn-clause-body (car V2515) (car (cdr V2515)) (kl:fst (car (cdr (cdr V2515))))) (quote ()))))) (#t (kl:shen.f_error (quote shen.rule->horn-clause))))) (quote shen.rule->horn-clause))
(begin (register-function-arity (quote shen.rule->horn-clause-head) 2) (define (kl:shen.rule->horn-clause-head V2518 V2519) (cons V2518 (cons (kl:shen.mode-ify V2519) (cons (quote Context_1957) (quote ()))))) (quote shen.rule->horn-clause-head))
(begin (register-function-arity (quote shen.mode-ify) 1) (define (kl:shen.mode-ify V2521) (cond ((and (pair? V2521) (and (pair? (cdr V2521)) (and (eq? (quote :) (car (cdr V2521))) (and (pair? (cdr (cdr V2521))) (null? (cdr (cdr (cdr V2521)))))))) (cons (quote mode) (cons (cons (car V2521) (cons (quote :) (cons (cons (quote mode) (cons (car (cdr (cdr V2521))) (cons (quote +) (quote ())))) (quote ())))) (cons (quote -) (quote ()))))) (#t V2521))) (quote shen.mode-ify))
(begin (register-function-arity (quote shen.rule->horn-clause-body) 3) (define (kl:shen.rule->horn-clause-body V2525 V2526 V2527) (let ((Variables (kl:map (lambda (X) (kl:shen.extract_vars X)) V2527))) (let ((Predicates (kl:map (lambda (X) (kl:gensym (quote shen.cl))) V2527))) (let ((SearchLiterals (kl:shen.construct-search-literals Predicates Variables (quote Context_1957) (quote Context1_1957)))) (let ((SearchClauses (kl:shen.construct-search-clauses Predicates V2527 Variables))) (let ((SideLiterals (kl:shen.construct-side-literals V2525))) (let ((PremissLiterals (kl:map (lambda (X) (kl:shen.construct-premiss-literal X (kl:empty? V2527))) V2526))) (kl:append SearchLiterals (kl:append SideLiterals PremissLiterals))))))))) (quote shen.rule->horn-clause-body))
(begin (register-function-arity (quote shen.construct-search-literals) 4) (define (kl:shen.construct-search-literals V2536 V2537 V2538 V2539) (cond ((and (null? V2536) (null? V2537)) (quote ())) (#t (kl:shen.csl-help V2536 V2537 V2538 V2539)))) (quote shen.construct-search-literals))
(begin (register-function-arity (quote shen.csl-help) 4) (define (kl:shen.csl-help V2546 V2547 V2548 V2549) (cond ((and (null? V2546) (null? V2547)) (cons (cons (quote bind) (cons (quote ContextOut_1957) (cons V2548 (quote ())))) (quote ()))) ((and (pair? V2546) (pair? V2547)) (cons (cons (car V2546) (cons V2548 (cons V2549 (car V2547)))) (kl:shen.csl-help (cdr V2546) (cdr V2547) V2549 (kl:gensym (quote Context))))) (#t (kl:shen.f_error (quote shen.csl-help))))) (quote shen.csl-help))
(begin (register-function-arity (quote shen.construct-search-clauses) 3) (define (kl:shen.construct-search-clauses V2553 V2554 V2555) (cond ((and (null? V2553) (and (null? V2554) (null? V2555))) (quote shen.skip)) ((and (pair? V2553) (and (pair? V2554) (pair? V2555))) (begin (kl:shen.construct-search-clause (car V2553) (car V2554) (car V2555)) (kl:shen.construct-search-clauses (cdr V2553) (cdr V2554) (cdr V2555)))) (#t (kl:shen.f_error (quote shen.construct-search-clauses))))) (quote shen.construct-search-clauses))
(begin (register-function-arity (quote shen.construct-search-clause) 3) (define (kl:shen.construct-search-clause V2559 V2560 V2561) (kl:shen.s-prolog (cons (kl:shen.construct-base-search-clause V2559 V2560 V2561) (cons (kl:shen.construct-recursive-search-clause V2559 V2560 V2561) (quote ()))))) (quote shen.construct-search-clause))
(begin (register-function-arity (quote shen.construct-base-search-clause) 3) (define (kl:shen.construct-base-search-clause V2565 V2566 V2567) (cons (cons V2565 (cons (cons (kl:shen.mode-ify V2566) (quote In_1957)) (cons (quote In_1957) V2567))) (cons (quote :-) (cons (quote ()) (quote ()))))) (quote shen.construct-base-search-clause))
(begin (register-function-arity (quote shen.construct-recursive-search-clause) 3) (define (kl:shen.construct-recursive-search-clause V2571 V2572 V2573) (cons (cons V2571 (cons (cons (quote Assumption_1957) (quote Assumptions_1957)) (cons (cons (quote Assumption_1957) (quote Out_1957)) V2573))) (cons (quote :-) (cons (cons (cons V2571 (cons (quote Assumptions_1957) (cons (quote Out_1957) V2573))) (quote ())) (quote ()))))) (quote shen.construct-recursive-search-clause))
(begin (register-function-arity (quote shen.construct-side-literals) 1) (define (kl:shen.construct-side-literals V2579) (cond ((null? V2579) (quote ())) ((and (pair? V2579) (and (pair? (car V2579)) (and (eq? (quote if) (car (car V2579))) (and (pair? (cdr (car V2579))) (null? (cdr (cdr (car V2579)))))))) (cons (cons (quote when) (cdr (car V2579))) (kl:shen.construct-side-literals (cdr V2579)))) ((and (pair? V2579) (and (pair? (car V2579)) (and (eq? (quote let) (car (car V2579))) (and (pair? (cdr (car V2579))) (and (pair? (cdr (cdr (car V2579)))) (null? (cdr (cdr (cdr (car V2579)))))))))) (cons (cons (quote is) (cdr (car V2579))) (kl:shen.construct-side-literals (cdr V2579)))) ((pair? V2579) (kl:shen.construct-side-literals (cdr V2579))) (#t (kl:shen.f_error (quote shen.construct-side-literals))))) (quote shen.construct-side-literals))
(begin (register-function-arity (quote shen.construct-premiss-literal) 2) (define (kl:shen.construct-premiss-literal V2586 V2587) (cond ((kl:tuple? V2586) (cons (quote shen.t*) (cons (kl:shen.recursive_cons_form (kl:snd V2586)) (cons (kl:shen.construct-context V2587 (kl:fst V2586)) (quote ()))))) ((eq? (quote !) V2586) (cons (quote cut) (cons (quote Throwcontrol) (quote ())))) (#t (kl:shen.f_error (quote shen.construct-premiss-literal))))) (quote shen.construct-premiss-literal))
(begin (register-function-arity (quote shen.construct-context) 2) (define (kl:shen.construct-context V2590 V2591) (cond ((and (kl:= #t V2590) (null? V2591)) (quote Context_1957)) ((and (kl:= #f V2590) (null? V2591)) (quote ContextOut_1957)) ((pair? V2591) (cons (quote cons) (cons (kl:shen.recursive_cons_form (car V2591)) (cons (kl:shen.construct-context V2590 (cdr V2591)) (quote ()))))) (#t (kl:shen.f_error (quote shen.construct-context))))) (quote shen.construct-context))
(begin (register-function-arity (quote shen.recursive_cons_form) 1) (define (kl:shen.recursive_cons_form V2593) (cond ((pair? V2593) (cons (quote cons) (cons (kl:shen.recursive_cons_form (car V2593)) (cons (kl:shen.recursive_cons_form (cdr V2593)) (quote ()))))) (#t V2593))) (quote shen.recursive_cons_form))
(begin (register-function-arity (quote preclude) 1) (define (kl:preclude V2595) (kl:shen.preclude-h (kl:map (lambda (X) (kl:shen.intern-type X)) V2595))) (quote preclude))
(begin (register-function-arity (quote shen.preclude-h) 1) (define (kl:shen.preclude-h V2597) (let ((FilterDatatypes (kl:set (quote shen.*datatypes*) (kl:difference (kl:value (quote shen.*datatypes*)) V2597)))) (kl:value (quote shen.*datatypes*)))) (quote shen.preclude-h))
(begin (register-function-arity (quote include) 1) (define (kl:include V2599) (kl:shen.include-h (kl:map (lambda (X) (kl:shen.intern-type X)) V2599))) (quote include))
(begin (register-function-arity (quote shen.include-h) 1) (define (kl:shen.include-h V2601) (let ((ValidTypes (kl:intersection V2601 (kl:value (quote shen.*alldatatypes*))))) (let ((NewDatatypes (kl:set (quote shen.*datatypes*) (kl:union ValidTypes (kl:value (quote shen.*datatypes*)))))) (kl:value (quote shen.*datatypes*))))) (quote shen.include-h))
(begin (register-function-arity (quote preclude-all-but) 1) (define (kl:preclude-all-but V2603) (kl:shen.preclude-h (kl:difference (kl:value (quote shen.*alldatatypes*)) (kl:map (lambda (X) (kl:shen.intern-type X)) V2603)))) (quote preclude-all-but))
(begin (register-function-arity (quote include-all-but) 1) (define (kl:include-all-but V2605) (kl:shen.include-h (kl:difference (kl:value (quote shen.*alldatatypes*)) (kl:map (lambda (X) (kl:shen.intern-type X)) V2605)))) (quote include-all-but))
(begin (register-function-arity (quote shen.synonyms-help) 1) (define (kl:shen.synonyms-help V2611) (cond ((null? V2611) (kl:shen.demodulation-function (kl:value (quote shen.*tc*)) (kl:mapcan (lambda (X) (kl:shen.demod-rule X)) (kl:value (quote shen.*synonyms*))))) ((and (pair? V2611) (pair? (cdr V2611))) (let ((Vs (kl:difference (kl:shen.extract_vars (car (cdr V2611))) (kl:shen.extract_vars (car V2611))))) (if (kl:empty? Vs) (begin (kl:shen.pushnew (cons (car V2611) (cons (car (cdr V2611)) (quote ()))) (quote shen.*synonyms*)) (kl:shen.synonyms-help (cdr (cdr V2611)))) (kl:shen.free_variable_warnings (car (cdr V2611)) Vs)))) (#t (simple-error "odd number of synonyms\n")))) (quote shen.synonyms-help))
(begin (register-function-arity (quote shen.pushnew) 2) (define (kl:shen.pushnew V2614 V2615) (if (kl:element? V2614 (kl:value V2615)) (kl:value V2615) (kl:set V2615 (cons V2614 (kl:value V2615))))) (quote shen.pushnew))
(begin (register-function-arity (quote shen.demod-rule) 1) (define (kl:shen.demod-rule V2617) (cond ((and (pair? V2617) (and (pair? (cdr V2617)) (null? (cdr (cdr V2617))))) (cons (kl:shen.rcons_form (car V2617)) (cons (quote ->) (cons (kl:shen.rcons_form (car (cdr V2617))) (quote ()))))) (#t (kl:shen.f_error (quote shen.demod-rule))))) (quote shen.demod-rule))
(begin (register-function-arity (quote shen.demodulation-function) 2) (define (kl:shen.demodulation-function V2620 V2621) (begin (kl:tc (quote -)) (begin (kl:eval (cons (quote define) (cons (quote shen.demod) (kl:append V2621 (kl:shen.default-rule))))) (begin (if (assert-boolean V2620) (kl:tc (quote +)) (quote shen.skip)) (quote synonyms))))) (quote shen.demodulation-function))
(begin (register-function-arity (quote shen.default-rule) 0) (define (kl:shen.default-rule) (cons (quote X) (cons (quote ->) (cons (quote X) (quote ()))))) (quote shen.default-rule))
