(module "compiled/sequent.kl")
"Copyright (c) 2010-2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
(begin (register-function-arity (quote shen.datatype-error) 1) (define (kl:shen.datatype-error V2825) (cond ((and (pair? V2825) (and (pair? (cdr V2825)) (null? (cdr (cdr V2825))))) (simple-error (string-append "datatype syntax error here:\n\n " (kl:shen.app (kl:shen.next-50 50 (car V2825)) "\n" (quote shen.a))))) (#t (kl:shen.f_error (quote shen.datatype-error))))) (export shen.datatype-error) (quote shen.datatype-error))
(begin (register-function-arity (quote shen.<datatype-rules>) 1) (define (kl:shen.<datatype-rules> V2827) (let ((YaccParse (let ((Parse_shen.<datatype-rule> (kl:shen.<datatype-rule> V2827))) (if (kl:not (kl:= (kl:fail) Parse_shen.<datatype-rule>)) (let ((Parse_shen.<datatype-rules> (kl:shen.<datatype-rules> Parse_shen.<datatype-rule>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<datatype-rules>)) (kl:shen.pair (car Parse_shen.<datatype-rules>) (cons (kl:shen.hdtl Parse_shen.<datatype-rule>) (kl:shen.hdtl Parse_shen.<datatype-rules>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2827))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<datatype-rules>) (quote shen.<datatype-rules>))
(begin (register-function-arity (quote shen.<datatype-rule>) 1) (define (kl:shen.<datatype-rule> V2829) (let ((YaccParse (let ((Parse_shen.<side-conditions> (kl:shen.<side-conditions> V2829))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-conditions>)) (let ((Parse_shen.<premises> (kl:shen.<premises> Parse_shen.<side-conditions>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premises>)) (let ((Parse_shen.<singleunderline> (kl:shen.<singleunderline> Parse_shen.<premises>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<singleunderline>)) (let ((Parse_shen.<conclusion> (kl:shen.<conclusion> Parse_shen.<singleunderline>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<conclusion>)) (kl:shen.pair (car Parse_shen.<conclusion>) (kl:shen.sequent (quote shen.single) (cons (kl:shen.hdtl Parse_shen.<side-conditions>) (cons (kl:shen.hdtl Parse_shen.<premises>) (cons (kl:shen.hdtl Parse_shen.<conclusion>) (quote ())))))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<side-conditions> (kl:shen.<side-conditions> V2829))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-conditions>)) (let ((Parse_shen.<premises> (kl:shen.<premises> Parse_shen.<side-conditions>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premises>)) (let ((Parse_shen.<doubleunderline> (kl:shen.<doubleunderline> Parse_shen.<premises>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<doubleunderline>)) (let ((Parse_shen.<conclusion> (kl:shen.<conclusion> Parse_shen.<doubleunderline>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<conclusion>)) (kl:shen.pair (car Parse_shen.<conclusion>) (kl:shen.sequent (quote shen.double) (cons (kl:shen.hdtl Parse_shen.<side-conditions>) (cons (kl:shen.hdtl Parse_shen.<premises>) (cons (kl:shen.hdtl Parse_shen.<conclusion>) (quote ())))))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))) YaccParse))) (export shen.<datatype-rule>) (quote shen.<datatype-rule>))
(begin (register-function-arity (quote shen.<side-conditions>) 1) (define (kl:shen.<side-conditions> V2831) (let ((YaccParse (let ((Parse_shen.<side-condition> (kl:shen.<side-condition> V2831))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-condition>)) (let ((Parse_shen.<side-conditions> (kl:shen.<side-conditions> Parse_shen.<side-condition>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-conditions>)) (kl:shen.pair (car Parse_shen.<side-conditions>) (cons (kl:shen.hdtl Parse_shen.<side-condition>) (kl:shen.hdtl Parse_shen.<side-conditions>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2831))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<side-conditions>) (quote shen.<side-conditions>))
(begin (register-function-arity (quote shen.<side-condition>) 1) (define (kl:shen.<side-condition> V2835) (let ((YaccParse (if (and (pair? (car V2835)) (eq? (quote if) (kl:shen.hdhd V2835))) (let ((NewStream2832 (kl:shen.pair (kl:shen.tlhd V2835) (kl:shen.hdtl V2835)))) (let ((Parse_shen.<expr> (kl:shen.<expr> NewStream2832))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (cons (quote if) (cons (kl:shen.hdtl Parse_shen.<expr>) (quote ())))) (kl:fail)))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (if (and (pair? (car V2835)) (eq? (quote let) (kl:shen.hdhd V2835))) (let ((NewStream2833 (kl:shen.pair (kl:shen.tlhd V2835) (kl:shen.hdtl V2835)))) (let ((Parse_shen.<variable?> (kl:shen.<variable?> NewStream2833))) (if (kl:not (kl:= (kl:fail) Parse_shen.<variable?>)) (let ((Parse_shen.<expr> (kl:shen.<expr> Parse_shen.<variable?>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (cons (quote let) (cons (kl:shen.hdtl Parse_shen.<variable?>) (cons (kl:shen.hdtl Parse_shen.<expr>) (quote ()))))) (kl:fail))) (kl:fail)))) (kl:fail)) YaccParse))) (export shen.<side-condition>) (quote shen.<side-condition>))
(begin (register-function-arity (quote shen.<variable?>) 1) (define (kl:shen.<variable?> V2837) (if (pair? (car V2837)) (let ((Parse_X (kl:shen.hdhd V2837))) (if (kl:variable? Parse_X) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2837) (kl:shen.hdtl V2837))) Parse_X) (kl:fail))) (kl:fail))) (export shen.<variable?>) (quote shen.<variable?>))
(begin (register-function-arity (quote shen.<expr>) 1) (define (kl:shen.<expr> V2839) (if (pair? (car V2839)) (let ((Parse_X (kl:shen.hdhd V2839))) (if (kl:not (or (kl:element? Parse_X (cons (quote >>) (cons (quote _waspvm_sc_) (quote ())))) (or (assert-boolean (kl:shen.singleunderline? Parse_X)) (assert-boolean (kl:shen.doubleunderline? Parse_X))))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2839) (kl:shen.hdtl V2839))) (kl:shen.remove-bar Parse_X)) (kl:fail))) (kl:fail))) (export shen.<expr>) (quote shen.<expr>))
(begin (register-function-arity (quote shen.remove-bar) 1) (define (kl:shen.remove-bar V2841) (cond ((and (pair? V2841) (and (pair? (cdr V2841)) (and (pair? (cdr (cdr V2841))) (and (null? (cdr (cdr (cdr V2841)))) (eq? (car (cdr V2841)) (quote bar!)))))) (cons (car V2841) (car (cdr (cdr V2841))))) ((pair? V2841) (cons (kl:shen.remove-bar (car V2841)) (kl:shen.remove-bar (cdr V2841)))) (#t V2841))) (export shen.remove-bar) (quote shen.remove-bar))
(begin (register-function-arity (quote shen.<premises>) 1) (define (kl:shen.<premises> V2843) (let ((YaccParse (let ((Parse_shen.<premise> (kl:shen.<premise> V2843))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premise>)) (let ((Parse_shen.<semicolon-symbol> (kl:shen.<semicolon-symbol> Parse_shen.<premise>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon-symbol>)) (let ((Parse_shen.<premises> (kl:shen.<premises> Parse_shen.<semicolon-symbol>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premises>)) (kl:shen.pair (car Parse_shen.<premises>) (cons (kl:shen.hdtl Parse_shen.<premise>) (kl:shen.hdtl Parse_shen.<premises>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2843))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<premises>) (quote shen.<premises>))
(begin (register-function-arity (quote shen.<semicolon-symbol>) 1) (define (kl:shen.<semicolon-symbol> V2845) (if (pair? (car V2845)) (let ((Parse_X (kl:shen.hdhd V2845))) (if (eq? Parse_X (quote _waspvm_sc_)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2845) (kl:shen.hdtl V2845))) (quote shen.skip)) (kl:fail))) (kl:fail))) (export shen.<semicolon-symbol>) (quote shen.<semicolon-symbol>))
(begin (register-function-arity (quote shen.<premise>) 1) (define (kl:shen.<premise> V2849) (let ((YaccParse (if (and (pair? (car V2849)) (eq? (quote !) (kl:shen.hdhd V2849))) (let ((NewStream2846 (kl:shen.pair (kl:shen.tlhd V2849) (kl:shen.hdtl V2849)))) (kl:shen.pair (car NewStream2846) (quote !))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<formulae> (kl:shen.<formulae> V2849))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formulae>)) (if (and (pair? (car Parse_shen.<formulae>)) (eq? (quote >>) (kl:shen.hdhd Parse_shen.<formulae>))) (let ((NewStream2847 (kl:shen.pair (kl:shen.tlhd Parse_shen.<formulae>) (kl:shen.hdtl Parse_shen.<formulae>)))) (let ((Parse_shen.<formula> (kl:shen.<formula> NewStream2847))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (kl:shen.pair (car Parse_shen.<formula>) (kl:shen.sequent (kl:shen.hdtl Parse_shen.<formulae>) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail)))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<formula> (kl:shen.<formula> V2849))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (kl:shen.pair (car Parse_shen.<formula>) (kl:shen.sequent (quote ()) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail))) YaccParse)) YaccParse))) (export shen.<premise>) (quote shen.<premise>))
(begin (register-function-arity (quote shen.<conclusion>) 1) (define (kl:shen.<conclusion> V2852) (let ((YaccParse (let ((Parse_shen.<formulae> (kl:shen.<formulae> V2852))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formulae>)) (if (and (pair? (car Parse_shen.<formulae>)) (eq? (quote >>) (kl:shen.hdhd Parse_shen.<formulae>))) (let ((NewStream2850 (kl:shen.pair (kl:shen.tlhd Parse_shen.<formulae>) (kl:shen.hdtl Parse_shen.<formulae>)))) (let ((Parse_shen.<formula> (kl:shen.<formula> NewStream2850))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (let ((Parse_shen.<semicolon-symbol> (kl:shen.<semicolon-symbol> Parse_shen.<formula>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon-symbol>)) (kl:shen.pair (car Parse_shen.<semicolon-symbol>) (kl:shen.sequent (kl:shen.hdtl Parse_shen.<formulae>) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail))) (kl:fail)))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<formula> (kl:shen.<formula> V2852))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (let ((Parse_shen.<semicolon-symbol> (kl:shen.<semicolon-symbol> Parse_shen.<formula>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon-symbol>)) (kl:shen.pair (car Parse_shen.<semicolon-symbol>) (kl:shen.sequent (quote ()) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail))) (kl:fail))) YaccParse))) (export shen.<conclusion>) (quote shen.<conclusion>))
(begin (register-function-arity (quote shen.sequent) 2) (define (kl:shen.sequent V2855 V2856) (kl:_waspvm_at_p V2855 V2856)) (export shen.sequent) (quote shen.sequent))
(begin (register-function-arity (quote shen.<formulae>) 1) (define (kl:shen.<formulae> V2858) (let ((YaccParse (let ((Parse_shen.<formula> (kl:shen.<formula> V2858))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (let ((Parse_shen.<comma-symbol> (kl:shen.<comma-symbol> Parse_shen.<formula>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comma-symbol>)) (let ((Parse_shen.<formulae> (kl:shen.<formulae> Parse_shen.<comma-symbol>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formulae>)) (kl:shen.pair (car Parse_shen.<formulae>) (cons (kl:shen.hdtl Parse_shen.<formula>) (kl:shen.hdtl Parse_shen.<formulae>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<formula> (kl:shen.<formula> V2858))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (kl:shen.pair (car Parse_shen.<formula>) (cons (kl:shen.hdtl Parse_shen.<formula>) (quote ()))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2858))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse)) YaccParse))) (export shen.<formulae>) (quote shen.<formulae>))
(begin (register-function-arity (quote shen.<comma-symbol>) 1) (define (kl:shen.<comma-symbol> V2860) (if (pair? (car V2860)) (let ((Parse_X (kl:shen.hdhd V2860))) (if (kl:= Parse_X (kl:intern ",")) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2860) (kl:shen.hdtl V2860))) (quote shen.skip)) (kl:fail))) (kl:fail))) (export shen.<comma-symbol>) (quote shen.<comma-symbol>))
(begin (register-function-arity (quote shen.<formula>) 1) (define (kl:shen.<formula> V2863) (let ((YaccParse (let ((Parse_shen.<expr> (kl:shen.<expr> V2863))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (if (and (pair? (car Parse_shen.<expr>)) (eq? (quote :) (kl:shen.hdhd Parse_shen.<expr>))) (let ((NewStream2861 (kl:shen.pair (kl:shen.tlhd Parse_shen.<expr>) (kl:shen.hdtl Parse_shen.<expr>)))) (let ((Parse_shen.<type> (kl:shen.<type> NewStream2861))) (if (kl:not (kl:= (kl:fail) Parse_shen.<type>)) (kl:shen.pair (car Parse_shen.<type>) (cons (kl:shen.curry (kl:shen.hdtl Parse_shen.<expr>)) (cons (quote :) (cons (kl:shen.demodulate (kl:shen.hdtl Parse_shen.<type>)) (quote ()))))) (kl:fail)))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<expr> (kl:shen.<expr> V2863))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (kl:shen.hdtl Parse_shen.<expr>)) (kl:fail))) YaccParse))) (export shen.<formula>) (quote shen.<formula>))
(begin (register-function-arity (quote shen.<type>) 1) (define (kl:shen.<type> V2865) (let ((Parse_shen.<expr> (kl:shen.<expr> V2865))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (kl:shen.curry-type (kl:shen.hdtl Parse_shen.<expr>))) (kl:fail)))) (export shen.<type>) (quote shen.<type>))
(begin (register-function-arity (quote shen.<doubleunderline>) 1) (define (kl:shen.<doubleunderline> V2867) (if (pair? (car V2867)) (let ((Parse_X (kl:shen.hdhd V2867))) (if (assert-boolean (kl:shen.doubleunderline? Parse_X)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2867) (kl:shen.hdtl V2867))) Parse_X) (kl:fail))) (kl:fail))) (export shen.<doubleunderline>) (quote shen.<doubleunderline>))
(begin (register-function-arity (quote shen.<singleunderline>) 1) (define (kl:shen.<singleunderline> V2869) (if (pair? (car V2869)) (let ((Parse_X (kl:shen.hdhd V2869))) (if (assert-boolean (kl:shen.singleunderline? Parse_X)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2869) (kl:shen.hdtl V2869))) Parse_X) (kl:fail))) (kl:fail))) (export shen.<singleunderline>) (quote shen.<singleunderline>))
(begin (register-function-arity (quote shen.singleunderline?) 1) (define (kl:shen.singleunderline? V2871) (and (kl:symbol? V2871) (assert-boolean (kl:shen.sh? (kl:str V2871))))) (export shen.singleunderline?) (quote shen.singleunderline?))
(begin (register-function-arity (quote shen.sh?) 1) (define (kl:shen.sh? V2873) (cond ((equal? "_" V2873) #t) (#t (and (equal? (make-string 1 (string-ref V2873 0)) "_") (assert-boolean (kl:shen.sh? (string-tail V2873 1))))))) (export shen.sh?) (quote shen.sh?))
(begin (register-function-arity (quote shen.doubleunderline?) 1) (define (kl:shen.doubleunderline? V2875) (and (kl:symbol? V2875) (assert-boolean (kl:shen.dh? (kl:str V2875))))) (export shen.doubleunderline?) (quote shen.doubleunderline?))
(begin (register-function-arity (quote shen.dh?) 1) (define (kl:shen.dh? V2877) (cond ((equal? "=" V2877) #t) (#t (and (equal? (make-string 1 (string-ref V2877 0)) "=") (assert-boolean (kl:shen.dh? (string-tail V2877 1))))))) (export shen.dh?) (quote shen.dh?))
(begin (register-function-arity (quote shen.process-datatype) 2) (define (kl:shen.process-datatype V2880 V2881) (kl:shen.remember-datatype (kl:shen.s-prolog (kl:shen.rules->horn-clauses V2880 V2881)))) (export shen.process-datatype) (quote shen.process-datatype))
(begin (register-function-arity (quote shen.remember-datatype) 1) (define (kl:shen.remember-datatype V2887) (cond ((pair? V2887) (begin (kl:set (quote shen.*datatypes*) (kl:adjoin (car V2887) (kl:value (quote shen.*datatypes*)))) (begin (kl:set (quote shen.*alldatatypes*) (kl:adjoin (car V2887) (kl:value (quote shen.*alldatatypes*)))) (car V2887)))) (#t (kl:shen.f_error (quote shen.remember-datatype))))) (export shen.remember-datatype) (quote shen.remember-datatype))
(begin (register-function-arity (quote shen.rules->horn-clauses) 2) (define (kl:shen.rules->horn-clauses V2892 V2893) (cond ((null? V2893) (quote ())) ((and (pair? V2893) (and (kl:tuple? (car V2893)) (eq? (quote shen.single) (kl:fst (car V2893))))) (cons (kl:shen.rule->horn-clause V2892 (kl:snd (car V2893))) (kl:shen.rules->horn-clauses V2892 (cdr V2893)))) ((and (pair? V2893) (and (kl:tuple? (car V2893)) (eq? (quote shen.double) (kl:fst (car V2893))))) (kl:shen.rules->horn-clauses V2892 (kl:append (kl:shen.double->singles (kl:snd (car V2893))) (cdr V2893)))) (#t (kl:shen.f_error (quote shen.rules->horn-clauses))))) (export shen.rules->horn-clauses) (quote shen.rules->horn-clauses))
(begin (register-function-arity (quote shen.double->singles) 1) (define (kl:shen.double->singles V2895) (cons (kl:shen.right-rule V2895) (cons (kl:shen.left-rule V2895) (quote ())))) (export shen.double->singles) (quote shen.double->singles))
(begin (register-function-arity (quote shen.right-rule) 1) (define (kl:shen.right-rule V2897) (kl:_waspvm_at_p (quote shen.single) V2897)) (export shen.right-rule) (quote shen.right-rule))
(begin (register-function-arity (quote shen.left-rule) 1) (define (kl:shen.left-rule V2899) (cond ((and (pair? V2899) (and (pair? (cdr V2899)) (and (pair? (cdr (cdr V2899))) (and (kl:tuple? (car (cdr (cdr V2899)))) (and (null? (kl:fst (car (cdr (cdr V2899))))) (null? (cdr (cdr (cdr V2899))))))))) (let ((Q (kl:gensym (quote Qv)))) (let ((NewConclusion (kl:_waspvm_at_p (cons (kl:snd (car (cdr (cdr V2899)))) (quote ())) Q))) (let ((NewPremises (cons (kl:_waspvm_at_p (kl:map (lambda (X) (kl:shen.right->left X)) (car (cdr V2899))) Q) (quote ())))) (kl:_waspvm_at_p (quote shen.single) (cons (car V2899) (cons NewPremises (cons NewConclusion (quote ()))))))))) (#t (kl:shen.f_error (quote shen.left-rule))))) (export shen.left-rule) (quote shen.left-rule))
(begin (register-function-arity (quote shen.right->left) 1) (define (kl:shen.right->left V2905) (cond ((and (kl:tuple? V2905) (null? (kl:fst V2905))) (kl:snd V2905)) (#t (simple-error "syntax error with ==========\n")))) (export shen.right->left) (quote shen.right->left))
(begin (register-function-arity (quote shen.rule->horn-clause) 2) (define (kl:shen.rule->horn-clause V2908 V2909) (cond ((and (pair? V2909) (and (pair? (cdr V2909)) (and (pair? (cdr (cdr V2909))) (and (kl:tuple? (car (cdr (cdr V2909)))) (null? (cdr (cdr (cdr V2909)))))))) (cons (kl:shen.rule->horn-clause-head V2908 (kl:snd (car (cdr (cdr V2909))))) (cons (quote :-) (cons (kl:shen.rule->horn-clause-body (car V2909) (car (cdr V2909)) (kl:fst (car (cdr (cdr V2909))))) (quote ()))))) (#t (kl:shen.f_error (quote shen.rule->horn-clause))))) (export shen.rule->horn-clause) (quote shen.rule->horn-clause))
(begin (register-function-arity (quote shen.rule->horn-clause-head) 2) (define (kl:shen.rule->horn-clause-head V2912 V2913) (cons V2912 (cons (kl:shen.mode-ify V2913) (cons (quote Context_1957) (quote ()))))) (export shen.rule->horn-clause-head) (quote shen.rule->horn-clause-head))
(begin (register-function-arity (quote shen.mode-ify) 1) (define (kl:shen.mode-ify V2915) (cond ((and (pair? V2915) (and (pair? (cdr V2915)) (and (eq? (quote :) (car (cdr V2915))) (and (pair? (cdr (cdr V2915))) (null? (cdr (cdr (cdr V2915)))))))) (cons (quote mode) (cons (cons (car V2915) (cons (quote :) (cons (cons (quote mode) (cons (car (cdr (cdr V2915))) (cons (quote +) (quote ())))) (quote ())))) (cons (quote -) (quote ()))))) (#t V2915))) (export shen.mode-ify) (quote shen.mode-ify))
(begin (register-function-arity (quote shen.rule->horn-clause-body) 3) (define (kl:shen.rule->horn-clause-body V2919 V2920 V2921) (let ((Variables (kl:map (lambda (X) (kl:shen.extract_vars X)) V2921))) (let ((Predicates (kl:map (lambda (X) (kl:gensym (quote shen.cl))) V2921))) (let ((SearchLiterals (kl:shen.construct-search-literals Predicates Variables (quote Context_1957) (quote Context1_1957)))) (let ((SearchClauses (kl:shen.construct-search-clauses Predicates V2921 Variables))) (let ((SideLiterals (kl:shen.construct-side-literals V2919))) (let ((PremissLiterals (kl:map (lambda (X) (kl:shen.construct-premiss-literal X (kl:empty? V2921))) V2920))) (kl:append SearchLiterals (kl:append SideLiterals PremissLiterals))))))))) (export shen.rule->horn-clause-body) (quote shen.rule->horn-clause-body))
(begin (register-function-arity (quote shen.construct-search-literals) 4) (define (kl:shen.construct-search-literals V2930 V2931 V2932 V2933) (cond ((and (null? V2930) (null? V2931)) (quote ())) (#t (kl:shen.csl-help V2930 V2931 V2932 V2933)))) (export shen.construct-search-literals) (quote shen.construct-search-literals))
(begin (register-function-arity (quote shen.csl-help) 4) (define (kl:shen.csl-help V2940 V2941 V2942 V2943) (cond ((and (null? V2940) (null? V2941)) (cons (cons (quote bind) (cons (quote ContextOut_1957) (cons V2942 (quote ())))) (quote ()))) ((and (pair? V2940) (pair? V2941)) (cons (cons (car V2940) (cons V2942 (cons V2943 (car V2941)))) (kl:shen.csl-help (cdr V2940) (cdr V2941) V2943 (kl:gensym (quote Context))))) (#t (kl:shen.f_error (quote shen.csl-help))))) (export shen.csl-help) (quote shen.csl-help))
(begin (register-function-arity (quote shen.construct-search-clauses) 3) (define (kl:shen.construct-search-clauses V2947 V2948 V2949) (cond ((and (null? V2947) (and (null? V2948) (null? V2949))) (quote shen.skip)) ((and (pair? V2947) (and (pair? V2948) (pair? V2949))) (begin (kl:shen.construct-search-clause (car V2947) (car V2948) (car V2949)) (kl:shen.construct-search-clauses (cdr V2947) (cdr V2948) (cdr V2949)))) (#t (kl:shen.f_error (quote shen.construct-search-clauses))))) (export shen.construct-search-clauses) (quote shen.construct-search-clauses))
(begin (register-function-arity (quote shen.construct-search-clause) 3) (define (kl:shen.construct-search-clause V2953 V2954 V2955) (kl:shen.s-prolog (cons (kl:shen.construct-base-search-clause V2953 V2954 V2955) (cons (kl:shen.construct-recursive-search-clause V2953 V2954 V2955) (quote ()))))) (export shen.construct-search-clause) (quote shen.construct-search-clause))
(begin (register-function-arity (quote shen.construct-base-search-clause) 3) (define (kl:shen.construct-base-search-clause V2959 V2960 V2961) (cons (cons V2959 (cons (cons (kl:shen.mode-ify V2960) (quote In_1957)) (cons (quote In_1957) V2961))) (cons (quote :-) (cons (quote ()) (quote ()))))) (export shen.construct-base-search-clause) (quote shen.construct-base-search-clause))
(begin (register-function-arity (quote shen.construct-recursive-search-clause) 3) (define (kl:shen.construct-recursive-search-clause V2965 V2966 V2967) (cons (cons V2965 (cons (cons (quote Assumption_1957) (quote Assumptions_1957)) (cons (cons (quote Assumption_1957) (quote Out_1957)) V2967))) (cons (quote :-) (cons (cons (cons V2965 (cons (quote Assumptions_1957) (cons (quote Out_1957) V2967))) (quote ())) (quote ()))))) (export shen.construct-recursive-search-clause) (quote shen.construct-recursive-search-clause))
(begin (register-function-arity (quote shen.construct-side-literals) 1) (define (kl:shen.construct-side-literals V2973) (cond ((null? V2973) (quote ())) ((and (pair? V2973) (and (pair? (car V2973)) (and (eq? (quote if) (car (car V2973))) (and (pair? (cdr (car V2973))) (null? (cdr (cdr (car V2973)))))))) (cons (cons (quote when) (cdr (car V2973))) (kl:shen.construct-side-literals (cdr V2973)))) ((and (pair? V2973) (and (pair? (car V2973)) (and (eq? (quote let) (car (car V2973))) (and (pair? (cdr (car V2973))) (and (pair? (cdr (cdr (car V2973)))) (null? (cdr (cdr (cdr (car V2973)))))))))) (cons (cons (quote is) (cdr (car V2973))) (kl:shen.construct-side-literals (cdr V2973)))) ((pair? V2973) (kl:shen.construct-side-literals (cdr V2973))) (#t (kl:shen.f_error (quote shen.construct-side-literals))))) (export shen.construct-side-literals) (quote shen.construct-side-literals))
(begin (register-function-arity (quote shen.construct-premiss-literal) 2) (define (kl:shen.construct-premiss-literal V2980 V2981) (cond ((kl:tuple? V2980) (cons (quote shen.t*) (cons (kl:shen.recursive_cons_form (kl:snd V2980)) (cons (kl:shen.construct-context V2981 (kl:fst V2980)) (quote ()))))) ((eq? (quote !) V2980) (cons (quote cut) (cons (quote Throwcontrol) (quote ())))) (#t (kl:shen.f_error (quote shen.construct-premiss-literal))))) (export shen.construct-premiss-literal) (quote shen.construct-premiss-literal))
(begin (register-function-arity (quote shen.construct-context) 2) (define (kl:shen.construct-context V2984 V2985) (cond ((and (kl:= #t V2984) (null? V2985)) (quote Context_1957)) ((and (kl:= #f V2984) (null? V2985)) (quote ContextOut_1957)) ((pair? V2985) (cons (quote cons) (cons (kl:shen.recursive_cons_form (car V2985)) (cons (kl:shen.construct-context V2984 (cdr V2985)) (quote ()))))) (#t (kl:shen.f_error (quote shen.construct-context))))) (export shen.construct-context) (quote shen.construct-context))
(begin (register-function-arity (quote shen.recursive_cons_form) 1) (define (kl:shen.recursive_cons_form V2987) (cond ((pair? V2987) (cons (quote cons) (cons (kl:shen.recursive_cons_form (car V2987)) (cons (kl:shen.recursive_cons_form (cdr V2987)) (quote ()))))) (#t V2987))) (export shen.recursive_cons_form) (quote shen.recursive_cons_form))
(begin (register-function-arity (quote preclude) 1) (define (kl:preclude V2989) (kl:shen.preclude-h (kl:map (lambda (X) (kl:shen.intern-type X)) V2989))) (export preclude) (quote preclude))
(begin (register-function-arity (quote shen.preclude-h) 1) (define (kl:shen.preclude-h V2991) (let ((FilterDatatypes (kl:set (quote shen.*datatypes*) (kl:difference (kl:value (quote shen.*datatypes*)) V2991)))) (kl:value (quote shen.*datatypes*)))) (export shen.preclude-h) (quote shen.preclude-h))
(begin (register-function-arity (quote include) 1) (define (kl:include V2993) (kl:shen.include-h (kl:map (lambda (X) (kl:shen.intern-type X)) V2993))) (export include) (quote include))
(begin (register-function-arity (quote shen.include-h) 1) (define (kl:shen.include-h V2995) (let ((ValidTypes (kl:intersection V2995 (kl:value (quote shen.*alldatatypes*))))) (let ((NewDatatypes (kl:set (quote shen.*datatypes*) (kl:union ValidTypes (kl:value (quote shen.*datatypes*)))))) (kl:value (quote shen.*datatypes*))))) (export shen.include-h) (quote shen.include-h))
(begin (register-function-arity (quote preclude-all-but) 1) (define (kl:preclude-all-but V2997) (kl:shen.preclude-h (kl:difference (kl:value (quote shen.*alldatatypes*)) (kl:map (lambda (X) (kl:shen.intern-type X)) V2997)))) (export preclude-all-but) (quote preclude-all-but))
(begin (register-function-arity (quote include-all-but) 1) (define (kl:include-all-but V2999) (kl:shen.include-h (kl:difference (kl:value (quote shen.*alldatatypes*)) (kl:map (lambda (X) (kl:shen.intern-type X)) V2999)))) (export include-all-but) (quote include-all-but))
(begin (register-function-arity (quote shen.synonyms-help) 1) (define (kl:shen.synonyms-help V3005) (cond ((null? V3005) (kl:shen.update-demodulation-function (kl:value (quote shen.*tc*)) (kl:mapcan (lambda (X) (kl:shen.demod-rule X)) (kl:value (quote shen.*synonyms*))))) ((and (pair? V3005) (pair? (cdr V3005))) (let ((Vs (kl:difference (kl:shen.extract_vars (car (cdr V3005))) (kl:shen.extract_vars (car V3005))))) (if (kl:empty? Vs) (begin (kl:shen.pushnew (cons (car V3005) (cons (car (cdr V3005)) (quote ()))) (quote shen.*synonyms*)) (kl:shen.synonyms-help (cdr (cdr V3005)))) (kl:shen.free_variable_warnings (car (cdr V3005)) Vs)))) (#t (simple-error "odd number of synonyms\n")))) (export shen.synonyms-help) (quote shen.synonyms-help))
(begin (register-function-arity (quote shen.pushnew) 2) (define (kl:shen.pushnew V3008 V3009) (if (kl:element? V3008 (kl:value V3009)) (kl:value V3009) (kl:set V3009 (cons V3008 (kl:value V3009))))) (export shen.pushnew) (quote shen.pushnew))
(begin (register-function-arity (quote shen.demod-rule) 1) (define (kl:shen.demod-rule V3011) (cond ((and (pair? V3011) (and (pair? (cdr V3011)) (null? (cdr (cdr V3011))))) (cons (kl:shen.rcons_form (car V3011)) (cons (quote ->) (cons (kl:shen.rcons_form (car (cdr V3011))) (quote ()))))) (#t (kl:shen.f_error (quote shen.demod-rule))))) (export shen.demod-rule) (quote shen.demod-rule))
(begin (register-function-arity (quote shen.lambda-of-defun) 1) (define (kl:shen.lambda-of-defun V3017) (cond ((and (pair? V3017) (and (eq? (quote defun) (car V3017)) (and (pair? (cdr V3017)) (and (pair? (cdr (cdr V3017))) (and (pair? (car (cdr (cdr V3017)))) (and (null? (cdr (car (cdr (cdr V3017))))) (and (pair? (cdr (cdr (cdr V3017)))) (null? (cdr (cdr (cdr (cdr V3017)))))))))))) (kl:eval (cons (quote /.) (cons (car (car (cdr (cdr V3017)))) (cdr (cdr (cdr V3017))))))) (#t (kl:shen.f_error (quote shen.lambda-of-defun))))) (export shen.lambda-of-defun) (quote shen.lambda-of-defun))
(begin (register-function-arity (quote shen.update-demodulation-function) 2) (define (kl:shen.update-demodulation-function V3020 V3021) (begin (kl:tc (quote -)) (begin (kl:set (quote shen.*demodulation-function*) (kl:shen.lambda-of-defun (kl:shen.elim-def (cons (quote define) (cons (quote shen.demod) (kl:append V3021 (kl:shen.default-rule))))))) (begin (if (assert-boolean V3020) (kl:tc (quote +)) (quote shen.skip)) (quote synonyms))))) (export shen.update-demodulation-function) (quote shen.update-demodulation-function))
(begin (register-function-arity (quote shen.default-rule) 0) (define (kl:shen.default-rule) (cons (quote X) (cons (quote ->) (cons (quote X) (quote ()))))) (export shen.default-rule) (quote shen.default-rule))
