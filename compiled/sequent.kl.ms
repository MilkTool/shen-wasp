"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.datatype-error) 1) (define (kl:shen.datatype-error V2440) (cond ((and (pair? V2440) (and (pair? (cdr V2440)) (null? (cdr (cdr V2440))))) (simple-error (string-append "datatype syntax error here:\n\n " (kl:shen.app (kl:shen.next-50 50 (car V2440)) "\n" (quote shen.a))))) (#t (kl:shen.f_error (quote shen.datatype-error))))) (quote shen.datatype-error))
(begin (register-function-arity (quote shen.<datatype-rules>) 1) (define (kl:shen.<datatype-rules> V2442) (let ((YaccParse (let ((Parse_shen.<datatype-rule> (kl:shen.<datatype-rule> V2442))) (if (kl:not (kl:= (kl:fail) Parse_shen.<datatype-rule>)) (let ((Parse_shen.<datatype-rules> (kl:shen.<datatype-rules> Parse_shen.<datatype-rule>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<datatype-rules>)) (kl:shen.pair (car Parse_shen.<datatype-rules>) (cons (kl:shen.hdtl Parse_shen.<datatype-rule>) (kl:shen.hdtl Parse_shen.<datatype-rules>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2442))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<datatype-rules>))
(begin (register-function-arity (quote shen.<datatype-rule>) 1) (define (kl:shen.<datatype-rule> V2444) (let ((YaccParse (let ((Parse_shen.<side-conditions> (kl:shen.<side-conditions> V2444))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-conditions>)) (let ((Parse_shen.<premises> (kl:shen.<premises> Parse_shen.<side-conditions>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premises>)) (let ((Parse_shen.<singleunderline> (kl:shen.<singleunderline> Parse_shen.<premises>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<singleunderline>)) (let ((Parse_shen.<conclusion> (kl:shen.<conclusion> Parse_shen.<singleunderline>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<conclusion>)) (kl:shen.pair (car Parse_shen.<conclusion>) (kl:shen.sequent (quote shen.single) (cons (kl:shen.hdtl Parse_shen.<side-conditions>) (cons (kl:shen.hdtl Parse_shen.<premises>) (cons (kl:shen.hdtl Parse_shen.<conclusion>) (quote ())))))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<side-conditions> (kl:shen.<side-conditions> V2444))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-conditions>)) (let ((Parse_shen.<premises> (kl:shen.<premises> Parse_shen.<side-conditions>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premises>)) (let ((Parse_shen.<doubleunderline> (kl:shen.<doubleunderline> Parse_shen.<premises>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<doubleunderline>)) (let ((Parse_shen.<conclusion> (kl:shen.<conclusion> Parse_shen.<doubleunderline>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<conclusion>)) (kl:shen.pair (car Parse_shen.<conclusion>) (kl:shen.sequent (quote shen.double) (cons (kl:shen.hdtl Parse_shen.<side-conditions>) (cons (kl:shen.hdtl Parse_shen.<premises>) (cons (kl:shen.hdtl Parse_shen.<conclusion>) (quote ())))))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))) YaccParse))) (quote shen.<datatype-rule>))
(begin (register-function-arity (quote shen.<side-conditions>) 1) (define (kl:shen.<side-conditions> V2446) (let ((YaccParse (let ((Parse_shen.<side-condition> (kl:shen.<side-condition> V2446))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-condition>)) (let ((Parse_shen.<side-conditions> (kl:shen.<side-conditions> Parse_shen.<side-condition>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-conditions>)) (kl:shen.pair (car Parse_shen.<side-conditions>) (cons (kl:shen.hdtl Parse_shen.<side-condition>) (kl:shen.hdtl Parse_shen.<side-conditions>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2446))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<side-conditions>))
(begin (register-function-arity (quote shen.<side-condition>) 1) (define (kl:shen.<side-condition> V2448) (let ((YaccParse (if (and (pair? (car V2448)) (eq? (quote if) (car (car V2448)))) (let ((Parse_shen.<expr> (kl:shen.<expr> (kl:shen.pair (cdr (car V2448)) (kl:shen.hdtl V2448))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (cons (quote if) (cons (kl:shen.hdtl Parse_shen.<expr>) (quote ())))) (kl:fail))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (if (and (pair? (car V2448)) (eq? (quote let) (car (car V2448)))) (let ((Parse_shen.<variable?> (kl:shen.<variable?> (kl:shen.pair (cdr (car V2448)) (kl:shen.hdtl V2448))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<variable?>)) (let ((Parse_shen.<expr> (kl:shen.<expr> Parse_shen.<variable?>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (cons (quote let) (cons (kl:shen.hdtl Parse_shen.<variable?>) (cons (kl:shen.hdtl Parse_shen.<expr>) (quote ()))))) (kl:fail))) (kl:fail))) (kl:fail)) YaccParse))) (quote shen.<side-condition>))
(begin (register-function-arity (quote shen.<variable?>) 1) (define (kl:shen.<variable?> V2450) (if (pair? (car V2450)) (let ((Parse_X (car (car V2450)))) (if (kl:variable? Parse_X) (kl:shen.pair (car (kl:shen.pair (cdr (car V2450)) (kl:shen.hdtl V2450))) Parse_X) (kl:fail))) (kl:fail))) (quote shen.<variable?>))
(begin (register-function-arity (quote shen.<expr>) 1) (define (kl:shen.<expr> V2452) (if (pair? (car V2452)) (let ((Parse_X (car (car V2452)))) (if (kl:not (or (kl:element? Parse_X (cons (quote >>) (cons (quote _waspvm_sc_) (quote ())))) (or (assert-boolean (kl:shen.singleunderline? Parse_X)) (assert-boolean (kl:shen.doubleunderline? Parse_X))))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2452)) (kl:shen.hdtl V2452))) (kl:shen.remove-bar Parse_X)) (kl:fail))) (kl:fail))) (quote shen.<expr>))
(begin (register-function-arity (quote shen.remove-bar) 1) (define (kl:shen.remove-bar V2454) (cond ((and (pair? V2454) (and (pair? (cdr V2454)) (and (pair? (cdr (cdr V2454))) (and (null? (cdr (cdr (cdr V2454)))) (eq? (car (cdr V2454)) (quote bar!)))))) (cons (car V2454) (car (cdr (cdr V2454))))) ((pair? V2454) (cons (kl:shen.remove-bar (car V2454)) (kl:shen.remove-bar (cdr V2454)))) (#t V2454))) (quote shen.remove-bar))
(begin (register-function-arity (quote shen.<premises>) 1) (define (kl:shen.<premises> V2456) (let ((YaccParse (let ((Parse_shen.<premise> (kl:shen.<premise> V2456))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premise>)) (let ((Parse_shen.<semicolon-symbol> (kl:shen.<semicolon-symbol> Parse_shen.<premise>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon-symbol>)) (let ((Parse_shen.<premises> (kl:shen.<premises> Parse_shen.<semicolon-symbol>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premises>)) (kl:shen.pair (car Parse_shen.<premises>) (cons (kl:shen.hdtl Parse_shen.<premise>) (kl:shen.hdtl Parse_shen.<premises>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2456))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<premises>))
(begin (register-function-arity (quote shen.<semicolon-symbol>) 1) (define (kl:shen.<semicolon-symbol> V2458) (if (pair? (car V2458)) (let ((Parse_X (car (car V2458)))) (if (eq? Parse_X (quote _waspvm_sc_)) (kl:shen.pair (car (kl:shen.pair (cdr (car V2458)) (kl:shen.hdtl V2458))) (quote shen.skip)) (kl:fail))) (kl:fail))) (quote shen.<semicolon-symbol>))
(begin (register-function-arity (quote shen.<premise>) 1) (define (kl:shen.<premise> V2460) (let ((YaccParse (if (and (pair? (car V2460)) (eq? (quote !) (car (car V2460)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2460)) (kl:shen.hdtl V2460))) (quote !)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<formulae> (kl:shen.<formulae> V2460))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formulae>)) (if (and (pair? (car Parse_shen.<formulae>)) (eq? (quote >>) (car (car Parse_shen.<formulae>)))) (let ((Parse_shen.<formula> (kl:shen.<formula> (kl:shen.pair (cdr (car Parse_shen.<formulae>)) (kl:shen.hdtl Parse_shen.<formulae>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (kl:shen.pair (car Parse_shen.<formula>) (kl:shen.sequent (kl:shen.hdtl Parse_shen.<formulae>) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<formula> (kl:shen.<formula> V2460))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (kl:shen.pair (car Parse_shen.<formula>) (kl:shen.sequent (quote ()) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail))) YaccParse)) YaccParse))) (quote shen.<premise>))
(begin (register-function-arity (quote shen.<conclusion>) 1) (define (kl:shen.<conclusion> V2462) (let ((YaccParse (let ((Parse_shen.<formulae> (kl:shen.<formulae> V2462))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formulae>)) (if (and (pair? (car Parse_shen.<formulae>)) (eq? (quote >>) (car (car Parse_shen.<formulae>)))) (let ((Parse_shen.<formula> (kl:shen.<formula> (kl:shen.pair (cdr (car Parse_shen.<formulae>)) (kl:shen.hdtl Parse_shen.<formulae>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (let ((Parse_shen.<semicolon-symbol> (kl:shen.<semicolon-symbol> Parse_shen.<formula>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon-symbol>)) (kl:shen.pair (car Parse_shen.<semicolon-symbol>) (kl:shen.sequent (kl:shen.hdtl Parse_shen.<formulae>) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail))) (kl:fail))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<formula> (kl:shen.<formula> V2462))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (let ((Parse_shen.<semicolon-symbol> (kl:shen.<semicolon-symbol> Parse_shen.<formula>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon-symbol>)) (kl:shen.pair (car Parse_shen.<semicolon-symbol>) (kl:shen.sequent (quote ()) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail))) (kl:fail))) YaccParse))) (quote shen.<conclusion>))
(begin (register-function-arity (quote shen.sequent) 2) (define (kl:shen.sequent V2465 V2466) (kl:_waspvm_at_p V2465 V2466)) (quote shen.sequent))
(begin (register-function-arity (quote shen.<formulae>) 1) (define (kl:shen.<formulae> V2468) (let ((YaccParse (let ((Parse_shen.<formula> (kl:shen.<formula> V2468))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (let ((Parse_shen.<comma-symbol> (kl:shen.<comma-symbol> Parse_shen.<formula>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comma-symbol>)) (let ((Parse_shen.<formulae> (kl:shen.<formulae> Parse_shen.<comma-symbol>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formulae>)) (kl:shen.pair (car Parse_shen.<formulae>) (cons (kl:shen.hdtl Parse_shen.<formula>) (kl:shen.hdtl Parse_shen.<formulae>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<formula> (kl:shen.<formula> V2468))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (kl:shen.pair (car Parse_shen.<formula>) (cons (kl:shen.hdtl Parse_shen.<formula>) (quote ()))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2468))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse)) YaccParse))) (quote shen.<formulae>))
(begin (register-function-arity (quote shen.<comma-symbol>) 1) (define (kl:shen.<comma-symbol> V2470) (if (pair? (car V2470)) (let ((Parse_X (car (car V2470)))) (if (kl:= Parse_X (kl:intern ",")) (kl:shen.pair (car (kl:shen.pair (cdr (car V2470)) (kl:shen.hdtl V2470))) (quote shen.skip)) (kl:fail))) (kl:fail))) (quote shen.<comma-symbol>))
(begin (register-function-arity (quote shen.<formula>) 1) (define (kl:shen.<formula> V2472) (let ((YaccParse (let ((Parse_shen.<expr> (kl:shen.<expr> V2472))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (if (and (pair? (car Parse_shen.<expr>)) (eq? (quote :) (car (car Parse_shen.<expr>)))) (let ((Parse_shen.<type> (kl:shen.<type> (kl:shen.pair (cdr (car Parse_shen.<expr>)) (kl:shen.hdtl Parse_shen.<expr>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<type>)) (kl:shen.pair (car Parse_shen.<type>) (cons (kl:shen.curry (kl:shen.hdtl Parse_shen.<expr>)) (cons (quote :) (cons (kl:shen.demodulate (kl:shen.hdtl Parse_shen.<type>)) (quote ()))))) (kl:fail))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<expr> (kl:shen.<expr> V2472))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (kl:shen.hdtl Parse_shen.<expr>)) (kl:fail))) YaccParse))) (quote shen.<formula>))
(begin (register-function-arity (quote shen.<type>) 1) (define (kl:shen.<type> V2474) (let ((Parse_shen.<expr> (kl:shen.<expr> V2474))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (kl:shen.curry-type (kl:shen.hdtl Parse_shen.<expr>))) (kl:fail)))) (quote shen.<type>))
(begin (register-function-arity (quote shen.<doubleunderline>) 1) (define (kl:shen.<doubleunderline> V2476) (if (pair? (car V2476)) (let ((Parse_X (car (car V2476)))) (if (assert-boolean (kl:shen.doubleunderline? Parse_X)) (kl:shen.pair (car (kl:shen.pair (cdr (car V2476)) (kl:shen.hdtl V2476))) Parse_X) (kl:fail))) (kl:fail))) (quote shen.<doubleunderline>))
(begin (register-function-arity (quote shen.<singleunderline>) 1) (define (kl:shen.<singleunderline> V2478) (if (pair? (car V2478)) (let ((Parse_X (car (car V2478)))) (if (assert-boolean (kl:shen.singleunderline? Parse_X)) (kl:shen.pair (car (kl:shen.pair (cdr (car V2478)) (kl:shen.hdtl V2478))) Parse_X) (kl:fail))) (kl:fail))) (quote shen.<singleunderline>))
(begin (register-function-arity (quote shen.singleunderline?) 1) (define (kl:shen.singleunderline? V2480) (and (kl:symbol? V2480) (assert-boolean (kl:shen.sh? (kl:str V2480))))) (quote shen.singleunderline?))
(begin (register-function-arity (quote shen.sh?) 1) (define (kl:shen.sh? V2482) (cond ((equal? "_" V2482) #t) (#t (and (equal? (make-string 1 (string-ref V2482 0)) "_") (assert-boolean (kl:shen.sh? (string-tail V2482 1))))))) (quote shen.sh?))
(begin (register-function-arity (quote shen.doubleunderline?) 1) (define (kl:shen.doubleunderline? V2484) (and (kl:symbol? V2484) (assert-boolean (kl:shen.dh? (kl:str V2484))))) (quote shen.doubleunderline?))
(begin (register-function-arity (quote shen.dh?) 1) (define (kl:shen.dh? V2486) (cond ((equal? "=" V2486) #t) (#t (and (equal? (make-string 1 (string-ref V2486 0)) "=") (assert-boolean (kl:shen.dh? (string-tail V2486 1))))))) (quote shen.dh?))
(begin (register-function-arity (quote shen.process-datatype) 2) (define (kl:shen.process-datatype V2489 V2490) (kl:shen.remember-datatype (kl:shen.s-prolog (kl:shen.rules->horn-clauses V2489 V2490)))) (quote shen.process-datatype))
(begin (register-function-arity (quote shen.remember-datatype) 1) (define (kl:shen.remember-datatype V2496) (cond ((pair? V2496) (begin (kl:set (quote shen.*datatypes*) (kl:adjoin (car V2496) (kl:value (quote shen.*datatypes*)))) (begin (kl:set (quote shen.*alldatatypes*) (kl:adjoin (car V2496) (kl:value (quote shen.*alldatatypes*)))) (car V2496)))) (#t (kl:shen.f_error (quote shen.remember-datatype))))) (quote shen.remember-datatype))
(begin (register-function-arity (quote shen.rules->horn-clauses) 2) (define (kl:shen.rules->horn-clauses V2501 V2502) (cond ((null? V2502) (quote ())) ((and (pair? V2502) (and (kl:tuple? (car V2502)) (eq? (quote shen.single) (kl:fst (car V2502))))) (cons (kl:shen.rule->horn-clause V2501 (kl:snd (car V2502))) (kl:shen.rules->horn-clauses V2501 (cdr V2502)))) ((and (pair? V2502) (and (kl:tuple? (car V2502)) (eq? (quote shen.double) (kl:fst (car V2502))))) (kl:shen.rules->horn-clauses V2501 (kl:append (kl:shen.double->singles (kl:snd (car V2502))) (cdr V2502)))) (#t (kl:shen.f_error (quote shen.rules->horn-clauses))))) (quote shen.rules->horn-clauses))
(begin (register-function-arity (quote shen.double->singles) 1) (define (kl:shen.double->singles V2504) (cons (kl:shen.right-rule V2504) (cons (kl:shen.left-rule V2504) (quote ())))) (quote shen.double->singles))
(begin (register-function-arity (quote shen.right-rule) 1) (define (kl:shen.right-rule V2506) (kl:_waspvm_at_p (quote shen.single) V2506)) (quote shen.right-rule))
(begin (register-function-arity (quote shen.left-rule) 1) (define (kl:shen.left-rule V2508) (cond ((and (pair? V2508) (and (pair? (cdr V2508)) (and (pair? (cdr (cdr V2508))) (and (kl:tuple? (car (cdr (cdr V2508)))) (and (null? (kl:fst (car (cdr (cdr V2508))))) (null? (cdr (cdr (cdr V2508))))))))) (let ((Q (kl:gensym (quote Qv)))) (let ((NewConclusion (kl:_waspvm_at_p (cons (kl:snd (car (cdr (cdr V2508)))) (quote ())) Q))) (let ((NewPremises (cons (kl:_waspvm_at_p (kl:map (lambda (X) (kl:shen.right->left X)) (car (cdr V2508))) Q) (quote ())))) (kl:_waspvm_at_p (quote shen.single) (cons (car V2508) (cons NewPremises (cons NewConclusion (quote ()))))))))) (#t (kl:shen.f_error (quote shen.left-rule))))) (quote shen.left-rule))
(begin (register-function-arity (quote shen.right->left) 1) (define (kl:shen.right->left V2514) (cond ((and (kl:tuple? V2514) (null? (kl:fst V2514))) (kl:snd V2514)) (#t (simple-error "syntax error with ==========\n")))) (quote shen.right->left))
(begin (register-function-arity (quote shen.rule->horn-clause) 2) (define (kl:shen.rule->horn-clause V2517 V2518) (cond ((and (pair? V2518) (and (pair? (cdr V2518)) (and (pair? (cdr (cdr V2518))) (and (kl:tuple? (car (cdr (cdr V2518)))) (null? (cdr (cdr (cdr V2518)))))))) (cons (kl:shen.rule->horn-clause-head V2517 (kl:snd (car (cdr (cdr V2518))))) (cons (quote :-) (cons (kl:shen.rule->horn-clause-body (car V2518) (car (cdr V2518)) (kl:fst (car (cdr (cdr V2518))))) (quote ()))))) (#t (kl:shen.f_error (quote shen.rule->horn-clause))))) (quote shen.rule->horn-clause))
(begin (register-function-arity (quote shen.rule->horn-clause-head) 2) (define (kl:shen.rule->horn-clause-head V2521 V2522) (cons V2521 (cons (kl:shen.mode-ify V2522) (cons (quote Context_1957) (quote ()))))) (quote shen.rule->horn-clause-head))
(begin (register-function-arity (quote shen.mode-ify) 1) (define (kl:shen.mode-ify V2524) (cond ((and (pair? V2524) (and (pair? (cdr V2524)) (and (eq? (quote :) (car (cdr V2524))) (and (pair? (cdr (cdr V2524))) (null? (cdr (cdr (cdr V2524)))))))) (cons (quote mode) (cons (cons (car V2524) (cons (quote :) (cons (cons (quote mode) (cons (car (cdr (cdr V2524))) (cons (quote +) (quote ())))) (quote ())))) (cons (quote -) (quote ()))))) (#t V2524))) (quote shen.mode-ify))
(begin (register-function-arity (quote shen.rule->horn-clause-body) 3) (define (kl:shen.rule->horn-clause-body V2528 V2529 V2530) (let ((Variables (kl:map (lambda (X) (kl:shen.extract_vars X)) V2530))) (let ((Predicates (kl:map (lambda (X) (kl:gensym (quote shen.cl))) V2530))) (let ((SearchLiterals (kl:shen.construct-search-literals Predicates Variables (quote Context_1957) (quote Context1_1957)))) (let ((SearchClauses (kl:shen.construct-search-clauses Predicates V2530 Variables))) (let ((SideLiterals (kl:shen.construct-side-literals V2528))) (let ((PremissLiterals (kl:map (lambda (X) (kl:shen.construct-premiss-literal X (kl:empty? V2530))) V2529))) (kl:append SearchLiterals (kl:append SideLiterals PremissLiterals))))))))) (quote shen.rule->horn-clause-body))
(begin (register-function-arity (quote shen.construct-search-literals) 4) (define (kl:shen.construct-search-literals V2539 V2540 V2541 V2542) (cond ((and (null? V2539) (null? V2540)) (quote ())) (#t (kl:shen.csl-help V2539 V2540 V2541 V2542)))) (quote shen.construct-search-literals))
(begin (register-function-arity (quote shen.csl-help) 4) (define (kl:shen.csl-help V2549 V2550 V2551 V2552) (cond ((and (null? V2549) (null? V2550)) (cons (cons (quote bind) (cons (quote ContextOut_1957) (cons V2551 (quote ())))) (quote ()))) ((and (pair? V2549) (pair? V2550)) (cons (cons (car V2549) (cons V2551 (cons V2552 (car V2550)))) (kl:shen.csl-help (cdr V2549) (cdr V2550) V2552 (kl:gensym (quote Context))))) (#t (kl:shen.f_error (quote shen.csl-help))))) (quote shen.csl-help))
(begin (register-function-arity (quote shen.construct-search-clauses) 3) (define (kl:shen.construct-search-clauses V2556 V2557 V2558) (cond ((and (null? V2556) (and (null? V2557) (null? V2558))) (quote shen.skip)) ((and (pair? V2556) (and (pair? V2557) (pair? V2558))) (begin (kl:shen.construct-search-clause (car V2556) (car V2557) (car V2558)) (kl:shen.construct-search-clauses (cdr V2556) (cdr V2557) (cdr V2558)))) (#t (kl:shen.f_error (quote shen.construct-search-clauses))))) (quote shen.construct-search-clauses))
(begin (register-function-arity (quote shen.construct-search-clause) 3) (define (kl:shen.construct-search-clause V2562 V2563 V2564) (kl:shen.s-prolog (cons (kl:shen.construct-base-search-clause V2562 V2563 V2564) (cons (kl:shen.construct-recursive-search-clause V2562 V2563 V2564) (quote ()))))) (quote shen.construct-search-clause))
(begin (register-function-arity (quote shen.construct-base-search-clause) 3) (define (kl:shen.construct-base-search-clause V2568 V2569 V2570) (cons (cons V2568 (cons (cons (kl:shen.mode-ify V2569) (quote In_1957)) (cons (quote In_1957) V2570))) (cons (quote :-) (cons (quote ()) (quote ()))))) (quote shen.construct-base-search-clause))
(begin (register-function-arity (quote shen.construct-recursive-search-clause) 3) (define (kl:shen.construct-recursive-search-clause V2574 V2575 V2576) (cons (cons V2574 (cons (cons (quote Assumption_1957) (quote Assumptions_1957)) (cons (cons (quote Assumption_1957) (quote Out_1957)) V2576))) (cons (quote :-) (cons (cons (cons V2574 (cons (quote Assumptions_1957) (cons (quote Out_1957) V2576))) (quote ())) (quote ()))))) (quote shen.construct-recursive-search-clause))
(begin (register-function-arity (quote shen.construct-side-literals) 1) (define (kl:shen.construct-side-literals V2582) (cond ((null? V2582) (quote ())) ((and (pair? V2582) (and (pair? (car V2582)) (and (eq? (quote if) (car (car V2582))) (and (pair? (cdr (car V2582))) (null? (cdr (cdr (car V2582)))))))) (cons (cons (quote when) (cdr (car V2582))) (kl:shen.construct-side-literals (cdr V2582)))) ((and (pair? V2582) (and (pair? (car V2582)) (and (eq? (quote let) (car (car V2582))) (and (pair? (cdr (car V2582))) (and (pair? (cdr (cdr (car V2582)))) (null? (cdr (cdr (cdr (car V2582)))))))))) (cons (cons (quote is) (cdr (car V2582))) (kl:shen.construct-side-literals (cdr V2582)))) ((pair? V2582) (kl:shen.construct-side-literals (cdr V2582))) (#t (kl:shen.f_error (quote shen.construct-side-literals))))) (quote shen.construct-side-literals))
(begin (register-function-arity (quote shen.construct-premiss-literal) 2) (define (kl:shen.construct-premiss-literal V2589 V2590) (cond ((kl:tuple? V2589) (cons (quote shen.t*) (cons (kl:shen.recursive_cons_form (kl:snd V2589)) (cons (kl:shen.construct-context V2590 (kl:fst V2589)) (quote ()))))) ((eq? (quote !) V2589) (cons (quote cut) (cons (quote Throwcontrol) (quote ())))) (#t (kl:shen.f_error (quote shen.construct-premiss-literal))))) (quote shen.construct-premiss-literal))
(begin (register-function-arity (quote shen.construct-context) 2) (define (kl:shen.construct-context V2593 V2594) (cond ((and (kl:= #t V2593) (null? V2594)) (quote Context_1957)) ((and (kl:= #f V2593) (null? V2594)) (quote ContextOut_1957)) ((pair? V2594) (cons (quote cons) (cons (kl:shen.recursive_cons_form (car V2594)) (cons (kl:shen.construct-context V2593 (cdr V2594)) (quote ()))))) (#t (kl:shen.f_error (quote shen.construct-context))))) (quote shen.construct-context))
(begin (register-function-arity (quote shen.recursive_cons_form) 1) (define (kl:shen.recursive_cons_form V2596) (cond ((pair? V2596) (cons (quote cons) (cons (kl:shen.recursive_cons_form (car V2596)) (cons (kl:shen.recursive_cons_form (cdr V2596)) (quote ()))))) (#t V2596))) (quote shen.recursive_cons_form))
(begin (register-function-arity (quote preclude) 1) (define (kl:preclude V2598) (kl:shen.preclude-h (kl:map (lambda (X) (kl:shen.intern-type X)) V2598))) (quote preclude))
(begin (register-function-arity (quote shen.preclude-h) 1) (define (kl:shen.preclude-h V2600) (let ((FilterDatatypes (kl:set (quote shen.*datatypes*) (kl:difference (kl:value (quote shen.*datatypes*)) V2600)))) (kl:value (quote shen.*datatypes*)))) (quote shen.preclude-h))
(begin (register-function-arity (quote include) 1) (define (kl:include V2602) (kl:shen.include-h (kl:map (lambda (X) (kl:shen.intern-type X)) V2602))) (quote include))
(begin (register-function-arity (quote shen.include-h) 1) (define (kl:shen.include-h V2604) (let ((ValidTypes (kl:intersection V2604 (kl:value (quote shen.*alldatatypes*))))) (let ((NewDatatypes (kl:set (quote shen.*datatypes*) (kl:union ValidTypes (kl:value (quote shen.*datatypes*)))))) (kl:value (quote shen.*datatypes*))))) (quote shen.include-h))
(begin (register-function-arity (quote preclude-all-but) 1) (define (kl:preclude-all-but V2606) (kl:shen.preclude-h (kl:difference (kl:value (quote shen.*alldatatypes*)) (kl:map (lambda (X) (kl:shen.intern-type X)) V2606)))) (quote preclude-all-but))
(begin (register-function-arity (quote include-all-but) 1) (define (kl:include-all-but V2608) (kl:shen.include-h (kl:difference (kl:value (quote shen.*alldatatypes*)) (kl:map (lambda (X) (kl:shen.intern-type X)) V2608)))) (quote include-all-but))
(begin (register-function-arity (quote shen.synonyms-help) 1) (define (kl:shen.synonyms-help V2614) (cond ((null? V2614) (kl:shen.update-demodulation-function (kl:value (quote shen.*tc*)) (kl:mapcan (lambda (X) (kl:shen.demod-rule X)) (kl:value (quote shen.*synonyms*))))) ((and (pair? V2614) (pair? (cdr V2614))) (let ((Vs (kl:difference (kl:shen.extract_vars (car (cdr V2614))) (kl:shen.extract_vars (car V2614))))) (if (kl:empty? Vs) (begin (kl:shen.pushnew (cons (car V2614) (cons (car (cdr V2614)) (quote ()))) (quote shen.*synonyms*)) (kl:shen.synonyms-help (cdr (cdr V2614)))) (kl:shen.free_variable_warnings (car (cdr V2614)) Vs)))) (#t (simple-error "odd number of synonyms\n")))) (quote shen.synonyms-help))
(begin (register-function-arity (quote shen.pushnew) 2) (define (kl:shen.pushnew V2617 V2618) (if (kl:element? V2617 (kl:value V2618)) (kl:value V2618) (kl:set V2618 (cons V2617 (kl:value V2618))))) (quote shen.pushnew))
(begin (register-function-arity (quote shen.demod-rule) 1) (define (kl:shen.demod-rule V2620) (cond ((and (pair? V2620) (and (pair? (cdr V2620)) (null? (cdr (cdr V2620))))) (cons (kl:shen.rcons_form (car V2620)) (cons (quote ->) (cons (kl:shen.rcons_form (car (cdr V2620))) (quote ()))))) (#t (kl:shen.f_error (quote shen.demod-rule))))) (quote shen.demod-rule))
(begin (register-function-arity (quote shen.lambda-of-defun) 1) (define (kl:shen.lambda-of-defun V2626) (cond ((and (pair? V2626) (and (eq? (quote defun) (car V2626)) (and (pair? (cdr V2626)) (and (pair? (cdr (cdr V2626))) (and (pair? (car (cdr (cdr V2626)))) (and (null? (cdr (car (cdr (cdr V2626))))) (and (pair? (cdr (cdr (cdr V2626)))) (null? (cdr (cdr (cdr (cdr V2626)))))))))))) (kl:eval (cons (quote /.) (cons (car (car (cdr (cdr V2626)))) (cdr (cdr (cdr V2626))))))) (#t (kl:shen.f_error (quote shen.lambda-of-defun))))) (quote shen.lambda-of-defun))
(begin (register-function-arity (quote shen.update-demodulation-function) 2) (define (kl:shen.update-demodulation-function V2629 V2630) (begin (kl:tc (quote -)) (begin (kl:set (quote shen.*demodulation-function*) (kl:shen.lambda-of-defun (kl:shen.elim-def (cons (quote define) (cons (quote shen.demod) (kl:append V2630 (kl:shen.default-rule))))))) (begin (if (assert-boolean V2629) (kl:tc (quote +)) (quote shen.skip)) (quote synonyms))))) (quote shen.update-demodulation-function))
(begin (register-function-arity (quote shen.default-rule) 0) (define (kl:shen.default-rule) (cons (quote X) (cons (quote ->) (cons (quote X) (quote ()))))) (quote shen.default-rule))
