"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.datatype-error) 1) (define (kl:shen.datatype-error V2613) (cond ((and (pair? V2613) (and (pair? (cdr V2613)) (null? (cdr (cdr V2613))))) (simple-error (string-append "datatype syntax error here:\n\n " (kl:shen.app (kl:shen.next-50 50 (car V2613)) "\n" (quote shen.a))))) (#t (kl:shen.f_error (quote shen.datatype-error))))) (quote shen.datatype-error))
(begin (register-function-arity (quote shen.<datatype-rules>) 1) (define (kl:shen.<datatype-rules> V2615) (let ((YaccParse (let ((Parse_shen.<datatype-rule> (kl:shen.<datatype-rule> V2615))) (if (kl:not (kl:= (kl:fail) Parse_shen.<datatype-rule>)) (let ((Parse_shen.<datatype-rules> (kl:shen.<datatype-rules> Parse_shen.<datatype-rule>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<datatype-rules>)) (kl:shen.pair (car Parse_shen.<datatype-rules>) (cons (kl:shen.hdtl Parse_shen.<datatype-rule>) (kl:shen.hdtl Parse_shen.<datatype-rules>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2615))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<datatype-rules>))
(begin (register-function-arity (quote shen.<datatype-rule>) 1) (define (kl:shen.<datatype-rule> V2617) (let ((YaccParse (let ((Parse_shen.<side-conditions> (kl:shen.<side-conditions> V2617))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-conditions>)) (let ((Parse_shen.<premises> (kl:shen.<premises> Parse_shen.<side-conditions>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premises>)) (let ((Parse_shen.<singleunderline> (kl:shen.<singleunderline> Parse_shen.<premises>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<singleunderline>)) (let ((Parse_shen.<conclusion> (kl:shen.<conclusion> Parse_shen.<singleunderline>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<conclusion>)) (kl:shen.pair (car Parse_shen.<conclusion>) (kl:shen.sequent (quote shen.single) (cons (kl:shen.hdtl Parse_shen.<side-conditions>) (cons (kl:shen.hdtl Parse_shen.<premises>) (cons (kl:shen.hdtl Parse_shen.<conclusion>) (quote ())))))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<side-conditions> (kl:shen.<side-conditions> V2617))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-conditions>)) (let ((Parse_shen.<premises> (kl:shen.<premises> Parse_shen.<side-conditions>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premises>)) (let ((Parse_shen.<doubleunderline> (kl:shen.<doubleunderline> Parse_shen.<premises>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<doubleunderline>)) (let ((Parse_shen.<conclusion> (kl:shen.<conclusion> Parse_shen.<doubleunderline>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<conclusion>)) (kl:shen.pair (car Parse_shen.<conclusion>) (kl:shen.sequent (quote shen.double) (cons (kl:shen.hdtl Parse_shen.<side-conditions>) (cons (kl:shen.hdtl Parse_shen.<premises>) (cons (kl:shen.hdtl Parse_shen.<conclusion>) (quote ())))))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))) YaccParse))) (quote shen.<datatype-rule>))
(begin (register-function-arity (quote shen.<side-conditions>) 1) (define (kl:shen.<side-conditions> V2619) (let ((YaccParse (let ((Parse_shen.<side-condition> (kl:shen.<side-condition> V2619))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-condition>)) (let ((Parse_shen.<side-conditions> (kl:shen.<side-conditions> Parse_shen.<side-condition>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-conditions>)) (kl:shen.pair (car Parse_shen.<side-conditions>) (cons (kl:shen.hdtl Parse_shen.<side-condition>) (kl:shen.hdtl Parse_shen.<side-conditions>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2619))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<side-conditions>))
(begin (register-function-arity (quote shen.<side-condition>) 1) (define (kl:shen.<side-condition> V2621) (let ((YaccParse (if (and (pair? (car V2621)) (eq? (quote if) (car (car V2621)))) (let ((Parse_shen.<expr> (kl:shen.<expr> (kl:shen.pair (cdr (car V2621)) (kl:shen.hdtl V2621))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (cons (quote if) (cons (kl:shen.hdtl Parse_shen.<expr>) (quote ())))) (kl:fail))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (if (and (pair? (car V2621)) (eq? (quote let) (car (car V2621)))) (let ((Parse_shen.<variable?> (kl:shen.<variable?> (kl:shen.pair (cdr (car V2621)) (kl:shen.hdtl V2621))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<variable?>)) (let ((Parse_shen.<expr> (kl:shen.<expr> Parse_shen.<variable?>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (cons (quote let) (cons (kl:shen.hdtl Parse_shen.<variable?>) (cons (kl:shen.hdtl Parse_shen.<expr>) (quote ()))))) (kl:fail))) (kl:fail))) (kl:fail)) YaccParse))) (quote shen.<side-condition>))
(begin (register-function-arity (quote shen.<variable?>) 1) (define (kl:shen.<variable?> V2623) (if (pair? (car V2623)) (let ((Parse_X (car (car V2623)))) (if (kl:variable? Parse_X) (kl:shen.pair (car (kl:shen.pair (cdr (car V2623)) (kl:shen.hdtl V2623))) Parse_X) (kl:fail))) (kl:fail))) (quote shen.<variable?>))
(begin (register-function-arity (quote shen.<expr>) 1) (define (kl:shen.<expr> V2625) (if (pair? (car V2625)) (let ((Parse_X (car (car V2625)))) (if (kl:not (or (kl:element? Parse_X (cons (quote >>) (cons (quote _waspvm_sc_) (quote ())))) (or (assert-boolean (kl:shen.singleunderline? Parse_X)) (assert-boolean (kl:shen.doubleunderline? Parse_X))))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2625)) (kl:shen.hdtl V2625))) (kl:shen.remove-bar Parse_X)) (kl:fail))) (kl:fail))) (quote shen.<expr>))
(begin (register-function-arity (quote shen.remove-bar) 1) (define (kl:shen.remove-bar V2627) (cond ((and (pair? V2627) (and (pair? (cdr V2627)) (and (pair? (cdr (cdr V2627))) (and (null? (cdr (cdr (cdr V2627)))) (eq? (car (cdr V2627)) (quote bar!)))))) (cons (car V2627) (car (cdr (cdr V2627))))) ((pair? V2627) (cons (kl:shen.remove-bar (car V2627)) (kl:shen.remove-bar (cdr V2627)))) (#t V2627))) (quote shen.remove-bar))
(begin (register-function-arity (quote shen.<premises>) 1) (define (kl:shen.<premises> V2629) (let ((YaccParse (let ((Parse_shen.<premise> (kl:shen.<premise> V2629))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premise>)) (let ((Parse_shen.<semicolon-symbol> (kl:shen.<semicolon-symbol> Parse_shen.<premise>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon-symbol>)) (let ((Parse_shen.<premises> (kl:shen.<premises> Parse_shen.<semicolon-symbol>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premises>)) (kl:shen.pair (car Parse_shen.<premises>) (cons (kl:shen.hdtl Parse_shen.<premise>) (kl:shen.hdtl Parse_shen.<premises>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2629))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<premises>))
(begin (register-function-arity (quote shen.<semicolon-symbol>) 1) (define (kl:shen.<semicolon-symbol> V2631) (if (pair? (car V2631)) (let ((Parse_X (car (car V2631)))) (if (eq? Parse_X (quote _waspvm_sc_)) (kl:shen.pair (car (kl:shen.pair (cdr (car V2631)) (kl:shen.hdtl V2631))) (quote shen.skip)) (kl:fail))) (kl:fail))) (quote shen.<semicolon-symbol>))
(begin (register-function-arity (quote shen.<premise>) 1) (define (kl:shen.<premise> V2633) (let ((YaccParse (if (and (pair? (car V2633)) (eq? (quote !) (car (car V2633)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2633)) (kl:shen.hdtl V2633))) (quote !)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<formulae> (kl:shen.<formulae> V2633))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formulae>)) (if (and (pair? (car Parse_shen.<formulae>)) (eq? (quote >>) (car (car Parse_shen.<formulae>)))) (let ((Parse_shen.<formula> (kl:shen.<formula> (kl:shen.pair (cdr (car Parse_shen.<formulae>)) (kl:shen.hdtl Parse_shen.<formulae>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (kl:shen.pair (car Parse_shen.<formula>) (kl:shen.sequent (kl:shen.hdtl Parse_shen.<formulae>) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<formula> (kl:shen.<formula> V2633))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (kl:shen.pair (car Parse_shen.<formula>) (kl:shen.sequent (quote ()) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail))) YaccParse)) YaccParse))) (quote shen.<premise>))
(begin (register-function-arity (quote shen.<conclusion>) 1) (define (kl:shen.<conclusion> V2635) (let ((YaccParse (let ((Parse_shen.<formulae> (kl:shen.<formulae> V2635))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formulae>)) (if (and (pair? (car Parse_shen.<formulae>)) (eq? (quote >>) (car (car Parse_shen.<formulae>)))) (let ((Parse_shen.<formula> (kl:shen.<formula> (kl:shen.pair (cdr (car Parse_shen.<formulae>)) (kl:shen.hdtl Parse_shen.<formulae>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (let ((Parse_shen.<semicolon-symbol> (kl:shen.<semicolon-symbol> Parse_shen.<formula>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon-symbol>)) (kl:shen.pair (car Parse_shen.<semicolon-symbol>) (kl:shen.sequent (kl:shen.hdtl Parse_shen.<formulae>) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail))) (kl:fail))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<formula> (kl:shen.<formula> V2635))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (let ((Parse_shen.<semicolon-symbol> (kl:shen.<semicolon-symbol> Parse_shen.<formula>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon-symbol>)) (kl:shen.pair (car Parse_shen.<semicolon-symbol>) (kl:shen.sequent (quote ()) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail))) (kl:fail))) YaccParse))) (quote shen.<conclusion>))
(begin (register-function-arity (quote shen.sequent) 2) (define (kl:shen.sequent V2638 V2639) (kl:_waspvm_at_p V2638 V2639)) (quote shen.sequent))
(begin (register-function-arity (quote shen.<formulae>) 1) (define (kl:shen.<formulae> V2641) (let ((YaccParse (let ((Parse_shen.<formula> (kl:shen.<formula> V2641))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (let ((Parse_shen.<comma-symbol> (kl:shen.<comma-symbol> Parse_shen.<formula>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comma-symbol>)) (let ((Parse_shen.<formulae> (kl:shen.<formulae> Parse_shen.<comma-symbol>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formulae>)) (kl:shen.pair (car Parse_shen.<formulae>) (cons (kl:shen.hdtl Parse_shen.<formula>) (kl:shen.hdtl Parse_shen.<formulae>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<formula> (kl:shen.<formula> V2641))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (kl:shen.pair (car Parse_shen.<formula>) (cons (kl:shen.hdtl Parse_shen.<formula>) (quote ()))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2641))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse)) YaccParse))) (quote shen.<formulae>))
(begin (register-function-arity (quote shen.<comma-symbol>) 1) (define (kl:shen.<comma-symbol> V2643) (if (pair? (car V2643)) (let ((Parse_X (car (car V2643)))) (if (kl:= Parse_X (kl:intern ",")) (kl:shen.pair (car (kl:shen.pair (cdr (car V2643)) (kl:shen.hdtl V2643))) (quote shen.skip)) (kl:fail))) (kl:fail))) (quote shen.<comma-symbol>))
(begin (register-function-arity (quote shen.<formula>) 1) (define (kl:shen.<formula> V2645) (let ((YaccParse (let ((Parse_shen.<expr> (kl:shen.<expr> V2645))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (if (and (pair? (car Parse_shen.<expr>)) (eq? (quote :) (car (car Parse_shen.<expr>)))) (let ((Parse_shen.<type> (kl:shen.<type> (kl:shen.pair (cdr (car Parse_shen.<expr>)) (kl:shen.hdtl Parse_shen.<expr>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<type>)) (kl:shen.pair (car Parse_shen.<type>) (cons (kl:shen.curry (kl:shen.hdtl Parse_shen.<expr>)) (cons (quote :) (cons (kl:shen.demodulate (kl:shen.hdtl Parse_shen.<type>)) (quote ()))))) (kl:fail))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<expr> (kl:shen.<expr> V2645))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (kl:shen.hdtl Parse_shen.<expr>)) (kl:fail))) YaccParse))) (quote shen.<formula>))
(begin (register-function-arity (quote shen.<type>) 1) (define (kl:shen.<type> V2647) (let ((Parse_shen.<expr> (kl:shen.<expr> V2647))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (kl:shen.curry-type (kl:shen.hdtl Parse_shen.<expr>))) (kl:fail)))) (quote shen.<type>))
(begin (register-function-arity (quote shen.<doubleunderline>) 1) (define (kl:shen.<doubleunderline> V2649) (if (pair? (car V2649)) (let ((Parse_X (car (car V2649)))) (if (assert-boolean (kl:shen.doubleunderline? Parse_X)) (kl:shen.pair (car (kl:shen.pair (cdr (car V2649)) (kl:shen.hdtl V2649))) Parse_X) (kl:fail))) (kl:fail))) (quote shen.<doubleunderline>))
(begin (register-function-arity (quote shen.<singleunderline>) 1) (define (kl:shen.<singleunderline> V2651) (if (pair? (car V2651)) (let ((Parse_X (car (car V2651)))) (if (assert-boolean (kl:shen.singleunderline? Parse_X)) (kl:shen.pair (car (kl:shen.pair (cdr (car V2651)) (kl:shen.hdtl V2651))) Parse_X) (kl:fail))) (kl:fail))) (quote shen.<singleunderline>))
(begin (register-function-arity (quote shen.singleunderline?) 1) (define (kl:shen.singleunderline? V2653) (and (kl:symbol? V2653) (assert-boolean (kl:shen.sh? (kl:str V2653))))) (quote shen.singleunderline?))
(begin (register-function-arity (quote shen.sh?) 1) (define (kl:shen.sh? V2655) (cond ((equal? "_" V2655) #t) (#t (and (equal? (make-string 1 (string-ref V2655 0)) "_") (assert-boolean (kl:shen.sh? (string-tail V2655 1))))))) (quote shen.sh?))
(begin (register-function-arity (quote shen.doubleunderline?) 1) (define (kl:shen.doubleunderline? V2657) (and (kl:symbol? V2657) (assert-boolean (kl:shen.dh? (kl:str V2657))))) (quote shen.doubleunderline?))
(begin (register-function-arity (quote shen.dh?) 1) (define (kl:shen.dh? V2659) (cond ((equal? "=" V2659) #t) (#t (and (equal? (make-string 1 (string-ref V2659 0)) "=") (assert-boolean (kl:shen.dh? (string-tail V2659 1))))))) (quote shen.dh?))
(begin (register-function-arity (quote shen.process-datatype) 2) (define (kl:shen.process-datatype V2662 V2663) (kl:shen.remember-datatype (kl:shen.s-prolog (kl:shen.rules->horn-clauses V2662 V2663)))) (quote shen.process-datatype))
(begin (register-function-arity (quote shen.remember-datatype) 1) (define (kl:shen.remember-datatype V2669) (cond ((pair? V2669) (begin (kl:set (quote shen.*datatypes*) (kl:adjoin (car V2669) (kl:value (quote shen.*datatypes*)))) (begin (kl:set (quote shen.*alldatatypes*) (kl:adjoin (car V2669) (kl:value (quote shen.*alldatatypes*)))) (car V2669)))) (#t (kl:shen.f_error (quote shen.remember-datatype))))) (quote shen.remember-datatype))
(begin (register-function-arity (quote shen.rules->horn-clauses) 2) (define (kl:shen.rules->horn-clauses V2674 V2675) (cond ((null? V2675) (quote ())) ((and (pair? V2675) (and (kl:tuple? (car V2675)) (eq? (quote shen.single) (kl:fst (car V2675))))) (cons (kl:shen.rule->horn-clause V2674 (kl:snd (car V2675))) (kl:shen.rules->horn-clauses V2674 (cdr V2675)))) ((and (pair? V2675) (and (kl:tuple? (car V2675)) (eq? (quote shen.double) (kl:fst (car V2675))))) (kl:shen.rules->horn-clauses V2674 (kl:append (kl:shen.double->singles (kl:snd (car V2675))) (cdr V2675)))) (#t (kl:shen.f_error (quote shen.rules->horn-clauses))))) (quote shen.rules->horn-clauses))
(begin (register-function-arity (quote shen.double->singles) 1) (define (kl:shen.double->singles V2677) (cons (kl:shen.right-rule V2677) (cons (kl:shen.left-rule V2677) (quote ())))) (quote shen.double->singles))
(begin (register-function-arity (quote shen.right-rule) 1) (define (kl:shen.right-rule V2679) (kl:_waspvm_at_p (quote shen.single) V2679)) (quote shen.right-rule))
(begin (register-function-arity (quote shen.left-rule) 1) (define (kl:shen.left-rule V2681) (cond ((and (pair? V2681) (and (pair? (cdr V2681)) (and (pair? (cdr (cdr V2681))) (and (kl:tuple? (car (cdr (cdr V2681)))) (and (null? (kl:fst (car (cdr (cdr V2681))))) (null? (cdr (cdr (cdr V2681))))))))) (let ((Q (kl:gensym (quote Qv)))) (let ((NewConclusion (kl:_waspvm_at_p (cons (kl:snd (car (cdr (cdr V2681)))) (quote ())) Q))) (let ((NewPremises (cons (kl:_waspvm_at_p (kl:map (lambda (X) (kl:shen.right->left X)) (car (cdr V2681))) Q) (quote ())))) (kl:_waspvm_at_p (quote shen.single) (cons (car V2681) (cons NewPremises (cons NewConclusion (quote ()))))))))) (#t (kl:shen.f_error (quote shen.left-rule))))) (quote shen.left-rule))
(begin (register-function-arity (quote shen.right->left) 1) (define (kl:shen.right->left V2687) (cond ((and (kl:tuple? V2687) (null? (kl:fst V2687))) (kl:snd V2687)) (#t (simple-error "syntax error with ==========\n")))) (quote shen.right->left))
(begin (register-function-arity (quote shen.rule->horn-clause) 2) (define (kl:shen.rule->horn-clause V2690 V2691) (cond ((and (pair? V2691) (and (pair? (cdr V2691)) (and (pair? (cdr (cdr V2691))) (and (kl:tuple? (car (cdr (cdr V2691)))) (null? (cdr (cdr (cdr V2691)))))))) (cons (kl:shen.rule->horn-clause-head V2690 (kl:snd (car (cdr (cdr V2691))))) (cons (quote :-) (cons (kl:shen.rule->horn-clause-body (car V2691) (car (cdr V2691)) (kl:fst (car (cdr (cdr V2691))))) (quote ()))))) (#t (kl:shen.f_error (quote shen.rule->horn-clause))))) (quote shen.rule->horn-clause))
(begin (register-function-arity (quote shen.rule->horn-clause-head) 2) (define (kl:shen.rule->horn-clause-head V2694 V2695) (cons V2694 (cons (kl:shen.mode-ify V2695) (cons (quote Context_1957) (quote ()))))) (quote shen.rule->horn-clause-head))
(begin (register-function-arity (quote shen.mode-ify) 1) (define (kl:shen.mode-ify V2697) (cond ((and (pair? V2697) (and (pair? (cdr V2697)) (and (eq? (quote :) (car (cdr V2697))) (and (pair? (cdr (cdr V2697))) (null? (cdr (cdr (cdr V2697)))))))) (cons (quote mode) (cons (cons (car V2697) (cons (quote :) (cons (cons (quote mode) (cons (car (cdr (cdr V2697))) (cons (quote +) (quote ())))) (quote ())))) (cons (quote -) (quote ()))))) (#t V2697))) (quote shen.mode-ify))
(begin (register-function-arity (quote shen.rule->horn-clause-body) 3) (define (kl:shen.rule->horn-clause-body V2701 V2702 V2703) (let ((Variables (kl:map (lambda (X) (kl:shen.extract_vars X)) V2703))) (let ((Predicates (kl:map (lambda (X) (kl:gensym (quote shen.cl))) V2703))) (let ((SearchLiterals (kl:shen.construct-search-literals Predicates Variables (quote Context_1957) (quote Context1_1957)))) (let ((SearchClauses (kl:shen.construct-search-clauses Predicates V2703 Variables))) (let ((SideLiterals (kl:shen.construct-side-literals V2701))) (let ((PremissLiterals (kl:map (lambda (X) (kl:shen.construct-premiss-literal X (kl:empty? V2703))) V2702))) (kl:append SearchLiterals (kl:append SideLiterals PremissLiterals))))))))) (quote shen.rule->horn-clause-body))
(begin (register-function-arity (quote shen.construct-search-literals) 4) (define (kl:shen.construct-search-literals V2712 V2713 V2714 V2715) (cond ((and (null? V2712) (null? V2713)) (quote ())) (#t (kl:shen.csl-help V2712 V2713 V2714 V2715)))) (quote shen.construct-search-literals))
(begin (register-function-arity (quote shen.csl-help) 4) (define (kl:shen.csl-help V2722 V2723 V2724 V2725) (cond ((and (null? V2722) (null? V2723)) (cons (cons (quote bind) (cons (quote ContextOut_1957) (cons V2724 (quote ())))) (quote ()))) ((and (pair? V2722) (pair? V2723)) (cons (cons (car V2722) (cons V2724 (cons V2725 (car V2723)))) (kl:shen.csl-help (cdr V2722) (cdr V2723) V2725 (kl:gensym (quote Context))))) (#t (kl:shen.f_error (quote shen.csl-help))))) (quote shen.csl-help))
(begin (register-function-arity (quote shen.construct-search-clauses) 3) (define (kl:shen.construct-search-clauses V2729 V2730 V2731) (cond ((and (null? V2729) (and (null? V2730) (null? V2731))) (quote shen.skip)) ((and (pair? V2729) (and (pair? V2730) (pair? V2731))) (begin (kl:shen.construct-search-clause (car V2729) (car V2730) (car V2731)) (kl:shen.construct-search-clauses (cdr V2729) (cdr V2730) (cdr V2731)))) (#t (kl:shen.f_error (quote shen.construct-search-clauses))))) (quote shen.construct-search-clauses))
(begin (register-function-arity (quote shen.construct-search-clause) 3) (define (kl:shen.construct-search-clause V2735 V2736 V2737) (kl:shen.s-prolog (cons (kl:shen.construct-base-search-clause V2735 V2736 V2737) (cons (kl:shen.construct-recursive-search-clause V2735 V2736 V2737) (quote ()))))) (quote shen.construct-search-clause))
(begin (register-function-arity (quote shen.construct-base-search-clause) 3) (define (kl:shen.construct-base-search-clause V2741 V2742 V2743) (cons (cons V2741 (cons (cons (kl:shen.mode-ify V2742) (quote In_1957)) (cons (quote In_1957) V2743))) (cons (quote :-) (cons (quote ()) (quote ()))))) (quote shen.construct-base-search-clause))
(begin (register-function-arity (quote shen.construct-recursive-search-clause) 3) (define (kl:shen.construct-recursive-search-clause V2747 V2748 V2749) (cons (cons V2747 (cons (cons (quote Assumption_1957) (quote Assumptions_1957)) (cons (cons (quote Assumption_1957) (quote Out_1957)) V2749))) (cons (quote :-) (cons (cons (cons V2747 (cons (quote Assumptions_1957) (cons (quote Out_1957) V2749))) (quote ())) (quote ()))))) (quote shen.construct-recursive-search-clause))
(begin (register-function-arity (quote shen.construct-side-literals) 1) (define (kl:shen.construct-side-literals V2755) (cond ((null? V2755) (quote ())) ((and (pair? V2755) (and (pair? (car V2755)) (and (eq? (quote if) (car (car V2755))) (and (pair? (cdr (car V2755))) (null? (cdr (cdr (car V2755)))))))) (cons (cons (quote when) (cdr (car V2755))) (kl:shen.construct-side-literals (cdr V2755)))) ((and (pair? V2755) (and (pair? (car V2755)) (and (eq? (quote let) (car (car V2755))) (and (pair? (cdr (car V2755))) (and (pair? (cdr (cdr (car V2755)))) (null? (cdr (cdr (cdr (car V2755)))))))))) (cons (cons (quote is) (cdr (car V2755))) (kl:shen.construct-side-literals (cdr V2755)))) ((pair? V2755) (kl:shen.construct-side-literals (cdr V2755))) (#t (kl:shen.f_error (quote shen.construct-side-literals))))) (quote shen.construct-side-literals))
(begin (register-function-arity (quote shen.construct-premiss-literal) 2) (define (kl:shen.construct-premiss-literal V2762 V2763) (cond ((kl:tuple? V2762) (cons (quote shen.t*) (cons (kl:shen.recursive_cons_form (kl:snd V2762)) (cons (kl:shen.construct-context V2763 (kl:fst V2762)) (quote ()))))) ((eq? (quote !) V2762) (cons (quote cut) (cons (quote Throwcontrol) (quote ())))) (#t (kl:shen.f_error (quote shen.construct-premiss-literal))))) (quote shen.construct-premiss-literal))
(begin (register-function-arity (quote shen.construct-context) 2) (define (kl:shen.construct-context V2766 V2767) (cond ((and (kl:= #t V2766) (null? V2767)) (quote Context_1957)) ((and (kl:= #f V2766) (null? V2767)) (quote ContextOut_1957)) ((pair? V2767) (cons (quote cons) (cons (kl:shen.recursive_cons_form (car V2767)) (cons (kl:shen.construct-context V2766 (cdr V2767)) (quote ()))))) (#t (kl:shen.f_error (quote shen.construct-context))))) (quote shen.construct-context))
(begin (register-function-arity (quote shen.recursive_cons_form) 1) (define (kl:shen.recursive_cons_form V2769) (cond ((pair? V2769) (cons (quote cons) (cons (kl:shen.recursive_cons_form (car V2769)) (cons (kl:shen.recursive_cons_form (cdr V2769)) (quote ()))))) (#t V2769))) (quote shen.recursive_cons_form))
(begin (register-function-arity (quote preclude) 1) (define (kl:preclude V2771) (kl:shen.preclude-h (kl:map (lambda (X) (kl:shen.intern-type X)) V2771))) (quote preclude))
(begin (register-function-arity (quote shen.preclude-h) 1) (define (kl:shen.preclude-h V2773) (let ((FilterDatatypes (kl:set (quote shen.*datatypes*) (kl:difference (kl:value (quote shen.*datatypes*)) V2773)))) (kl:value (quote shen.*datatypes*)))) (quote shen.preclude-h))
(begin (register-function-arity (quote include) 1) (define (kl:include V2775) (kl:shen.include-h (kl:map (lambda (X) (kl:shen.intern-type X)) V2775))) (quote include))
(begin (register-function-arity (quote shen.include-h) 1) (define (kl:shen.include-h V2777) (let ((ValidTypes (kl:intersection V2777 (kl:value (quote shen.*alldatatypes*))))) (let ((NewDatatypes (kl:set (quote shen.*datatypes*) (kl:union ValidTypes (kl:value (quote shen.*datatypes*)))))) (kl:value (quote shen.*datatypes*))))) (quote shen.include-h))
(begin (register-function-arity (quote preclude-all-but) 1) (define (kl:preclude-all-but V2779) (kl:shen.preclude-h (kl:difference (kl:value (quote shen.*alldatatypes*)) (kl:map (lambda (X) (kl:shen.intern-type X)) V2779)))) (quote preclude-all-but))
(begin (register-function-arity (quote include-all-but) 1) (define (kl:include-all-but V2781) (kl:shen.include-h (kl:difference (kl:value (quote shen.*alldatatypes*)) (kl:map (lambda (X) (kl:shen.intern-type X)) V2781)))) (quote include-all-but))
(begin (register-function-arity (quote shen.synonyms-help) 1) (define (kl:shen.synonyms-help V2787) (cond ((null? V2787) (kl:shen.update-demodulation-function (kl:value (quote shen.*tc*)) (kl:mapcan (lambda (X) (kl:shen.demod-rule X)) (kl:value (quote shen.*synonyms*))))) ((and (pair? V2787) (pair? (cdr V2787))) (let ((Vs (kl:difference (kl:shen.extract_vars (car (cdr V2787))) (kl:shen.extract_vars (car V2787))))) (if (kl:empty? Vs) (begin (kl:shen.pushnew (cons (car V2787) (cons (car (cdr V2787)) (quote ()))) (quote shen.*synonyms*)) (kl:shen.synonyms-help (cdr (cdr V2787)))) (kl:shen.free_variable_warnings (car (cdr V2787)) Vs)))) (#t (simple-error "odd number of synonyms\n")))) (quote shen.synonyms-help))
(begin (register-function-arity (quote shen.pushnew) 2) (define (kl:shen.pushnew V2790 V2791) (if (kl:element? V2790 (kl:value V2791)) (kl:value V2791) (kl:set V2791 (cons V2790 (kl:value V2791))))) (quote shen.pushnew))
(begin (register-function-arity (quote shen.demod-rule) 1) (define (kl:shen.demod-rule V2793) (cond ((and (pair? V2793) (and (pair? (cdr V2793)) (null? (cdr (cdr V2793))))) (cons (kl:shen.rcons_form (car V2793)) (cons (quote ->) (cons (kl:shen.rcons_form (car (cdr V2793))) (quote ()))))) (#t (kl:shen.f_error (quote shen.demod-rule))))) (quote shen.demod-rule))
(begin (register-function-arity (quote shen.lambda-of-defun) 1) (define (kl:shen.lambda-of-defun V2799) (cond ((and (pair? V2799) (and (eq? (quote defun) (car V2799)) (and (pair? (cdr V2799)) (and (pair? (cdr (cdr V2799))) (and (pair? (car (cdr (cdr V2799)))) (and (null? (cdr (car (cdr (cdr V2799))))) (and (pair? (cdr (cdr (cdr V2799)))) (null? (cdr (cdr (cdr (cdr V2799)))))))))))) (kl:eval (cons (quote /.) (cons (car (car (cdr (cdr V2799)))) (cdr (cdr (cdr V2799))))))) (#t (kl:shen.f_error (quote shen.lambda-of-defun))))) (quote shen.lambda-of-defun))
(begin (register-function-arity (quote shen.update-demodulation-function) 2) (define (kl:shen.update-demodulation-function V2802 V2803) (begin (kl:tc (quote -)) (begin (kl:set (quote shen.*demodulation-function*) (kl:shen.lambda-of-defun (kl:shen.elim-def (cons (quote define) (cons (quote shen.demod) (kl:append V2803 (kl:shen.default-rule))))))) (begin (if (assert-boolean V2802) (kl:tc (quote +)) (quote shen.skip)) (quote synonyms))))) (quote shen.update-demodulation-function))
(begin (register-function-arity (quote shen.default-rule) 0) (define (kl:shen.default-rule) (cons (quote X) (cons (quote ->) (cons (quote X) (quote ()))))) (quote shen.default-rule))
