(module "compiled/reader.kl")
"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.read-char-code) 1) (define (kl:shen.read-char-code V2227) (read-u8 V2227)) (export shen.read-char-code) (quote shen.read-char-code))
(begin (register-function-arity (quote read-file-as-bytelist) 1) (define (kl:read-file-as-bytelist V2229) (kl:shen.read-file-as-Xlist V2229 (lambda (S) (read-u8 S)))) (export read-file-as-bytelist) (quote read-file-as-bytelist))
(begin (register-function-arity (quote shen.read-file-as-charlist) 1) (define (kl:shen.read-file-as-charlist V2231) (kl:shen.read-file-as-Xlist V2231 (lambda (S) (kl:shen.read-char-code S)))) (export shen.read-file-as-charlist) (quote shen.read-file-as-charlist))
(begin (register-function-arity (quote shen.read-file-as-Xlist) 2) (define (kl:shen.read-file-as-Xlist V2234 V2235) (let ((Stream (kl:open V2234 (quote in)))) (let ((X (V2235 Stream))) (let ((Xs (kl:shen.read-file-as-Xlist-help Stream V2235 X (quote ())))) (let ((Close (kl:close Stream))) (kl:reverse Xs)))))) (export shen.read-file-as-Xlist) (quote shen.read-file-as-Xlist))
(begin (register-function-arity (quote shen.read-file-as-Xlist-help) 4) (define (kl:shen.read-file-as-Xlist-help V2240 V2241 V2242 V2243) (cond ((kl:= -1 V2242) V2243) (#t (kl:shen.read-file-as-Xlist-help V2240 V2241 (V2241 V2240) (cons V2242 V2243))))) (export shen.read-file-as-Xlist-help) (quote shen.read-file-as-Xlist-help))
(begin (register-function-arity (quote read-file-as-string) 1) (define (kl:read-file-as-string V2245) (let ((Stream (kl:open V2245 (quote in)))) (kl:shen.rfas-h Stream (kl:shen.read-char-code Stream) ""))) (export read-file-as-string) (quote read-file-as-string))
(begin (register-function-arity (quote shen.rfas-h) 3) (define (kl:shen.rfas-h V2249 V2250 V2251) (cond ((kl:= -1 V2250) (begin (kl:close V2249) V2251)) (#t (kl:shen.rfas-h V2249 (kl:shen.read-char-code V2249) (string-append V2251 (make-string 1 V2250)))))) (export shen.rfas-h) (quote shen.rfas-h))
(begin (register-function-arity (quote input) 1) (define (kl:input V2253) (kl:eval-kl (kl:read V2253))) (export input) (quote input))
(begin (register-function-arity (quote input+) 2) (define (kl:input+ V2256 V2257) (let ((Mono? (kl:shen.monotype V2256))) (let ((Input (kl:read V2257))) (if (kl:= #f (kl:shen.typecheck Input (kl:shen.demodulate V2256))) (simple-error (string-append "type error: " (kl:shen.app Input (string-append " is not of type " (kl:shen.app V2256 "\n" (quote shen.r))) (quote shen.r)))) (kl:eval-kl Input))))) (export input+) (quote input+))
(begin (register-function-arity (quote shen.monotype) 1) (define (kl:shen.monotype V2259) (cond ((pair? V2259) (kl:map (lambda (Z) (kl:shen.monotype Z)) V2259)) (#t (if (kl:variable? V2259) (simple-error (string-append "input+ expects a monotype: not " (kl:shen.app V2259 "\n" (quote shen.a)))) V2259)))) (export shen.monotype) (quote shen.monotype))
(begin (register-function-arity (quote read) 1) (define (kl:read V2261) (car (kl:shen.read-loop V2261 (kl:shen.read-char-code V2261) (quote ())))) (export read) (quote read))
(begin (register-function-arity (quote it) 0) (define (kl:it) (kl:value (quote shen.*it*))) (export it) (quote it))
(begin (register-function-arity (quote shen.read-loop) 3) (define (kl:shen.read-loop V2269 V2270 V2271) (cond ((kl:= 94 V2270) (simple-error "read aborted")) ((kl:= -1 V2270) (if (kl:empty? V2271) (simple-error "error: empty stream") (kl:compile (lambda (X) (kl:shen.<st_input> X)) V2271 (lambda (E) E)))) ((assert-boolean (kl:shen.terminator? V2270)) (let ((AllChars (kl:append V2271 (cons V2270 (quote ()))))) (let ((It (kl:shen.record-it AllChars))) (let ((Read (kl:compile (lambda (X) (kl:shen.<st_input> X)) AllChars (lambda (E) (quote shen.nextbyte))))) (if (or (eq? Read (quote shen.nextbyte)) (kl:empty? Read)) (kl:shen.read-loop V2269 (kl:shen.read-char-code V2269) AllChars) Read))))) (#t (kl:shen.read-loop V2269 (kl:shen.read-char-code V2269) (kl:append V2271 (cons V2270 (quote ()))))))) (export shen.read-loop) (quote shen.read-loop))
(begin (register-function-arity (quote shen.terminator?) 1) (define (kl:shen.terminator? V2273) (kl:element? V2273 (cons 9 (cons 10 (cons 13 (cons 32 (cons 34 (cons 41 (cons 93 (quote ())))))))))) (export shen.terminator?) (quote shen.terminator?))
(begin (register-function-arity (quote lineread) 1) (define (kl:lineread V2275) (kl:shen.lineread-loop (kl:shen.read-char-code V2275) (quote ()) V2275)) (export lineread) (quote lineread))
(begin (register-function-arity (quote shen.lineread-loop) 3) (define (kl:shen.lineread-loop V2280 V2281 V2282) (cond ((kl:= -1 V2280) (if (kl:empty? V2281) (simple-error "empty stream") (kl:compile (lambda (X) (kl:shen.<st_input> X)) V2281 (lambda (E) E)))) ((kl:= V2280 (kl:shen.hat)) (simple-error "line read aborted")) ((kl:element? V2280 (cons (kl:shen.newline) (cons (kl:shen.carriage-return) (quote ())))) (let ((Line (kl:compile (lambda (X) (kl:shen.<st_input> X)) V2281 (lambda (E) (quote shen.nextline))))) (let ((It (kl:shen.record-it V2281))) (if (or (eq? Line (quote shen.nextline)) (kl:empty? Line)) (kl:shen.lineread-loop (kl:shen.read-char-code V2282) (kl:append V2281 (cons V2280 (quote ()))) V2282) Line)))) (#t (kl:shen.lineread-loop (kl:shen.read-char-code V2282) (kl:append V2281 (cons V2280 (quote ()))) V2282)))) (export shen.lineread-loop) (quote shen.lineread-loop))
(begin (register-function-arity (quote shen.record-it) 1) (define (kl:shen.record-it V2284) (let ((TrimLeft (kl:shen.trim-whitespace V2284))) (let ((TrimRight (kl:shen.trim-whitespace (kl:reverse TrimLeft)))) (let ((Trimmed (kl:reverse TrimRight))) (kl:shen.record-it-h Trimmed))))) (export shen.record-it) (quote shen.record-it))
(begin (register-function-arity (quote shen.trim-whitespace) 1) (define (kl:shen.trim-whitespace V2286) (cond ((and (pair? V2286) (kl:element? (car V2286) (cons 9 (cons 10 (cons 13 (cons 32 (quote ()))))))) (kl:shen.trim-whitespace (cdr V2286))) (#t V2286))) (export shen.trim-whitespace) (quote shen.trim-whitespace))
(begin (register-function-arity (quote shen.record-it-h) 1) (define (kl:shen.record-it-h V2288) (begin (kl:set (quote shen.*it*) (kl:shen.cn-all (kl:map (lambda (X) (make-string 1 X)) V2288))) V2288)) (export shen.record-it-h) (quote shen.record-it-h))
(begin (register-function-arity (quote shen.cn-all) 1) (define (kl:shen.cn-all V2290) (cond ((null? V2290) "") ((pair? V2290) (string-append (car V2290) (kl:shen.cn-all (cdr V2290)))) (#t (kl:shen.f_error (quote shen.cn-all))))) (export shen.cn-all) (quote shen.cn-all))
(begin (register-function-arity (quote read-file) 1) (define (kl:read-file V2292) (let ((Charlist (kl:shen.read-file-as-charlist V2292))) (kl:compile (lambda (X) (kl:shen.<st_input> X)) Charlist (lambda (X) (kl:shen.read-error X))))) (export read-file) (quote read-file))
(begin (register-function-arity (quote read-from-string) 1) (define (kl:read-from-string V2294) (let ((Ns (kl:map (lambda (X) (string-ref X 0)) (kl:explode V2294)))) (kl:compile (lambda (X) (kl:shen.<st_input> X)) Ns (lambda (X) (kl:shen.read-error X))))) (export read-from-string) (quote read-from-string))
(begin (register-function-arity (quote shen.read-error) 1) (define (kl:shen.read-error V2302) (cond ((and (pair? V2302) (and (pair? (car V2302)) (and (pair? (cdr V2302)) (null? (cdr (cdr V2302)))))) (simple-error (string-append "read error here:\n\n " (kl:shen.app (kl:shen.compress-50 50 (car V2302)) "\n" (quote shen.a))))) (#t (simple-error "read error\n")))) (export shen.read-error) (quote shen.read-error))
(begin (register-function-arity (quote shen.compress-50) 2) (define (kl:shen.compress-50 V2309 V2310) (cond ((null? V2310) "") ((kl:= 0 V2309) "") ((pair? V2310) (string-append (make-string 1 (car V2310)) (kl:shen.compress-50 (- V2309 1) (cdr V2310)))) (#t (kl:shen.f_error (quote shen.compress-50))))) (export shen.compress-50) (quote shen.compress-50))
(begin (register-function-arity (quote shen.<st_input>) 1) (define (kl:shen.<st_input> V2312) (let ((YaccParse (let ((Parse_shen.<lsb> (kl:shen.<lsb> V2312))) (if (kl:not (kl:= (kl:fail) Parse_shen.<lsb>)) (let ((Parse_shen.<st_input1> (kl:shen.<st_input1> Parse_shen.<lsb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input1>)) (let ((Parse_shen.<rsb> (kl:shen.<rsb> Parse_shen.<st_input1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rsb>)) (let ((Parse_shen.<st_input2> (kl:shen.<st_input2> Parse_shen.<rsb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input2>)) (kl:shen.pair (car Parse_shen.<st_input2>) (cons (kl:macroexpand (kl:shen.cons_form (kl:shen.hdtl Parse_shen.<st_input1>))) (kl:shen.hdtl Parse_shen.<st_input2>))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<lrb> (kl:shen.<lrb> V2312))) (if (kl:not (kl:= (kl:fail) Parse_shen.<lrb>)) (let ((Parse_shen.<st_input1> (kl:shen.<st_input1> Parse_shen.<lrb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input1>)) (let ((Parse_shen.<rrb> (kl:shen.<rrb> Parse_shen.<st_input1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rrb>)) (let ((Parse_shen.<st_input2> (kl:shen.<st_input2> Parse_shen.<rrb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input2>)) (kl:shen.pair (car Parse_shen.<st_input2>) (kl:shen.package-macro (kl:macroexpand (kl:shen.hdtl Parse_shen.<st_input1>)) (kl:shen.hdtl Parse_shen.<st_input2>))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<lcurly> (kl:shen.<lcurly> V2312))) (if (kl:not (kl:= (kl:fail) Parse_shen.<lcurly>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<lcurly>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote {) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<rcurly> (kl:shen.<rcurly> V2312))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rcurly>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<rcurly>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote }) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<bar> (kl:shen.<bar> V2312))) (if (kl:not (kl:= (kl:fail) Parse_shen.<bar>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<bar>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote bar!) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<semicolon> (kl:shen.<semicolon> V2312))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<semicolon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote _waspvm_sc_) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<colon> (kl:shen.<colon> V2312))) (if (kl:not (kl:= (kl:fail) Parse_shen.<colon>)) (let ((Parse_shen.<equal> (kl:shen.<equal> Parse_shen.<colon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<equal>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<equal>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote :=) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<colon> (kl:shen.<colon> V2312))) (if (kl:not (kl:= (kl:fail) Parse_shen.<colon>)) (let ((Parse_shen.<minus> (kl:shen.<minus> Parse_shen.<colon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<minus>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<minus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote :-) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<colon> (kl:shen.<colon> V2312))) (if (kl:not (kl:= (kl:fail) Parse_shen.<colon>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<colon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote :) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<comma> (kl:shen.<comma> V2312))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comma>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<comma>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (kl:intern ",") (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<comment> (kl:shen.<comment> V2312))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comment>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<comment>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<atom> (kl:shen.<atom> V2312))) (if (kl:not (kl:= (kl:fail) Parse_shen.<atom>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<atom>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (kl:macroexpand (kl:shen.hdtl Parse_shen.<atom>)) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<whitespaces> (kl:shen.<whitespaces> V2312))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespaces>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<whitespaces>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2312))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse))) (export shen.<st_input>) (quote shen.<st_input>))
(begin (register-function-arity (quote shen.<lsb>) 1) (define (kl:shen.<lsb> V2315) (if (and (pair? (car V2315)) (kl:= 91 (kl:shen.hdhd V2315))) (let ((NewStream2313 (kl:shen.pair (kl:shen.tlhd V2315) (kl:shen.hdtl V2315)))) (kl:shen.pair (car NewStream2313) (quote shen.skip))) (kl:fail))) (export shen.<lsb>) (quote shen.<lsb>))
(begin (register-function-arity (quote shen.<rsb>) 1) (define (kl:shen.<rsb> V2318) (if (and (pair? (car V2318)) (kl:= 93 (kl:shen.hdhd V2318))) (let ((NewStream2316 (kl:shen.pair (kl:shen.tlhd V2318) (kl:shen.hdtl V2318)))) (kl:shen.pair (car NewStream2316) (quote shen.skip))) (kl:fail))) (export shen.<rsb>) (quote shen.<rsb>))
(begin (register-function-arity (quote shen.<lcurly>) 1) (define (kl:shen.<lcurly> V2321) (if (and (pair? (car V2321)) (kl:= 123 (kl:shen.hdhd V2321))) (let ((NewStream2319 (kl:shen.pair (kl:shen.tlhd V2321) (kl:shen.hdtl V2321)))) (kl:shen.pair (car NewStream2319) (quote shen.skip))) (kl:fail))) (export shen.<lcurly>) (quote shen.<lcurly>))
(begin (register-function-arity (quote shen.<rcurly>) 1) (define (kl:shen.<rcurly> V2324) (if (and (pair? (car V2324)) (kl:= 125 (kl:shen.hdhd V2324))) (let ((NewStream2322 (kl:shen.pair (kl:shen.tlhd V2324) (kl:shen.hdtl V2324)))) (kl:shen.pair (car NewStream2322) (quote shen.skip))) (kl:fail))) (export shen.<rcurly>) (quote shen.<rcurly>))
(begin (register-function-arity (quote shen.<bar>) 1) (define (kl:shen.<bar> V2327) (if (and (pair? (car V2327)) (kl:= 124 (kl:shen.hdhd V2327))) (let ((NewStream2325 (kl:shen.pair (kl:shen.tlhd V2327) (kl:shen.hdtl V2327)))) (kl:shen.pair (car NewStream2325) (quote shen.skip))) (kl:fail))) (export shen.<bar>) (quote shen.<bar>))
(begin (register-function-arity (quote shen.<semicolon>) 1) (define (kl:shen.<semicolon> V2330) (if (and (pair? (car V2330)) (kl:= 59 (kl:shen.hdhd V2330))) (let ((NewStream2328 (kl:shen.pair (kl:shen.tlhd V2330) (kl:shen.hdtl V2330)))) (kl:shen.pair (car NewStream2328) (quote shen.skip))) (kl:fail))) (export shen.<semicolon>) (quote shen.<semicolon>))
(begin (register-function-arity (quote shen.<colon>) 1) (define (kl:shen.<colon> V2333) (if (and (pair? (car V2333)) (kl:= 58 (kl:shen.hdhd V2333))) (let ((NewStream2331 (kl:shen.pair (kl:shen.tlhd V2333) (kl:shen.hdtl V2333)))) (kl:shen.pair (car NewStream2331) (quote shen.skip))) (kl:fail))) (export shen.<colon>) (quote shen.<colon>))
(begin (register-function-arity (quote shen.<comma>) 1) (define (kl:shen.<comma> V2336) (if (and (pair? (car V2336)) (kl:= 44 (kl:shen.hdhd V2336))) (let ((NewStream2334 (kl:shen.pair (kl:shen.tlhd V2336) (kl:shen.hdtl V2336)))) (kl:shen.pair (car NewStream2334) (quote shen.skip))) (kl:fail))) (export shen.<comma>) (quote shen.<comma>))
(begin (register-function-arity (quote shen.<equal>) 1) (define (kl:shen.<equal> V2339) (if (and (pair? (car V2339)) (kl:= 61 (kl:shen.hdhd V2339))) (let ((NewStream2337 (kl:shen.pair (kl:shen.tlhd V2339) (kl:shen.hdtl V2339)))) (kl:shen.pair (car NewStream2337) (quote shen.skip))) (kl:fail))) (export shen.<equal>) (quote shen.<equal>))
(begin (register-function-arity (quote shen.<minus>) 1) (define (kl:shen.<minus> V2342) (if (and (pair? (car V2342)) (kl:= 45 (kl:shen.hdhd V2342))) (let ((NewStream2340 (kl:shen.pair (kl:shen.tlhd V2342) (kl:shen.hdtl V2342)))) (kl:shen.pair (car NewStream2340) (quote shen.skip))) (kl:fail))) (export shen.<minus>) (quote shen.<minus>))
(begin (register-function-arity (quote shen.<lrb>) 1) (define (kl:shen.<lrb> V2345) (if (and (pair? (car V2345)) (kl:= 40 (kl:shen.hdhd V2345))) (let ((NewStream2343 (kl:shen.pair (kl:shen.tlhd V2345) (kl:shen.hdtl V2345)))) (kl:shen.pair (car NewStream2343) (quote shen.skip))) (kl:fail))) (export shen.<lrb>) (quote shen.<lrb>))
(begin (register-function-arity (quote shen.<rrb>) 1) (define (kl:shen.<rrb> V2348) (if (and (pair? (car V2348)) (kl:= 41 (kl:shen.hdhd V2348))) (let ((NewStream2346 (kl:shen.pair (kl:shen.tlhd V2348) (kl:shen.hdtl V2348)))) (kl:shen.pair (car NewStream2346) (quote shen.skip))) (kl:fail))) (export shen.<rrb>) (quote shen.<rrb>))
(begin (register-function-arity (quote shen.<atom>) 1) (define (kl:shen.<atom> V2350) (let ((YaccParse (let ((Parse_shen.<str> (kl:shen.<str> V2350))) (if (kl:not (kl:= (kl:fail) Parse_shen.<str>)) (kl:shen.pair (car Parse_shen.<str>) (kl:shen.control-chars (kl:shen.hdtl Parse_shen.<str>))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<number> (kl:shen.<number> V2350))) (if (kl:not (kl:= (kl:fail) Parse_shen.<number>)) (kl:shen.pair (car Parse_shen.<number>) (kl:shen.hdtl Parse_shen.<number>)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<sym> (kl:shen.<sym> V2350))) (if (kl:not (kl:= (kl:fail) Parse_shen.<sym>)) (kl:shen.pair (car Parse_shen.<sym>) (if (equal? (kl:shen.hdtl Parse_shen.<sym>) "<>") (cons (quote vector) (cons 0 (quote ()))) (kl:intern (kl:shen.hdtl Parse_shen.<sym>)))) (kl:fail))) YaccParse)) YaccParse))) (export shen.<atom>) (quote shen.<atom>))
(begin (register-function-arity (quote shen.control-chars) 1) (define (kl:shen.control-chars V2352) (cond ((null? V2352) "") ((and (pair? V2352) (and (equal? "c" (car V2352)) (and (pair? (cdr V2352)) (equal? "#" (car (cdr V2352)))))) (let ((CodePoint (kl:shen.code-point (cdr (cdr V2352))))) (let ((AfterCodePoint (kl:shen.after-codepoint (cdr (cdr V2352))))) (kl:_waspvm_at_s (make-string 1 (kl:shen.decimalise CodePoint)) (kl:shen.control-chars AfterCodePoint))))) ((pair? V2352) (kl:_waspvm_at_s (car V2352) (kl:shen.control-chars (cdr V2352)))) (#t (kl:shen.f_error (quote shen.control-chars))))) (export shen.control-chars) (quote shen.control-chars))
(begin (register-function-arity (quote shen.code-point) 1) (define (kl:shen.code-point V2356) (cond ((and (pair? V2356) (equal? ";" (car V2356))) "") ((and (pair? V2356) (kl:element? (car V2356) (cons "0" (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" (quote ())))))))))))))) (cons (car V2356) (kl:shen.code-point (cdr V2356)))) (#t (simple-error (string-append "code point parse error " (kl:shen.app V2356 "\n" (quote shen.a))))))) (export shen.code-point) (quote shen.code-point))
(begin (register-function-arity (quote shen.after-codepoint) 1) (define (kl:shen.after-codepoint V2362) (cond ((null? V2362) (quote ())) ((and (pair? V2362) (equal? ";" (car V2362))) (cdr V2362)) ((pair? V2362) (kl:shen.after-codepoint (cdr V2362))) (#t (kl:shen.f_error (quote shen.after-codepoint))))) (export shen.after-codepoint) (quote shen.after-codepoint))
(begin (register-function-arity (quote shen.decimalise) 1) (define (kl:shen.decimalise V2364) (kl:shen.pre (kl:reverse (kl:shen.digits->integers V2364)) 0)) (export shen.decimalise) (quote shen.decimalise))
(begin (register-function-arity (quote shen.digits->integers) 1) (define (kl:shen.digits->integers V2370) (cond ((and (pair? V2370) (equal? "0" (car V2370))) (cons 0 (kl:shen.digits->integers (cdr V2370)))) ((and (pair? V2370) (equal? "1" (car V2370))) (cons 1 (kl:shen.digits->integers (cdr V2370)))) ((and (pair? V2370) (equal? "2" (car V2370))) (cons 2 (kl:shen.digits->integers (cdr V2370)))) ((and (pair? V2370) (equal? "3" (car V2370))) (cons 3 (kl:shen.digits->integers (cdr V2370)))) ((and (pair? V2370) (equal? "4" (car V2370))) (cons 4 (kl:shen.digits->integers (cdr V2370)))) ((and (pair? V2370) (equal? "5" (car V2370))) (cons 5 (kl:shen.digits->integers (cdr V2370)))) ((and (pair? V2370) (equal? "6" (car V2370))) (cons 6 (kl:shen.digits->integers (cdr V2370)))) ((and (pair? V2370) (equal? "7" (car V2370))) (cons 7 (kl:shen.digits->integers (cdr V2370)))) ((and (pair? V2370) (equal? "8" (car V2370))) (cons 8 (kl:shen.digits->integers (cdr V2370)))) ((and (pair? V2370) (equal? "9" (car V2370))) (cons 9 (kl:shen.digits->integers (cdr V2370)))) (#t (quote ())))) (export shen.digits->integers) (quote shen.digits->integers))
(begin (register-function-arity (quote shen.<sym>) 1) (define (kl:shen.<sym> V2372) (let ((Parse_shen.<alpha> (kl:shen.<alpha> V2372))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alpha>)) (let ((Parse_shen.<alphanums> (kl:shen.<alphanums> Parse_shen.<alpha>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alphanums>)) (kl:shen.pair (car Parse_shen.<alphanums>) (kl:_waspvm_at_s (kl:shen.hdtl Parse_shen.<alpha>) (kl:shen.hdtl Parse_shen.<alphanums>))) (kl:fail))) (kl:fail)))) (export shen.<sym>) (quote shen.<sym>))
(begin (register-function-arity (quote shen.<alphanums>) 1) (define (kl:shen.<alphanums> V2374) (let ((YaccParse (let ((Parse_shen.<alphanum> (kl:shen.<alphanum> V2374))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alphanum>)) (let ((Parse_shen.<alphanums> (kl:shen.<alphanums> Parse_shen.<alphanum>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alphanums>)) (kl:shen.pair (car Parse_shen.<alphanums>) (kl:_waspvm_at_s (kl:shen.hdtl Parse_shen.<alphanum>) (kl:shen.hdtl Parse_shen.<alphanums>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2374))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) "") (kl:fail))) YaccParse))) (export shen.<alphanums>) (quote shen.<alphanums>))
(begin (register-function-arity (quote shen.<alphanum>) 1) (define (kl:shen.<alphanum> V2376) (let ((YaccParse (let ((Parse_shen.<alpha> (kl:shen.<alpha> V2376))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alpha>)) (kl:shen.pair (car Parse_shen.<alpha>) (kl:shen.hdtl Parse_shen.<alpha>)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<num> (kl:shen.<num> V2376))) (if (kl:not (kl:= (kl:fail) Parse_shen.<num>)) (kl:shen.pair (car Parse_shen.<num>) (kl:shen.hdtl Parse_shen.<num>)) (kl:fail))) YaccParse))) (export shen.<alphanum>) (quote shen.<alphanum>))
(begin (register-function-arity (quote shen.<num>) 1) (define (kl:shen.<num> V2378) (if (pair? (car V2378)) (let ((Parse_Char (kl:shen.hdhd V2378))) (if (assert-boolean (kl:shen.numbyte? Parse_Char)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2378) (kl:shen.hdtl V2378))) (make-string 1 Parse_Char)) (kl:fail))) (kl:fail))) (export shen.<num>) (quote shen.<num>))
(begin (register-function-arity (quote shen.numbyte?) 1) (define (kl:shen.numbyte? V2384) (cond ((kl:= 48 V2384) #t) ((kl:= 49 V2384) #t) ((kl:= 50 V2384) #t) ((kl:= 51 V2384) #t) ((kl:= 52 V2384) #t) ((kl:= 53 V2384) #t) ((kl:= 54 V2384) #t) ((kl:= 55 V2384) #t) ((kl:= 56 V2384) #t) ((kl:= 57 V2384) #t) (#t #f))) (export shen.numbyte?) (quote shen.numbyte?))
(begin (register-function-arity (quote shen.<alpha>) 1) (define (kl:shen.<alpha> V2386) (if (pair? (car V2386)) (let ((Parse_Char (kl:shen.hdhd V2386))) (if (assert-boolean (kl:shen.symbol-code? Parse_Char)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2386) (kl:shen.hdtl V2386))) (make-string 1 Parse_Char)) (kl:fail))) (kl:fail))) (export shen.<alpha>) (quote shen.<alpha>))
(begin (register-function-arity (quote shen.symbol-code?) 1) (define (kl:shen.symbol-code? V2388) (or (kl:= V2388 126) (or (and (> V2388 94) (< V2388 123)) (or (and (> V2388 59) (< V2388 91)) (or (and (> V2388 41) (and (< V2388 58) (kl:not (kl:= V2388 44)))) (or (and (> V2388 34) (< V2388 40)) (kl:= V2388 33))))))) (export shen.symbol-code?) (quote shen.symbol-code?))
(begin (register-function-arity (quote shen.<str>) 1) (define (kl:shen.<str> V2390) (let ((Parse_shen.<dbq> (kl:shen.<dbq> V2390))) (if (kl:not (kl:= (kl:fail) Parse_shen.<dbq>)) (let ((Parse_shen.<strcontents> (kl:shen.<strcontents> Parse_shen.<dbq>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<strcontents>)) (let ((Parse_shen.<dbq> (kl:shen.<dbq> Parse_shen.<strcontents>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<dbq>)) (kl:shen.pair (car Parse_shen.<dbq>) (kl:shen.hdtl Parse_shen.<strcontents>)) (kl:fail))) (kl:fail))) (kl:fail)))) (export shen.<str>) (quote shen.<str>))
(begin (register-function-arity (quote shen.<dbq>) 1) (define (kl:shen.<dbq> V2392) (if (pair? (car V2392)) (let ((Parse_Char (kl:shen.hdhd V2392))) (if (kl:= Parse_Char 34) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2392) (kl:shen.hdtl V2392))) Parse_Char) (kl:fail))) (kl:fail))) (export shen.<dbq>) (quote shen.<dbq>))
(begin (register-function-arity (quote shen.<strcontents>) 1) (define (kl:shen.<strcontents> V2394) (let ((YaccParse (let ((Parse_shen.<strc> (kl:shen.<strc> V2394))) (if (kl:not (kl:= (kl:fail) Parse_shen.<strc>)) (let ((Parse_shen.<strcontents> (kl:shen.<strcontents> Parse_shen.<strc>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<strcontents>)) (kl:shen.pair (car Parse_shen.<strcontents>) (cons (kl:shen.hdtl Parse_shen.<strc>) (kl:shen.hdtl Parse_shen.<strcontents>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2394))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<strcontents>) (quote shen.<strcontents>))
(begin (register-function-arity (quote shen.<byte>) 1) (define (kl:shen.<byte> V2396) (if (pair? (car V2396)) (let ((Parse_Char (kl:shen.hdhd V2396))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2396) (kl:shen.hdtl V2396))) (make-string 1 Parse_Char))) (kl:fail))) (export shen.<byte>) (quote shen.<byte>))
(begin (register-function-arity (quote shen.<strc>) 1) (define (kl:shen.<strc> V2398) (if (pair? (car V2398)) (let ((Parse_Char (kl:shen.hdhd V2398))) (if (kl:not (kl:= Parse_Char 34)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2398) (kl:shen.hdtl V2398))) (make-string 1 Parse_Char)) (kl:fail))) (kl:fail))) (export shen.<strc>) (quote shen.<strc>))
(begin (register-function-arity (quote shen.<number>) 1) (define (kl:shen.<number> V2400) (let ((YaccParse (let ((Parse_shen.<minus> (kl:shen.<minus> V2400))) (if (kl:not (kl:= (kl:fail) Parse_shen.<minus>)) (let ((Parse_shen.<number> (kl:shen.<number> Parse_shen.<minus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<number>)) (kl:shen.pair (car Parse_shen.<number>) (- 0 (kl:shen.hdtl Parse_shen.<number>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<plus> (kl:shen.<plus> V2400))) (if (kl:not (kl:= (kl:fail) Parse_shen.<plus>)) (let ((Parse_shen.<number> (kl:shen.<number> Parse_shen.<plus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<number>)) (kl:shen.pair (car Parse_shen.<number>) (kl:shen.hdtl Parse_shen.<number>)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<predigits> (kl:shen.<predigits> V2400))) (if (kl:not (kl:= (kl:fail) Parse_shen.<predigits>)) (let ((Parse_shen.<stop> (kl:shen.<stop> Parse_shen.<predigits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<stop>)) (let ((Parse_shen.<postdigits> (kl:shen.<postdigits> Parse_shen.<stop>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<postdigits>)) (let ((Parse_shen.<E> (kl:shen.<E> Parse_shen.<postdigits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<E>)) (let ((Parse_shen.<log10> (kl:shen.<log10> Parse_shen.<E>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<log10>)) (kl:shen.pair (car Parse_shen.<log10>) (* (kl:shen.expt 10 (kl:shen.hdtl Parse_shen.<log10>)) (+ (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<predigits>)) 0) (kl:shen.post (kl:shen.hdtl Parse_shen.<postdigits>) 1)))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<digits> (kl:shen.<digits> V2400))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (let ((Parse_shen.<E> (kl:shen.<E> Parse_shen.<digits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<E>)) (let ((Parse_shen.<log10> (kl:shen.<log10> Parse_shen.<E>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<log10>)) (kl:shen.pair (car Parse_shen.<log10>) (* (kl:shen.expt 10 (kl:shen.hdtl Parse_shen.<log10>)) (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<predigits> (kl:shen.<predigits> V2400))) (if (kl:not (kl:= (kl:fail) Parse_shen.<predigits>)) (let ((Parse_shen.<stop> (kl:shen.<stop> Parse_shen.<predigits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<stop>)) (let ((Parse_shen.<postdigits> (kl:shen.<postdigits> Parse_shen.<stop>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<postdigits>)) (kl:shen.pair (car Parse_shen.<postdigits>) (+ (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<predigits>)) 0) (kl:shen.post (kl:shen.hdtl Parse_shen.<postdigits>) 1))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<digits> (kl:shen.<digits> V2400))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0)) (kl:fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse))) (export shen.<number>) (quote shen.<number>))
(begin (register-function-arity (quote shen.<E>) 1) (define (kl:shen.<E> V2403) (if (and (pair? (car V2403)) (kl:= 101 (kl:shen.hdhd V2403))) (let ((NewStream2401 (kl:shen.pair (kl:shen.tlhd V2403) (kl:shen.hdtl V2403)))) (kl:shen.pair (car NewStream2401) (quote shen.skip))) (kl:fail))) (export shen.<E>) (quote shen.<E>))
(begin (register-function-arity (quote shen.<log10>) 1) (define (kl:shen.<log10> V2405) (let ((YaccParse (let ((Parse_shen.<minus> (kl:shen.<minus> V2405))) (if (kl:not (kl:= (kl:fail) Parse_shen.<minus>)) (let ((Parse_shen.<digits> (kl:shen.<digits> Parse_shen.<minus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (- 0 (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<digits> (kl:shen.<digits> V2405))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0)) (kl:fail))) YaccParse))) (export shen.<log10>) (quote shen.<log10>))
(begin (register-function-arity (quote shen.<plus>) 1) (define (kl:shen.<plus> V2407) (if (pair? (car V2407)) (let ((Parse_Char (kl:shen.hdhd V2407))) (if (kl:= Parse_Char 43) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2407) (kl:shen.hdtl V2407))) Parse_Char) (kl:fail))) (kl:fail))) (export shen.<plus>) (quote shen.<plus>))
(begin (register-function-arity (quote shen.<stop>) 1) (define (kl:shen.<stop> V2409) (if (pair? (car V2409)) (let ((Parse_Char (kl:shen.hdhd V2409))) (if (kl:= Parse_Char 46) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2409) (kl:shen.hdtl V2409))) Parse_Char) (kl:fail))) (kl:fail))) (export shen.<stop>) (quote shen.<stop>))
(begin (register-function-arity (quote shen.<predigits>) 1) (define (kl:shen.<predigits> V2411) (let ((YaccParse (let ((Parse_shen.<digits> (kl:shen.<digits> V2411))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.hdtl Parse_shen.<digits>)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2411))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<predigits>) (quote shen.<predigits>))
(begin (register-function-arity (quote shen.<postdigits>) 1) (define (kl:shen.<postdigits> V2413) (let ((Parse_shen.<digits> (kl:shen.<digits> V2413))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.hdtl Parse_shen.<digits>)) (kl:fail)))) (export shen.<postdigits>) (quote shen.<postdigits>))
(begin (register-function-arity (quote shen.<digits>) 1) (define (kl:shen.<digits> V2415) (let ((YaccParse (let ((Parse_shen.<digit> (kl:shen.<digit> V2415))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digit>)) (let ((Parse_shen.<digits> (kl:shen.<digits> Parse_shen.<digit>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (cons (kl:shen.hdtl Parse_shen.<digit>) (kl:shen.hdtl Parse_shen.<digits>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<digit> (kl:shen.<digit> V2415))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digit>)) (kl:shen.pair (car Parse_shen.<digit>) (cons (kl:shen.hdtl Parse_shen.<digit>) (quote ()))) (kl:fail))) YaccParse))) (export shen.<digits>) (quote shen.<digits>))
(begin (register-function-arity (quote shen.<digit>) 1) (define (kl:shen.<digit> V2417) (if (pair? (car V2417)) (let ((Parse_X (kl:shen.hdhd V2417))) (if (assert-boolean (kl:shen.numbyte? Parse_X)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2417) (kl:shen.hdtl V2417))) (kl:shen.byte->digit Parse_X)) (kl:fail))) (kl:fail))) (export shen.<digit>) (quote shen.<digit>))
(begin (register-function-arity (quote shen.byte->digit) 1) (define (kl:shen.byte->digit V2419) (cond ((kl:= 48 V2419) 0) ((kl:= 49 V2419) 1) ((kl:= 50 V2419) 2) ((kl:= 51 V2419) 3) ((kl:= 52 V2419) 4) ((kl:= 53 V2419) 5) ((kl:= 54 V2419) 6) ((kl:= 55 V2419) 7) ((kl:= 56 V2419) 8) ((kl:= 57 V2419) 9) (#t (kl:shen.f_error (quote shen.byte->digit))))) (export shen.byte->digit) (quote shen.byte->digit))
(begin (register-function-arity (quote shen.pre) 2) (define (kl:shen.pre V2424 V2425) (cond ((null? V2424) 0) ((pair? V2424) (+ (* (kl:shen.expt 10 V2425) (car V2424)) (kl:shen.pre (cdr V2424) (+ V2425 1)))) (#t (kl:shen.f_error (quote shen.pre))))) (export shen.pre) (quote shen.pre))
(begin (register-function-arity (quote shen.post) 2) (define (kl:shen.post V2430 V2431) (cond ((null? V2430) 0) ((pair? V2430) (+ (* (kl:shen.expt 10 (- 0 V2431)) (car V2430)) (kl:shen.post (cdr V2430) (+ V2431 1)))) (#t (kl:shen.f_error (quote shen.post))))) (export shen.post) (quote shen.post))
(begin (register-function-arity (quote shen.expt) 2) (define (kl:shen.expt V2436 V2437) (cond ((kl:= 0 V2437) 1) ((> V2437 0) (* V2436 (kl:shen.expt V2436 (- V2437 1)))) (#t (* 1.000000000000000 (/ (kl:shen.expt V2436 (+ V2437 1)) V2436))))) (export shen.expt) (quote shen.expt))
(begin (register-function-arity (quote shen.<st_input1>) 1) (define (kl:shen.<st_input1> V2439) (let ((Parse_shen.<st_input> (kl:shen.<st_input> V2439))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail)))) (export shen.<st_input1>) (quote shen.<st_input1>))
(begin (register-function-arity (quote shen.<st_input2>) 1) (define (kl:shen.<st_input2> V2441) (let ((Parse_shen.<st_input> (kl:shen.<st_input> V2441))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail)))) (export shen.<st_input2>) (quote shen.<st_input2>))
(begin (register-function-arity (quote shen.<comment>) 1) (define (kl:shen.<comment> V2443) (let ((YaccParse (let ((Parse_shen.<singleline> (kl:shen.<singleline> V2443))) (if (kl:not (kl:= (kl:fail) Parse_shen.<singleline>)) (kl:shen.pair (car Parse_shen.<singleline>) (quote shen.skip)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<multiline> (kl:shen.<multiline> V2443))) (if (kl:not (kl:= (kl:fail) Parse_shen.<multiline>)) (kl:shen.pair (car Parse_shen.<multiline>) (quote shen.skip)) (kl:fail))) YaccParse))) (export shen.<comment>) (quote shen.<comment>))
(begin (register-function-arity (quote shen.<singleline>) 1) (define (kl:shen.<singleline> V2445) (let ((Parse_shen.<backslash> (kl:shen.<backslash> V2445))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (let ((Parse_shen.<backslash> (kl:shen.<backslash> Parse_shen.<backslash>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (let ((Parse_shen.<anysingle> (kl:shen.<anysingle> Parse_shen.<backslash>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anysingle>)) (let ((Parse_shen.<return> (kl:shen.<return> Parse_shen.<anysingle>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<return>)) (kl:shen.pair (car Parse_shen.<return>) (quote shen.skip)) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail)))) (export shen.<singleline>) (quote shen.<singleline>))
(begin (register-function-arity (quote shen.<backslash>) 1) (define (kl:shen.<backslash> V2448) (if (and (pair? (car V2448)) (kl:= 92 (kl:shen.hdhd V2448))) (let ((NewStream2446 (kl:shen.pair (kl:shen.tlhd V2448) (kl:shen.hdtl V2448)))) (kl:shen.pair (car NewStream2446) (quote shen.skip))) (kl:fail))) (export shen.<backslash>) (quote shen.<backslash>))
(begin (register-function-arity (quote shen.<anysingle>) 1) (define (kl:shen.<anysingle> V2450) (let ((YaccParse (let ((Parse_shen.<non-return> (kl:shen.<non-return> V2450))) (if (kl:not (kl:= (kl:fail) Parse_shen.<non-return>)) (let ((Parse_shen.<anysingle> (kl:shen.<anysingle> Parse_shen.<non-return>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anysingle>)) (kl:shen.pair (car Parse_shen.<anysingle>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2450))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote shen.skip)) (kl:fail))) YaccParse))) (export shen.<anysingle>) (quote shen.<anysingle>))
(begin (register-function-arity (quote shen.<non-return>) 1) (define (kl:shen.<non-return> V2452) (if (pair? (car V2452)) (let ((Parse_X (kl:shen.hdhd V2452))) (if (kl:not (kl:element? Parse_X (cons 10 (cons 13 (quote ()))))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2452) (kl:shen.hdtl V2452))) (quote shen.skip)) (kl:fail))) (kl:fail))) (export shen.<non-return>) (quote shen.<non-return>))
(begin (register-function-arity (quote shen.<return>) 1) (define (kl:shen.<return> V2454) (if (pair? (car V2454)) (let ((Parse_X (kl:shen.hdhd V2454))) (if (kl:element? Parse_X (cons 10 (cons 13 (quote ())))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2454) (kl:shen.hdtl V2454))) (quote shen.skip)) (kl:fail))) (kl:fail))) (export shen.<return>) (quote shen.<return>))
(begin (register-function-arity (quote shen.<multiline>) 1) (define (kl:shen.<multiline> V2456) (let ((Parse_shen.<backslash> (kl:shen.<backslash> V2456))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (let ((Parse_shen.<times> (kl:shen.<times> Parse_shen.<backslash>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<times>)) (let ((Parse_shen.<anymulti> (kl:shen.<anymulti> Parse_shen.<times>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anymulti>)) (kl:shen.pair (car Parse_shen.<anymulti>) (quote shen.skip)) (kl:fail))) (kl:fail))) (kl:fail)))) (export shen.<multiline>) (quote shen.<multiline>))
(begin (register-function-arity (quote shen.<times>) 1) (define (kl:shen.<times> V2459) (if (and (pair? (car V2459)) (kl:= 42 (kl:shen.hdhd V2459))) (let ((NewStream2457 (kl:shen.pair (kl:shen.tlhd V2459) (kl:shen.hdtl V2459)))) (kl:shen.pair (car NewStream2457) (quote shen.skip))) (kl:fail))) (export shen.<times>) (quote shen.<times>))
(begin (register-function-arity (quote shen.<anymulti>) 1) (define (kl:shen.<anymulti> V2461) (let ((YaccParse (let ((Parse_shen.<comment> (kl:shen.<comment> V2461))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comment>)) (let ((Parse_shen.<anymulti> (kl:shen.<anymulti> Parse_shen.<comment>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anymulti>)) (kl:shen.pair (car Parse_shen.<anymulti>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<times> (kl:shen.<times> V2461))) (if (kl:not (kl:= (kl:fail) Parse_shen.<times>)) (let ((Parse_shen.<backslash> (kl:shen.<backslash> Parse_shen.<times>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (kl:shen.pair (car Parse_shen.<backslash>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (if (pair? (car V2461)) (let ((Parse_X (kl:shen.hdhd V2461))) (let ((Parse_shen.<anymulti> (kl:shen.<anymulti> (kl:shen.pair (kl:shen.tlhd V2461) (kl:shen.hdtl V2461))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anymulti>)) (kl:shen.pair (car Parse_shen.<anymulti>) (quote shen.skip)) (kl:fail)))) (kl:fail)) YaccParse)) YaccParse))) (export shen.<anymulti>) (quote shen.<anymulti>))
(begin (register-function-arity (quote shen.<whitespaces>) 1) (define (kl:shen.<whitespaces> V2463) (let ((YaccParse (let ((Parse_shen.<whitespace> (kl:shen.<whitespace> V2463))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespace>)) (let ((Parse_shen.<whitespaces> (kl:shen.<whitespaces> Parse_shen.<whitespace>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespaces>)) (kl:shen.pair (car Parse_shen.<whitespaces>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<whitespace> (kl:shen.<whitespace> V2463))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespace>)) (kl:shen.pair (car Parse_shen.<whitespace>) (quote shen.skip)) (kl:fail))) YaccParse))) (export shen.<whitespaces>) (quote shen.<whitespaces>))
(begin (register-function-arity (quote shen.<whitespace>) 1) (define (kl:shen.<whitespace> V2465) (if (pair? (car V2465)) (let ((Parse_X (kl:shen.hdhd V2465))) (if (assert-boolean (let ((Parse_Case Parse_X)) (or (kl:= Parse_Case 32) (or (kl:= Parse_Case 13) (or (kl:= Parse_Case 10) (kl:= Parse_Case 9)))))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2465) (kl:shen.hdtl V2465))) (quote shen.skip)) (kl:fail))) (kl:fail))) (export shen.<whitespace>) (quote shen.<whitespace>))
(begin (register-function-arity (quote shen.cons_form) 1) (define (kl:shen.cons_form V2467) (cond ((null? V2467) (quote ())) ((and (pair? V2467) (and (pair? (cdr V2467)) (and (pair? (cdr (cdr V2467))) (and (null? (cdr (cdr (cdr V2467)))) (eq? (car (cdr V2467)) (quote bar!)))))) (cons (quote cons) (cons (car V2467) (cdr (cdr V2467))))) ((pair? V2467) (cons (quote cons) (cons (car V2467) (cons (kl:shen.cons_form (cdr V2467)) (quote ()))))) (#t (kl:shen.f_error (quote shen.cons_form))))) (export shen.cons_form) (quote shen.cons_form))
(begin (register-function-arity (quote shen.package-macro) 2) (define (kl:shen.package-macro V2472 V2473) (cond ((and (pair? V2472) (and (eq? (quote _waspvm_dl_) (car V2472)) (and (pair? (cdr V2472)) (null? (cdr (cdr V2472)))))) (kl:append (kl:explode (car (cdr V2472))) V2473)) ((and (pair? V2472) (and (eq? (quote package) (car V2472)) (and (pair? (cdr V2472)) (and (eq? (quote null) (car (cdr V2472))) (pair? (cdr (cdr V2472))))))) (kl:append (cdr (cdr (cdr V2472))) V2473)) ((and (pair? V2472) (and (eq? (quote package) (car V2472)) (and (pair? (cdr V2472)) (pair? (cdr (cdr V2472)))))) (let ((ListofExceptions (kl:shen.eval-without-macros (car (cdr (cdr V2472)))))) (let ((External (kl:shen.record-exceptions ListofExceptions (car (cdr V2472))))) (let ((PackageNameDot (kl:intern (string-append (kl:str (car (cdr V2472))) ".")))) (let ((ExpPackageNameDot (kl:explode PackageNameDot))) (let ((Packaged (kl:shen.packageh PackageNameDot ListofExceptions (cdr (cdr (cdr V2472))) ExpPackageNameDot))) (let ((Internal (kl:shen.record-internal (car (cdr V2472)) (kl:shen.internal-symbols ExpPackageNameDot Packaged)))) (kl:append Packaged V2473)))))))) (#t (cons V2472 V2473)))) (export shen.package-macro) (quote shen.package-macro))
(begin (register-function-arity (quote shen.record-exceptions) 2) (define (kl:shen.record-exceptions V2476 V2477) (let ((CurrExceptions (guard (lambda (E) (quote ())) (kl:get V2477 (quote shen.external-symbols) (kl:value (quote *property-vector*)))))) (let ((AllExceptions (kl:union V2476 CurrExceptions))) (kl:put V2477 (quote shen.external-symbols) AllExceptions (kl:value (quote *property-vector*)))))) (export shen.record-exceptions) (quote shen.record-exceptions))
(begin (register-function-arity (quote shen.record-internal) 2) (define (kl:shen.record-internal V2480 V2481) (kl:put V2480 (quote shen.internal-symbols) (kl:union V2481 (guard (lambda (E) (quote ())) (kl:get V2480 (quote shen.internal-symbols) (kl:value (quote *property-vector*))))) (kl:value (quote *property-vector*)))) (export shen.record-internal) (quote shen.record-internal))
(begin (register-function-arity (quote shen.internal-symbols) 2) (define (kl:shen.internal-symbols V2492 V2493) (cond ((and (kl:symbol? V2493) (assert-boolean (kl:shen.prefix? V2492 (kl:explode V2493)))) (cons V2493 (quote ()))) ((pair? V2493) (kl:union (kl:shen.internal-symbols V2492 (car V2493)) (kl:shen.internal-symbols V2492 (cdr V2493)))) (#t (quote ())))) (export shen.internal-symbols) (quote shen.internal-symbols))
(begin (register-function-arity (quote shen.packageh) 4) (define (kl:shen.packageh V2510 V2511 V2512 V2513) (cond ((pair? V2512) (cons (kl:shen.packageh V2510 V2511 (car V2512) V2513) (kl:shen.packageh V2510 V2511 (cdr V2512) V2513))) ((or (assert-boolean (kl:shen.sysfunc? V2512)) (or (kl:variable? V2512) (or (kl:element? V2512 V2511) (or (assert-boolean (kl:shen.doubleunderline? V2512)) (assert-boolean (kl:shen.singleunderline? V2512)))))) V2512) ((and (kl:symbol? V2512) (assert-boolean (let ((ExplodeX (kl:explode V2512))) (and (kl:not (kl:shen.prefix? (cons "s" (cons "h" (cons "e" (cons "n" (cons "." (quote ())))))) ExplodeX)) (kl:not (kl:shen.prefix? V2513 ExplodeX)))))) (kl:concat V2510 V2512)) (#t V2512))) (export shen.packageh) (quote shen.packageh))
