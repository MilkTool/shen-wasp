(module "compiled/reader.kl")
"Copyright (c) 2010-2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
(begin (register-function-arity (quote shen.read-char-code) 1) (define (kl:shen.read-char-code V2533) (read-u8 V2533)) (export shen.read-char-code) (quote shen.read-char-code))
(begin (register-function-arity (quote read-file-as-bytelist) 1) (define (kl:read-file-as-bytelist V2535) (kl:shen.read-file-as-Xlist V2535 (lambda (S) (read-u8 S)))) (export read-file-as-bytelist) (quote read-file-as-bytelist))
(begin (register-function-arity (quote shen.read-file-as-charlist) 1) (define (kl:shen.read-file-as-charlist V2537) (kl:shen.read-file-as-Xlist V2537 (lambda (S) (kl:shen.read-char-code S)))) (export shen.read-file-as-charlist) (quote shen.read-file-as-charlist))
(begin (register-function-arity (quote shen.read-file-as-Xlist) 2) (define (kl:shen.read-file-as-Xlist V2540 V2541) (let ((Stream (kl:open V2540 (quote in)))) (let ((X (V2541 Stream))) (let ((Xs (kl:shen.read-file-as-Xlist-help Stream V2541 X (quote ())))) (let ((Close (kl:close Stream))) (kl:reverse Xs)))))) (export shen.read-file-as-Xlist) (quote shen.read-file-as-Xlist))
(begin (register-function-arity (quote shen.read-file-as-Xlist-help) 4) (define (kl:shen.read-file-as-Xlist-help V2546 V2547 V2548 V2549) (cond ((kl:= -1 V2548) V2549) (#t (kl:shen.read-file-as-Xlist-help V2546 V2547 (V2547 V2546) (cons V2548 V2549))))) (export shen.read-file-as-Xlist-help) (quote shen.read-file-as-Xlist-help))
(begin (register-function-arity (quote read-file-as-string) 1) (define (kl:read-file-as-string V2551) (let ((Stream (kl:open V2551 (quote in)))) (kl:shen.rfas-h Stream (kl:shen.read-char-code Stream) ""))) (export read-file-as-string) (quote read-file-as-string))
(begin (register-function-arity (quote shen.rfas-h) 3) (define (kl:shen.rfas-h V2555 V2556 V2557) (cond ((kl:= -1 V2556) (begin (kl:close V2555) V2557)) (#t (kl:shen.rfas-h V2555 (kl:shen.read-char-code V2555) (string-append V2557 (make-string 1 V2556)))))) (export shen.rfas-h) (quote shen.rfas-h))
(begin (register-function-arity (quote input) 1) (define (kl:input V2559) (kl:eval-kl (kl:read V2559))) (export input) (quote input))
(begin (register-function-arity (quote input+) 2) (define (kl:input+ V2562 V2563) (let ((Mono? (kl:shen.monotype V2562))) (let ((Input (kl:read V2563))) (if (kl:= #f (kl:shen.typecheck Input (kl:shen.demodulate V2562))) (simple-error (string-append "type error: " (kl:shen.app Input (string-append " is not of type " (kl:shen.app V2562 "\n" (quote shen.r))) (quote shen.r)))) (kl:eval-kl Input))))) (export input+) (quote input+))
(begin (register-function-arity (quote shen.monotype) 1) (define (kl:shen.monotype V2565) (cond ((pair? V2565) (kl:map (lambda (Z) (kl:shen.monotype Z)) V2565)) (#t (if (kl:variable? V2565) (simple-error (string-append "input+ expects a monotype: not " (kl:shen.app V2565 "\n" (quote shen.a)))) V2565)))) (export shen.monotype) (quote shen.monotype))
(begin (register-function-arity (quote read) 1) (define (kl:read V2567) (car (kl:shen.read-loop V2567 (kl:shen.read-char-code V2567) (quote ())))) (export read) (quote read))
(begin (register-function-arity (quote it) 0) (define (kl:it) (kl:value (quote shen.*it*))) (export it) (quote it))
(begin (register-function-arity (quote shen.read-loop) 3) (define (kl:shen.read-loop V2575 V2576 V2577) (cond ((kl:= 94 V2576) (simple-error "read aborted")) ((kl:= -1 V2576) (if (kl:empty? V2577) (simple-error "error: empty stream") (kl:compile (lambda (X) (kl:shen.<st_input> X)) V2577 (lambda (E) E)))) ((assert-boolean (kl:shen.terminator? V2576)) (let ((AllChars (kl:append V2577 (cons V2576 (quote ()))))) (let ((It (kl:shen.record-it AllChars))) (let ((Read (kl:compile (lambda (X) (kl:shen.<st_input> X)) AllChars (lambda (E) (quote shen.nextbyte))))) (if (or (eq? Read (quote shen.nextbyte)) (kl:empty? Read)) (kl:shen.read-loop V2575 (kl:shen.read-char-code V2575) AllChars) Read))))) (#t (kl:shen.read-loop V2575 (kl:shen.read-char-code V2575) (kl:append V2577 (cons V2576 (quote ()))))))) (export shen.read-loop) (quote shen.read-loop))
(begin (register-function-arity (quote shen.terminator?) 1) (define (kl:shen.terminator? V2579) (kl:element? V2579 (cons 9 (cons 10 (cons 13 (cons 32 (cons 34 (cons 41 (cons 93 (quote ())))))))))) (export shen.terminator?) (quote shen.terminator?))
(begin (register-function-arity (quote lineread) 1) (define (kl:lineread V2581) (kl:shen.lineread-loop (kl:shen.read-char-code V2581) (quote ()) V2581)) (export lineread) (quote lineread))
(begin (register-function-arity (quote shen.lineread-loop) 3) (define (kl:shen.lineread-loop V2586 V2587 V2588) (cond ((kl:= -1 V2586) (if (kl:empty? V2587) (simple-error "empty stream") (kl:compile (lambda (X) (kl:shen.<st_input> X)) V2587 (lambda (E) E)))) ((kl:= V2586 (kl:shen.hat)) (simple-error "line read aborted")) ((kl:element? V2586 (cons (kl:shen.newline) (cons (kl:shen.carriage-return) (quote ())))) (let ((Line (kl:compile (lambda (X) (kl:shen.<st_input> X)) V2587 (lambda (E) (quote shen.nextline))))) (let ((It (kl:shen.record-it V2587))) (if (or (eq? Line (quote shen.nextline)) (kl:empty? Line)) (kl:shen.lineread-loop (kl:shen.read-char-code V2588) (kl:append V2587 (cons V2586 (quote ()))) V2588) Line)))) (#t (kl:shen.lineread-loop (kl:shen.read-char-code V2588) (kl:append V2587 (cons V2586 (quote ()))) V2588)))) (export shen.lineread-loop) (quote shen.lineread-loop))
(begin (register-function-arity (quote shen.record-it) 1) (define (kl:shen.record-it V2590) (let ((TrimLeft (kl:shen.trim-whitespace V2590))) (let ((TrimRight (kl:shen.trim-whitespace (kl:reverse TrimLeft)))) (let ((Trimmed (kl:reverse TrimRight))) (kl:shen.record-it-h Trimmed))))) (export shen.record-it) (quote shen.record-it))
(begin (register-function-arity (quote shen.trim-whitespace) 1) (define (kl:shen.trim-whitespace V2592) (cond ((and (pair? V2592) (kl:element? (car V2592) (cons 9 (cons 10 (cons 13 (cons 32 (quote ()))))))) (kl:shen.trim-whitespace (cdr V2592))) (#t V2592))) (export shen.trim-whitespace) (quote shen.trim-whitespace))
(begin (register-function-arity (quote shen.record-it-h) 1) (define (kl:shen.record-it-h V2594) (begin (kl:set (quote shen.*it*) (kl:shen.cn-all (kl:map (lambda (X) (make-string 1 X)) V2594))) V2594)) (export shen.record-it-h) (quote shen.record-it-h))
(begin (register-function-arity (quote shen.cn-all) 1) (define (kl:shen.cn-all V2596) (cond ((null? V2596) "") ((pair? V2596) (string-append (car V2596) (kl:shen.cn-all (cdr V2596)))) (#t (kl:shen.f_error (quote shen.cn-all))))) (export shen.cn-all) (quote shen.cn-all))
(begin (register-function-arity (quote read-file) 1) (define (kl:read-file V2598) (let ((Charlist (kl:shen.read-file-as-charlist V2598))) (kl:compile (lambda (X) (kl:shen.<st_input> X)) Charlist (lambda (X) (kl:shen.read-error X))))) (export read-file) (quote read-file))
(begin (register-function-arity (quote read-from-string) 1) (define (kl:read-from-string V2600) (let ((Ns (kl:map (lambda (X) (string-ref X 0)) (kl:explode V2600)))) (kl:compile (lambda (X) (kl:shen.<st_input> X)) Ns (lambda (X) (kl:shen.read-error X))))) (export read-from-string) (quote read-from-string))
(begin (register-function-arity (quote shen.read-error) 1) (define (kl:shen.read-error V2608) (cond ((and (pair? V2608) (and (pair? (car V2608)) (and (pair? (cdr V2608)) (null? (cdr (cdr V2608)))))) (simple-error (string-append "read error here:\n\n " (kl:shen.app (kl:shen.compress-50 50 (car V2608)) "\n" (quote shen.a))))) (#t (simple-error "read error\n")))) (export shen.read-error) (quote shen.read-error))
(begin (register-function-arity (quote shen.compress-50) 2) (define (kl:shen.compress-50 V2615 V2616) (cond ((null? V2616) "") ((kl:= 0 V2615) "") ((pair? V2616) (string-append (make-string 1 (car V2616)) (kl:shen.compress-50 (- V2615 1) (cdr V2616)))) (#t (kl:shen.f_error (quote shen.compress-50))))) (export shen.compress-50) (quote shen.compress-50))
(begin (register-function-arity (quote shen.<st_input>) 1) (define (kl:shen.<st_input> V2618) (let ((YaccParse (let ((Parse_shen.<lsb> (kl:shen.<lsb> V2618))) (if (kl:not (kl:= (kl:fail) Parse_shen.<lsb>)) (let ((Parse_shen.<st_input1> (kl:shen.<st_input1> Parse_shen.<lsb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input1>)) (let ((Parse_shen.<rsb> (kl:shen.<rsb> Parse_shen.<st_input1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rsb>)) (let ((Parse_shen.<st_input2> (kl:shen.<st_input2> Parse_shen.<rsb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input2>)) (kl:shen.pair (car Parse_shen.<st_input2>) (cons (kl:macroexpand (kl:shen.cons_form (kl:shen.hdtl Parse_shen.<st_input1>))) (kl:shen.hdtl Parse_shen.<st_input2>))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<lrb> (kl:shen.<lrb> V2618))) (if (kl:not (kl:= (kl:fail) Parse_shen.<lrb>)) (let ((Parse_shen.<st_input1> (kl:shen.<st_input1> Parse_shen.<lrb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input1>)) (let ((Parse_shen.<rrb> (kl:shen.<rrb> Parse_shen.<st_input1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rrb>)) (let ((Parse_shen.<st_input2> (kl:shen.<st_input2> Parse_shen.<rrb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input2>)) (kl:shen.pair (car Parse_shen.<st_input2>) (kl:shen.package-macro (kl:macroexpand (kl:shen.hdtl Parse_shen.<st_input1>)) (kl:shen.hdtl Parse_shen.<st_input2>))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<lcurly> (kl:shen.<lcurly> V2618))) (if (kl:not (kl:= (kl:fail) Parse_shen.<lcurly>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<lcurly>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote {) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<rcurly> (kl:shen.<rcurly> V2618))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rcurly>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<rcurly>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote }) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<bar> (kl:shen.<bar> V2618))) (if (kl:not (kl:= (kl:fail) Parse_shen.<bar>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<bar>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote bar!) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<semicolon> (kl:shen.<semicolon> V2618))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<semicolon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote _waspvm_sc_) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<colon> (kl:shen.<colon> V2618))) (if (kl:not (kl:= (kl:fail) Parse_shen.<colon>)) (let ((Parse_shen.<equal> (kl:shen.<equal> Parse_shen.<colon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<equal>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<equal>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote :=) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<colon> (kl:shen.<colon> V2618))) (if (kl:not (kl:= (kl:fail) Parse_shen.<colon>)) (let ((Parse_shen.<minus> (kl:shen.<minus> Parse_shen.<colon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<minus>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<minus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote :-) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<colon> (kl:shen.<colon> V2618))) (if (kl:not (kl:= (kl:fail) Parse_shen.<colon>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<colon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote :) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<comma> (kl:shen.<comma> V2618))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comma>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<comma>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (kl:intern ",") (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<comment> (kl:shen.<comment> V2618))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comment>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<comment>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<atom> (kl:shen.<atom> V2618))) (if (kl:not (kl:= (kl:fail) Parse_shen.<atom>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<atom>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (kl:macroexpand (kl:shen.hdtl Parse_shen.<atom>)) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<whitespaces> (kl:shen.<whitespaces> V2618))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespaces>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<whitespaces>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2618))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse))) (export shen.<st_input>) (quote shen.<st_input>))
(begin (register-function-arity (quote shen.<lsb>) 1) (define (kl:shen.<lsb> V2621) (if (and (pair? (car V2621)) (kl:= 91 (kl:shen.hdhd V2621))) (let ((NewStream2619 (kl:shen.pair (kl:shen.tlhd V2621) (kl:shen.hdtl V2621)))) (kl:shen.pair (car NewStream2619) (quote shen.skip))) (kl:fail))) (export shen.<lsb>) (quote shen.<lsb>))
(begin (register-function-arity (quote shen.<rsb>) 1) (define (kl:shen.<rsb> V2624) (if (and (pair? (car V2624)) (kl:= 93 (kl:shen.hdhd V2624))) (let ((NewStream2622 (kl:shen.pair (kl:shen.tlhd V2624) (kl:shen.hdtl V2624)))) (kl:shen.pair (car NewStream2622) (quote shen.skip))) (kl:fail))) (export shen.<rsb>) (quote shen.<rsb>))
(begin (register-function-arity (quote shen.<lcurly>) 1) (define (kl:shen.<lcurly> V2627) (if (and (pair? (car V2627)) (kl:= 123 (kl:shen.hdhd V2627))) (let ((NewStream2625 (kl:shen.pair (kl:shen.tlhd V2627) (kl:shen.hdtl V2627)))) (kl:shen.pair (car NewStream2625) (quote shen.skip))) (kl:fail))) (export shen.<lcurly>) (quote shen.<lcurly>))
(begin (register-function-arity (quote shen.<rcurly>) 1) (define (kl:shen.<rcurly> V2630) (if (and (pair? (car V2630)) (kl:= 125 (kl:shen.hdhd V2630))) (let ((NewStream2628 (kl:shen.pair (kl:shen.tlhd V2630) (kl:shen.hdtl V2630)))) (kl:shen.pair (car NewStream2628) (quote shen.skip))) (kl:fail))) (export shen.<rcurly>) (quote shen.<rcurly>))
(begin (register-function-arity (quote shen.<bar>) 1) (define (kl:shen.<bar> V2633) (if (and (pair? (car V2633)) (kl:= 124 (kl:shen.hdhd V2633))) (let ((NewStream2631 (kl:shen.pair (kl:shen.tlhd V2633) (kl:shen.hdtl V2633)))) (kl:shen.pair (car NewStream2631) (quote shen.skip))) (kl:fail))) (export shen.<bar>) (quote shen.<bar>))
(begin (register-function-arity (quote shen.<semicolon>) 1) (define (kl:shen.<semicolon> V2636) (if (and (pair? (car V2636)) (kl:= 59 (kl:shen.hdhd V2636))) (let ((NewStream2634 (kl:shen.pair (kl:shen.tlhd V2636) (kl:shen.hdtl V2636)))) (kl:shen.pair (car NewStream2634) (quote shen.skip))) (kl:fail))) (export shen.<semicolon>) (quote shen.<semicolon>))
(begin (register-function-arity (quote shen.<colon>) 1) (define (kl:shen.<colon> V2639) (if (and (pair? (car V2639)) (kl:= 58 (kl:shen.hdhd V2639))) (let ((NewStream2637 (kl:shen.pair (kl:shen.tlhd V2639) (kl:shen.hdtl V2639)))) (kl:shen.pair (car NewStream2637) (quote shen.skip))) (kl:fail))) (export shen.<colon>) (quote shen.<colon>))
(begin (register-function-arity (quote shen.<comma>) 1) (define (kl:shen.<comma> V2642) (if (and (pair? (car V2642)) (kl:= 44 (kl:shen.hdhd V2642))) (let ((NewStream2640 (kl:shen.pair (kl:shen.tlhd V2642) (kl:shen.hdtl V2642)))) (kl:shen.pair (car NewStream2640) (quote shen.skip))) (kl:fail))) (export shen.<comma>) (quote shen.<comma>))
(begin (register-function-arity (quote shen.<equal>) 1) (define (kl:shen.<equal> V2645) (if (and (pair? (car V2645)) (kl:= 61 (kl:shen.hdhd V2645))) (let ((NewStream2643 (kl:shen.pair (kl:shen.tlhd V2645) (kl:shen.hdtl V2645)))) (kl:shen.pair (car NewStream2643) (quote shen.skip))) (kl:fail))) (export shen.<equal>) (quote shen.<equal>))
(begin (register-function-arity (quote shen.<minus>) 1) (define (kl:shen.<minus> V2648) (if (and (pair? (car V2648)) (kl:= 45 (kl:shen.hdhd V2648))) (let ((NewStream2646 (kl:shen.pair (kl:shen.tlhd V2648) (kl:shen.hdtl V2648)))) (kl:shen.pair (car NewStream2646) (quote shen.skip))) (kl:fail))) (export shen.<minus>) (quote shen.<minus>))
(begin (register-function-arity (quote shen.<lrb>) 1) (define (kl:shen.<lrb> V2651) (if (and (pair? (car V2651)) (kl:= 40 (kl:shen.hdhd V2651))) (let ((NewStream2649 (kl:shen.pair (kl:shen.tlhd V2651) (kl:shen.hdtl V2651)))) (kl:shen.pair (car NewStream2649) (quote shen.skip))) (kl:fail))) (export shen.<lrb>) (quote shen.<lrb>))
(begin (register-function-arity (quote shen.<rrb>) 1) (define (kl:shen.<rrb> V2654) (if (and (pair? (car V2654)) (kl:= 41 (kl:shen.hdhd V2654))) (let ((NewStream2652 (kl:shen.pair (kl:shen.tlhd V2654) (kl:shen.hdtl V2654)))) (kl:shen.pair (car NewStream2652) (quote shen.skip))) (kl:fail))) (export shen.<rrb>) (quote shen.<rrb>))
(begin (register-function-arity (quote shen.<atom>) 1) (define (kl:shen.<atom> V2656) (let ((YaccParse (let ((Parse_shen.<str> (kl:shen.<str> V2656))) (if (kl:not (kl:= (kl:fail) Parse_shen.<str>)) (kl:shen.pair (car Parse_shen.<str>) (kl:shen.control-chars (kl:shen.hdtl Parse_shen.<str>))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<number> (kl:shen.<number> V2656))) (if (kl:not (kl:= (kl:fail) Parse_shen.<number>)) (kl:shen.pair (car Parse_shen.<number>) (kl:shen.hdtl Parse_shen.<number>)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<sym> (kl:shen.<sym> V2656))) (if (kl:not (kl:= (kl:fail) Parse_shen.<sym>)) (kl:shen.pair (car Parse_shen.<sym>) (if (equal? (kl:shen.hdtl Parse_shen.<sym>) "<>") (cons (quote vector) (cons 0 (quote ()))) (kl:intern (kl:shen.hdtl Parse_shen.<sym>)))) (kl:fail))) YaccParse)) YaccParse))) (export shen.<atom>) (quote shen.<atom>))
(begin (register-function-arity (quote shen.control-chars) 1) (define (kl:shen.control-chars V2658) (cond ((null? V2658) "") ((and (pair? V2658) (and (equal? "c" (car V2658)) (and (pair? (cdr V2658)) (equal? "#" (car (cdr V2658)))))) (let ((CodePoint (kl:shen.code-point (cdr (cdr V2658))))) (let ((AfterCodePoint (kl:shen.after-codepoint (cdr (cdr V2658))))) (kl:_waspvm_at_s (make-string 1 (kl:shen.decimalise CodePoint)) (kl:shen.control-chars AfterCodePoint))))) ((pair? V2658) (kl:_waspvm_at_s (car V2658) (kl:shen.control-chars (cdr V2658)))) (#t (kl:shen.f_error (quote shen.control-chars))))) (export shen.control-chars) (quote shen.control-chars))
(begin (register-function-arity (quote shen.code-point) 1) (define (kl:shen.code-point V2662) (cond ((and (pair? V2662) (equal? ";" (car V2662))) "") ((and (pair? V2662) (kl:element? (car V2662) (cons "0" (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" (quote ())))))))))))))) (cons (car V2662) (kl:shen.code-point (cdr V2662)))) (#t (simple-error (string-append "code point parse error " (kl:shen.app V2662 "\n" (quote shen.a))))))) (export shen.code-point) (quote shen.code-point))
(begin (register-function-arity (quote shen.after-codepoint) 1) (define (kl:shen.after-codepoint V2668) (cond ((null? V2668) (quote ())) ((and (pair? V2668) (equal? ";" (car V2668))) (cdr V2668)) ((pair? V2668) (kl:shen.after-codepoint (cdr V2668))) (#t (kl:shen.f_error (quote shen.after-codepoint))))) (export shen.after-codepoint) (quote shen.after-codepoint))
(begin (register-function-arity (quote shen.decimalise) 1) (define (kl:shen.decimalise V2670) (kl:shen.pre (kl:reverse (kl:shen.digits->integers V2670)) 0)) (export shen.decimalise) (quote shen.decimalise))
(begin (register-function-arity (quote shen.digits->integers) 1) (define (kl:shen.digits->integers V2676) (cond ((and (pair? V2676) (equal? "0" (car V2676))) (cons 0 (kl:shen.digits->integers (cdr V2676)))) ((and (pair? V2676) (equal? "1" (car V2676))) (cons 1 (kl:shen.digits->integers (cdr V2676)))) ((and (pair? V2676) (equal? "2" (car V2676))) (cons 2 (kl:shen.digits->integers (cdr V2676)))) ((and (pair? V2676) (equal? "3" (car V2676))) (cons 3 (kl:shen.digits->integers (cdr V2676)))) ((and (pair? V2676) (equal? "4" (car V2676))) (cons 4 (kl:shen.digits->integers (cdr V2676)))) ((and (pair? V2676) (equal? "5" (car V2676))) (cons 5 (kl:shen.digits->integers (cdr V2676)))) ((and (pair? V2676) (equal? "6" (car V2676))) (cons 6 (kl:shen.digits->integers (cdr V2676)))) ((and (pair? V2676) (equal? "7" (car V2676))) (cons 7 (kl:shen.digits->integers (cdr V2676)))) ((and (pair? V2676) (equal? "8" (car V2676))) (cons 8 (kl:shen.digits->integers (cdr V2676)))) ((and (pair? V2676) (equal? "9" (car V2676))) (cons 9 (kl:shen.digits->integers (cdr V2676)))) (#t (quote ())))) (export shen.digits->integers) (quote shen.digits->integers))
(begin (register-function-arity (quote shen.<sym>) 1) (define (kl:shen.<sym> V2678) (let ((Parse_shen.<alpha> (kl:shen.<alpha> V2678))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alpha>)) (let ((Parse_shen.<alphanums> (kl:shen.<alphanums> Parse_shen.<alpha>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alphanums>)) (kl:shen.pair (car Parse_shen.<alphanums>) (kl:_waspvm_at_s (kl:shen.hdtl Parse_shen.<alpha>) (kl:shen.hdtl Parse_shen.<alphanums>))) (kl:fail))) (kl:fail)))) (export shen.<sym>) (quote shen.<sym>))
(begin (register-function-arity (quote shen.<alphanums>) 1) (define (kl:shen.<alphanums> V2680) (let ((YaccParse (let ((Parse_shen.<alphanum> (kl:shen.<alphanum> V2680))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alphanum>)) (let ((Parse_shen.<alphanums> (kl:shen.<alphanums> Parse_shen.<alphanum>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alphanums>)) (kl:shen.pair (car Parse_shen.<alphanums>) (kl:_waspvm_at_s (kl:shen.hdtl Parse_shen.<alphanum>) (kl:shen.hdtl Parse_shen.<alphanums>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2680))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) "") (kl:fail))) YaccParse))) (export shen.<alphanums>) (quote shen.<alphanums>))
(begin (register-function-arity (quote shen.<alphanum>) 1) (define (kl:shen.<alphanum> V2682) (let ((YaccParse (let ((Parse_shen.<alpha> (kl:shen.<alpha> V2682))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alpha>)) (kl:shen.pair (car Parse_shen.<alpha>) (kl:shen.hdtl Parse_shen.<alpha>)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<num> (kl:shen.<num> V2682))) (if (kl:not (kl:= (kl:fail) Parse_shen.<num>)) (kl:shen.pair (car Parse_shen.<num>) (kl:shen.hdtl Parse_shen.<num>)) (kl:fail))) YaccParse))) (export shen.<alphanum>) (quote shen.<alphanum>))
(begin (register-function-arity (quote shen.<num>) 1) (define (kl:shen.<num> V2684) (if (pair? (car V2684)) (let ((Parse_Char (kl:shen.hdhd V2684))) (if (assert-boolean (kl:shen.numbyte? Parse_Char)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2684) (kl:shen.hdtl V2684))) (make-string 1 Parse_Char)) (kl:fail))) (kl:fail))) (export shen.<num>) (quote shen.<num>))
(begin (register-function-arity (quote shen.numbyte?) 1) (define (kl:shen.numbyte? V2690) (cond ((kl:= 48 V2690) #t) ((kl:= 49 V2690) #t) ((kl:= 50 V2690) #t) ((kl:= 51 V2690) #t) ((kl:= 52 V2690) #t) ((kl:= 53 V2690) #t) ((kl:= 54 V2690) #t) ((kl:= 55 V2690) #t) ((kl:= 56 V2690) #t) ((kl:= 57 V2690) #t) (#t #f))) (export shen.numbyte?) (quote shen.numbyte?))
(begin (register-function-arity (quote shen.<alpha>) 1) (define (kl:shen.<alpha> V2692) (if (pair? (car V2692)) (let ((Parse_Char (kl:shen.hdhd V2692))) (if (assert-boolean (kl:shen.symbol-code? Parse_Char)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2692) (kl:shen.hdtl V2692))) (make-string 1 Parse_Char)) (kl:fail))) (kl:fail))) (export shen.<alpha>) (quote shen.<alpha>))
(begin (register-function-arity (quote shen.symbol-code?) 1) (define (kl:shen.symbol-code? V2694) (or (kl:= V2694 126) (or (and (> V2694 94) (< V2694 123)) (or (and (> V2694 59) (< V2694 91)) (or (and (> V2694 41) (and (< V2694 58) (kl:not (kl:= V2694 44)))) (or (and (> V2694 34) (< V2694 40)) (kl:= V2694 33))))))) (export shen.symbol-code?) (quote shen.symbol-code?))
(begin (register-function-arity (quote shen.<str>) 1) (define (kl:shen.<str> V2696) (let ((Parse_shen.<dbq> (kl:shen.<dbq> V2696))) (if (kl:not (kl:= (kl:fail) Parse_shen.<dbq>)) (let ((Parse_shen.<strcontents> (kl:shen.<strcontents> Parse_shen.<dbq>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<strcontents>)) (let ((Parse_shen.<dbq> (kl:shen.<dbq> Parse_shen.<strcontents>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<dbq>)) (kl:shen.pair (car Parse_shen.<dbq>) (kl:shen.hdtl Parse_shen.<strcontents>)) (kl:fail))) (kl:fail))) (kl:fail)))) (export shen.<str>) (quote shen.<str>))
(begin (register-function-arity (quote shen.<dbq>) 1) (define (kl:shen.<dbq> V2698) (if (pair? (car V2698)) (let ((Parse_Char (kl:shen.hdhd V2698))) (if (kl:= Parse_Char 34) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2698) (kl:shen.hdtl V2698))) Parse_Char) (kl:fail))) (kl:fail))) (export shen.<dbq>) (quote shen.<dbq>))
(begin (register-function-arity (quote shen.<strcontents>) 1) (define (kl:shen.<strcontents> V2700) (let ((YaccParse (let ((Parse_shen.<strc> (kl:shen.<strc> V2700))) (if (kl:not (kl:= (kl:fail) Parse_shen.<strc>)) (let ((Parse_shen.<strcontents> (kl:shen.<strcontents> Parse_shen.<strc>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<strcontents>)) (kl:shen.pair (car Parse_shen.<strcontents>) (cons (kl:shen.hdtl Parse_shen.<strc>) (kl:shen.hdtl Parse_shen.<strcontents>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2700))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<strcontents>) (quote shen.<strcontents>))
(begin (register-function-arity (quote shen.<byte>) 1) (define (kl:shen.<byte> V2702) (if (pair? (car V2702)) (let ((Parse_Char (kl:shen.hdhd V2702))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2702) (kl:shen.hdtl V2702))) (make-string 1 Parse_Char))) (kl:fail))) (export shen.<byte>) (quote shen.<byte>))
(begin (register-function-arity (quote shen.<strc>) 1) (define (kl:shen.<strc> V2704) (if (pair? (car V2704)) (let ((Parse_Char (kl:shen.hdhd V2704))) (if (kl:not (kl:= Parse_Char 34)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2704) (kl:shen.hdtl V2704))) (make-string 1 Parse_Char)) (kl:fail))) (kl:fail))) (export shen.<strc>) (quote shen.<strc>))
(begin (register-function-arity (quote shen.<number>) 1) (define (kl:shen.<number> V2706) (let ((YaccParse (let ((Parse_shen.<minus> (kl:shen.<minus> V2706))) (if (kl:not (kl:= (kl:fail) Parse_shen.<minus>)) (let ((Parse_shen.<number> (kl:shen.<number> Parse_shen.<minus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<number>)) (kl:shen.pair (car Parse_shen.<number>) (- 0 (kl:shen.hdtl Parse_shen.<number>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<plus> (kl:shen.<plus> V2706))) (if (kl:not (kl:= (kl:fail) Parse_shen.<plus>)) (let ((Parse_shen.<number> (kl:shen.<number> Parse_shen.<plus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<number>)) (kl:shen.pair (car Parse_shen.<number>) (kl:shen.hdtl Parse_shen.<number>)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<predigits> (kl:shen.<predigits> V2706))) (if (kl:not (kl:= (kl:fail) Parse_shen.<predigits>)) (let ((Parse_shen.<stop> (kl:shen.<stop> Parse_shen.<predigits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<stop>)) (let ((Parse_shen.<postdigits> (kl:shen.<postdigits> Parse_shen.<stop>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<postdigits>)) (let ((Parse_shen.<E> (kl:shen.<E> Parse_shen.<postdigits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<E>)) (let ((Parse_shen.<log10> (kl:shen.<log10> Parse_shen.<E>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<log10>)) (kl:shen.pair (car Parse_shen.<log10>) (* (kl:shen.expt 10 (kl:shen.hdtl Parse_shen.<log10>)) (+ (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<predigits>)) 0) (kl:shen.post (kl:shen.hdtl Parse_shen.<postdigits>) 1)))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<digits> (kl:shen.<digits> V2706))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (let ((Parse_shen.<E> (kl:shen.<E> Parse_shen.<digits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<E>)) (let ((Parse_shen.<log10> (kl:shen.<log10> Parse_shen.<E>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<log10>)) (kl:shen.pair (car Parse_shen.<log10>) (* (kl:shen.expt 10 (kl:shen.hdtl Parse_shen.<log10>)) (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<predigits> (kl:shen.<predigits> V2706))) (if (kl:not (kl:= (kl:fail) Parse_shen.<predigits>)) (let ((Parse_shen.<stop> (kl:shen.<stop> Parse_shen.<predigits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<stop>)) (let ((Parse_shen.<postdigits> (kl:shen.<postdigits> Parse_shen.<stop>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<postdigits>)) (kl:shen.pair (car Parse_shen.<postdigits>) (+ (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<predigits>)) 0) (kl:shen.post (kl:shen.hdtl Parse_shen.<postdigits>) 1))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<digits> (kl:shen.<digits> V2706))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0)) (kl:fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse))) (export shen.<number>) (quote shen.<number>))
(begin (register-function-arity (quote shen.<E>) 1) (define (kl:shen.<E> V2709) (if (and (pair? (car V2709)) (kl:= 101 (kl:shen.hdhd V2709))) (let ((NewStream2707 (kl:shen.pair (kl:shen.tlhd V2709) (kl:shen.hdtl V2709)))) (kl:shen.pair (car NewStream2707) (quote shen.skip))) (kl:fail))) (export shen.<E>) (quote shen.<E>))
(begin (register-function-arity (quote shen.<log10>) 1) (define (kl:shen.<log10> V2711) (let ((YaccParse (let ((Parse_shen.<minus> (kl:shen.<minus> V2711))) (if (kl:not (kl:= (kl:fail) Parse_shen.<minus>)) (let ((Parse_shen.<digits> (kl:shen.<digits> Parse_shen.<minus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (- 0 (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<digits> (kl:shen.<digits> V2711))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0)) (kl:fail))) YaccParse))) (export shen.<log10>) (quote shen.<log10>))
(begin (register-function-arity (quote shen.<plus>) 1) (define (kl:shen.<plus> V2713) (if (pair? (car V2713)) (let ((Parse_Char (kl:shen.hdhd V2713))) (if (kl:= Parse_Char 43) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2713) (kl:shen.hdtl V2713))) Parse_Char) (kl:fail))) (kl:fail))) (export shen.<plus>) (quote shen.<plus>))
(begin (register-function-arity (quote shen.<stop>) 1) (define (kl:shen.<stop> V2715) (if (pair? (car V2715)) (let ((Parse_Char (kl:shen.hdhd V2715))) (if (kl:= Parse_Char 46) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2715) (kl:shen.hdtl V2715))) Parse_Char) (kl:fail))) (kl:fail))) (export shen.<stop>) (quote shen.<stop>))
(begin (register-function-arity (quote shen.<predigits>) 1) (define (kl:shen.<predigits> V2717) (let ((YaccParse (let ((Parse_shen.<digits> (kl:shen.<digits> V2717))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.hdtl Parse_shen.<digits>)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2717))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<predigits>) (quote shen.<predigits>))
(begin (register-function-arity (quote shen.<postdigits>) 1) (define (kl:shen.<postdigits> V2719) (let ((Parse_shen.<digits> (kl:shen.<digits> V2719))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.hdtl Parse_shen.<digits>)) (kl:fail)))) (export shen.<postdigits>) (quote shen.<postdigits>))
(begin (register-function-arity (quote shen.<digits>) 1) (define (kl:shen.<digits> V2721) (let ((YaccParse (let ((Parse_shen.<digit> (kl:shen.<digit> V2721))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digit>)) (let ((Parse_shen.<digits> (kl:shen.<digits> Parse_shen.<digit>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (cons (kl:shen.hdtl Parse_shen.<digit>) (kl:shen.hdtl Parse_shen.<digits>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<digit> (kl:shen.<digit> V2721))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digit>)) (kl:shen.pair (car Parse_shen.<digit>) (cons (kl:shen.hdtl Parse_shen.<digit>) (quote ()))) (kl:fail))) YaccParse))) (export shen.<digits>) (quote shen.<digits>))
(begin (register-function-arity (quote shen.<digit>) 1) (define (kl:shen.<digit> V2723) (if (pair? (car V2723)) (let ((Parse_X (kl:shen.hdhd V2723))) (if (assert-boolean (kl:shen.numbyte? Parse_X)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2723) (kl:shen.hdtl V2723))) (kl:shen.byte->digit Parse_X)) (kl:fail))) (kl:fail))) (export shen.<digit>) (quote shen.<digit>))
(begin (register-function-arity (quote shen.byte->digit) 1) (define (kl:shen.byte->digit V2725) (cond ((kl:= 48 V2725) 0) ((kl:= 49 V2725) 1) ((kl:= 50 V2725) 2) ((kl:= 51 V2725) 3) ((kl:= 52 V2725) 4) ((kl:= 53 V2725) 5) ((kl:= 54 V2725) 6) ((kl:= 55 V2725) 7) ((kl:= 56 V2725) 8) ((kl:= 57 V2725) 9) (#t (kl:shen.f_error (quote shen.byte->digit))))) (export shen.byte->digit) (quote shen.byte->digit))
(begin (register-function-arity (quote shen.pre) 2) (define (kl:shen.pre V2730 V2731) (cond ((null? V2730) 0) ((pair? V2730) (+ (* (kl:shen.expt 10 V2731) (car V2730)) (kl:shen.pre (cdr V2730) (+ V2731 1)))) (#t (kl:shen.f_error (quote shen.pre))))) (export shen.pre) (quote shen.pre))
(begin (register-function-arity (quote shen.post) 2) (define (kl:shen.post V2736 V2737) (cond ((null? V2736) 0) ((pair? V2736) (+ (* (kl:shen.expt 10 (- 0 V2737)) (car V2736)) (kl:shen.post (cdr V2736) (+ V2737 1)))) (#t (kl:shen.f_error (quote shen.post))))) (export shen.post) (quote shen.post))
(begin (register-function-arity (quote shen.expt) 2) (define (kl:shen.expt V2742 V2743) (cond ((kl:= 0 V2743) 1) ((> V2743 0) (* V2742 (kl:shen.expt V2742 (- V2743 1)))) (#t (* 1 (/ (kl:shen.expt V2742 (+ V2743 1)) V2742))))) (export shen.expt) (quote shen.expt))
(begin (register-function-arity (quote shen.<st_input1>) 1) (define (kl:shen.<st_input1> V2745) (let ((Parse_shen.<st_input> (kl:shen.<st_input> V2745))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail)))) (export shen.<st_input1>) (quote shen.<st_input1>))
(begin (register-function-arity (quote shen.<st_input2>) 1) (define (kl:shen.<st_input2> V2747) (let ((Parse_shen.<st_input> (kl:shen.<st_input> V2747))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail)))) (export shen.<st_input2>) (quote shen.<st_input2>))
(begin (register-function-arity (quote shen.<comment>) 1) (define (kl:shen.<comment> V2749) (let ((YaccParse (let ((Parse_shen.<singleline> (kl:shen.<singleline> V2749))) (if (kl:not (kl:= (kl:fail) Parse_shen.<singleline>)) (kl:shen.pair (car Parse_shen.<singleline>) (quote shen.skip)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<multiline> (kl:shen.<multiline> V2749))) (if (kl:not (kl:= (kl:fail) Parse_shen.<multiline>)) (kl:shen.pair (car Parse_shen.<multiline>) (quote shen.skip)) (kl:fail))) YaccParse))) (export shen.<comment>) (quote shen.<comment>))
(begin (register-function-arity (quote shen.<singleline>) 1) (define (kl:shen.<singleline> V2751) (let ((Parse_shen.<backslash> (kl:shen.<backslash> V2751))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (let ((Parse_shen.<backslash> (kl:shen.<backslash> Parse_shen.<backslash>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (let ((Parse_shen.<anysingle> (kl:shen.<anysingle> Parse_shen.<backslash>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anysingle>)) (let ((Parse_shen.<return> (kl:shen.<return> Parse_shen.<anysingle>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<return>)) (kl:shen.pair (car Parse_shen.<return>) (quote shen.skip)) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail)))) (export shen.<singleline>) (quote shen.<singleline>))
(begin (register-function-arity (quote shen.<backslash>) 1) (define (kl:shen.<backslash> V2754) (if (and (pair? (car V2754)) (kl:= 92 (kl:shen.hdhd V2754))) (let ((NewStream2752 (kl:shen.pair (kl:shen.tlhd V2754) (kl:shen.hdtl V2754)))) (kl:shen.pair (car NewStream2752) (quote shen.skip))) (kl:fail))) (export shen.<backslash>) (quote shen.<backslash>))
(begin (register-function-arity (quote shen.<anysingle>) 1) (define (kl:shen.<anysingle> V2756) (let ((YaccParse (let ((Parse_shen.<non-return> (kl:shen.<non-return> V2756))) (if (kl:not (kl:= (kl:fail) Parse_shen.<non-return>)) (let ((Parse_shen.<anysingle> (kl:shen.<anysingle> Parse_shen.<non-return>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anysingle>)) (kl:shen.pair (car Parse_shen.<anysingle>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2756))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote shen.skip)) (kl:fail))) YaccParse))) (export shen.<anysingle>) (quote shen.<anysingle>))
(begin (register-function-arity (quote shen.<non-return>) 1) (define (kl:shen.<non-return> V2758) (if (pair? (car V2758)) (let ((Parse_X (kl:shen.hdhd V2758))) (if (kl:not (kl:element? Parse_X (cons 10 (cons 13 (quote ()))))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2758) (kl:shen.hdtl V2758))) (quote shen.skip)) (kl:fail))) (kl:fail))) (export shen.<non-return>) (quote shen.<non-return>))
(begin (register-function-arity (quote shen.<return>) 1) (define (kl:shen.<return> V2760) (if (pair? (car V2760)) (let ((Parse_X (kl:shen.hdhd V2760))) (if (kl:element? Parse_X (cons 10 (cons 13 (quote ())))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2760) (kl:shen.hdtl V2760))) (quote shen.skip)) (kl:fail))) (kl:fail))) (export shen.<return>) (quote shen.<return>))
(begin (register-function-arity (quote shen.<multiline>) 1) (define (kl:shen.<multiline> V2762) (let ((Parse_shen.<backslash> (kl:shen.<backslash> V2762))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (let ((Parse_shen.<times> (kl:shen.<times> Parse_shen.<backslash>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<times>)) (let ((Parse_shen.<anymulti> (kl:shen.<anymulti> Parse_shen.<times>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anymulti>)) (kl:shen.pair (car Parse_shen.<anymulti>) (quote shen.skip)) (kl:fail))) (kl:fail))) (kl:fail)))) (export shen.<multiline>) (quote shen.<multiline>))
(begin (register-function-arity (quote shen.<times>) 1) (define (kl:shen.<times> V2765) (if (and (pair? (car V2765)) (kl:= 42 (kl:shen.hdhd V2765))) (let ((NewStream2763 (kl:shen.pair (kl:shen.tlhd V2765) (kl:shen.hdtl V2765)))) (kl:shen.pair (car NewStream2763) (quote shen.skip))) (kl:fail))) (export shen.<times>) (quote shen.<times>))
(begin (register-function-arity (quote shen.<anymulti>) 1) (define (kl:shen.<anymulti> V2767) (let ((YaccParse (let ((Parse_shen.<comment> (kl:shen.<comment> V2767))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comment>)) (let ((Parse_shen.<anymulti> (kl:shen.<anymulti> Parse_shen.<comment>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anymulti>)) (kl:shen.pair (car Parse_shen.<anymulti>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<times> (kl:shen.<times> V2767))) (if (kl:not (kl:= (kl:fail) Parse_shen.<times>)) (let ((Parse_shen.<backslash> (kl:shen.<backslash> Parse_shen.<times>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (kl:shen.pair (car Parse_shen.<backslash>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (if (pair? (car V2767)) (let ((Parse_X (kl:shen.hdhd V2767))) (let ((Parse_shen.<anymulti> (kl:shen.<anymulti> (kl:shen.pair (kl:shen.tlhd V2767) (kl:shen.hdtl V2767))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anymulti>)) (kl:shen.pair (car Parse_shen.<anymulti>) (quote shen.skip)) (kl:fail)))) (kl:fail)) YaccParse)) YaccParse))) (export shen.<anymulti>) (quote shen.<anymulti>))
(begin (register-function-arity (quote shen.<whitespaces>) 1) (define (kl:shen.<whitespaces> V2769) (let ((YaccParse (let ((Parse_shen.<whitespace> (kl:shen.<whitespace> V2769))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespace>)) (let ((Parse_shen.<whitespaces> (kl:shen.<whitespaces> Parse_shen.<whitespace>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespaces>)) (kl:shen.pair (car Parse_shen.<whitespaces>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<whitespace> (kl:shen.<whitespace> V2769))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespace>)) (kl:shen.pair (car Parse_shen.<whitespace>) (quote shen.skip)) (kl:fail))) YaccParse))) (export shen.<whitespaces>) (quote shen.<whitespaces>))
(begin (register-function-arity (quote shen.<whitespace>) 1) (define (kl:shen.<whitespace> V2771) (if (pair? (car V2771)) (let ((Parse_X (kl:shen.hdhd V2771))) (if (assert-boolean (let ((Parse_Case Parse_X)) (or (kl:= Parse_Case 32) (or (kl:= Parse_Case 13) (or (kl:= Parse_Case 10) (kl:= Parse_Case 9)))))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2771) (kl:shen.hdtl V2771))) (quote shen.skip)) (kl:fail))) (kl:fail))) (export shen.<whitespace>) (quote shen.<whitespace>))
(begin (register-function-arity (quote shen.cons_form) 1) (define (kl:shen.cons_form V2773) (cond ((null? V2773) (quote ())) ((and (pair? V2773) (and (pair? (cdr V2773)) (and (pair? (cdr (cdr V2773))) (and (null? (cdr (cdr (cdr V2773)))) (eq? (car (cdr V2773)) (quote bar!)))))) (cons (quote cons) (cons (car V2773) (cdr (cdr V2773))))) ((pair? V2773) (cons (quote cons) (cons (car V2773) (cons (kl:shen.cons_form (cdr V2773)) (quote ()))))) (#t (kl:shen.f_error (quote shen.cons_form))))) (export shen.cons_form) (quote shen.cons_form))
(begin (register-function-arity (quote shen.package-macro) 2) (define (kl:shen.package-macro V2778 V2779) (cond ((and (pair? V2778) (and (eq? (quote _waspvm_dl_) (car V2778)) (and (pair? (cdr V2778)) (null? (cdr (cdr V2778)))))) (kl:append (kl:explode (car (cdr V2778))) V2779)) ((and (pair? V2778) (and (eq? (quote package) (car V2778)) (and (pair? (cdr V2778)) (and (eq? (quote null) (car (cdr V2778))) (pair? (cdr (cdr V2778))))))) (kl:append (cdr (cdr (cdr V2778))) V2779)) ((and (pair? V2778) (and (eq? (quote package) (car V2778)) (and (pair? (cdr V2778)) (pair? (cdr (cdr V2778)))))) (let ((ListofExceptions (kl:shen.eval-without-macros (car (cdr (cdr V2778)))))) (let ((External (kl:shen.record-exceptions ListofExceptions (car (cdr V2778))))) (let ((PackageNameDot (kl:intern (string-append (kl:str (car (cdr V2778))) ".")))) (let ((ExpPackageNameDot (kl:explode PackageNameDot))) (let ((Packaged (kl:shen.packageh PackageNameDot ListofExceptions (cdr (cdr (cdr V2778))) ExpPackageNameDot))) (let ((Internal (kl:shen.record-internal (car (cdr V2778)) (kl:shen.internal-symbols ExpPackageNameDot Packaged)))) (kl:append Packaged V2779)))))))) (#t (cons V2778 V2779)))) (export shen.package-macro) (quote shen.package-macro))
(begin (register-function-arity (quote shen.record-exceptions) 2) (define (kl:shen.record-exceptions V2782 V2783) (let ((CurrExceptions (guard (lambda (E) (quote ())) (kl:get V2783 (quote shen.external-symbols) (kl:value (quote *property-vector*)))))) (let ((AllExceptions (kl:union V2782 CurrExceptions))) (kl:put V2783 (quote shen.external-symbols) AllExceptions (kl:value (quote *property-vector*)))))) (export shen.record-exceptions) (quote shen.record-exceptions))
(begin (register-function-arity (quote shen.record-internal) 2) (define (kl:shen.record-internal V2786 V2787) (kl:put V2786 (quote shen.internal-symbols) (kl:union V2787 (guard (lambda (E) (quote ())) (kl:get V2786 (quote shen.internal-symbols) (kl:value (quote *property-vector*))))) (kl:value (quote *property-vector*)))) (export shen.record-internal) (quote shen.record-internal))
(begin (register-function-arity (quote shen.internal-symbols) 2) (define (kl:shen.internal-symbols V2798 V2799) (cond ((and (kl:symbol? V2799) (assert-boolean (kl:shen.prefix? V2798 (kl:explode V2799)))) (cons V2799 (quote ()))) ((pair? V2799) (kl:union (kl:shen.internal-symbols V2798 (car V2799)) (kl:shen.internal-symbols V2798 (cdr V2799)))) (#t (quote ())))) (export shen.internal-symbols) (quote shen.internal-symbols))
(begin (register-function-arity (quote shen.packageh) 4) (define (kl:shen.packageh V2816 V2817 V2818 V2819) (cond ((pair? V2818) (cons (kl:shen.packageh V2816 V2817 (car V2818) V2819) (kl:shen.packageh V2816 V2817 (cdr V2818) V2819))) ((or (assert-boolean (kl:shen.sysfunc? V2818)) (or (kl:variable? V2818) (or (kl:element? V2818 V2817) (or (assert-boolean (kl:shen.doubleunderline? V2818)) (assert-boolean (kl:shen.singleunderline? V2818)))))) V2818) ((and (kl:symbol? V2818) (assert-boolean (let ((ExplodeX (kl:explode V2818))) (and (kl:not (kl:shen.prefix? (cons "s" (cons "h" (cons "e" (cons "n" (cons "." (quote ())))))) ExplodeX)) (kl:not (kl:shen.prefix? V2819 ExplodeX)))))) (kl:concat V2816 V2818)) (#t V2818))) (export shen.packageh) (quote shen.packageh))
