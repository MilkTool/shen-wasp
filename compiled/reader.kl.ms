"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote read-char-code) 1) (define (kl:read-char-code V2336) (read-u8 V2336)) (quote read-char-code))
(begin (register-function-arity (quote read-file-as-bytelist) 1) (define (kl:read-file-as-bytelist V2338) (kl:shen.read-file-as-Xlist V2338 (lambda (S) (read-u8 S)))) (quote read-file-as-bytelist))
(begin (register-function-arity (quote read-file-as-charlist) 1) (define (kl:read-file-as-charlist V2340) (kl:shen.read-file-as-Xlist V2340 (lambda (S) (kl:read-char-code S)))) (quote read-file-as-charlist))
(begin (register-function-arity (quote shen.read-file-as-Xlist) 2) (define (kl:shen.read-file-as-Xlist V2343 V2344) (let ((Stream (kl:open V2343 (quote in)))) (let ((X (V2344 Stream))) (let ((Xs (kl:shen.read-file-as-Xlist-help Stream V2344 X (quote ())))) (let ((Close (kl:close Stream))) (kl:reverse Xs)))))) (quote shen.read-file-as-Xlist))
(begin (register-function-arity (quote shen.read-file-as-Xlist-help) 4) (define (kl:shen.read-file-as-Xlist-help V2349 V2350 V2351 V2352) (cond ((kl:= -1 V2351) V2352) (#t (kl:shen.read-file-as-Xlist-help V2349 V2350 (V2350 V2349) (cons V2351 V2352))))) (quote shen.read-file-as-Xlist-help))
(begin (register-function-arity (quote read-file-as-string) 1) (define (kl:read-file-as-string V2354) (let ((Stream (kl:open V2354 (quote in)))) (kl:shen.rfas-h Stream (kl:read-char-code Stream) ""))) (quote read-file-as-string))
(begin (register-function-arity (quote shen.rfas-h) 3) (define (kl:shen.rfas-h V2358 V2359 V2360) (cond ((kl:= -1 V2359) (begin (kl:close V2358) V2360)) (#t (kl:shen.rfas-h V2358 (kl:read-char-code V2358) (string-append V2360 (make-string 1 V2359)))))) (quote shen.rfas-h))
(begin (register-function-arity (quote input) 1) (define (kl:input V2362) (kl:eval-kl (kl:read V2362))) (quote input))
(begin (register-function-arity (quote input+) 2) (define (kl:input+ V2365 V2366) (let ((Mono? (kl:shen.monotype V2365))) (let ((Input (kl:read V2366))) (if (kl:= #f (kl:shen.typecheck Input (kl:shen.demodulate V2365))) (simple-error (string-append "type error: " (kl:shen.app Input (string-append " is not of type " (kl:shen.app V2365 "\n" (quote shen.r))) (quote shen.r)))) (kl:eval-kl Input))))) (quote input+))
(begin (register-function-arity (quote shen.monotype) 1) (define (kl:shen.monotype V2368) (cond ((pair? V2368) (kl:map (lambda (Z) (kl:shen.monotype Z)) V2368)) (#t (if (kl:variable? V2368) (simple-error (string-append "input+ expects a monotype: not " (kl:shen.app V2368 "\n" (quote shen.a)))) V2368)))) (quote shen.monotype))
(begin (register-function-arity (quote read) 1) (define (kl:read V2370) (car (kl:shen.read-loop V2370 (kl:read-char-code V2370) (quote ())))) (quote read))
(begin (register-function-arity (quote it) 0) (define (kl:it) (kl:value (quote shen.*it*))) (quote it))
(begin (register-function-arity (quote shen.read-loop) 3) (define (kl:shen.read-loop V2378 V2379 V2380) (cond ((kl:= 94 V2379) (simple-error "read aborted")) ((kl:= -1 V2379) (if (kl:empty? V2380) (simple-error "error: empty stream") (kl:compile (lambda (X) (kl:shen.<st_input> X)) V2380 (lambda (E) E)))) ((assert-boolean (kl:shen.terminator? V2379)) (let ((AllChars (kl:append V2380 (cons V2379 (quote ()))))) (let ((It (kl:shen.record-it AllChars))) (let ((Read (kl:compile (lambda (X) (kl:shen.<st_input> X)) AllChars (lambda (E) (quote shen.nextbyte))))) (if (or (eq? Read (quote shen.nextbyte)) (kl:empty? Read)) (kl:shen.read-loop V2378 (kl:read-char-code V2378) AllChars) Read))))) (#t (kl:shen.read-loop V2378 (kl:read-char-code V2378) (kl:append V2380 (cons V2379 (quote ()))))))) (quote shen.read-loop))
(begin (register-function-arity (quote shen.terminator?) 1) (define (kl:shen.terminator? V2382) (kl:element? V2382 (cons 9 (cons 10 (cons 13 (cons 32 (cons 34 (cons 41 (cons 93 (quote ())))))))))) (quote shen.terminator?))
(begin (register-function-arity (quote lineread) 1) (define (kl:lineread V2384) (kl:shen.lineread-loop (kl:read-char-code V2384) (quote ()) V2384)) (quote lineread))
(begin (register-function-arity (quote shen.lineread-loop) 3) (define (kl:shen.lineread-loop V2389 V2390 V2391) (cond ((kl:= -1 V2389) (if (kl:empty? V2390) (simple-error "empty stream") (kl:compile (lambda (X) (kl:shen.<st_input> X)) V2390 (lambda (E) E)))) ((kl:= V2389 (kl:shen.hat)) (simple-error "line read aborted")) ((kl:element? V2389 (cons (kl:shen.newline) (cons (kl:shen.carriage-return) (quote ())))) (let ((Line (kl:compile (lambda (X) (kl:shen.<st_input> X)) V2390 (lambda (E) (quote shen.nextline))))) (let ((It (kl:shen.record-it V2390))) (if (or (eq? Line (quote shen.nextline)) (kl:empty? Line)) (kl:shen.lineread-loop (kl:read-char-code V2391) (kl:append V2390 (cons V2389 (quote ()))) V2391) Line)))) (#t (kl:shen.lineread-loop (kl:read-char-code V2391) (kl:append V2390 (cons V2389 (quote ()))) V2391)))) (quote shen.lineread-loop))
(begin (register-function-arity (quote shen.record-it) 1) (define (kl:shen.record-it V2393) (let ((TrimLeft (kl:shen.trim-whitespace V2393))) (let ((TrimRight (kl:shen.trim-whitespace (kl:reverse TrimLeft)))) (let ((Trimmed (kl:reverse TrimRight))) (kl:shen.record-it-h Trimmed))))) (quote shen.record-it))
(begin (register-function-arity (quote shen.trim-whitespace) 1) (define (kl:shen.trim-whitespace V2395) (cond ((and (pair? V2395) (kl:element? (car V2395) (cons 9 (cons 10 (cons 13 (cons 32 (quote ()))))))) (kl:shen.trim-whitespace (cdr V2395))) (#t V2395))) (quote shen.trim-whitespace))
(begin (register-function-arity (quote shen.record-it-h) 1) (define (kl:shen.record-it-h V2397) (begin (kl:set (quote shen.*it*) (kl:shen.cn-all (kl:map (lambda (X) (make-string 1 X)) V2397))) V2397)) (quote shen.record-it-h))
(begin (register-function-arity (quote shen.cn-all) 1) (define (kl:shen.cn-all V2399) (cond ((null? V2399) "") ((pair? V2399) (string-append (car V2399) (kl:shen.cn-all (cdr V2399)))) (#t (kl:shen.f_error (quote shen.cn-all))))) (quote shen.cn-all))
(begin (register-function-arity (quote read-file) 1) (define (kl:read-file V2401) (let ((Charlist (kl:read-file-as-charlist V2401))) (kl:compile (lambda (X) (kl:shen.<st_input> X)) Charlist (lambda (X) (kl:shen.read-error X))))) (quote read-file))
(begin (register-function-arity (quote read-from-string) 1) (define (kl:read-from-string V2403) (let ((Ns (kl:map (lambda (X) (string-ref X 0)) (kl:explode V2403)))) (kl:compile (lambda (X) (kl:shen.<st_input> X)) Ns (lambda (X) (kl:shen.read-error X))))) (quote read-from-string))
(begin (register-function-arity (quote shen.read-error) 1) (define (kl:shen.read-error V2411) (cond ((and (pair? V2411) (and (pair? (car V2411)) (and (pair? (cdr V2411)) (null? (cdr (cdr V2411)))))) (simple-error (string-append "read error here:\n\n " (kl:shen.app (kl:shen.compress-50 50 (car V2411)) "\n" (quote shen.a))))) (#t (simple-error "read error\n")))) (quote shen.read-error))
(begin (register-function-arity (quote shen.compress-50) 2) (define (kl:shen.compress-50 V2418 V2419) (cond ((null? V2419) "") ((kl:= 0 V2418) "") ((pair? V2419) (string-append (make-string 1 (car V2419)) (kl:shen.compress-50 (- V2418 1) (cdr V2419)))) (#t (kl:shen.f_error (quote shen.compress-50))))) (quote shen.compress-50))
(begin (register-function-arity (quote shen.<st_input>) 1) (define (kl:shen.<st_input> V2421) (let ((YaccParse (let ((Parse_shen.<lsb> (kl:shen.<lsb> V2421))) (if (kl:not (kl:= (kl:fail) Parse_shen.<lsb>)) (let ((Parse_shen.<st_input1> (kl:shen.<st_input1> Parse_shen.<lsb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input1>)) (let ((Parse_shen.<rsb> (kl:shen.<rsb> Parse_shen.<st_input1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rsb>)) (let ((Parse_shen.<st_input2> (kl:shen.<st_input2> Parse_shen.<rsb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input2>)) (kl:shen.pair (car Parse_shen.<st_input2>) (cons (kl:macroexpand (kl:shen.cons_form (kl:shen.hdtl Parse_shen.<st_input1>))) (kl:shen.hdtl Parse_shen.<st_input2>))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<lrb> (kl:shen.<lrb> V2421))) (if (kl:not (kl:= (kl:fail) Parse_shen.<lrb>)) (let ((Parse_shen.<st_input1> (kl:shen.<st_input1> Parse_shen.<lrb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input1>)) (let ((Parse_shen.<rrb> (kl:shen.<rrb> Parse_shen.<st_input1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rrb>)) (let ((Parse_shen.<st_input2> (kl:shen.<st_input2> Parse_shen.<rrb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input2>)) (kl:shen.pair (car Parse_shen.<st_input2>) (kl:shen.package-macro (kl:macroexpand (kl:shen.hdtl Parse_shen.<st_input1>)) (kl:shen.hdtl Parse_shen.<st_input2>))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<lcurly> (kl:shen.<lcurly> V2421))) (if (kl:not (kl:= (kl:fail) Parse_shen.<lcurly>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<lcurly>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote {) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<rcurly> (kl:shen.<rcurly> V2421))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rcurly>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<rcurly>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote }) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<bar> (kl:shen.<bar> V2421))) (if (kl:not (kl:= (kl:fail) Parse_shen.<bar>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<bar>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote bar!) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<semicolon> (kl:shen.<semicolon> V2421))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<semicolon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote _waspvm_sc_) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<colon> (kl:shen.<colon> V2421))) (if (kl:not (kl:= (kl:fail) Parse_shen.<colon>)) (let ((Parse_shen.<equal> (kl:shen.<equal> Parse_shen.<colon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<equal>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<equal>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote :=) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<colon> (kl:shen.<colon> V2421))) (if (kl:not (kl:= (kl:fail) Parse_shen.<colon>)) (let ((Parse_shen.<minus> (kl:shen.<minus> Parse_shen.<colon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<minus>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<minus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote :-) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<colon> (kl:shen.<colon> V2421))) (if (kl:not (kl:= (kl:fail) Parse_shen.<colon>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<colon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote :) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<comma> (kl:shen.<comma> V2421))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comma>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<comma>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (kl:intern ",") (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<comment> (kl:shen.<comment> V2421))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comment>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<comment>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<atom> (kl:shen.<atom> V2421))) (if (kl:not (kl:= (kl:fail) Parse_shen.<atom>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<atom>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (kl:macroexpand (kl:shen.hdtl Parse_shen.<atom>)) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<whitespaces> (kl:shen.<whitespaces> V2421))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespaces>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<whitespaces>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2421))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse))) (quote shen.<st_input>))
(begin (register-function-arity (quote shen.<lsb>) 1) (define (kl:shen.<lsb> V2423) (if (and (pair? (car V2423)) (kl:= 91 (car (car V2423)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2423)) (kl:shen.hdtl V2423))) (quote shen.skip)) (kl:fail))) (quote shen.<lsb>))
(begin (register-function-arity (quote shen.<rsb>) 1) (define (kl:shen.<rsb> V2425) (if (and (pair? (car V2425)) (kl:= 93 (car (car V2425)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2425)) (kl:shen.hdtl V2425))) (quote shen.skip)) (kl:fail))) (quote shen.<rsb>))
(begin (register-function-arity (quote shen.<lcurly>) 1) (define (kl:shen.<lcurly> V2427) (if (and (pair? (car V2427)) (kl:= 123 (car (car V2427)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2427)) (kl:shen.hdtl V2427))) (quote shen.skip)) (kl:fail))) (quote shen.<lcurly>))
(begin (register-function-arity (quote shen.<rcurly>) 1) (define (kl:shen.<rcurly> V2429) (if (and (pair? (car V2429)) (kl:= 125 (car (car V2429)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2429)) (kl:shen.hdtl V2429))) (quote shen.skip)) (kl:fail))) (quote shen.<rcurly>))
(begin (register-function-arity (quote shen.<bar>) 1) (define (kl:shen.<bar> V2431) (if (and (pair? (car V2431)) (kl:= 124 (car (car V2431)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2431)) (kl:shen.hdtl V2431))) (quote shen.skip)) (kl:fail))) (quote shen.<bar>))
(begin (register-function-arity (quote shen.<semicolon>) 1) (define (kl:shen.<semicolon> V2433) (if (and (pair? (car V2433)) (kl:= 59 (car (car V2433)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2433)) (kl:shen.hdtl V2433))) (quote shen.skip)) (kl:fail))) (quote shen.<semicolon>))
(begin (register-function-arity (quote shen.<colon>) 1) (define (kl:shen.<colon> V2435) (if (and (pair? (car V2435)) (kl:= 58 (car (car V2435)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2435)) (kl:shen.hdtl V2435))) (quote shen.skip)) (kl:fail))) (quote shen.<colon>))
(begin (register-function-arity (quote shen.<comma>) 1) (define (kl:shen.<comma> V2437) (if (and (pair? (car V2437)) (kl:= 44 (car (car V2437)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2437)) (kl:shen.hdtl V2437))) (quote shen.skip)) (kl:fail))) (quote shen.<comma>))
(begin (register-function-arity (quote shen.<equal>) 1) (define (kl:shen.<equal> V2439) (if (and (pair? (car V2439)) (kl:= 61 (car (car V2439)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2439)) (kl:shen.hdtl V2439))) (quote shen.skip)) (kl:fail))) (quote shen.<equal>))
(begin (register-function-arity (quote shen.<minus>) 1) (define (kl:shen.<minus> V2441) (if (and (pair? (car V2441)) (kl:= 45 (car (car V2441)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2441)) (kl:shen.hdtl V2441))) (quote shen.skip)) (kl:fail))) (quote shen.<minus>))
(begin (register-function-arity (quote shen.<lrb>) 1) (define (kl:shen.<lrb> V2443) (if (and (pair? (car V2443)) (kl:= 40 (car (car V2443)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2443)) (kl:shen.hdtl V2443))) (quote shen.skip)) (kl:fail))) (quote shen.<lrb>))
(begin (register-function-arity (quote shen.<rrb>) 1) (define (kl:shen.<rrb> V2445) (if (and (pair? (car V2445)) (kl:= 41 (car (car V2445)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2445)) (kl:shen.hdtl V2445))) (quote shen.skip)) (kl:fail))) (quote shen.<rrb>))
(begin (register-function-arity (quote shen.<atom>) 1) (define (kl:shen.<atom> V2447) (let ((YaccParse (let ((Parse_shen.<str> (kl:shen.<str> V2447))) (if (kl:not (kl:= (kl:fail) Parse_shen.<str>)) (kl:shen.pair (car Parse_shen.<str>) (kl:shen.control-chars (kl:shen.hdtl Parse_shen.<str>))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<number> (kl:shen.<number> V2447))) (if (kl:not (kl:= (kl:fail) Parse_shen.<number>)) (kl:shen.pair (car Parse_shen.<number>) (kl:shen.hdtl Parse_shen.<number>)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<sym> (kl:shen.<sym> V2447))) (if (kl:not (kl:= (kl:fail) Parse_shen.<sym>)) (kl:shen.pair (car Parse_shen.<sym>) (if (equal? (kl:shen.hdtl Parse_shen.<sym>) "<>") (cons (quote vector) (cons 0 (quote ()))) (kl:intern (kl:shen.hdtl Parse_shen.<sym>)))) (kl:fail))) YaccParse)) YaccParse))) (quote shen.<atom>))
(begin (register-function-arity (quote shen.control-chars) 1) (define (kl:shen.control-chars V2449) (cond ((null? V2449) "") ((and (pair? V2449) (and (equal? "c" (car V2449)) (and (pair? (cdr V2449)) (equal? "#" (car (cdr V2449)))))) (let ((CodePoint (kl:shen.code-point (cdr (cdr V2449))))) (let ((AfterCodePoint (kl:shen.after-codepoint (cdr (cdr V2449))))) (kl:_waspvm_at_s (make-string 1 (kl:shen.decimalise CodePoint)) (kl:shen.control-chars AfterCodePoint))))) ((pair? V2449) (kl:_waspvm_at_s (car V2449) (kl:shen.control-chars (cdr V2449)))) (#t (kl:shen.f_error (quote shen.control-chars))))) (quote shen.control-chars))
(begin (register-function-arity (quote shen.code-point) 1) (define (kl:shen.code-point V2453) (cond ((and (pair? V2453) (equal? ";" (car V2453))) "") ((and (pair? V2453) (kl:element? (car V2453) (cons "0" (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" (quote ())))))))))))))) (cons (car V2453) (kl:shen.code-point (cdr V2453)))) (#t (simple-error (string-append "code point parse error " (kl:shen.app V2453 "\n" (quote shen.a))))))) (quote shen.code-point))
(begin (register-function-arity (quote shen.after-codepoint) 1) (define (kl:shen.after-codepoint V2459) (cond ((null? V2459) (quote ())) ((and (pair? V2459) (equal? ";" (car V2459))) (cdr V2459)) ((pair? V2459) (kl:shen.after-codepoint (cdr V2459))) (#t (kl:shen.f_error (quote shen.after-codepoint))))) (quote shen.after-codepoint))
(begin (register-function-arity (quote shen.decimalise) 1) (define (kl:shen.decimalise V2461) (kl:shen.pre (kl:reverse (kl:shen.digits->integers V2461)) 0)) (quote shen.decimalise))
(begin (register-function-arity (quote shen.digits->integers) 1) (define (kl:shen.digits->integers V2467) (cond ((and (pair? V2467) (equal? "0" (car V2467))) (cons 0 (kl:shen.digits->integers (cdr V2467)))) ((and (pair? V2467) (equal? "1" (car V2467))) (cons 1 (kl:shen.digits->integers (cdr V2467)))) ((and (pair? V2467) (equal? "2" (car V2467))) (cons 2 (kl:shen.digits->integers (cdr V2467)))) ((and (pair? V2467) (equal? "3" (car V2467))) (cons 3 (kl:shen.digits->integers (cdr V2467)))) ((and (pair? V2467) (equal? "4" (car V2467))) (cons 4 (kl:shen.digits->integers (cdr V2467)))) ((and (pair? V2467) (equal? "5" (car V2467))) (cons 5 (kl:shen.digits->integers (cdr V2467)))) ((and (pair? V2467) (equal? "6" (car V2467))) (cons 6 (kl:shen.digits->integers (cdr V2467)))) ((and (pair? V2467) (equal? "7" (car V2467))) (cons 7 (kl:shen.digits->integers (cdr V2467)))) ((and (pair? V2467) (equal? "8" (car V2467))) (cons 8 (kl:shen.digits->integers (cdr V2467)))) ((and (pair? V2467) (equal? "9" (car V2467))) (cons 9 (kl:shen.digits->integers (cdr V2467)))) (#t (quote ())))) (quote shen.digits->integers))
(begin (register-function-arity (quote shen.<sym>) 1) (define (kl:shen.<sym> V2469) (let ((Parse_shen.<alpha> (kl:shen.<alpha> V2469))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alpha>)) (let ((Parse_shen.<alphanums> (kl:shen.<alphanums> Parse_shen.<alpha>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alphanums>)) (kl:shen.pair (car Parse_shen.<alphanums>) (kl:_waspvm_at_s (kl:shen.hdtl Parse_shen.<alpha>) (kl:shen.hdtl Parse_shen.<alphanums>))) (kl:fail))) (kl:fail)))) (quote shen.<sym>))
(begin (register-function-arity (quote shen.<alphanums>) 1) (define (kl:shen.<alphanums> V2471) (let ((YaccParse (let ((Parse_shen.<alphanum> (kl:shen.<alphanum> V2471))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alphanum>)) (let ((Parse_shen.<alphanums> (kl:shen.<alphanums> Parse_shen.<alphanum>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alphanums>)) (kl:shen.pair (car Parse_shen.<alphanums>) (kl:_waspvm_at_s (kl:shen.hdtl Parse_shen.<alphanum>) (kl:shen.hdtl Parse_shen.<alphanums>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2471))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) "") (kl:fail))) YaccParse))) (quote shen.<alphanums>))
(begin (register-function-arity (quote shen.<alphanum>) 1) (define (kl:shen.<alphanum> V2473) (let ((YaccParse (let ((Parse_shen.<alpha> (kl:shen.<alpha> V2473))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alpha>)) (kl:shen.pair (car Parse_shen.<alpha>) (kl:shen.hdtl Parse_shen.<alpha>)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<num> (kl:shen.<num> V2473))) (if (kl:not (kl:= (kl:fail) Parse_shen.<num>)) (kl:shen.pair (car Parse_shen.<num>) (kl:shen.hdtl Parse_shen.<num>)) (kl:fail))) YaccParse))) (quote shen.<alphanum>))
(begin (register-function-arity (quote shen.<num>) 1) (define (kl:shen.<num> V2475) (if (pair? (car V2475)) (let ((Parse_Char (car (car V2475)))) (if (assert-boolean (kl:shen.numbyte? Parse_Char)) (kl:shen.pair (car (kl:shen.pair (cdr (car V2475)) (kl:shen.hdtl V2475))) (make-string 1 Parse_Char)) (kl:fail))) (kl:fail))) (quote shen.<num>))
(begin (register-function-arity (quote shen.numbyte?) 1) (define (kl:shen.numbyte? V2481) (cond ((kl:= 48 V2481) #t) ((kl:= 49 V2481) #t) ((kl:= 50 V2481) #t) ((kl:= 51 V2481) #t) ((kl:= 52 V2481) #t) ((kl:= 53 V2481) #t) ((kl:= 54 V2481) #t) ((kl:= 55 V2481) #t) ((kl:= 56 V2481) #t) ((kl:= 57 V2481) #t) (#t #f))) (quote shen.numbyte?))
(begin (register-function-arity (quote shen.<alpha>) 1) (define (kl:shen.<alpha> V2483) (if (pair? (car V2483)) (let ((Parse_Char (car (car V2483)))) (if (assert-boolean (kl:shen.symbol-code? Parse_Char)) (kl:shen.pair (car (kl:shen.pair (cdr (car V2483)) (kl:shen.hdtl V2483))) (make-string 1 Parse_Char)) (kl:fail))) (kl:fail))) (quote shen.<alpha>))
(begin (register-function-arity (quote shen.symbol-code?) 1) (define (kl:shen.symbol-code? V2485) (or (kl:= V2485 126) (or (and (> V2485 94) (< V2485 123)) (or (and (> V2485 59) (< V2485 91)) (or (and (> V2485 41) (and (< V2485 58) (kl:not (kl:= V2485 44)))) (or (and (> V2485 34) (< V2485 40)) (kl:= V2485 33))))))) (quote shen.symbol-code?))
(begin (register-function-arity (quote shen.<str>) 1) (define (kl:shen.<str> V2487) (let ((Parse_shen.<dbq> (kl:shen.<dbq> V2487))) (if (kl:not (kl:= (kl:fail) Parse_shen.<dbq>)) (let ((Parse_shen.<strcontents> (kl:shen.<strcontents> Parse_shen.<dbq>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<strcontents>)) (let ((Parse_shen.<dbq> (kl:shen.<dbq> Parse_shen.<strcontents>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<dbq>)) (kl:shen.pair (car Parse_shen.<dbq>) (kl:shen.hdtl Parse_shen.<strcontents>)) (kl:fail))) (kl:fail))) (kl:fail)))) (quote shen.<str>))
(begin (register-function-arity (quote shen.<dbq>) 1) (define (kl:shen.<dbq> V2489) (if (pair? (car V2489)) (let ((Parse_Char (car (car V2489)))) (if (kl:= Parse_Char 34) (kl:shen.pair (car (kl:shen.pair (cdr (car V2489)) (kl:shen.hdtl V2489))) Parse_Char) (kl:fail))) (kl:fail))) (quote shen.<dbq>))
(begin (register-function-arity (quote shen.<strcontents>) 1) (define (kl:shen.<strcontents> V2491) (let ((YaccParse (let ((Parse_shen.<strc> (kl:shen.<strc> V2491))) (if (kl:not (kl:= (kl:fail) Parse_shen.<strc>)) (let ((Parse_shen.<strcontents> (kl:shen.<strcontents> Parse_shen.<strc>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<strcontents>)) (kl:shen.pair (car Parse_shen.<strcontents>) (cons (kl:shen.hdtl Parse_shen.<strc>) (kl:shen.hdtl Parse_shen.<strcontents>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2491))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<strcontents>))
(begin (register-function-arity (quote shen.<byte>) 1) (define (kl:shen.<byte> V2493) (if (pair? (car V2493)) (let ((Parse_Char (car (car V2493)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2493)) (kl:shen.hdtl V2493))) (make-string 1 Parse_Char))) (kl:fail))) (quote shen.<byte>))
(begin (register-function-arity (quote shen.<strc>) 1) (define (kl:shen.<strc> V2495) (if (pair? (car V2495)) (let ((Parse_Char (car (car V2495)))) (if (kl:not (kl:= Parse_Char 34)) (kl:shen.pair (car (kl:shen.pair (cdr (car V2495)) (kl:shen.hdtl V2495))) (make-string 1 Parse_Char)) (kl:fail))) (kl:fail))) (quote shen.<strc>))
(begin (register-function-arity (quote shen.<number>) 1) (define (kl:shen.<number> V2497) (let ((YaccParse (let ((Parse_shen.<minus> (kl:shen.<minus> V2497))) (if (kl:not (kl:= (kl:fail) Parse_shen.<minus>)) (let ((Parse_shen.<number> (kl:shen.<number> Parse_shen.<minus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<number>)) (kl:shen.pair (car Parse_shen.<number>) (- 0 (kl:shen.hdtl Parse_shen.<number>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<plus> (kl:shen.<plus> V2497))) (if (kl:not (kl:= (kl:fail) Parse_shen.<plus>)) (let ((Parse_shen.<number> (kl:shen.<number> Parse_shen.<plus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<number>)) (kl:shen.pair (car Parse_shen.<number>) (kl:shen.hdtl Parse_shen.<number>)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<predigits> (kl:shen.<predigits> V2497))) (if (kl:not (kl:= (kl:fail) Parse_shen.<predigits>)) (let ((Parse_shen.<stop> (kl:shen.<stop> Parse_shen.<predigits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<stop>)) (let ((Parse_shen.<postdigits> (kl:shen.<postdigits> Parse_shen.<stop>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<postdigits>)) (let ((Parse_shen.<E> (kl:shen.<E> Parse_shen.<postdigits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<E>)) (let ((Parse_shen.<log10> (kl:shen.<log10> Parse_shen.<E>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<log10>)) (kl:shen.pair (car Parse_shen.<log10>) (* (kl:shen.expt 10 (kl:shen.hdtl Parse_shen.<log10>)) (+ (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<predigits>)) 0) (kl:shen.post (kl:shen.hdtl Parse_shen.<postdigits>) 1)))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<digits> (kl:shen.<digits> V2497))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (let ((Parse_shen.<E> (kl:shen.<E> Parse_shen.<digits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<E>)) (let ((Parse_shen.<log10> (kl:shen.<log10> Parse_shen.<E>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<log10>)) (kl:shen.pair (car Parse_shen.<log10>) (* (kl:shen.expt 10 (kl:shen.hdtl Parse_shen.<log10>)) (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<predigits> (kl:shen.<predigits> V2497))) (if (kl:not (kl:= (kl:fail) Parse_shen.<predigits>)) (let ((Parse_shen.<stop> (kl:shen.<stop> Parse_shen.<predigits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<stop>)) (let ((Parse_shen.<postdigits> (kl:shen.<postdigits> Parse_shen.<stop>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<postdigits>)) (kl:shen.pair (car Parse_shen.<postdigits>) (+ (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<predigits>)) 0) (kl:shen.post (kl:shen.hdtl Parse_shen.<postdigits>) 1))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<digits> (kl:shen.<digits> V2497))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0)) (kl:fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse))) (quote shen.<number>))
(begin (register-function-arity (quote shen.<E>) 1) (define (kl:shen.<E> V2499) (if (and (pair? (car V2499)) (kl:= 101 (car (car V2499)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2499)) (kl:shen.hdtl V2499))) (quote shen.skip)) (kl:fail))) (quote shen.<E>))
(begin (register-function-arity (quote shen.<log10>) 1) (define (kl:shen.<log10> V2501) (let ((YaccParse (let ((Parse_shen.<minus> (kl:shen.<minus> V2501))) (if (kl:not (kl:= (kl:fail) Parse_shen.<minus>)) (let ((Parse_shen.<digits> (kl:shen.<digits> Parse_shen.<minus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (- 0 (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<digits> (kl:shen.<digits> V2501))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0)) (kl:fail))) YaccParse))) (quote shen.<log10>))
(begin (register-function-arity (quote shen.<plus>) 1) (define (kl:shen.<plus> V2503) (if (pair? (car V2503)) (let ((Parse_Char (car (car V2503)))) (if (kl:= Parse_Char 43) (kl:shen.pair (car (kl:shen.pair (cdr (car V2503)) (kl:shen.hdtl V2503))) Parse_Char) (kl:fail))) (kl:fail))) (quote shen.<plus>))
(begin (register-function-arity (quote shen.<stop>) 1) (define (kl:shen.<stop> V2505) (if (pair? (car V2505)) (let ((Parse_Char (car (car V2505)))) (if (kl:= Parse_Char 46) (kl:shen.pair (car (kl:shen.pair (cdr (car V2505)) (kl:shen.hdtl V2505))) Parse_Char) (kl:fail))) (kl:fail))) (quote shen.<stop>))
(begin (register-function-arity (quote shen.<predigits>) 1) (define (kl:shen.<predigits> V2507) (let ((YaccParse (let ((Parse_shen.<digits> (kl:shen.<digits> V2507))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.hdtl Parse_shen.<digits>)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2507))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<predigits>))
(begin (register-function-arity (quote shen.<postdigits>) 1) (define (kl:shen.<postdigits> V2509) (let ((Parse_shen.<digits> (kl:shen.<digits> V2509))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.hdtl Parse_shen.<digits>)) (kl:fail)))) (quote shen.<postdigits>))
(begin (register-function-arity (quote shen.<digits>) 1) (define (kl:shen.<digits> V2511) (let ((YaccParse (let ((Parse_shen.<digit> (kl:shen.<digit> V2511))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digit>)) (let ((Parse_shen.<digits> (kl:shen.<digits> Parse_shen.<digit>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (cons (kl:shen.hdtl Parse_shen.<digit>) (kl:shen.hdtl Parse_shen.<digits>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<digit> (kl:shen.<digit> V2511))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digit>)) (kl:shen.pair (car Parse_shen.<digit>) (cons (kl:shen.hdtl Parse_shen.<digit>) (quote ()))) (kl:fail))) YaccParse))) (quote shen.<digits>))
(begin (register-function-arity (quote shen.<digit>) 1) (define (kl:shen.<digit> V2513) (if (pair? (car V2513)) (let ((Parse_X (car (car V2513)))) (if (assert-boolean (kl:shen.numbyte? Parse_X)) (kl:shen.pair (car (kl:shen.pair (cdr (car V2513)) (kl:shen.hdtl V2513))) (kl:shen.byte->digit Parse_X)) (kl:fail))) (kl:fail))) (quote shen.<digit>))
(begin (register-function-arity (quote shen.byte->digit) 1) (define (kl:shen.byte->digit V2515) (cond ((kl:= 48 V2515) 0) ((kl:= 49 V2515) 1) ((kl:= 50 V2515) 2) ((kl:= 51 V2515) 3) ((kl:= 52 V2515) 4) ((kl:= 53 V2515) 5) ((kl:= 54 V2515) 6) ((kl:= 55 V2515) 7) ((kl:= 56 V2515) 8) ((kl:= 57 V2515) 9) (#t (kl:shen.f_error (quote shen.byte->digit))))) (quote shen.byte->digit))
(begin (register-function-arity (quote shen.pre) 2) (define (kl:shen.pre V2520 V2521) (cond ((null? V2520) 0) ((pair? V2520) (+ (* (kl:shen.expt 10 V2521) (car V2520)) (kl:shen.pre (cdr V2520) (+ V2521 1)))) (#t (kl:shen.f_error (quote shen.pre))))) (quote shen.pre))
(begin (register-function-arity (quote shen.post) 2) (define (kl:shen.post V2526 V2527) (cond ((null? V2526) 0) ((pair? V2526) (+ (* (kl:shen.expt 10 (- 0 V2527)) (car V2526)) (kl:shen.post (cdr V2526) (+ V2527 1)))) (#t (kl:shen.f_error (quote shen.post))))) (quote shen.post))
(begin (register-function-arity (quote shen.expt) 2) (define (kl:shen.expt V2532 V2533) (cond ((kl:= 0 V2533) 1) ((> V2533 0) (* V2532 (kl:shen.expt V2532 (- V2533 1)))) (#t (* 1.000000000000000 (/ (kl:shen.expt V2532 (+ V2533 1)) V2532))))) (quote shen.expt))
(begin (register-function-arity (quote shen.<st_input1>) 1) (define (kl:shen.<st_input1> V2535) (let ((Parse_shen.<st_input> (kl:shen.<st_input> V2535))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail)))) (quote shen.<st_input1>))
(begin (register-function-arity (quote shen.<st_input2>) 1) (define (kl:shen.<st_input2> V2537) (let ((Parse_shen.<st_input> (kl:shen.<st_input> V2537))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail)))) (quote shen.<st_input2>))
(begin (register-function-arity (quote shen.<comment>) 1) (define (kl:shen.<comment> V2539) (let ((YaccParse (let ((Parse_shen.<singleline> (kl:shen.<singleline> V2539))) (if (kl:not (kl:= (kl:fail) Parse_shen.<singleline>)) (kl:shen.pair (car Parse_shen.<singleline>) (quote shen.skip)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<multiline> (kl:shen.<multiline> V2539))) (if (kl:not (kl:= (kl:fail) Parse_shen.<multiline>)) (kl:shen.pair (car Parse_shen.<multiline>) (quote shen.skip)) (kl:fail))) YaccParse))) (quote shen.<comment>))
(begin (register-function-arity (quote shen.<singleline>) 1) (define (kl:shen.<singleline> V2541) (let ((Parse_shen.<backslash> (kl:shen.<backslash> V2541))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (let ((Parse_shen.<backslash> (kl:shen.<backslash> Parse_shen.<backslash>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (let ((Parse_shen.<anysingle> (kl:shen.<anysingle> Parse_shen.<backslash>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anysingle>)) (let ((Parse_shen.<return> (kl:shen.<return> Parse_shen.<anysingle>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<return>)) (kl:shen.pair (car Parse_shen.<return>) (quote shen.skip)) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail)))) (quote shen.<singleline>))
(begin (register-function-arity (quote shen.<backslash>) 1) (define (kl:shen.<backslash> V2543) (if (and (pair? (car V2543)) (kl:= 92 (car (car V2543)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2543)) (kl:shen.hdtl V2543))) (quote shen.skip)) (kl:fail))) (quote shen.<backslash>))
(begin (register-function-arity (quote shen.<anysingle>) 1) (define (kl:shen.<anysingle> V2545) (let ((YaccParse (let ((Parse_shen.<non-return> (kl:shen.<non-return> V2545))) (if (kl:not (kl:= (kl:fail) Parse_shen.<non-return>)) (let ((Parse_shen.<anysingle> (kl:shen.<anysingle> Parse_shen.<non-return>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anysingle>)) (kl:shen.pair (car Parse_shen.<anysingle>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2545))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote shen.skip)) (kl:fail))) YaccParse))) (quote shen.<anysingle>))
(begin (register-function-arity (quote shen.<non-return>) 1) (define (kl:shen.<non-return> V2547) (if (pair? (car V2547)) (let ((Parse_X (car (car V2547)))) (if (kl:not (kl:element? Parse_X (cons 10 (cons 13 (quote ()))))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2547)) (kl:shen.hdtl V2547))) (quote shen.skip)) (kl:fail))) (kl:fail))) (quote shen.<non-return>))
(begin (register-function-arity (quote shen.<return>) 1) (define (kl:shen.<return> V2549) (if (pair? (car V2549)) (let ((Parse_X (car (car V2549)))) (if (kl:element? Parse_X (cons 10 (cons 13 (quote ())))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2549)) (kl:shen.hdtl V2549))) (quote shen.skip)) (kl:fail))) (kl:fail))) (quote shen.<return>))
(begin (register-function-arity (quote shen.<multiline>) 1) (define (kl:shen.<multiline> V2551) (let ((Parse_shen.<backslash> (kl:shen.<backslash> V2551))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (let ((Parse_shen.<times> (kl:shen.<times> Parse_shen.<backslash>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<times>)) (let ((Parse_shen.<anymulti> (kl:shen.<anymulti> Parse_shen.<times>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anymulti>)) (kl:shen.pair (car Parse_shen.<anymulti>) (quote shen.skip)) (kl:fail))) (kl:fail))) (kl:fail)))) (quote shen.<multiline>))
(begin (register-function-arity (quote shen.<times>) 1) (define (kl:shen.<times> V2553) (if (and (pair? (car V2553)) (kl:= 42 (car (car V2553)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2553)) (kl:shen.hdtl V2553))) (quote shen.skip)) (kl:fail))) (quote shen.<times>))
(begin (register-function-arity (quote shen.<anymulti>) 1) (define (kl:shen.<anymulti> V2555) (let ((YaccParse (let ((Parse_shen.<comment> (kl:shen.<comment> V2555))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comment>)) (let ((Parse_shen.<anymulti> (kl:shen.<anymulti> Parse_shen.<comment>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anymulti>)) (kl:shen.pair (car Parse_shen.<anymulti>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<times> (kl:shen.<times> V2555))) (if (kl:not (kl:= (kl:fail) Parse_shen.<times>)) (let ((Parse_shen.<backslash> (kl:shen.<backslash> Parse_shen.<times>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (kl:shen.pair (car Parse_shen.<backslash>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (if (pair? (car V2555)) (let ((Parse_X (car (car V2555)))) (let ((Parse_shen.<anymulti> (kl:shen.<anymulti> (kl:shen.pair (cdr (car V2555)) (kl:shen.hdtl V2555))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anymulti>)) (kl:shen.pair (car Parse_shen.<anymulti>) (quote shen.skip)) (kl:fail)))) (kl:fail)) YaccParse)) YaccParse))) (quote shen.<anymulti>))
(begin (register-function-arity (quote shen.<whitespaces>) 1) (define (kl:shen.<whitespaces> V2557) (let ((YaccParse (let ((Parse_shen.<whitespace> (kl:shen.<whitespace> V2557))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespace>)) (let ((Parse_shen.<whitespaces> (kl:shen.<whitespaces> Parse_shen.<whitespace>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespaces>)) (kl:shen.pair (car Parse_shen.<whitespaces>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<whitespace> (kl:shen.<whitespace> V2557))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespace>)) (kl:shen.pair (car Parse_shen.<whitespace>) (quote shen.skip)) (kl:fail))) YaccParse))) (quote shen.<whitespaces>))
(begin (register-function-arity (quote shen.<whitespace>) 1) (define (kl:shen.<whitespace> V2559) (if (pair? (car V2559)) (let ((Parse_X (car (car V2559)))) (if (assert-boolean (let ((Parse_Case Parse_X)) (or (kl:= Parse_Case 32) (or (kl:= Parse_Case 13) (or (kl:= Parse_Case 10) (kl:= Parse_Case 9)))))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2559)) (kl:shen.hdtl V2559))) (quote shen.skip)) (kl:fail))) (kl:fail))) (quote shen.<whitespace>))
(begin (register-function-arity (quote shen.cons_form) 1) (define (kl:shen.cons_form V2561) (cond ((null? V2561) (quote ())) ((and (pair? V2561) (and (pair? (cdr V2561)) (and (pair? (cdr (cdr V2561))) (and (null? (cdr (cdr (cdr V2561)))) (eq? (car (cdr V2561)) (quote bar!)))))) (cons (quote cons) (cons (car V2561) (cdr (cdr V2561))))) ((pair? V2561) (cons (quote cons) (cons (car V2561) (cons (kl:shen.cons_form (cdr V2561)) (quote ()))))) (#t (kl:shen.f_error (quote shen.cons_form))))) (quote shen.cons_form))
(begin (register-function-arity (quote shen.package-macro) 2) (define (kl:shen.package-macro V2566 V2567) (cond ((and (pair? V2566) (and (eq? (quote _waspvm_dl_) (car V2566)) (and (pair? (cdr V2566)) (null? (cdr (cdr V2566)))))) (kl:append (kl:explode (car (cdr V2566))) V2567)) ((and (pair? V2566) (and (eq? (quote package) (car V2566)) (and (pair? (cdr V2566)) (and (eq? (quote null) (car (cdr V2566))) (pair? (cdr (cdr V2566))))))) (kl:append (cdr (cdr (cdr V2566))) V2567)) ((and (pair? V2566) (and (eq? (quote package) (car V2566)) (and (pair? (cdr V2566)) (pair? (cdr (cdr V2566)))))) (let ((ListofExceptions (kl:shen.eval-without-macros (car (cdr (cdr V2566)))))) (let ((External (kl:shen.record-exceptions ListofExceptions (car (cdr V2566))))) (let ((PackageNameDot (kl:intern (string-append (kl:str (car (cdr V2566))) ".")))) (let ((ExpPackageNameDot (kl:explode PackageNameDot))) (let ((Packaged (kl:shen.packageh PackageNameDot ListofExceptions (cdr (cdr (cdr V2566))) ExpPackageNameDot))) (let ((Internal (kl:shen.record-internal (car (cdr V2566)) (kl:shen.internal-symbols ExpPackageNameDot Packaged)))) (kl:append Packaged V2567)))))))) (#t (cons V2566 V2567)))) (quote shen.package-macro))
(begin (register-function-arity (quote shen.record-exceptions) 2) (define (kl:shen.record-exceptions V2570 V2571) (let ((CurrExceptions (kl:get/or V2571 (quote shen.external-symbols) (lambda () (quote ())) (kl:value (quote *property-vector*))))) (let ((AllExceptions (kl:union V2570 CurrExceptions))) (kl:put V2571 (quote shen.external-symbols) AllExceptions (kl:value (quote *property-vector*)))))) (quote shen.record-exceptions))
(begin (register-function-arity (quote shen.record-internal) 2) (define (kl:shen.record-internal V2574 V2575) (kl:put V2574 (quote shen.internal-symbols) (kl:union V2575 (kl:get/or V2574 (quote shen.internal-symbols) (lambda () (quote ())) (kl:value (quote *property-vector*)))) (kl:value (quote *property-vector*)))) (quote shen.record-internal))
(begin (register-function-arity (quote shen.internal-symbols) 2) (define (kl:shen.internal-symbols V2586 V2587) (cond ((and (kl:symbol? V2587) (assert-boolean (kl:shen.prefix? V2586 (kl:explode V2587)))) (cons V2587 (quote ()))) ((pair? V2587) (kl:union (kl:shen.internal-symbols V2586 (car V2587)) (kl:shen.internal-symbols V2586 (cdr V2587)))) (#t (quote ())))) (quote shen.internal-symbols))
(begin (register-function-arity (quote shen.packageh) 4) (define (kl:shen.packageh V2604 V2605 V2606 V2607) (cond ((pair? V2606) (cons (kl:shen.packageh V2604 V2605 (car V2606) V2607) (kl:shen.packageh V2604 V2605 (cdr V2606) V2607))) ((or (assert-boolean (kl:shen.sysfunc? V2606)) (or (kl:variable? V2606) (or (kl:element? V2606 V2605) (or (assert-boolean (kl:shen.doubleunderline? V2606)) (assert-boolean (kl:shen.singleunderline? V2606)))))) V2606) ((and (kl:symbol? V2606) (assert-boolean (let ((ExplodeX (kl:explode V2606))) (and (kl:not (kl:shen.prefix? (cons "s" (cons "h" (cons "e" (cons "n" (cons "." (quote ())))))) ExplodeX)) (kl:not (kl:shen.prefix? V2607 ExplodeX)))))) (kl:concat V2604 V2606)) (#t V2606))) (quote shen.packageh))
