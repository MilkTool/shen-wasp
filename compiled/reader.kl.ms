"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote read-char-code) 1) (define (kl:read-char-code V2163) (read-u8 V2163)) (quote read-char-code))
(begin (register-function-arity (quote read-file-as-bytelist) 1) (define (kl:read-file-as-bytelist V2165) (kl:shen.read-file-as-Xlist V2165 (lambda (S) (read-u8 S)))) (quote read-file-as-bytelist))
(begin (register-function-arity (quote read-file-as-charlist) 1) (define (kl:read-file-as-charlist V2167) (kl:shen.read-file-as-Xlist V2167 (lambda (S) (kl:read-char-code S)))) (quote read-file-as-charlist))
(begin (register-function-arity (quote shen.read-file-as-Xlist) 2) (define (kl:shen.read-file-as-Xlist V2170 V2171) (let ((Stream (kl:open V2170 (quote in)))) (let ((X (V2171 Stream))) (let ((Xs (kl:shen.read-file-as-Xlist-help Stream V2171 X (quote ())))) (let ((Close (kl:close Stream))) (kl:reverse Xs)))))) (quote shen.read-file-as-Xlist))
(begin (register-function-arity (quote shen.read-file-as-Xlist-help) 4) (define (kl:shen.read-file-as-Xlist-help V2176 V2177 V2178 V2179) (cond ((kl:= -1 V2178) V2179) (#t (kl:shen.read-file-as-Xlist-help V2176 V2177 (V2177 V2176) (cons V2178 V2179))))) (quote shen.read-file-as-Xlist-help))
(begin (register-function-arity (quote read-file-as-string) 1) (define (kl:read-file-as-string V2181) (let ((Stream (kl:open V2181 (quote in)))) (kl:shen.rfas-h Stream (kl:read-char-code Stream) ""))) (quote read-file-as-string))
(begin (register-function-arity (quote shen.rfas-h) 3) (define (kl:shen.rfas-h V2185 V2186 V2187) (cond ((kl:= -1 V2186) (begin (kl:close V2185) V2187)) (#t (kl:shen.rfas-h V2185 (kl:read-char-code V2185) (string-append V2187 (make-string 1 V2186)))))) (quote shen.rfas-h))
(begin (register-function-arity (quote input) 1) (define (kl:input V2189) (kl:eval-kl (kl:read V2189))) (quote input))
(begin (register-function-arity (quote input+) 2) (define (kl:input+ V2192 V2193) (let ((Mono? (kl:shen.monotype V2192))) (let ((Input (kl:read V2193))) (if (kl:= #f (kl:shen.typecheck Input (kl:shen.demodulate V2192))) (simple-error (string-append "type error: " (kl:shen.app Input (string-append " is not of type " (kl:shen.app V2192 "\n" (quote shen.r))) (quote shen.r)))) (kl:eval-kl Input))))) (quote input+))
(begin (register-function-arity (quote shen.monotype) 1) (define (kl:shen.monotype V2195) (cond ((pair? V2195) (kl:map (lambda (Z) (kl:shen.monotype Z)) V2195)) (#t (if (kl:variable? V2195) (simple-error (string-append "input+ expects a monotype: not " (kl:shen.app V2195 "\n" (quote shen.a)))) V2195)))) (quote shen.monotype))
(begin (register-function-arity (quote read) 1) (define (kl:read V2197) (car (kl:shen.read-loop V2197 (kl:read-char-code V2197) (quote ())))) (quote read))
(begin (register-function-arity (quote it) 0) (define (kl:it) (kl:value (quote shen.*it*))) (quote it))
(begin (register-function-arity (quote shen.read-loop) 3) (define (kl:shen.read-loop V2205 V2206 V2207) (cond ((kl:= 94 V2206) (simple-error "read aborted")) ((kl:= -1 V2206) (if (kl:empty? V2207) (simple-error "error: empty stream") (kl:compile (lambda (X) (kl:shen.<st_input> X)) V2207 (lambda (E) E)))) ((assert-boolean (kl:shen.terminator? V2206)) (let ((AllChars (kl:append V2207 (cons V2206 (quote ()))))) (let ((It (kl:shen.record-it AllChars))) (let ((Read (kl:compile (lambda (X) (kl:shen.<st_input> X)) AllChars (lambda (E) (quote shen.nextbyte))))) (if (or (eq? Read (quote shen.nextbyte)) (kl:empty? Read)) (kl:shen.read-loop V2205 (kl:read-char-code V2205) AllChars) Read))))) (#t (kl:shen.read-loop V2205 (kl:read-char-code V2205) (kl:append V2207 (cons V2206 (quote ()))))))) (quote shen.read-loop))
(begin (register-function-arity (quote shen.terminator?) 1) (define (kl:shen.terminator? V2209) (kl:element? V2209 (cons 9 (cons 10 (cons 13 (cons 32 (cons 34 (cons 41 (cons 93 (quote ())))))))))) (quote shen.terminator?))
(begin (register-function-arity (quote lineread) 1) (define (kl:lineread V2211) (kl:shen.lineread-loop (kl:read-char-code V2211) (quote ()) V2211)) (quote lineread))
(begin (register-function-arity (quote shen.lineread-loop) 3) (define (kl:shen.lineread-loop V2216 V2217 V2218) (cond ((kl:= -1 V2216) (if (kl:empty? V2217) (simple-error "empty stream") (kl:compile (lambda (X) (kl:shen.<st_input> X)) V2217 (lambda (E) E)))) ((kl:= V2216 (kl:shen.hat)) (simple-error "line read aborted")) ((kl:element? V2216 (cons (kl:shen.newline) (cons (kl:shen.carriage-return) (quote ())))) (let ((Line (kl:compile (lambda (X) (kl:shen.<st_input> X)) V2217 (lambda (E) (quote shen.nextline))))) (let ((It (kl:shen.record-it V2217))) (if (or (eq? Line (quote shen.nextline)) (kl:empty? Line)) (kl:shen.lineread-loop (kl:read-char-code V2218) (kl:append V2217 (cons V2216 (quote ()))) V2218) Line)))) (#t (kl:shen.lineread-loop (kl:read-char-code V2218) (kl:append V2217 (cons V2216 (quote ()))) V2218)))) (quote shen.lineread-loop))
(begin (register-function-arity (quote shen.record-it) 1) (define (kl:shen.record-it V2220) (let ((TrimLeft (kl:shen.trim-whitespace V2220))) (let ((TrimRight (kl:shen.trim-whitespace (kl:reverse TrimLeft)))) (let ((Trimmed (kl:reverse TrimRight))) (kl:shen.record-it-h Trimmed))))) (quote shen.record-it))
(begin (register-function-arity (quote shen.trim-whitespace) 1) (define (kl:shen.trim-whitespace V2222) (cond ((and (pair? V2222) (kl:element? (car V2222) (cons 9 (cons 10 (cons 13 (cons 32 (quote ()))))))) (kl:shen.trim-whitespace (cdr V2222))) (#t V2222))) (quote shen.trim-whitespace))
(begin (register-function-arity (quote shen.record-it-h) 1) (define (kl:shen.record-it-h V2224) (begin (kl:set (quote shen.*it*) (kl:shen.cn-all (kl:map (lambda (X) (make-string 1 X)) V2224))) V2224)) (quote shen.record-it-h))
(begin (register-function-arity (quote shen.cn-all) 1) (define (kl:shen.cn-all V2226) (cond ((null? V2226) "") ((pair? V2226) (string-append (car V2226) (kl:shen.cn-all (cdr V2226)))) (#t (kl:shen.f_error (quote shen.cn-all))))) (quote shen.cn-all))
(begin (register-function-arity (quote read-file) 1) (define (kl:read-file V2228) (let ((Charlist (kl:read-file-as-charlist V2228))) (kl:compile (lambda (X) (kl:shen.<st_input> X)) Charlist (lambda (X) (kl:shen.read-error X))))) (quote read-file))
(begin (register-function-arity (quote read-from-string) 1) (define (kl:read-from-string V2230) (let ((Ns (kl:map (lambda (X) (string-ref X 0)) (kl:explode V2230)))) (kl:compile (lambda (X) (kl:shen.<st_input> X)) Ns (lambda (X) (kl:shen.read-error X))))) (quote read-from-string))
(begin (register-function-arity (quote shen.read-error) 1) (define (kl:shen.read-error V2238) (cond ((and (pair? V2238) (and (pair? (car V2238)) (and (pair? (cdr V2238)) (null? (cdr (cdr V2238)))))) (simple-error (string-append "read error here:\n\n " (kl:shen.app (kl:shen.compress-50 50 (car V2238)) "\n" (quote shen.a))))) (#t (simple-error "read error\n")))) (quote shen.read-error))
(begin (register-function-arity (quote shen.compress-50) 2) (define (kl:shen.compress-50 V2245 V2246) (cond ((null? V2246) "") ((kl:= 0 V2245) "") ((pair? V2246) (string-append (make-string 1 (car V2246)) (kl:shen.compress-50 (- V2245 1) (cdr V2246)))) (#t (kl:shen.f_error (quote shen.compress-50))))) (quote shen.compress-50))
(begin (register-function-arity (quote shen.<st_input>) 1) (define (kl:shen.<st_input> V2248) (let ((YaccParse (let ((Parse_shen.<lsb> (kl:shen.<lsb> V2248))) (if (kl:not (kl:= (kl:fail) Parse_shen.<lsb>)) (let ((Parse_shen.<st_input1> (kl:shen.<st_input1> Parse_shen.<lsb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input1>)) (let ((Parse_shen.<rsb> (kl:shen.<rsb> Parse_shen.<st_input1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rsb>)) (let ((Parse_shen.<st_input2> (kl:shen.<st_input2> Parse_shen.<rsb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input2>)) (kl:shen.pair (car Parse_shen.<st_input2>) (cons (kl:macroexpand (kl:shen.cons_form (kl:shen.hdtl Parse_shen.<st_input1>))) (kl:shen.hdtl Parse_shen.<st_input2>))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<lrb> (kl:shen.<lrb> V2248))) (if (kl:not (kl:= (kl:fail) Parse_shen.<lrb>)) (let ((Parse_shen.<st_input1> (kl:shen.<st_input1> Parse_shen.<lrb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input1>)) (let ((Parse_shen.<rrb> (kl:shen.<rrb> Parse_shen.<st_input1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rrb>)) (let ((Parse_shen.<st_input2> (kl:shen.<st_input2> Parse_shen.<rrb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input2>)) (kl:shen.pair (car Parse_shen.<st_input2>) (kl:shen.package-macro (kl:macroexpand (kl:shen.hdtl Parse_shen.<st_input1>)) (kl:shen.hdtl Parse_shen.<st_input2>))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<lcurly> (kl:shen.<lcurly> V2248))) (if (kl:not (kl:= (kl:fail) Parse_shen.<lcurly>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<lcurly>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote {) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<rcurly> (kl:shen.<rcurly> V2248))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rcurly>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<rcurly>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote }) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<bar> (kl:shen.<bar> V2248))) (if (kl:not (kl:= (kl:fail) Parse_shen.<bar>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<bar>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote bar!) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<semicolon> (kl:shen.<semicolon> V2248))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<semicolon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote _waspvm_sc_) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<colon> (kl:shen.<colon> V2248))) (if (kl:not (kl:= (kl:fail) Parse_shen.<colon>)) (let ((Parse_shen.<equal> (kl:shen.<equal> Parse_shen.<colon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<equal>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<equal>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote :=) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<colon> (kl:shen.<colon> V2248))) (if (kl:not (kl:= (kl:fail) Parse_shen.<colon>)) (let ((Parse_shen.<minus> (kl:shen.<minus> Parse_shen.<colon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<minus>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<minus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote :-) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<colon> (kl:shen.<colon> V2248))) (if (kl:not (kl:= (kl:fail) Parse_shen.<colon>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<colon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote :) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<comma> (kl:shen.<comma> V2248))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comma>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<comma>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (kl:intern ",") (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<comment> (kl:shen.<comment> V2248))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comment>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<comment>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<atom> (kl:shen.<atom> V2248))) (if (kl:not (kl:= (kl:fail) Parse_shen.<atom>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<atom>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (kl:macroexpand (kl:shen.hdtl Parse_shen.<atom>)) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<whitespaces> (kl:shen.<whitespaces> V2248))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespaces>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<whitespaces>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2248))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse))) (quote shen.<st_input>))
(begin (register-function-arity (quote shen.<lsb>) 1) (define (kl:shen.<lsb> V2250) (if (and (pair? (car V2250)) (kl:= 91 (car (car V2250)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2250)) (kl:shen.hdtl V2250))) (quote shen.skip)) (kl:fail))) (quote shen.<lsb>))
(begin (register-function-arity (quote shen.<rsb>) 1) (define (kl:shen.<rsb> V2252) (if (and (pair? (car V2252)) (kl:= 93 (car (car V2252)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2252)) (kl:shen.hdtl V2252))) (quote shen.skip)) (kl:fail))) (quote shen.<rsb>))
(begin (register-function-arity (quote shen.<lcurly>) 1) (define (kl:shen.<lcurly> V2254) (if (and (pair? (car V2254)) (kl:= 123 (car (car V2254)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2254)) (kl:shen.hdtl V2254))) (quote shen.skip)) (kl:fail))) (quote shen.<lcurly>))
(begin (register-function-arity (quote shen.<rcurly>) 1) (define (kl:shen.<rcurly> V2256) (if (and (pair? (car V2256)) (kl:= 125 (car (car V2256)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2256)) (kl:shen.hdtl V2256))) (quote shen.skip)) (kl:fail))) (quote shen.<rcurly>))
(begin (register-function-arity (quote shen.<bar>) 1) (define (kl:shen.<bar> V2258) (if (and (pair? (car V2258)) (kl:= 124 (car (car V2258)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2258)) (kl:shen.hdtl V2258))) (quote shen.skip)) (kl:fail))) (quote shen.<bar>))
(begin (register-function-arity (quote shen.<semicolon>) 1) (define (kl:shen.<semicolon> V2260) (if (and (pair? (car V2260)) (kl:= 59 (car (car V2260)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2260)) (kl:shen.hdtl V2260))) (quote shen.skip)) (kl:fail))) (quote shen.<semicolon>))
(begin (register-function-arity (quote shen.<colon>) 1) (define (kl:shen.<colon> V2262) (if (and (pair? (car V2262)) (kl:= 58 (car (car V2262)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2262)) (kl:shen.hdtl V2262))) (quote shen.skip)) (kl:fail))) (quote shen.<colon>))
(begin (register-function-arity (quote shen.<comma>) 1) (define (kl:shen.<comma> V2264) (if (and (pair? (car V2264)) (kl:= 44 (car (car V2264)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2264)) (kl:shen.hdtl V2264))) (quote shen.skip)) (kl:fail))) (quote shen.<comma>))
(begin (register-function-arity (quote shen.<equal>) 1) (define (kl:shen.<equal> V2266) (if (and (pair? (car V2266)) (kl:= 61 (car (car V2266)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2266)) (kl:shen.hdtl V2266))) (quote shen.skip)) (kl:fail))) (quote shen.<equal>))
(begin (register-function-arity (quote shen.<minus>) 1) (define (kl:shen.<minus> V2268) (if (and (pair? (car V2268)) (kl:= 45 (car (car V2268)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2268)) (kl:shen.hdtl V2268))) (quote shen.skip)) (kl:fail))) (quote shen.<minus>))
(begin (register-function-arity (quote shen.<lrb>) 1) (define (kl:shen.<lrb> V2270) (if (and (pair? (car V2270)) (kl:= 40 (car (car V2270)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2270)) (kl:shen.hdtl V2270))) (quote shen.skip)) (kl:fail))) (quote shen.<lrb>))
(begin (register-function-arity (quote shen.<rrb>) 1) (define (kl:shen.<rrb> V2272) (if (and (pair? (car V2272)) (kl:= 41 (car (car V2272)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2272)) (kl:shen.hdtl V2272))) (quote shen.skip)) (kl:fail))) (quote shen.<rrb>))
(begin (register-function-arity (quote shen.<atom>) 1) (define (kl:shen.<atom> V2274) (let ((YaccParse (let ((Parse_shen.<str> (kl:shen.<str> V2274))) (if (kl:not (kl:= (kl:fail) Parse_shen.<str>)) (kl:shen.pair (car Parse_shen.<str>) (kl:shen.control-chars (kl:shen.hdtl Parse_shen.<str>))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<number> (kl:shen.<number> V2274))) (if (kl:not (kl:= (kl:fail) Parse_shen.<number>)) (kl:shen.pair (car Parse_shen.<number>) (kl:shen.hdtl Parse_shen.<number>)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<sym> (kl:shen.<sym> V2274))) (if (kl:not (kl:= (kl:fail) Parse_shen.<sym>)) (kl:shen.pair (car Parse_shen.<sym>) (if (equal? (kl:shen.hdtl Parse_shen.<sym>) "<>") (cons (quote vector) (cons 0 (quote ()))) (kl:intern (kl:shen.hdtl Parse_shen.<sym>)))) (kl:fail))) YaccParse)) YaccParse))) (quote shen.<atom>))
(begin (register-function-arity (quote shen.control-chars) 1) (define (kl:shen.control-chars V2276) (cond ((null? V2276) "") ((and (pair? V2276) (and (equal? "c" (car V2276)) (and (pair? (cdr V2276)) (equal? "#" (car (cdr V2276)))))) (let ((CodePoint (kl:shen.code-point (cdr (cdr V2276))))) (let ((AfterCodePoint (kl:shen.after-codepoint (cdr (cdr V2276))))) (kl:_waspvm_at_s (make-string 1 (kl:shen.decimalise CodePoint)) (kl:shen.control-chars AfterCodePoint))))) ((pair? V2276) (kl:_waspvm_at_s (car V2276) (kl:shen.control-chars (cdr V2276)))) (#t (kl:shen.f_error (quote shen.control-chars))))) (quote shen.control-chars))
(begin (register-function-arity (quote shen.code-point) 1) (define (kl:shen.code-point V2280) (cond ((and (pair? V2280) (equal? ";" (car V2280))) "") ((and (pair? V2280) (kl:element? (car V2280) (cons "0" (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" (quote ())))))))))))))) (cons (car V2280) (kl:shen.code-point (cdr V2280)))) (#t (simple-error (string-append "code point parse error " (kl:shen.app V2280 "\n" (quote shen.a))))))) (quote shen.code-point))
(begin (register-function-arity (quote shen.after-codepoint) 1) (define (kl:shen.after-codepoint V2286) (cond ((null? V2286) (quote ())) ((and (pair? V2286) (equal? ";" (car V2286))) (cdr V2286)) ((pair? V2286) (kl:shen.after-codepoint (cdr V2286))) (#t (kl:shen.f_error (quote shen.after-codepoint))))) (quote shen.after-codepoint))
(begin (register-function-arity (quote shen.decimalise) 1) (define (kl:shen.decimalise V2288) (kl:shen.pre (kl:reverse (kl:shen.digits->integers V2288)) 0)) (quote shen.decimalise))
(begin (register-function-arity (quote shen.digits->integers) 1) (define (kl:shen.digits->integers V2294) (cond ((and (pair? V2294) (equal? "0" (car V2294))) (cons 0 (kl:shen.digits->integers (cdr V2294)))) ((and (pair? V2294) (equal? "1" (car V2294))) (cons 1 (kl:shen.digits->integers (cdr V2294)))) ((and (pair? V2294) (equal? "2" (car V2294))) (cons 2 (kl:shen.digits->integers (cdr V2294)))) ((and (pair? V2294) (equal? "3" (car V2294))) (cons 3 (kl:shen.digits->integers (cdr V2294)))) ((and (pair? V2294) (equal? "4" (car V2294))) (cons 4 (kl:shen.digits->integers (cdr V2294)))) ((and (pair? V2294) (equal? "5" (car V2294))) (cons 5 (kl:shen.digits->integers (cdr V2294)))) ((and (pair? V2294) (equal? "6" (car V2294))) (cons 6 (kl:shen.digits->integers (cdr V2294)))) ((and (pair? V2294) (equal? "7" (car V2294))) (cons 7 (kl:shen.digits->integers (cdr V2294)))) ((and (pair? V2294) (equal? "8" (car V2294))) (cons 8 (kl:shen.digits->integers (cdr V2294)))) ((and (pair? V2294) (equal? "9" (car V2294))) (cons 9 (kl:shen.digits->integers (cdr V2294)))) (#t (quote ())))) (quote shen.digits->integers))
(begin (register-function-arity (quote shen.<sym>) 1) (define (kl:shen.<sym> V2296) (let ((Parse_shen.<alpha> (kl:shen.<alpha> V2296))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alpha>)) (let ((Parse_shen.<alphanums> (kl:shen.<alphanums> Parse_shen.<alpha>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alphanums>)) (kl:shen.pair (car Parse_shen.<alphanums>) (kl:_waspvm_at_s (kl:shen.hdtl Parse_shen.<alpha>) (kl:shen.hdtl Parse_shen.<alphanums>))) (kl:fail))) (kl:fail)))) (quote shen.<sym>))
(begin (register-function-arity (quote shen.<alphanums>) 1) (define (kl:shen.<alphanums> V2298) (let ((YaccParse (let ((Parse_shen.<alphanum> (kl:shen.<alphanum> V2298))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alphanum>)) (let ((Parse_shen.<alphanums> (kl:shen.<alphanums> Parse_shen.<alphanum>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alphanums>)) (kl:shen.pair (car Parse_shen.<alphanums>) (kl:_waspvm_at_s (kl:shen.hdtl Parse_shen.<alphanum>) (kl:shen.hdtl Parse_shen.<alphanums>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2298))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) "") (kl:fail))) YaccParse))) (quote shen.<alphanums>))
(begin (register-function-arity (quote shen.<alphanum>) 1) (define (kl:shen.<alphanum> V2300) (let ((YaccParse (let ((Parse_shen.<alpha> (kl:shen.<alpha> V2300))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alpha>)) (kl:shen.pair (car Parse_shen.<alpha>) (kl:shen.hdtl Parse_shen.<alpha>)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<num> (kl:shen.<num> V2300))) (if (kl:not (kl:= (kl:fail) Parse_shen.<num>)) (kl:shen.pair (car Parse_shen.<num>) (kl:shen.hdtl Parse_shen.<num>)) (kl:fail))) YaccParse))) (quote shen.<alphanum>))
(begin (register-function-arity (quote shen.<num>) 1) (define (kl:shen.<num> V2302) (if (pair? (car V2302)) (let ((Parse_Char (car (car V2302)))) (if (assert-boolean (kl:shen.numbyte? Parse_Char)) (kl:shen.pair (car (kl:shen.pair (cdr (car V2302)) (kl:shen.hdtl V2302))) (make-string 1 Parse_Char)) (kl:fail))) (kl:fail))) (quote shen.<num>))
(begin (register-function-arity (quote shen.numbyte?) 1) (define (kl:shen.numbyte? V2308) (cond ((kl:= 48 V2308) #t) ((kl:= 49 V2308) #t) ((kl:= 50 V2308) #t) ((kl:= 51 V2308) #t) ((kl:= 52 V2308) #t) ((kl:= 53 V2308) #t) ((kl:= 54 V2308) #t) ((kl:= 55 V2308) #t) ((kl:= 56 V2308) #t) ((kl:= 57 V2308) #t) (#t #f))) (quote shen.numbyte?))
(begin (register-function-arity (quote shen.<alpha>) 1) (define (kl:shen.<alpha> V2310) (if (pair? (car V2310)) (let ((Parse_Char (car (car V2310)))) (if (assert-boolean (kl:shen.symbol-code? Parse_Char)) (kl:shen.pair (car (kl:shen.pair (cdr (car V2310)) (kl:shen.hdtl V2310))) (make-string 1 Parse_Char)) (kl:fail))) (kl:fail))) (quote shen.<alpha>))
(begin (register-function-arity (quote shen.symbol-code?) 1) (define (kl:shen.symbol-code? V2312) (or (kl:= V2312 126) (or (and (> V2312 94) (< V2312 123)) (or (and (> V2312 59) (< V2312 91)) (or (and (> V2312 41) (and (< V2312 58) (kl:not (kl:= V2312 44)))) (or (and (> V2312 34) (< V2312 40)) (kl:= V2312 33))))))) (quote shen.symbol-code?))
(begin (register-function-arity (quote shen.<str>) 1) (define (kl:shen.<str> V2314) (let ((Parse_shen.<dbq> (kl:shen.<dbq> V2314))) (if (kl:not (kl:= (kl:fail) Parse_shen.<dbq>)) (let ((Parse_shen.<strcontents> (kl:shen.<strcontents> Parse_shen.<dbq>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<strcontents>)) (let ((Parse_shen.<dbq> (kl:shen.<dbq> Parse_shen.<strcontents>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<dbq>)) (kl:shen.pair (car Parse_shen.<dbq>) (kl:shen.hdtl Parse_shen.<strcontents>)) (kl:fail))) (kl:fail))) (kl:fail)))) (quote shen.<str>))
(begin (register-function-arity (quote shen.<dbq>) 1) (define (kl:shen.<dbq> V2316) (if (pair? (car V2316)) (let ((Parse_Char (car (car V2316)))) (if (kl:= Parse_Char 34) (kl:shen.pair (car (kl:shen.pair (cdr (car V2316)) (kl:shen.hdtl V2316))) Parse_Char) (kl:fail))) (kl:fail))) (quote shen.<dbq>))
(begin (register-function-arity (quote shen.<strcontents>) 1) (define (kl:shen.<strcontents> V2318) (let ((YaccParse (let ((Parse_shen.<strc> (kl:shen.<strc> V2318))) (if (kl:not (kl:= (kl:fail) Parse_shen.<strc>)) (let ((Parse_shen.<strcontents> (kl:shen.<strcontents> Parse_shen.<strc>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<strcontents>)) (kl:shen.pair (car Parse_shen.<strcontents>) (cons (kl:shen.hdtl Parse_shen.<strc>) (kl:shen.hdtl Parse_shen.<strcontents>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2318))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<strcontents>))
(begin (register-function-arity (quote shen.<byte>) 1) (define (kl:shen.<byte> V2320) (if (pair? (car V2320)) (let ((Parse_Char (car (car V2320)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2320)) (kl:shen.hdtl V2320))) (make-string 1 Parse_Char))) (kl:fail))) (quote shen.<byte>))
(begin (register-function-arity (quote shen.<strc>) 1) (define (kl:shen.<strc> V2322) (if (pair? (car V2322)) (let ((Parse_Char (car (car V2322)))) (if (kl:not (kl:= Parse_Char 34)) (kl:shen.pair (car (kl:shen.pair (cdr (car V2322)) (kl:shen.hdtl V2322))) (make-string 1 Parse_Char)) (kl:fail))) (kl:fail))) (quote shen.<strc>))
(begin (register-function-arity (quote shen.<number>) 1) (define (kl:shen.<number> V2324) (let ((YaccParse (let ((Parse_shen.<minus> (kl:shen.<minus> V2324))) (if (kl:not (kl:= (kl:fail) Parse_shen.<minus>)) (let ((Parse_shen.<number> (kl:shen.<number> Parse_shen.<minus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<number>)) (kl:shen.pair (car Parse_shen.<number>) (- 0 (kl:shen.hdtl Parse_shen.<number>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<plus> (kl:shen.<plus> V2324))) (if (kl:not (kl:= (kl:fail) Parse_shen.<plus>)) (let ((Parse_shen.<number> (kl:shen.<number> Parse_shen.<plus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<number>)) (kl:shen.pair (car Parse_shen.<number>) (kl:shen.hdtl Parse_shen.<number>)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<predigits> (kl:shen.<predigits> V2324))) (if (kl:not (kl:= (kl:fail) Parse_shen.<predigits>)) (let ((Parse_shen.<stop> (kl:shen.<stop> Parse_shen.<predigits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<stop>)) (let ((Parse_shen.<postdigits> (kl:shen.<postdigits> Parse_shen.<stop>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<postdigits>)) (let ((Parse_shen.<E> (kl:shen.<E> Parse_shen.<postdigits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<E>)) (let ((Parse_shen.<log10> (kl:shen.<log10> Parse_shen.<E>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<log10>)) (kl:shen.pair (car Parse_shen.<log10>) (* (kl:shen.expt 10 (kl:shen.hdtl Parse_shen.<log10>)) (+ (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<predigits>)) 0) (kl:shen.post (kl:shen.hdtl Parse_shen.<postdigits>) 1)))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<digits> (kl:shen.<digits> V2324))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (let ((Parse_shen.<E> (kl:shen.<E> Parse_shen.<digits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<E>)) (let ((Parse_shen.<log10> (kl:shen.<log10> Parse_shen.<E>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<log10>)) (kl:shen.pair (car Parse_shen.<log10>) (* (kl:shen.expt 10 (kl:shen.hdtl Parse_shen.<log10>)) (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<predigits> (kl:shen.<predigits> V2324))) (if (kl:not (kl:= (kl:fail) Parse_shen.<predigits>)) (let ((Parse_shen.<stop> (kl:shen.<stop> Parse_shen.<predigits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<stop>)) (let ((Parse_shen.<postdigits> (kl:shen.<postdigits> Parse_shen.<stop>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<postdigits>)) (kl:shen.pair (car Parse_shen.<postdigits>) (+ (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<predigits>)) 0) (kl:shen.post (kl:shen.hdtl Parse_shen.<postdigits>) 1))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<digits> (kl:shen.<digits> V2324))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0)) (kl:fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse))) (quote shen.<number>))
(begin (register-function-arity (quote shen.<E>) 1) (define (kl:shen.<E> V2326) (if (and (pair? (car V2326)) (kl:= 101 (car (car V2326)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2326)) (kl:shen.hdtl V2326))) (quote shen.skip)) (kl:fail))) (quote shen.<E>))
(begin (register-function-arity (quote shen.<log10>) 1) (define (kl:shen.<log10> V2328) (let ((YaccParse (let ((Parse_shen.<minus> (kl:shen.<minus> V2328))) (if (kl:not (kl:= (kl:fail) Parse_shen.<minus>)) (let ((Parse_shen.<digits> (kl:shen.<digits> Parse_shen.<minus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (- 0 (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<digits> (kl:shen.<digits> V2328))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0)) (kl:fail))) YaccParse))) (quote shen.<log10>))
(begin (register-function-arity (quote shen.<plus>) 1) (define (kl:shen.<plus> V2330) (if (pair? (car V2330)) (let ((Parse_Char (car (car V2330)))) (if (kl:= Parse_Char 43) (kl:shen.pair (car (kl:shen.pair (cdr (car V2330)) (kl:shen.hdtl V2330))) Parse_Char) (kl:fail))) (kl:fail))) (quote shen.<plus>))
(begin (register-function-arity (quote shen.<stop>) 1) (define (kl:shen.<stop> V2332) (if (pair? (car V2332)) (let ((Parse_Char (car (car V2332)))) (if (kl:= Parse_Char 46) (kl:shen.pair (car (kl:shen.pair (cdr (car V2332)) (kl:shen.hdtl V2332))) Parse_Char) (kl:fail))) (kl:fail))) (quote shen.<stop>))
(begin (register-function-arity (quote shen.<predigits>) 1) (define (kl:shen.<predigits> V2334) (let ((YaccParse (let ((Parse_shen.<digits> (kl:shen.<digits> V2334))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.hdtl Parse_shen.<digits>)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2334))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<predigits>))
(begin (register-function-arity (quote shen.<postdigits>) 1) (define (kl:shen.<postdigits> V2336) (let ((Parse_shen.<digits> (kl:shen.<digits> V2336))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.hdtl Parse_shen.<digits>)) (kl:fail)))) (quote shen.<postdigits>))
(begin (register-function-arity (quote shen.<digits>) 1) (define (kl:shen.<digits> V2338) (let ((YaccParse (let ((Parse_shen.<digit> (kl:shen.<digit> V2338))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digit>)) (let ((Parse_shen.<digits> (kl:shen.<digits> Parse_shen.<digit>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (cons (kl:shen.hdtl Parse_shen.<digit>) (kl:shen.hdtl Parse_shen.<digits>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<digit> (kl:shen.<digit> V2338))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digit>)) (kl:shen.pair (car Parse_shen.<digit>) (cons (kl:shen.hdtl Parse_shen.<digit>) (quote ()))) (kl:fail))) YaccParse))) (quote shen.<digits>))
(begin (register-function-arity (quote shen.<digit>) 1) (define (kl:shen.<digit> V2340) (if (pair? (car V2340)) (let ((Parse_X (car (car V2340)))) (if (assert-boolean (kl:shen.numbyte? Parse_X)) (kl:shen.pair (car (kl:shen.pair (cdr (car V2340)) (kl:shen.hdtl V2340))) (kl:shen.byte->digit Parse_X)) (kl:fail))) (kl:fail))) (quote shen.<digit>))
(begin (register-function-arity (quote shen.byte->digit) 1) (define (kl:shen.byte->digit V2342) (cond ((kl:= 48 V2342) 0) ((kl:= 49 V2342) 1) ((kl:= 50 V2342) 2) ((kl:= 51 V2342) 3) ((kl:= 52 V2342) 4) ((kl:= 53 V2342) 5) ((kl:= 54 V2342) 6) ((kl:= 55 V2342) 7) ((kl:= 56 V2342) 8) ((kl:= 57 V2342) 9) (#t (kl:shen.f_error (quote shen.byte->digit))))) (quote shen.byte->digit))
(begin (register-function-arity (quote shen.pre) 2) (define (kl:shen.pre V2347 V2348) (cond ((null? V2347) 0) ((pair? V2347) (+ (* (kl:shen.expt 10 V2348) (car V2347)) (kl:shen.pre (cdr V2347) (+ V2348 1)))) (#t (kl:shen.f_error (quote shen.pre))))) (quote shen.pre))
(begin (register-function-arity (quote shen.post) 2) (define (kl:shen.post V2353 V2354) (cond ((null? V2353) 0) ((pair? V2353) (+ (* (kl:shen.expt 10 (- 0 V2354)) (car V2353)) (kl:shen.post (cdr V2353) (+ V2354 1)))) (#t (kl:shen.f_error (quote shen.post))))) (quote shen.post))
(begin (register-function-arity (quote shen.expt) 2) (define (kl:shen.expt V2359 V2360) (cond ((kl:= 0 V2360) 1) ((> V2360 0) (* V2359 (kl:shen.expt V2359 (- V2360 1)))) (#t (* 1.000000 (/ (kl:shen.expt V2359 (+ V2360 1)) V2359))))) (quote shen.expt))
(begin (register-function-arity (quote shen.<st_input1>) 1) (define (kl:shen.<st_input1> V2362) (let ((Parse_shen.<st_input> (kl:shen.<st_input> V2362))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail)))) (quote shen.<st_input1>))
(begin (register-function-arity (quote shen.<st_input2>) 1) (define (kl:shen.<st_input2> V2364) (let ((Parse_shen.<st_input> (kl:shen.<st_input> V2364))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail)))) (quote shen.<st_input2>))
(begin (register-function-arity (quote shen.<comment>) 1) (define (kl:shen.<comment> V2366) (let ((YaccParse (let ((Parse_shen.<singleline> (kl:shen.<singleline> V2366))) (if (kl:not (kl:= (kl:fail) Parse_shen.<singleline>)) (kl:shen.pair (car Parse_shen.<singleline>) (quote shen.skip)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<multiline> (kl:shen.<multiline> V2366))) (if (kl:not (kl:= (kl:fail) Parse_shen.<multiline>)) (kl:shen.pair (car Parse_shen.<multiline>) (quote shen.skip)) (kl:fail))) YaccParse))) (quote shen.<comment>))
(begin (register-function-arity (quote shen.<singleline>) 1) (define (kl:shen.<singleline> V2368) (let ((Parse_shen.<backslash> (kl:shen.<backslash> V2368))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (let ((Parse_shen.<backslash> (kl:shen.<backslash> Parse_shen.<backslash>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (let ((Parse_shen.<anysingle> (kl:shen.<anysingle> Parse_shen.<backslash>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anysingle>)) (let ((Parse_shen.<return> (kl:shen.<return> Parse_shen.<anysingle>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<return>)) (kl:shen.pair (car Parse_shen.<return>) (quote shen.skip)) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail)))) (quote shen.<singleline>))
(begin (register-function-arity (quote shen.<backslash>) 1) (define (kl:shen.<backslash> V2370) (if (and (pair? (car V2370)) (kl:= 92 (car (car V2370)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2370)) (kl:shen.hdtl V2370))) (quote shen.skip)) (kl:fail))) (quote shen.<backslash>))
(begin (register-function-arity (quote shen.<anysingle>) 1) (define (kl:shen.<anysingle> V2372) (let ((YaccParse (let ((Parse_shen.<non-return> (kl:shen.<non-return> V2372))) (if (kl:not (kl:= (kl:fail) Parse_shen.<non-return>)) (let ((Parse_shen.<anysingle> (kl:shen.<anysingle> Parse_shen.<non-return>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anysingle>)) (kl:shen.pair (car Parse_shen.<anysingle>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2372))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote shen.skip)) (kl:fail))) YaccParse))) (quote shen.<anysingle>))
(begin (register-function-arity (quote shen.<non-return>) 1) (define (kl:shen.<non-return> V2374) (if (pair? (car V2374)) (let ((Parse_X (car (car V2374)))) (if (kl:not (kl:element? Parse_X (cons 10 (cons 13 (quote ()))))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2374)) (kl:shen.hdtl V2374))) (quote shen.skip)) (kl:fail))) (kl:fail))) (quote shen.<non-return>))
(begin (register-function-arity (quote shen.<return>) 1) (define (kl:shen.<return> V2376) (if (pair? (car V2376)) (let ((Parse_X (car (car V2376)))) (if (kl:element? Parse_X (cons 10 (cons 13 (quote ())))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2376)) (kl:shen.hdtl V2376))) (quote shen.skip)) (kl:fail))) (kl:fail))) (quote shen.<return>))
(begin (register-function-arity (quote shen.<multiline>) 1) (define (kl:shen.<multiline> V2378) (let ((Parse_shen.<backslash> (kl:shen.<backslash> V2378))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (let ((Parse_shen.<times> (kl:shen.<times> Parse_shen.<backslash>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<times>)) (let ((Parse_shen.<anymulti> (kl:shen.<anymulti> Parse_shen.<times>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anymulti>)) (kl:shen.pair (car Parse_shen.<anymulti>) (quote shen.skip)) (kl:fail))) (kl:fail))) (kl:fail)))) (quote shen.<multiline>))
(begin (register-function-arity (quote shen.<times>) 1) (define (kl:shen.<times> V2380) (if (and (pair? (car V2380)) (kl:= 42 (car (car V2380)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2380)) (kl:shen.hdtl V2380))) (quote shen.skip)) (kl:fail))) (quote shen.<times>))
(begin (register-function-arity (quote shen.<anymulti>) 1) (define (kl:shen.<anymulti> V2382) (let ((YaccParse (let ((Parse_shen.<comment> (kl:shen.<comment> V2382))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comment>)) (let ((Parse_shen.<anymulti> (kl:shen.<anymulti> Parse_shen.<comment>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anymulti>)) (kl:shen.pair (car Parse_shen.<anymulti>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<times> (kl:shen.<times> V2382))) (if (kl:not (kl:= (kl:fail) Parse_shen.<times>)) (let ((Parse_shen.<backslash> (kl:shen.<backslash> Parse_shen.<times>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (kl:shen.pair (car Parse_shen.<backslash>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (if (pair? (car V2382)) (let ((Parse_X (car (car V2382)))) (let ((Parse_shen.<anymulti> (kl:shen.<anymulti> (kl:shen.pair (cdr (car V2382)) (kl:shen.hdtl V2382))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anymulti>)) (kl:shen.pair (car Parse_shen.<anymulti>) (quote shen.skip)) (kl:fail)))) (kl:fail)) YaccParse)) YaccParse))) (quote shen.<anymulti>))
(begin (register-function-arity (quote shen.<whitespaces>) 1) (define (kl:shen.<whitespaces> V2384) (let ((YaccParse (let ((Parse_shen.<whitespace> (kl:shen.<whitespace> V2384))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespace>)) (let ((Parse_shen.<whitespaces> (kl:shen.<whitespaces> Parse_shen.<whitespace>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespaces>)) (kl:shen.pair (car Parse_shen.<whitespaces>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<whitespace> (kl:shen.<whitespace> V2384))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespace>)) (kl:shen.pair (car Parse_shen.<whitespace>) (quote shen.skip)) (kl:fail))) YaccParse))) (quote shen.<whitespaces>))
(begin (register-function-arity (quote shen.<whitespace>) 1) (define (kl:shen.<whitespace> V2386) (if (pair? (car V2386)) (let ((Parse_X (car (car V2386)))) (if (assert-boolean (let ((Parse_Case Parse_X)) (or (kl:= Parse_Case 32) (or (kl:= Parse_Case 13) (or (kl:= Parse_Case 10) (kl:= Parse_Case 9)))))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2386)) (kl:shen.hdtl V2386))) (quote shen.skip)) (kl:fail))) (kl:fail))) (quote shen.<whitespace>))
(begin (register-function-arity (quote shen.cons_form) 1) (define (kl:shen.cons_form V2388) (cond ((null? V2388) (quote ())) ((and (pair? V2388) (and (pair? (cdr V2388)) (and (pair? (cdr (cdr V2388))) (and (null? (cdr (cdr (cdr V2388)))) (eq? (car (cdr V2388)) (quote bar!)))))) (cons (quote cons) (cons (car V2388) (cdr (cdr V2388))))) ((pair? V2388) (cons (quote cons) (cons (car V2388) (cons (kl:shen.cons_form (cdr V2388)) (quote ()))))) (#t (kl:shen.f_error (quote shen.cons_form))))) (quote shen.cons_form))
(begin (register-function-arity (quote shen.package-macro) 2) (define (kl:shen.package-macro V2393 V2394) (cond ((and (pair? V2393) (and (eq? (quote _waspvm_dl_) (car V2393)) (and (pair? (cdr V2393)) (null? (cdr (cdr V2393)))))) (kl:append (kl:explode (car (cdr V2393))) V2394)) ((and (pair? V2393) (and (eq? (quote package) (car V2393)) (and (pair? (cdr V2393)) (and (eq? (quote null) (car (cdr V2393))) (pair? (cdr (cdr V2393))))))) (kl:append (cdr (cdr (cdr V2393))) V2394)) ((and (pair? V2393) (and (eq? (quote package) (car V2393)) (and (pair? (cdr V2393)) (pair? (cdr (cdr V2393)))))) (let ((ListofExceptions (kl:shen.eval-without-macros (car (cdr (cdr V2393)))))) (let ((External (kl:shen.record-exceptions ListofExceptions (car (cdr V2393))))) (let ((PackageNameDot (kl:intern (string-append (kl:str (car (cdr V2393))) ".")))) (let ((ExpPackageNameDot (kl:explode PackageNameDot))) (let ((Packaged (kl:shen.packageh PackageNameDot ListofExceptions (cdr (cdr (cdr V2393))) ExpPackageNameDot))) (let ((Internal (kl:shen.record-internal (car (cdr V2393)) (kl:shen.internal-symbols ExpPackageNameDot Packaged)))) (kl:append Packaged V2394)))))))) (#t (cons V2393 V2394)))) (quote shen.package-macro))
(begin (register-function-arity (quote shen.record-exceptions) 2) (define (kl:shen.record-exceptions V2397 V2398) (let ((CurrExceptions (kl:get/or V2398 (quote shen.external-symbols) (lambda () (quote ())) (kl:value (quote *property-vector*))))) (let ((AllExceptions (kl:union V2397 CurrExceptions))) (kl:put V2398 (quote shen.external-symbols) AllExceptions (kl:value (quote *property-vector*)))))) (quote shen.record-exceptions))
(begin (register-function-arity (quote shen.record-internal) 2) (define (kl:shen.record-internal V2401 V2402) (kl:put V2401 (quote shen.internal-symbols) (kl:union V2402 (kl:get/or V2401 (quote shen.internal-symbols) (lambda () (quote ())) (kl:value (quote *property-vector*)))) (kl:value (quote *property-vector*)))) (quote shen.record-internal))
(begin (register-function-arity (quote shen.internal-symbols) 2) (define (kl:shen.internal-symbols V2413 V2414) (cond ((and (kl:symbol? V2414) (assert-boolean (kl:shen.prefix? V2413 (kl:explode V2414)))) (cons V2414 (quote ()))) ((pair? V2414) (kl:union (kl:shen.internal-symbols V2413 (car V2414)) (kl:shen.internal-symbols V2413 (cdr V2414)))) (#t (quote ())))) (quote shen.internal-symbols))
(begin (register-function-arity (quote shen.packageh) 4) (define (kl:shen.packageh V2431 V2432 V2433 V2434) (cond ((pair? V2433) (cons (kl:shen.packageh V2431 V2432 (car V2433) V2434) (kl:shen.packageh V2431 V2432 (cdr V2433) V2434))) ((or (assert-boolean (kl:shen.sysfunc? V2433)) (or (kl:variable? V2433) (or (kl:element? V2433 V2432) (or (assert-boolean (kl:shen.doubleunderline? V2433)) (assert-boolean (kl:shen.singleunderline? V2433)))))) V2433) ((and (kl:symbol? V2433) (assert-boolean (let ((ExplodeX (kl:explode V2433))) (and (kl:not (kl:shen.prefix? (cons "s" (cons "h" (cons "e" (cons "n" (cons "." (quote ())))))) ExplodeX)) (kl:not (kl:shen.prefix? V2434 ExplodeX)))))) (kl:concat V2431 V2433)) (#t V2433))) (quote shen.packageh))
