"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.read-char-code) 1) (define (kl:shen.read-char-code V2181) (read-u8 V2181)) (quote shen.read-char-code))
(begin (register-function-arity (quote read-file-as-bytelist) 1) (define (kl:read-file-as-bytelist V2183) (kl:shen.read-file-as-Xlist V2183 (lambda (S) (read-u8 S)))) (quote read-file-as-bytelist))
(begin (register-function-arity (quote shen.read-file-as-charlist) 1) (define (kl:shen.read-file-as-charlist V2185) (kl:shen.read-file-as-Xlist V2185 (lambda (S) (kl:shen.read-char-code S)))) (quote shen.read-file-as-charlist))
(begin (register-function-arity (quote shen.read-file-as-Xlist) 2) (define (kl:shen.read-file-as-Xlist V2188 V2189) (let ((Stream (kl:open V2188 (quote in)))) (let ((X (V2189 Stream))) (let ((Xs (kl:shen.read-file-as-Xlist-help Stream V2189 X (quote ())))) (let ((Close (kl:close Stream))) (kl:reverse Xs)))))) (quote shen.read-file-as-Xlist))
(begin (register-function-arity (quote shen.read-file-as-Xlist-help) 4) (define (kl:shen.read-file-as-Xlist-help V2194 V2195 V2196 V2197) (cond ((kl:= -1 V2196) V2197) (#t (kl:shen.read-file-as-Xlist-help V2194 V2195 (V2195 V2194) (cons V2196 V2197))))) (quote shen.read-file-as-Xlist-help))
(begin (register-function-arity (quote read-file-as-string) 1) (define (kl:read-file-as-string V2199) (let ((Stream (kl:open V2199 (quote in)))) (kl:shen.rfas-h Stream (kl:shen.read-char-code Stream) ""))) (quote read-file-as-string))
(begin (register-function-arity (quote shen.rfas-h) 3) (define (kl:shen.rfas-h V2203 V2204 V2205) (cond ((kl:= -1 V2204) (begin (kl:close V2203) V2205)) (#t (kl:shen.rfas-h V2203 (kl:shen.read-char-code V2203) (string-append V2205 (make-string 1 V2204)))))) (quote shen.rfas-h))
(begin (register-function-arity (quote input) 1) (define (kl:input V2207) (kl:eval-kl (kl:read V2207))) (quote input))
(begin (register-function-arity (quote input+) 2) (define (kl:input+ V2210 V2211) (let ((Mono? (kl:shen.monotype V2210))) (let ((Input (kl:read V2211))) (if (kl:= #f (kl:shen.typecheck Input (kl:shen.demodulate V2210))) (simple-error (string-append "type error: " (kl:shen.app Input (string-append " is not of type " (kl:shen.app V2210 "\n" (quote shen.r))) (quote shen.r)))) (kl:eval-kl Input))))) (quote input+))
(begin (register-function-arity (quote shen.monotype) 1) (define (kl:shen.monotype V2213) (cond ((pair? V2213) (kl:map (lambda (Z) (kl:shen.monotype Z)) V2213)) (#t (if (kl:variable? V2213) (simple-error (string-append "input+ expects a monotype: not " (kl:shen.app V2213 "\n" (quote shen.a)))) V2213)))) (quote shen.monotype))
(begin (register-function-arity (quote read) 1) (define (kl:read V2215) (car (kl:shen.read-loop V2215 (kl:shen.read-char-code V2215) (quote ())))) (quote read))
(begin (register-function-arity (quote it) 0) (define (kl:it) (kl:value (quote shen.*it*))) (quote it))
(begin (register-function-arity (quote shen.read-loop) 3) (define (kl:shen.read-loop V2223 V2224 V2225) (cond ((kl:= 94 V2224) (simple-error "read aborted")) ((kl:= -1 V2224) (if (kl:empty? V2225) (simple-error "error: empty stream") (kl:compile (lambda (X) (kl:shen.<st_input> X)) V2225 (lambda (E) E)))) ((assert-boolean (kl:shen.terminator? V2224)) (let ((AllChars (kl:append V2225 (cons V2224 (quote ()))))) (let ((It (kl:shen.record-it AllChars))) (let ((Read (kl:compile (lambda (X) (kl:shen.<st_input> X)) AllChars (lambda (E) (quote shen.nextbyte))))) (if (or (eq? Read (quote shen.nextbyte)) (kl:empty? Read)) (kl:shen.read-loop V2223 (kl:shen.read-char-code V2223) AllChars) Read))))) (#t (kl:shen.read-loop V2223 (kl:shen.read-char-code V2223) (kl:append V2225 (cons V2224 (quote ()))))))) (quote shen.read-loop))
(begin (register-function-arity (quote shen.terminator?) 1) (define (kl:shen.terminator? V2227) (kl:element? V2227 (cons 9 (cons 10 (cons 13 (cons 32 (cons 34 (cons 41 (cons 93 (quote ())))))))))) (quote shen.terminator?))
(begin (register-function-arity (quote lineread) 1) (define (kl:lineread V2229) (kl:shen.lineread-loop (kl:shen.read-char-code V2229) (quote ()) V2229)) (quote lineread))
(begin (register-function-arity (quote shen.lineread-loop) 3) (define (kl:shen.lineread-loop V2234 V2235 V2236) (cond ((kl:= -1 V2234) (if (kl:empty? V2235) (simple-error "empty stream") (kl:compile (lambda (X) (kl:shen.<st_input> X)) V2235 (lambda (E) E)))) ((kl:= V2234 (kl:shen.hat)) (simple-error "line read aborted")) ((kl:element? V2234 (cons (kl:shen.newline) (cons (kl:shen.carriage-return) (quote ())))) (let ((Line (kl:compile (lambda (X) (kl:shen.<st_input> X)) V2235 (lambda (E) (quote shen.nextline))))) (let ((It (kl:shen.record-it V2235))) (if (or (eq? Line (quote shen.nextline)) (kl:empty? Line)) (kl:shen.lineread-loop (kl:shen.read-char-code V2236) (kl:append V2235 (cons V2234 (quote ()))) V2236) Line)))) (#t (kl:shen.lineread-loop (kl:shen.read-char-code V2236) (kl:append V2235 (cons V2234 (quote ()))) V2236)))) (quote shen.lineread-loop))
(begin (register-function-arity (quote shen.record-it) 1) (define (kl:shen.record-it V2238) (let ((TrimLeft (kl:shen.trim-whitespace V2238))) (let ((TrimRight (kl:shen.trim-whitespace (kl:reverse TrimLeft)))) (let ((Trimmed (kl:reverse TrimRight))) (kl:shen.record-it-h Trimmed))))) (quote shen.record-it))
(begin (register-function-arity (quote shen.trim-whitespace) 1) (define (kl:shen.trim-whitespace V2240) (cond ((and (pair? V2240) (kl:element? (car V2240) (cons 9 (cons 10 (cons 13 (cons 32 (quote ()))))))) (kl:shen.trim-whitespace (cdr V2240))) (#t V2240))) (quote shen.trim-whitespace))
(begin (register-function-arity (quote shen.record-it-h) 1) (define (kl:shen.record-it-h V2242) (begin (kl:set (quote shen.*it*) (kl:shen.cn-all (kl:map (lambda (X) (make-string 1 X)) V2242))) V2242)) (quote shen.record-it-h))
(begin (register-function-arity (quote shen.cn-all) 1) (define (kl:shen.cn-all V2244) (cond ((null? V2244) "") ((pair? V2244) (string-append (car V2244) (kl:shen.cn-all (cdr V2244)))) (#t (kl:shen.f_error (quote shen.cn-all))))) (quote shen.cn-all))
(begin (register-function-arity (quote read-file) 1) (define (kl:read-file V2246) (let ((Charlist (kl:shen.read-file-as-charlist V2246))) (kl:compile (lambda (X) (kl:shen.<st_input> X)) Charlist (lambda (X) (kl:shen.read-error X))))) (quote read-file))
(begin (register-function-arity (quote read-from-string) 1) (define (kl:read-from-string V2248) (let ((Ns (kl:map (lambda (X) (string-ref X 0)) (kl:explode V2248)))) (kl:compile (lambda (X) (kl:shen.<st_input> X)) Ns (lambda (X) (kl:shen.read-error X))))) (quote read-from-string))
(begin (register-function-arity (quote shen.read-error) 1) (define (kl:shen.read-error V2256) (cond ((and (pair? V2256) (and (pair? (car V2256)) (and (pair? (cdr V2256)) (null? (cdr (cdr V2256)))))) (simple-error (string-append "read error here:\n\n " (kl:shen.app (kl:shen.compress-50 50 (car V2256)) "\n" (quote shen.a))))) (#t (simple-error "read error\n")))) (quote shen.read-error))
(begin (register-function-arity (quote shen.compress-50) 2) (define (kl:shen.compress-50 V2263 V2264) (cond ((null? V2264) "") ((kl:= 0 V2263) "") ((pair? V2264) (string-append (make-string 1 (car V2264)) (kl:shen.compress-50 (- V2263 1) (cdr V2264)))) (#t (kl:shen.f_error (quote shen.compress-50))))) (quote shen.compress-50))
(begin (register-function-arity (quote shen.<st_input>) 1) (define (kl:shen.<st_input> V2266) (let ((YaccParse (let ((Parse_shen.<lsb> (kl:shen.<lsb> V2266))) (if (kl:not (kl:= (kl:fail) Parse_shen.<lsb>)) (let ((Parse_shen.<st_input1> (kl:shen.<st_input1> Parse_shen.<lsb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input1>)) (let ((Parse_shen.<rsb> (kl:shen.<rsb> Parse_shen.<st_input1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rsb>)) (let ((Parse_shen.<st_input2> (kl:shen.<st_input2> Parse_shen.<rsb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input2>)) (kl:shen.pair (car Parse_shen.<st_input2>) (cons (kl:macroexpand (kl:shen.cons_form (kl:shen.hdtl Parse_shen.<st_input1>))) (kl:shen.hdtl Parse_shen.<st_input2>))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<lrb> (kl:shen.<lrb> V2266))) (if (kl:not (kl:= (kl:fail) Parse_shen.<lrb>)) (let ((Parse_shen.<st_input1> (kl:shen.<st_input1> Parse_shen.<lrb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input1>)) (let ((Parse_shen.<rrb> (kl:shen.<rrb> Parse_shen.<st_input1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rrb>)) (let ((Parse_shen.<st_input2> (kl:shen.<st_input2> Parse_shen.<rrb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input2>)) (kl:shen.pair (car Parse_shen.<st_input2>) (kl:shen.package-macro (kl:macroexpand (kl:shen.hdtl Parse_shen.<st_input1>)) (kl:shen.hdtl Parse_shen.<st_input2>))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<lcurly> (kl:shen.<lcurly> V2266))) (if (kl:not (kl:= (kl:fail) Parse_shen.<lcurly>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<lcurly>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote {) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<rcurly> (kl:shen.<rcurly> V2266))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rcurly>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<rcurly>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote }) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<bar> (kl:shen.<bar> V2266))) (if (kl:not (kl:= (kl:fail) Parse_shen.<bar>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<bar>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote bar!) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<semicolon> (kl:shen.<semicolon> V2266))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<semicolon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote _waspvm_sc_) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<colon> (kl:shen.<colon> V2266))) (if (kl:not (kl:= (kl:fail) Parse_shen.<colon>)) (let ((Parse_shen.<equal> (kl:shen.<equal> Parse_shen.<colon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<equal>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<equal>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote :=) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<colon> (kl:shen.<colon> V2266))) (if (kl:not (kl:= (kl:fail) Parse_shen.<colon>)) (let ((Parse_shen.<minus> (kl:shen.<minus> Parse_shen.<colon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<minus>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<minus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote :-) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<colon> (kl:shen.<colon> V2266))) (if (kl:not (kl:= (kl:fail) Parse_shen.<colon>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<colon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote :) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<comma> (kl:shen.<comma> V2266))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comma>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<comma>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (kl:intern ",") (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<comment> (kl:shen.<comment> V2266))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comment>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<comment>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<atom> (kl:shen.<atom> V2266))) (if (kl:not (kl:= (kl:fail) Parse_shen.<atom>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<atom>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (kl:macroexpand (kl:shen.hdtl Parse_shen.<atom>)) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<whitespaces> (kl:shen.<whitespaces> V2266))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespaces>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<whitespaces>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2266))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse))) (quote shen.<st_input>))
(begin (register-function-arity (quote shen.<lsb>) 1) (define (kl:shen.<lsb> V2269) (if (and (pair? (car V2269)) (kl:= 91 (kl:shen.hdhd V2269))) (let ((NewStream2267 (kl:shen.pair (kl:shen.tlhd V2269) (kl:shen.hdtl V2269)))) (kl:shen.pair (car NewStream2267) (quote shen.skip))) (kl:fail))) (quote shen.<lsb>))
(begin (register-function-arity (quote shen.<rsb>) 1) (define (kl:shen.<rsb> V2272) (if (and (pair? (car V2272)) (kl:= 93 (kl:shen.hdhd V2272))) (let ((NewStream2270 (kl:shen.pair (kl:shen.tlhd V2272) (kl:shen.hdtl V2272)))) (kl:shen.pair (car NewStream2270) (quote shen.skip))) (kl:fail))) (quote shen.<rsb>))
(begin (register-function-arity (quote shen.<lcurly>) 1) (define (kl:shen.<lcurly> V2275) (if (and (pair? (car V2275)) (kl:= 123 (kl:shen.hdhd V2275))) (let ((NewStream2273 (kl:shen.pair (kl:shen.tlhd V2275) (kl:shen.hdtl V2275)))) (kl:shen.pair (car NewStream2273) (quote shen.skip))) (kl:fail))) (quote shen.<lcurly>))
(begin (register-function-arity (quote shen.<rcurly>) 1) (define (kl:shen.<rcurly> V2278) (if (and (pair? (car V2278)) (kl:= 125 (kl:shen.hdhd V2278))) (let ((NewStream2276 (kl:shen.pair (kl:shen.tlhd V2278) (kl:shen.hdtl V2278)))) (kl:shen.pair (car NewStream2276) (quote shen.skip))) (kl:fail))) (quote shen.<rcurly>))
(begin (register-function-arity (quote shen.<bar>) 1) (define (kl:shen.<bar> V2281) (if (and (pair? (car V2281)) (kl:= 124 (kl:shen.hdhd V2281))) (let ((NewStream2279 (kl:shen.pair (kl:shen.tlhd V2281) (kl:shen.hdtl V2281)))) (kl:shen.pair (car NewStream2279) (quote shen.skip))) (kl:fail))) (quote shen.<bar>))
(begin (register-function-arity (quote shen.<semicolon>) 1) (define (kl:shen.<semicolon> V2284) (if (and (pair? (car V2284)) (kl:= 59 (kl:shen.hdhd V2284))) (let ((NewStream2282 (kl:shen.pair (kl:shen.tlhd V2284) (kl:shen.hdtl V2284)))) (kl:shen.pair (car NewStream2282) (quote shen.skip))) (kl:fail))) (quote shen.<semicolon>))
(begin (register-function-arity (quote shen.<colon>) 1) (define (kl:shen.<colon> V2287) (if (and (pair? (car V2287)) (kl:= 58 (kl:shen.hdhd V2287))) (let ((NewStream2285 (kl:shen.pair (kl:shen.tlhd V2287) (kl:shen.hdtl V2287)))) (kl:shen.pair (car NewStream2285) (quote shen.skip))) (kl:fail))) (quote shen.<colon>))
(begin (register-function-arity (quote shen.<comma>) 1) (define (kl:shen.<comma> V2290) (if (and (pair? (car V2290)) (kl:= 44 (kl:shen.hdhd V2290))) (let ((NewStream2288 (kl:shen.pair (kl:shen.tlhd V2290) (kl:shen.hdtl V2290)))) (kl:shen.pair (car NewStream2288) (quote shen.skip))) (kl:fail))) (quote shen.<comma>))
(begin (register-function-arity (quote shen.<equal>) 1) (define (kl:shen.<equal> V2293) (if (and (pair? (car V2293)) (kl:= 61 (kl:shen.hdhd V2293))) (let ((NewStream2291 (kl:shen.pair (kl:shen.tlhd V2293) (kl:shen.hdtl V2293)))) (kl:shen.pair (car NewStream2291) (quote shen.skip))) (kl:fail))) (quote shen.<equal>))
(begin (register-function-arity (quote shen.<minus>) 1) (define (kl:shen.<minus> V2296) (if (and (pair? (car V2296)) (kl:= 45 (kl:shen.hdhd V2296))) (let ((NewStream2294 (kl:shen.pair (kl:shen.tlhd V2296) (kl:shen.hdtl V2296)))) (kl:shen.pair (car NewStream2294) (quote shen.skip))) (kl:fail))) (quote shen.<minus>))
(begin (register-function-arity (quote shen.<lrb>) 1) (define (kl:shen.<lrb> V2299) (if (and (pair? (car V2299)) (kl:= 40 (kl:shen.hdhd V2299))) (let ((NewStream2297 (kl:shen.pair (kl:shen.tlhd V2299) (kl:shen.hdtl V2299)))) (kl:shen.pair (car NewStream2297) (quote shen.skip))) (kl:fail))) (quote shen.<lrb>))
(begin (register-function-arity (quote shen.<rrb>) 1) (define (kl:shen.<rrb> V2302) (if (and (pair? (car V2302)) (kl:= 41 (kl:shen.hdhd V2302))) (let ((NewStream2300 (kl:shen.pair (kl:shen.tlhd V2302) (kl:shen.hdtl V2302)))) (kl:shen.pair (car NewStream2300) (quote shen.skip))) (kl:fail))) (quote shen.<rrb>))
(begin (register-function-arity (quote shen.<atom>) 1) (define (kl:shen.<atom> V2304) (let ((YaccParse (let ((Parse_shen.<str> (kl:shen.<str> V2304))) (if (kl:not (kl:= (kl:fail) Parse_shen.<str>)) (kl:shen.pair (car Parse_shen.<str>) (kl:shen.control-chars (kl:shen.hdtl Parse_shen.<str>))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<number> (kl:shen.<number> V2304))) (if (kl:not (kl:= (kl:fail) Parse_shen.<number>)) (kl:shen.pair (car Parse_shen.<number>) (kl:shen.hdtl Parse_shen.<number>)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<sym> (kl:shen.<sym> V2304))) (if (kl:not (kl:= (kl:fail) Parse_shen.<sym>)) (kl:shen.pair (car Parse_shen.<sym>) (if (equal? (kl:shen.hdtl Parse_shen.<sym>) "<>") (cons (quote vector) (cons 0 (quote ()))) (kl:intern (kl:shen.hdtl Parse_shen.<sym>)))) (kl:fail))) YaccParse)) YaccParse))) (quote shen.<atom>))
(begin (register-function-arity (quote shen.control-chars) 1) (define (kl:shen.control-chars V2306) (cond ((null? V2306) "") ((and (pair? V2306) (and (equal? "c" (car V2306)) (and (pair? (cdr V2306)) (equal? "#" (car (cdr V2306)))))) (let ((CodePoint (kl:shen.code-point (cdr (cdr V2306))))) (let ((AfterCodePoint (kl:shen.after-codepoint (cdr (cdr V2306))))) (kl:_waspvm_at_s (make-string 1 (kl:shen.decimalise CodePoint)) (kl:shen.control-chars AfterCodePoint))))) ((pair? V2306) (kl:_waspvm_at_s (car V2306) (kl:shen.control-chars (cdr V2306)))) (#t (kl:shen.f_error (quote shen.control-chars))))) (quote shen.control-chars))
(begin (register-function-arity (quote shen.code-point) 1) (define (kl:shen.code-point V2310) (cond ((and (pair? V2310) (equal? ";" (car V2310))) "") ((and (pair? V2310) (kl:element? (car V2310) (cons "0" (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" (quote ())))))))))))))) (cons (car V2310) (kl:shen.code-point (cdr V2310)))) (#t (simple-error (string-append "code point parse error " (kl:shen.app V2310 "\n" (quote shen.a))))))) (quote shen.code-point))
(begin (register-function-arity (quote shen.after-codepoint) 1) (define (kl:shen.after-codepoint V2316) (cond ((null? V2316) (quote ())) ((and (pair? V2316) (equal? ";" (car V2316))) (cdr V2316)) ((pair? V2316) (kl:shen.after-codepoint (cdr V2316))) (#t (kl:shen.f_error (quote shen.after-codepoint))))) (quote shen.after-codepoint))
(begin (register-function-arity (quote shen.decimalise) 1) (define (kl:shen.decimalise V2318) (kl:shen.pre (kl:reverse (kl:shen.digits->integers V2318)) 0)) (quote shen.decimalise))
(begin (register-function-arity (quote shen.digits->integers) 1) (define (kl:shen.digits->integers V2324) (cond ((and (pair? V2324) (equal? "0" (car V2324))) (cons 0 (kl:shen.digits->integers (cdr V2324)))) ((and (pair? V2324) (equal? "1" (car V2324))) (cons 1 (kl:shen.digits->integers (cdr V2324)))) ((and (pair? V2324) (equal? "2" (car V2324))) (cons 2 (kl:shen.digits->integers (cdr V2324)))) ((and (pair? V2324) (equal? "3" (car V2324))) (cons 3 (kl:shen.digits->integers (cdr V2324)))) ((and (pair? V2324) (equal? "4" (car V2324))) (cons 4 (kl:shen.digits->integers (cdr V2324)))) ((and (pair? V2324) (equal? "5" (car V2324))) (cons 5 (kl:shen.digits->integers (cdr V2324)))) ((and (pair? V2324) (equal? "6" (car V2324))) (cons 6 (kl:shen.digits->integers (cdr V2324)))) ((and (pair? V2324) (equal? "7" (car V2324))) (cons 7 (kl:shen.digits->integers (cdr V2324)))) ((and (pair? V2324) (equal? "8" (car V2324))) (cons 8 (kl:shen.digits->integers (cdr V2324)))) ((and (pair? V2324) (equal? "9" (car V2324))) (cons 9 (kl:shen.digits->integers (cdr V2324)))) (#t (quote ())))) (quote shen.digits->integers))
(begin (register-function-arity (quote shen.<sym>) 1) (define (kl:shen.<sym> V2326) (let ((Parse_shen.<alpha> (kl:shen.<alpha> V2326))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alpha>)) (let ((Parse_shen.<alphanums> (kl:shen.<alphanums> Parse_shen.<alpha>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alphanums>)) (kl:shen.pair (car Parse_shen.<alphanums>) (kl:_waspvm_at_s (kl:shen.hdtl Parse_shen.<alpha>) (kl:shen.hdtl Parse_shen.<alphanums>))) (kl:fail))) (kl:fail)))) (quote shen.<sym>))
(begin (register-function-arity (quote shen.<alphanums>) 1) (define (kl:shen.<alphanums> V2328) (let ((YaccParse (let ((Parse_shen.<alphanum> (kl:shen.<alphanum> V2328))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alphanum>)) (let ((Parse_shen.<alphanums> (kl:shen.<alphanums> Parse_shen.<alphanum>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alphanums>)) (kl:shen.pair (car Parse_shen.<alphanums>) (kl:_waspvm_at_s (kl:shen.hdtl Parse_shen.<alphanum>) (kl:shen.hdtl Parse_shen.<alphanums>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2328))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) "") (kl:fail))) YaccParse))) (quote shen.<alphanums>))
(begin (register-function-arity (quote shen.<alphanum>) 1) (define (kl:shen.<alphanum> V2330) (let ((YaccParse (let ((Parse_shen.<alpha> (kl:shen.<alpha> V2330))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alpha>)) (kl:shen.pair (car Parse_shen.<alpha>) (kl:shen.hdtl Parse_shen.<alpha>)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<num> (kl:shen.<num> V2330))) (if (kl:not (kl:= (kl:fail) Parse_shen.<num>)) (kl:shen.pair (car Parse_shen.<num>) (kl:shen.hdtl Parse_shen.<num>)) (kl:fail))) YaccParse))) (quote shen.<alphanum>))
(begin (register-function-arity (quote shen.<num>) 1) (define (kl:shen.<num> V2332) (if (pair? (car V2332)) (let ((Parse_Char (kl:shen.hdhd V2332))) (if (assert-boolean (kl:shen.numbyte? Parse_Char)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2332) (kl:shen.hdtl V2332))) (make-string 1 Parse_Char)) (kl:fail))) (kl:fail))) (quote shen.<num>))
(begin (register-function-arity (quote shen.numbyte?) 1) (define (kl:shen.numbyte? V2338) (cond ((kl:= 48 V2338) #t) ((kl:= 49 V2338) #t) ((kl:= 50 V2338) #t) ((kl:= 51 V2338) #t) ((kl:= 52 V2338) #t) ((kl:= 53 V2338) #t) ((kl:= 54 V2338) #t) ((kl:= 55 V2338) #t) ((kl:= 56 V2338) #t) ((kl:= 57 V2338) #t) (#t #f))) (quote shen.numbyte?))
(begin (register-function-arity (quote shen.<alpha>) 1) (define (kl:shen.<alpha> V2340) (if (pair? (car V2340)) (let ((Parse_Char (kl:shen.hdhd V2340))) (if (assert-boolean (kl:shen.symbol-code? Parse_Char)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2340) (kl:shen.hdtl V2340))) (make-string 1 Parse_Char)) (kl:fail))) (kl:fail))) (quote shen.<alpha>))
(begin (register-function-arity (quote shen.symbol-code?) 1) (define (kl:shen.symbol-code? V2342) (or (kl:= V2342 126) (or (and (> V2342 94) (< V2342 123)) (or (and (> V2342 59) (< V2342 91)) (or (and (> V2342 41) (and (< V2342 58) (kl:not (kl:= V2342 44)))) (or (and (> V2342 34) (< V2342 40)) (kl:= V2342 33))))))) (quote shen.symbol-code?))
(begin (register-function-arity (quote shen.<str>) 1) (define (kl:shen.<str> V2344) (let ((Parse_shen.<dbq> (kl:shen.<dbq> V2344))) (if (kl:not (kl:= (kl:fail) Parse_shen.<dbq>)) (let ((Parse_shen.<strcontents> (kl:shen.<strcontents> Parse_shen.<dbq>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<strcontents>)) (let ((Parse_shen.<dbq> (kl:shen.<dbq> Parse_shen.<strcontents>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<dbq>)) (kl:shen.pair (car Parse_shen.<dbq>) (kl:shen.hdtl Parse_shen.<strcontents>)) (kl:fail))) (kl:fail))) (kl:fail)))) (quote shen.<str>))
(begin (register-function-arity (quote shen.<dbq>) 1) (define (kl:shen.<dbq> V2346) (if (pair? (car V2346)) (let ((Parse_Char (kl:shen.hdhd V2346))) (if (kl:= Parse_Char 34) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2346) (kl:shen.hdtl V2346))) Parse_Char) (kl:fail))) (kl:fail))) (quote shen.<dbq>))
(begin (register-function-arity (quote shen.<strcontents>) 1) (define (kl:shen.<strcontents> V2348) (let ((YaccParse (let ((Parse_shen.<strc> (kl:shen.<strc> V2348))) (if (kl:not (kl:= (kl:fail) Parse_shen.<strc>)) (let ((Parse_shen.<strcontents> (kl:shen.<strcontents> Parse_shen.<strc>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<strcontents>)) (kl:shen.pair (car Parse_shen.<strcontents>) (cons (kl:shen.hdtl Parse_shen.<strc>) (kl:shen.hdtl Parse_shen.<strcontents>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2348))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<strcontents>))
(begin (register-function-arity (quote shen.<byte>) 1) (define (kl:shen.<byte> V2350) (if (pair? (car V2350)) (let ((Parse_Char (kl:shen.hdhd V2350))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2350) (kl:shen.hdtl V2350))) (make-string 1 Parse_Char))) (kl:fail))) (quote shen.<byte>))
(begin (register-function-arity (quote shen.<strc>) 1) (define (kl:shen.<strc> V2352) (if (pair? (car V2352)) (let ((Parse_Char (kl:shen.hdhd V2352))) (if (kl:not (kl:= Parse_Char 34)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2352) (kl:shen.hdtl V2352))) (make-string 1 Parse_Char)) (kl:fail))) (kl:fail))) (quote shen.<strc>))
(begin (register-function-arity (quote shen.<number>) 1) (define (kl:shen.<number> V2354) (let ((YaccParse (let ((Parse_shen.<minus> (kl:shen.<minus> V2354))) (if (kl:not (kl:= (kl:fail) Parse_shen.<minus>)) (let ((Parse_shen.<number> (kl:shen.<number> Parse_shen.<minus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<number>)) (kl:shen.pair (car Parse_shen.<number>) (- 0 (kl:shen.hdtl Parse_shen.<number>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<plus> (kl:shen.<plus> V2354))) (if (kl:not (kl:= (kl:fail) Parse_shen.<plus>)) (let ((Parse_shen.<number> (kl:shen.<number> Parse_shen.<plus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<number>)) (kl:shen.pair (car Parse_shen.<number>) (kl:shen.hdtl Parse_shen.<number>)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<predigits> (kl:shen.<predigits> V2354))) (if (kl:not (kl:= (kl:fail) Parse_shen.<predigits>)) (let ((Parse_shen.<stop> (kl:shen.<stop> Parse_shen.<predigits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<stop>)) (let ((Parse_shen.<postdigits> (kl:shen.<postdigits> Parse_shen.<stop>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<postdigits>)) (let ((Parse_shen.<E> (kl:shen.<E> Parse_shen.<postdigits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<E>)) (let ((Parse_shen.<log10> (kl:shen.<log10> Parse_shen.<E>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<log10>)) (kl:shen.pair (car Parse_shen.<log10>) (* (kl:shen.expt 10 (kl:shen.hdtl Parse_shen.<log10>)) (+ (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<predigits>)) 0) (kl:shen.post (kl:shen.hdtl Parse_shen.<postdigits>) 1)))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<digits> (kl:shen.<digits> V2354))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (let ((Parse_shen.<E> (kl:shen.<E> Parse_shen.<digits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<E>)) (let ((Parse_shen.<log10> (kl:shen.<log10> Parse_shen.<E>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<log10>)) (kl:shen.pair (car Parse_shen.<log10>) (* (kl:shen.expt 10 (kl:shen.hdtl Parse_shen.<log10>)) (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<predigits> (kl:shen.<predigits> V2354))) (if (kl:not (kl:= (kl:fail) Parse_shen.<predigits>)) (let ((Parse_shen.<stop> (kl:shen.<stop> Parse_shen.<predigits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<stop>)) (let ((Parse_shen.<postdigits> (kl:shen.<postdigits> Parse_shen.<stop>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<postdigits>)) (kl:shen.pair (car Parse_shen.<postdigits>) (+ (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<predigits>)) 0) (kl:shen.post (kl:shen.hdtl Parse_shen.<postdigits>) 1))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<digits> (kl:shen.<digits> V2354))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0)) (kl:fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse))) (quote shen.<number>))
(begin (register-function-arity (quote shen.<E>) 1) (define (kl:shen.<E> V2357) (if (and (pair? (car V2357)) (kl:= 101 (kl:shen.hdhd V2357))) (let ((NewStream2355 (kl:shen.pair (kl:shen.tlhd V2357) (kl:shen.hdtl V2357)))) (kl:shen.pair (car NewStream2355) (quote shen.skip))) (kl:fail))) (quote shen.<E>))
(begin (register-function-arity (quote shen.<log10>) 1) (define (kl:shen.<log10> V2359) (let ((YaccParse (let ((Parse_shen.<minus> (kl:shen.<minus> V2359))) (if (kl:not (kl:= (kl:fail) Parse_shen.<minus>)) (let ((Parse_shen.<digits> (kl:shen.<digits> Parse_shen.<minus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (- 0 (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<digits> (kl:shen.<digits> V2359))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0)) (kl:fail))) YaccParse))) (quote shen.<log10>))
(begin (register-function-arity (quote shen.<plus>) 1) (define (kl:shen.<plus> V2361) (if (pair? (car V2361)) (let ((Parse_Char (kl:shen.hdhd V2361))) (if (kl:= Parse_Char 43) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2361) (kl:shen.hdtl V2361))) Parse_Char) (kl:fail))) (kl:fail))) (quote shen.<plus>))
(begin (register-function-arity (quote shen.<stop>) 1) (define (kl:shen.<stop> V2363) (if (pair? (car V2363)) (let ((Parse_Char (kl:shen.hdhd V2363))) (if (kl:= Parse_Char 46) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2363) (kl:shen.hdtl V2363))) Parse_Char) (kl:fail))) (kl:fail))) (quote shen.<stop>))
(begin (register-function-arity (quote shen.<predigits>) 1) (define (kl:shen.<predigits> V2365) (let ((YaccParse (let ((Parse_shen.<digits> (kl:shen.<digits> V2365))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.hdtl Parse_shen.<digits>)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2365))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<predigits>))
(begin (register-function-arity (quote shen.<postdigits>) 1) (define (kl:shen.<postdigits> V2367) (let ((Parse_shen.<digits> (kl:shen.<digits> V2367))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.hdtl Parse_shen.<digits>)) (kl:fail)))) (quote shen.<postdigits>))
(begin (register-function-arity (quote shen.<digits>) 1) (define (kl:shen.<digits> V2369) (let ((YaccParse (let ((Parse_shen.<digit> (kl:shen.<digit> V2369))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digit>)) (let ((Parse_shen.<digits> (kl:shen.<digits> Parse_shen.<digit>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (cons (kl:shen.hdtl Parse_shen.<digit>) (kl:shen.hdtl Parse_shen.<digits>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<digit> (kl:shen.<digit> V2369))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digit>)) (kl:shen.pair (car Parse_shen.<digit>) (cons (kl:shen.hdtl Parse_shen.<digit>) (quote ()))) (kl:fail))) YaccParse))) (quote shen.<digits>))
(begin (register-function-arity (quote shen.<digit>) 1) (define (kl:shen.<digit> V2371) (if (pair? (car V2371)) (let ((Parse_X (kl:shen.hdhd V2371))) (if (assert-boolean (kl:shen.numbyte? Parse_X)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2371) (kl:shen.hdtl V2371))) (kl:shen.byte->digit Parse_X)) (kl:fail))) (kl:fail))) (quote shen.<digit>))
(begin (register-function-arity (quote shen.byte->digit) 1) (define (kl:shen.byte->digit V2373) (cond ((kl:= 48 V2373) 0) ((kl:= 49 V2373) 1) ((kl:= 50 V2373) 2) ((kl:= 51 V2373) 3) ((kl:= 52 V2373) 4) ((kl:= 53 V2373) 5) ((kl:= 54 V2373) 6) ((kl:= 55 V2373) 7) ((kl:= 56 V2373) 8) ((kl:= 57 V2373) 9) (#t (kl:shen.f_error (quote shen.byte->digit))))) (quote shen.byte->digit))
(begin (register-function-arity (quote shen.pre) 2) (define (kl:shen.pre V2378 V2379) (cond ((null? V2378) 0) ((pair? V2378) (+ (* (kl:shen.expt 10 V2379) (car V2378)) (kl:shen.pre (cdr V2378) (+ V2379 1)))) (#t (kl:shen.f_error (quote shen.pre))))) (quote shen.pre))
(begin (register-function-arity (quote shen.post) 2) (define (kl:shen.post V2384 V2385) (cond ((null? V2384) 0) ((pair? V2384) (+ (* (kl:shen.expt 10 (- 0 V2385)) (car V2384)) (kl:shen.post (cdr V2384) (+ V2385 1)))) (#t (kl:shen.f_error (quote shen.post))))) (quote shen.post))
(begin (register-function-arity (quote shen.expt) 2) (define (kl:shen.expt V2390 V2391) (cond ((kl:= 0 V2391) 1) ((> V2391 0) (* V2390 (kl:shen.expt V2390 (- V2391 1)))) (#t (* 1.000000000000000 (/ (kl:shen.expt V2390 (+ V2391 1)) V2390))))) (quote shen.expt))
(begin (register-function-arity (quote shen.<st_input1>) 1) (define (kl:shen.<st_input1> V2393) (let ((Parse_shen.<st_input> (kl:shen.<st_input> V2393))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail)))) (quote shen.<st_input1>))
(begin (register-function-arity (quote shen.<st_input2>) 1) (define (kl:shen.<st_input2> V2395) (let ((Parse_shen.<st_input> (kl:shen.<st_input> V2395))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail)))) (quote shen.<st_input2>))
(begin (register-function-arity (quote shen.<comment>) 1) (define (kl:shen.<comment> V2397) (let ((YaccParse (let ((Parse_shen.<singleline> (kl:shen.<singleline> V2397))) (if (kl:not (kl:= (kl:fail) Parse_shen.<singleline>)) (kl:shen.pair (car Parse_shen.<singleline>) (quote shen.skip)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<multiline> (kl:shen.<multiline> V2397))) (if (kl:not (kl:= (kl:fail) Parse_shen.<multiline>)) (kl:shen.pair (car Parse_shen.<multiline>) (quote shen.skip)) (kl:fail))) YaccParse))) (quote shen.<comment>))
(begin (register-function-arity (quote shen.<singleline>) 1) (define (kl:shen.<singleline> V2399) (let ((Parse_shen.<backslash> (kl:shen.<backslash> V2399))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (let ((Parse_shen.<backslash> (kl:shen.<backslash> Parse_shen.<backslash>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (let ((Parse_shen.<anysingle> (kl:shen.<anysingle> Parse_shen.<backslash>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anysingle>)) (let ((Parse_shen.<return> (kl:shen.<return> Parse_shen.<anysingle>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<return>)) (kl:shen.pair (car Parse_shen.<return>) (quote shen.skip)) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail)))) (quote shen.<singleline>))
(begin (register-function-arity (quote shen.<backslash>) 1) (define (kl:shen.<backslash> V2402) (if (and (pair? (car V2402)) (kl:= 92 (kl:shen.hdhd V2402))) (let ((NewStream2400 (kl:shen.pair (kl:shen.tlhd V2402) (kl:shen.hdtl V2402)))) (kl:shen.pair (car NewStream2400) (quote shen.skip))) (kl:fail))) (quote shen.<backslash>))
(begin (register-function-arity (quote shen.<anysingle>) 1) (define (kl:shen.<anysingle> V2404) (let ((YaccParse (let ((Parse_shen.<non-return> (kl:shen.<non-return> V2404))) (if (kl:not (kl:= (kl:fail) Parse_shen.<non-return>)) (let ((Parse_shen.<anysingle> (kl:shen.<anysingle> Parse_shen.<non-return>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anysingle>)) (kl:shen.pair (car Parse_shen.<anysingle>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2404))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote shen.skip)) (kl:fail))) YaccParse))) (quote shen.<anysingle>))
(begin (register-function-arity (quote shen.<non-return>) 1) (define (kl:shen.<non-return> V2406) (if (pair? (car V2406)) (let ((Parse_X (kl:shen.hdhd V2406))) (if (kl:not (kl:element? Parse_X (cons 10 (cons 13 (quote ()))))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2406) (kl:shen.hdtl V2406))) (quote shen.skip)) (kl:fail))) (kl:fail))) (quote shen.<non-return>))
(begin (register-function-arity (quote shen.<return>) 1) (define (kl:shen.<return> V2408) (if (pair? (car V2408)) (let ((Parse_X (kl:shen.hdhd V2408))) (if (kl:element? Parse_X (cons 10 (cons 13 (quote ())))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2408) (kl:shen.hdtl V2408))) (quote shen.skip)) (kl:fail))) (kl:fail))) (quote shen.<return>))
(begin (register-function-arity (quote shen.<multiline>) 1) (define (kl:shen.<multiline> V2410) (let ((Parse_shen.<backslash> (kl:shen.<backslash> V2410))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (let ((Parse_shen.<times> (kl:shen.<times> Parse_shen.<backslash>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<times>)) (let ((Parse_shen.<anymulti> (kl:shen.<anymulti> Parse_shen.<times>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anymulti>)) (kl:shen.pair (car Parse_shen.<anymulti>) (quote shen.skip)) (kl:fail))) (kl:fail))) (kl:fail)))) (quote shen.<multiline>))
(begin (register-function-arity (quote shen.<times>) 1) (define (kl:shen.<times> V2413) (if (and (pair? (car V2413)) (kl:= 42 (kl:shen.hdhd V2413))) (let ((NewStream2411 (kl:shen.pair (kl:shen.tlhd V2413) (kl:shen.hdtl V2413)))) (kl:shen.pair (car NewStream2411) (quote shen.skip))) (kl:fail))) (quote shen.<times>))
(begin (register-function-arity (quote shen.<anymulti>) 1) (define (kl:shen.<anymulti> V2415) (let ((YaccParse (let ((Parse_shen.<comment> (kl:shen.<comment> V2415))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comment>)) (let ((Parse_shen.<anymulti> (kl:shen.<anymulti> Parse_shen.<comment>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anymulti>)) (kl:shen.pair (car Parse_shen.<anymulti>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<times> (kl:shen.<times> V2415))) (if (kl:not (kl:= (kl:fail) Parse_shen.<times>)) (let ((Parse_shen.<backslash> (kl:shen.<backslash> Parse_shen.<times>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (kl:shen.pair (car Parse_shen.<backslash>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (if (pair? (car V2415)) (let ((Parse_X (kl:shen.hdhd V2415))) (let ((Parse_shen.<anymulti> (kl:shen.<anymulti> (kl:shen.pair (kl:shen.tlhd V2415) (kl:shen.hdtl V2415))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anymulti>)) (kl:shen.pair (car Parse_shen.<anymulti>) (quote shen.skip)) (kl:fail)))) (kl:fail)) YaccParse)) YaccParse))) (quote shen.<anymulti>))
(begin (register-function-arity (quote shen.<whitespaces>) 1) (define (kl:shen.<whitespaces> V2417) (let ((YaccParse (let ((Parse_shen.<whitespace> (kl:shen.<whitespace> V2417))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespace>)) (let ((Parse_shen.<whitespaces> (kl:shen.<whitespaces> Parse_shen.<whitespace>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespaces>)) (kl:shen.pair (car Parse_shen.<whitespaces>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<whitespace> (kl:shen.<whitespace> V2417))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespace>)) (kl:shen.pair (car Parse_shen.<whitespace>) (quote shen.skip)) (kl:fail))) YaccParse))) (quote shen.<whitespaces>))
(begin (register-function-arity (quote shen.<whitespace>) 1) (define (kl:shen.<whitespace> V2419) (if (pair? (car V2419)) (let ((Parse_X (kl:shen.hdhd V2419))) (if (assert-boolean (let ((Parse_Case Parse_X)) (or (kl:= Parse_Case 32) (or (kl:= Parse_Case 13) (or (kl:= Parse_Case 10) (kl:= Parse_Case 9)))))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V2419) (kl:shen.hdtl V2419))) (quote shen.skip)) (kl:fail))) (kl:fail))) (quote shen.<whitespace>))
(begin (register-function-arity (quote shen.cons_form) 1) (define (kl:shen.cons_form V2421) (cond ((null? V2421) (quote ())) ((and (pair? V2421) (and (pair? (cdr V2421)) (and (pair? (cdr (cdr V2421))) (and (null? (cdr (cdr (cdr V2421)))) (eq? (car (cdr V2421)) (quote bar!)))))) (cons (quote cons) (cons (car V2421) (cdr (cdr V2421))))) ((pair? V2421) (cons (quote cons) (cons (car V2421) (cons (kl:shen.cons_form (cdr V2421)) (quote ()))))) (#t (kl:shen.f_error (quote shen.cons_form))))) (quote shen.cons_form))
(begin (register-function-arity (quote shen.package-macro) 2) (define (kl:shen.package-macro V2426 V2427) (cond ((and (pair? V2426) (and (eq? (quote _waspvm_dl_) (car V2426)) (and (pair? (cdr V2426)) (null? (cdr (cdr V2426)))))) (kl:append (kl:explode (car (cdr V2426))) V2427)) ((and (pair? V2426) (and (eq? (quote package) (car V2426)) (and (pair? (cdr V2426)) (and (eq? (quote null) (car (cdr V2426))) (pair? (cdr (cdr V2426))))))) (kl:append (cdr (cdr (cdr V2426))) V2427)) ((and (pair? V2426) (and (eq? (quote package) (car V2426)) (and (pair? (cdr V2426)) (pair? (cdr (cdr V2426)))))) (let ((ListofExceptions (kl:shen.eval-without-macros (car (cdr (cdr V2426)))))) (let ((External (kl:shen.record-exceptions ListofExceptions (car (cdr V2426))))) (let ((PackageNameDot (kl:intern (string-append (kl:str (car (cdr V2426))) ".")))) (let ((ExpPackageNameDot (kl:explode PackageNameDot))) (let ((Packaged (kl:shen.packageh PackageNameDot ListofExceptions (cdr (cdr (cdr V2426))) ExpPackageNameDot))) (let ((Internal (kl:shen.record-internal (car (cdr V2426)) (kl:shen.internal-symbols ExpPackageNameDot Packaged)))) (kl:append Packaged V2427)))))))) (#t (cons V2426 V2427)))) (quote shen.package-macro))
(begin (register-function-arity (quote shen.record-exceptions) 2) (define (kl:shen.record-exceptions V2430 V2431) (let ((CurrExceptions (guard (lambda (E) (quote ())) (kl:get V2431 (quote shen.external-symbols) (kl:value (quote *property-vector*)))))) (let ((AllExceptions (kl:union V2430 CurrExceptions))) (kl:put V2431 (quote shen.external-symbols) AllExceptions (kl:value (quote *property-vector*)))))) (quote shen.record-exceptions))
(begin (register-function-arity (quote shen.record-internal) 2) (define (kl:shen.record-internal V2434 V2435) (kl:put V2434 (quote shen.internal-symbols) (kl:union V2435 (guard (lambda (E) (quote ())) (kl:get V2434 (quote shen.internal-symbols) (kl:value (quote *property-vector*))))) (kl:value (quote *property-vector*)))) (quote shen.record-internal))
(begin (register-function-arity (quote shen.internal-symbols) 2) (define (kl:shen.internal-symbols V2446 V2447) (cond ((and (kl:symbol? V2447) (assert-boolean (kl:shen.prefix? V2446 (kl:explode V2447)))) (cons V2447 (quote ()))) ((pair? V2447) (kl:union (kl:shen.internal-symbols V2446 (car V2447)) (kl:shen.internal-symbols V2446 (cdr V2447)))) (#t (quote ())))) (quote shen.internal-symbols))
(begin (register-function-arity (quote shen.packageh) 4) (define (kl:shen.packageh V2464 V2465 V2466 V2467) (cond ((pair? V2466) (cons (kl:shen.packageh V2464 V2465 (car V2466) V2467) (kl:shen.packageh V2464 V2465 (cdr V2466) V2467))) ((or (assert-boolean (kl:shen.sysfunc? V2466)) (or (kl:variable? V2466) (or (kl:element? V2466 V2465) (or (assert-boolean (kl:shen.doubleunderline? V2466)) (assert-boolean (kl:shen.singleunderline? V2466)))))) V2466) ((and (kl:symbol? V2466) (assert-boolean (let ((ExplodeX (kl:explode V2466))) (and (kl:not (kl:shen.prefix? (cons "s" (cons "h" (cons "e" (cons "n" (cons "." (quote ())))))) ExplodeX)) (kl:not (kl:shen.prefix? V2467 ExplodeX)))))) (kl:concat V2464 V2466)) (#t V2466))) (quote shen.packageh))
