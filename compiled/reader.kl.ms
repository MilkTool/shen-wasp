"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote read-file-as-bytelist) 1) (define (kl:read-file-as-bytelist V2170) (let ((Stream (kl:open V2170 (quote in)))) (let ((Byte (read-u8 Stream))) (let ((Bytes (kl:shen.read-file-as-bytelist-help Stream Byte (quote ())))) (let ((Close (kl:close Stream))) (kl:reverse Bytes)))))) (quote read-file-as-bytelist))
(begin (register-function-arity (quote shen.read-file-as-bytelist-help) 3) (define (kl:shen.read-file-as-bytelist-help V2174 V2175 V2176) (cond ((kl:= -1 V2175) V2176) (#t (kl:shen.read-file-as-bytelist-help V2174 (read-u8 V2174) (cons V2175 V2176))))) (quote shen.read-file-as-bytelist-help))
(begin (register-function-arity (quote read-file-as-string) 1) (define (kl:read-file-as-string V2178) (let ((Stream (kl:open V2178 (quote in)))) (kl:shen.rfas-h Stream (read-u8 Stream) ""))) (quote read-file-as-string))
(begin (register-function-arity (quote shen.rfas-h) 3) (define (kl:shen.rfas-h V2182 V2183 V2184) (cond ((kl:= -1 V2183) (begin (kl:close V2182) V2184)) (#t (kl:shen.rfas-h V2182 (read-u8 V2182) (string-append V2184 (make-string 1 V2183)))))) (quote shen.rfas-h))
(begin (register-function-arity (quote input) 1) (define (kl:input V2186) (kl:eval-kl (kl:read V2186))) (quote input))
(begin (register-function-arity (quote input+) 2) (define (kl:input+ V2189 V2190) (let ((Mono? (kl:shen.monotype V2189))) (let ((Input (kl:read V2190))) (if (kl:= #f (kl:shen.typecheck Input (kl:shen.demodulate V2189))) (simple-error (string-append "type error: " (kl:shen.app Input (string-append " is not of type " (kl:shen.app V2189 "\n" (quote shen.r))) (quote shen.r)))) (kl:eval-kl Input))))) (quote input+))
(begin (register-function-arity (quote shen.monotype) 1) (define (kl:shen.monotype V2192) (cond ((pair? V2192) (kl:map (lambda (Z) (kl:shen.monotype Z)) V2192)) (#t (if (kl:variable? V2192) (simple-error (string-append "input+ expects a monotype: not " (kl:shen.app V2192 "\n" (quote shen.a)))) V2192)))) (quote shen.monotype))
(begin (register-function-arity (quote read) 1) (define (kl:read V2194) (car (kl:shen.read-loop V2194 (read-u8 V2194) (quote ())))) (quote read))
(begin (register-function-arity (quote it) 0) (define (kl:it) (kl:value (quote shen.*it*))) (quote it))
(begin (register-function-arity (quote shen.read-loop) 3) (define (kl:shen.read-loop V2202 V2203 V2204) (cond ((kl:= 94 V2203) (simple-error "read aborted")) ((kl:= -1 V2203) (if (kl:empty? V2204) (simple-error "error: empty stream") (kl:compile (lambda (X) (kl:shen.<st_input> X)) V2204 (lambda (E) E)))) ((assert-boolean (kl:shen.terminator? V2203)) (let ((AllBytes (kl:append V2204 (cons V2203 (quote ()))))) (let ((It (kl:shen.record-it AllBytes))) (let ((Read (kl:compile (lambda (X) (kl:shen.<st_input> X)) AllBytes (lambda (E) (quote shen.nextbyte))))) (if (or (eq? Read (quote shen.nextbyte)) (kl:empty? Read)) (kl:shen.read-loop V2202 (read-u8 V2202) AllBytes) Read))))) (#t (kl:shen.read-loop V2202 (read-u8 V2202) (kl:append V2204 (cons V2203 (quote ()))))))) (quote shen.read-loop))
(begin (register-function-arity (quote shen.terminator?) 1) (define (kl:shen.terminator? V2206) (kl:element? V2206 (cons 9 (cons 10 (cons 13 (cons 32 (cons 34 (cons 41 (cons 93 (quote ())))))))))) (quote shen.terminator?))
(begin (register-function-arity (quote lineread) 1) (define (kl:lineread V2208) (kl:shen.lineread-loop (read-u8 V2208) (quote ()) V2208)) (quote lineread))
(begin (register-function-arity (quote shen.lineread-loop) 3) (define (kl:shen.lineread-loop V2213 V2214 V2215) (cond ((kl:= -1 V2213) (if (kl:empty? V2214) (simple-error "empty stream") (kl:compile (lambda (X) (kl:shen.<st_input> X)) V2214 (lambda (E) E)))) ((kl:= V2213 (kl:shen.hat)) (simple-error "line read aborted")) ((kl:element? V2213 (cons (kl:shen.newline) (cons (kl:shen.carriage-return) (quote ())))) (let ((Line (kl:compile (lambda (X) (kl:shen.<st_input> X)) V2214 (lambda (E) (quote shen.nextline))))) (let ((It (kl:shen.record-it V2214))) (if (or (eq? Line (quote shen.nextline)) (kl:empty? Line)) (kl:shen.lineread-loop (read-u8 V2215) (kl:append V2214 (cons V2213 (quote ()))) V2215) Line)))) (#t (kl:shen.lineread-loop (read-u8 V2215) (kl:append V2214 (cons V2213 (quote ()))) V2215)))) (quote shen.lineread-loop))
(begin (register-function-arity (quote shen.record-it) 1) (define (kl:shen.record-it V2217) (let ((TrimLeft (kl:shen.trim-whitespace V2217))) (let ((TrimRight (kl:shen.trim-whitespace (kl:reverse TrimLeft)))) (let ((Trimmed (kl:reverse TrimRight))) (kl:shen.record-it-h Trimmed))))) (quote shen.record-it))
(begin (register-function-arity (quote shen.trim-whitespace) 1) (define (kl:shen.trim-whitespace V2219) (cond ((and (pair? V2219) (kl:element? (car V2219) (cons 9 (cons 10 (cons 13 (cons 32 (quote ()))))))) (kl:shen.trim-whitespace (cdr V2219))) (#t V2219))) (quote shen.trim-whitespace))
(begin (register-function-arity (quote shen.record-it-h) 1) (define (kl:shen.record-it-h V2221) (begin (kl:set (quote shen.*it*) (kl:shen.cn-all (kl:map (lambda (X) (make-string 1 X)) V2221))) V2221)) (quote shen.record-it-h))
(begin (register-function-arity (quote shen.cn-all) 1) (define (kl:shen.cn-all V2223) (cond ((null? V2223) "") ((pair? V2223) (string-append (car V2223) (kl:shen.cn-all (cdr V2223)))) (#t (kl:shen.f_error (quote shen.cn-all))))) (quote shen.cn-all))
(begin (register-function-arity (quote read-file) 1) (define (kl:read-file V2225) (let ((Bytelist (kl:read-file-as-bytelist V2225))) (kl:compile (lambda (X) (kl:shen.<st_input> X)) Bytelist (lambda (X) (kl:shen.read-error X))))) (quote read-file))
(begin (register-function-arity (quote read-from-string) 1) (define (kl:read-from-string V2227) (let ((Ns (kl:map (lambda (X) (string-ref X 0)) (kl:explode V2227)))) (kl:compile (lambda (X) (kl:shen.<st_input> X)) Ns (lambda (X) (kl:shen.read-error X))))) (quote read-from-string))
(begin (register-function-arity (quote shen.read-error) 1) (define (kl:shen.read-error V2235) (cond ((and (pair? V2235) (and (pair? (car V2235)) (and (pair? (cdr V2235)) (null? (cdr (cdr V2235)))))) (simple-error (string-append "read error here:\n\n " (kl:shen.app (kl:shen.compress-50 50 (car V2235)) "\n" (quote shen.a))))) (#t (simple-error "read error\n")))) (quote shen.read-error))
(begin (register-function-arity (quote shen.compress-50) 2) (define (kl:shen.compress-50 V2242 V2243) (cond ((null? V2243) "") ((kl:= 0 V2242) "") ((pair? V2243) (string-append (make-string 1 (car V2243)) (kl:shen.compress-50 (- V2242 1) (cdr V2243)))) (#t (kl:shen.f_error (quote shen.compress-50))))) (quote shen.compress-50))
(begin (register-function-arity (quote shen.<st_input>) 1) (define (kl:shen.<st_input> V2245) (let ((YaccParse (let ((Parse_shen.<lsb> (kl:shen.<lsb> V2245))) (if (kl:not (kl:= (kl:fail) Parse_shen.<lsb>)) (let ((Parse_shen.<st_input1> (kl:shen.<st_input1> Parse_shen.<lsb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input1>)) (let ((Parse_shen.<rsb> (kl:shen.<rsb> Parse_shen.<st_input1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rsb>)) (let ((Parse_shen.<st_input2> (kl:shen.<st_input2> Parse_shen.<rsb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input2>)) (kl:shen.pair (car Parse_shen.<st_input2>) (cons (kl:macroexpand (kl:shen.cons_form (kl:shen.hdtl Parse_shen.<st_input1>))) (kl:shen.hdtl Parse_shen.<st_input2>))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<lrb> (kl:shen.<lrb> V2245))) (if (kl:not (kl:= (kl:fail) Parse_shen.<lrb>)) (let ((Parse_shen.<st_input1> (kl:shen.<st_input1> Parse_shen.<lrb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input1>)) (let ((Parse_shen.<rrb> (kl:shen.<rrb> Parse_shen.<st_input1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rrb>)) (let ((Parse_shen.<st_input2> (kl:shen.<st_input2> Parse_shen.<rrb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input2>)) (kl:shen.pair (car Parse_shen.<st_input2>) (kl:shen.package-macro (kl:macroexpand (kl:shen.hdtl Parse_shen.<st_input1>)) (kl:shen.hdtl Parse_shen.<st_input2>))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<lcurly> (kl:shen.<lcurly> V2245))) (if (kl:not (kl:= (kl:fail) Parse_shen.<lcurly>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<lcurly>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote {) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<rcurly> (kl:shen.<rcurly> V2245))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rcurly>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<rcurly>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote }) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<bar> (kl:shen.<bar> V2245))) (if (kl:not (kl:= (kl:fail) Parse_shen.<bar>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<bar>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote bar!) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<semicolon> (kl:shen.<semicolon> V2245))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<semicolon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote _waspvm_sc_) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<colon> (kl:shen.<colon> V2245))) (if (kl:not (kl:= (kl:fail) Parse_shen.<colon>)) (let ((Parse_shen.<equal> (kl:shen.<equal> Parse_shen.<colon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<equal>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<equal>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote :=) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<colon> (kl:shen.<colon> V2245))) (if (kl:not (kl:= (kl:fail) Parse_shen.<colon>)) (let ((Parse_shen.<minus> (kl:shen.<minus> Parse_shen.<colon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<minus>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<minus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote :-) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<colon> (kl:shen.<colon> V2245))) (if (kl:not (kl:= (kl:fail) Parse_shen.<colon>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<colon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote :) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<comma> (kl:shen.<comma> V2245))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comma>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<comma>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (kl:intern ",") (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<comment> (kl:shen.<comment> V2245))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comment>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<comment>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<atom> (kl:shen.<atom> V2245))) (if (kl:not (kl:= (kl:fail) Parse_shen.<atom>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<atom>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (kl:macroexpand (kl:shen.hdtl Parse_shen.<atom>)) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<whitespaces> (kl:shen.<whitespaces> V2245))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespaces>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<whitespaces>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2245))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse))) (quote shen.<st_input>))
(begin (register-function-arity (quote shen.<lsb>) 1) (define (kl:shen.<lsb> V2247) (if (and (pair? (car V2247)) (kl:= 91 (car (car V2247)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2247)) (kl:shen.hdtl V2247))) (quote shen.skip)) (kl:fail))) (quote shen.<lsb>))
(begin (register-function-arity (quote shen.<rsb>) 1) (define (kl:shen.<rsb> V2249) (if (and (pair? (car V2249)) (kl:= 93 (car (car V2249)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2249)) (kl:shen.hdtl V2249))) (quote shen.skip)) (kl:fail))) (quote shen.<rsb>))
(begin (register-function-arity (quote shen.<lcurly>) 1) (define (kl:shen.<lcurly> V2251) (if (and (pair? (car V2251)) (kl:= 123 (car (car V2251)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2251)) (kl:shen.hdtl V2251))) (quote shen.skip)) (kl:fail))) (quote shen.<lcurly>))
(begin (register-function-arity (quote shen.<rcurly>) 1) (define (kl:shen.<rcurly> V2253) (if (and (pair? (car V2253)) (kl:= 125 (car (car V2253)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2253)) (kl:shen.hdtl V2253))) (quote shen.skip)) (kl:fail))) (quote shen.<rcurly>))
(begin (register-function-arity (quote shen.<bar>) 1) (define (kl:shen.<bar> V2255) (if (and (pair? (car V2255)) (kl:= 124 (car (car V2255)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2255)) (kl:shen.hdtl V2255))) (quote shen.skip)) (kl:fail))) (quote shen.<bar>))
(begin (register-function-arity (quote shen.<semicolon>) 1) (define (kl:shen.<semicolon> V2257) (if (and (pair? (car V2257)) (kl:= 59 (car (car V2257)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2257)) (kl:shen.hdtl V2257))) (quote shen.skip)) (kl:fail))) (quote shen.<semicolon>))
(begin (register-function-arity (quote shen.<colon>) 1) (define (kl:shen.<colon> V2259) (if (and (pair? (car V2259)) (kl:= 58 (car (car V2259)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2259)) (kl:shen.hdtl V2259))) (quote shen.skip)) (kl:fail))) (quote shen.<colon>))
(begin (register-function-arity (quote shen.<comma>) 1) (define (kl:shen.<comma> V2261) (if (and (pair? (car V2261)) (kl:= 44 (car (car V2261)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2261)) (kl:shen.hdtl V2261))) (quote shen.skip)) (kl:fail))) (quote shen.<comma>))
(begin (register-function-arity (quote shen.<equal>) 1) (define (kl:shen.<equal> V2263) (if (and (pair? (car V2263)) (kl:= 61 (car (car V2263)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2263)) (kl:shen.hdtl V2263))) (quote shen.skip)) (kl:fail))) (quote shen.<equal>))
(begin (register-function-arity (quote shen.<minus>) 1) (define (kl:shen.<minus> V2265) (if (and (pair? (car V2265)) (kl:= 45 (car (car V2265)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2265)) (kl:shen.hdtl V2265))) (quote shen.skip)) (kl:fail))) (quote shen.<minus>))
(begin (register-function-arity (quote shen.<lrb>) 1) (define (kl:shen.<lrb> V2267) (if (and (pair? (car V2267)) (kl:= 40 (car (car V2267)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2267)) (kl:shen.hdtl V2267))) (quote shen.skip)) (kl:fail))) (quote shen.<lrb>))
(begin (register-function-arity (quote shen.<rrb>) 1) (define (kl:shen.<rrb> V2269) (if (and (pair? (car V2269)) (kl:= 41 (car (car V2269)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2269)) (kl:shen.hdtl V2269))) (quote shen.skip)) (kl:fail))) (quote shen.<rrb>))
(begin (register-function-arity (quote shen.<atom>) 1) (define (kl:shen.<atom> V2271) (let ((YaccParse (let ((Parse_shen.<str> (kl:shen.<str> V2271))) (if (kl:not (kl:= (kl:fail) Parse_shen.<str>)) (kl:shen.pair (car Parse_shen.<str>) (kl:shen.control-chars (kl:shen.hdtl Parse_shen.<str>))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<number> (kl:shen.<number> V2271))) (if (kl:not (kl:= (kl:fail) Parse_shen.<number>)) (kl:shen.pair (car Parse_shen.<number>) (kl:shen.hdtl Parse_shen.<number>)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<sym> (kl:shen.<sym> V2271))) (if (kl:not (kl:= (kl:fail) Parse_shen.<sym>)) (kl:shen.pair (car Parse_shen.<sym>) (if (equal? (kl:shen.hdtl Parse_shen.<sym>) "<>") (cons (quote vector) (cons 0 (quote ()))) (kl:intern (kl:shen.hdtl Parse_shen.<sym>)))) (kl:fail))) YaccParse)) YaccParse))) (quote shen.<atom>))
(begin (register-function-arity (quote shen.control-chars) 1) (define (kl:shen.control-chars V2273) (cond ((null? V2273) "") ((and (pair? V2273) (and (equal? "c" (car V2273)) (and (pair? (cdr V2273)) (equal? "#" (car (cdr V2273)))))) (let ((CodePoint (kl:shen.code-point (cdr (cdr V2273))))) (let ((AfterCodePoint (kl:shen.after-codepoint (cdr (cdr V2273))))) (kl:_waspvm_at_s (make-string 1 (kl:shen.decimalise CodePoint)) (kl:shen.control-chars AfterCodePoint))))) ((pair? V2273) (kl:_waspvm_at_s (car V2273) (kl:shen.control-chars (cdr V2273)))) (#t (kl:shen.f_error (quote shen.control-chars))))) (quote shen.control-chars))
(begin (register-function-arity (quote shen.code-point) 1) (define (kl:shen.code-point V2277) (cond ((and (pair? V2277) (equal? ";" (car V2277))) "") ((and (pair? V2277) (kl:element? (car V2277) (cons "0" (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" (quote ())))))))))))))) (cons (car V2277) (kl:shen.code-point (cdr V2277)))) (#t (simple-error (string-append "code point parse error " (kl:shen.app V2277 "\n" (quote shen.a))))))) (quote shen.code-point))
(begin (register-function-arity (quote shen.after-codepoint) 1) (define (kl:shen.after-codepoint V2283) (cond ((null? V2283) (quote ())) ((and (pair? V2283) (equal? ";" (car V2283))) (cdr V2283)) ((pair? V2283) (kl:shen.after-codepoint (cdr V2283))) (#t (kl:shen.f_error (quote shen.after-codepoint))))) (quote shen.after-codepoint))
(begin (register-function-arity (quote shen.decimalise) 1) (define (kl:shen.decimalise V2285) (kl:shen.pre (kl:reverse (kl:shen.digits->integers V2285)) 0)) (quote shen.decimalise))
(begin (register-function-arity (quote shen.digits->integers) 1) (define (kl:shen.digits->integers V2291) (cond ((and (pair? V2291) (equal? "0" (car V2291))) (cons 0 (kl:shen.digits->integers (cdr V2291)))) ((and (pair? V2291) (equal? "1" (car V2291))) (cons 1 (kl:shen.digits->integers (cdr V2291)))) ((and (pair? V2291) (equal? "2" (car V2291))) (cons 2 (kl:shen.digits->integers (cdr V2291)))) ((and (pair? V2291) (equal? "3" (car V2291))) (cons 3 (kl:shen.digits->integers (cdr V2291)))) ((and (pair? V2291) (equal? "4" (car V2291))) (cons 4 (kl:shen.digits->integers (cdr V2291)))) ((and (pair? V2291) (equal? "5" (car V2291))) (cons 5 (kl:shen.digits->integers (cdr V2291)))) ((and (pair? V2291) (equal? "6" (car V2291))) (cons 6 (kl:shen.digits->integers (cdr V2291)))) ((and (pair? V2291) (equal? "7" (car V2291))) (cons 7 (kl:shen.digits->integers (cdr V2291)))) ((and (pair? V2291) (equal? "8" (car V2291))) (cons 8 (kl:shen.digits->integers (cdr V2291)))) ((and (pair? V2291) (equal? "9" (car V2291))) (cons 9 (kl:shen.digits->integers (cdr V2291)))) (#t (quote ())))) (quote shen.digits->integers))
(begin (register-function-arity (quote shen.<sym>) 1) (define (kl:shen.<sym> V2293) (let ((Parse_shen.<alpha> (kl:shen.<alpha> V2293))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alpha>)) (let ((Parse_shen.<alphanums> (kl:shen.<alphanums> Parse_shen.<alpha>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alphanums>)) (kl:shen.pair (car Parse_shen.<alphanums>) (kl:_waspvm_at_s (kl:shen.hdtl Parse_shen.<alpha>) (kl:shen.hdtl Parse_shen.<alphanums>))) (kl:fail))) (kl:fail)))) (quote shen.<sym>))
(begin (register-function-arity (quote shen.<alphanums>) 1) (define (kl:shen.<alphanums> V2295) (let ((YaccParse (let ((Parse_shen.<alphanum> (kl:shen.<alphanum> V2295))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alphanum>)) (let ((Parse_shen.<alphanums> (kl:shen.<alphanums> Parse_shen.<alphanum>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alphanums>)) (kl:shen.pair (car Parse_shen.<alphanums>) (kl:_waspvm_at_s (kl:shen.hdtl Parse_shen.<alphanum>) (kl:shen.hdtl Parse_shen.<alphanums>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2295))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) "") (kl:fail))) YaccParse))) (quote shen.<alphanums>))
(begin (register-function-arity (quote shen.<alphanum>) 1) (define (kl:shen.<alphanum> V2297) (let ((YaccParse (let ((Parse_shen.<alpha> (kl:shen.<alpha> V2297))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alpha>)) (kl:shen.pair (car Parse_shen.<alpha>) (kl:shen.hdtl Parse_shen.<alpha>)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<num> (kl:shen.<num> V2297))) (if (kl:not (kl:= (kl:fail) Parse_shen.<num>)) (kl:shen.pair (car Parse_shen.<num>) (kl:shen.hdtl Parse_shen.<num>)) (kl:fail))) YaccParse))) (quote shen.<alphanum>))
(begin (register-function-arity (quote shen.<num>) 1) (define (kl:shen.<num> V2299) (if (pair? (car V2299)) (let ((Parse_Byte (car (car V2299)))) (if (assert-boolean (kl:shen.numbyte? Parse_Byte)) (kl:shen.pair (car (kl:shen.pair (cdr (car V2299)) (kl:shen.hdtl V2299))) (make-string 1 Parse_Byte)) (kl:fail))) (kl:fail))) (quote shen.<num>))
(begin (register-function-arity (quote shen.numbyte?) 1) (define (kl:shen.numbyte? V2305) (cond ((kl:= 48 V2305) #t) ((kl:= 49 V2305) #t) ((kl:= 50 V2305) #t) ((kl:= 51 V2305) #t) ((kl:= 52 V2305) #t) ((kl:= 53 V2305) #t) ((kl:= 54 V2305) #t) ((kl:= 55 V2305) #t) ((kl:= 56 V2305) #t) ((kl:= 57 V2305) #t) (#t #f))) (quote shen.numbyte?))
(begin (register-function-arity (quote shen.<alpha>) 1) (define (kl:shen.<alpha> V2307) (if (pair? (car V2307)) (let ((Parse_Byte (car (car V2307)))) (if (assert-boolean (kl:shen.symbol-code? Parse_Byte)) (kl:shen.pair (car (kl:shen.pair (cdr (car V2307)) (kl:shen.hdtl V2307))) (make-string 1 Parse_Byte)) (kl:fail))) (kl:fail))) (quote shen.<alpha>))
(begin (register-function-arity (quote shen.symbol-code?) 1) (define (kl:shen.symbol-code? V2309) (or (kl:= V2309 126) (or (and (> V2309 94) (< V2309 123)) (or (and (> V2309 59) (< V2309 91)) (or (and (> V2309 41) (and (< V2309 58) (kl:not (kl:= V2309 44)))) (or (and (> V2309 34) (< V2309 40)) (kl:= V2309 33))))))) (quote shen.symbol-code?))
(begin (register-function-arity (quote shen.<str>) 1) (define (kl:shen.<str> V2311) (let ((Parse_shen.<dbq> (kl:shen.<dbq> V2311))) (if (kl:not (kl:= (kl:fail) Parse_shen.<dbq>)) (let ((Parse_shen.<strcontents> (kl:shen.<strcontents> Parse_shen.<dbq>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<strcontents>)) (let ((Parse_shen.<dbq> (kl:shen.<dbq> Parse_shen.<strcontents>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<dbq>)) (kl:shen.pair (car Parse_shen.<dbq>) (kl:shen.hdtl Parse_shen.<strcontents>)) (kl:fail))) (kl:fail))) (kl:fail)))) (quote shen.<str>))
(begin (register-function-arity (quote shen.<dbq>) 1) (define (kl:shen.<dbq> V2313) (if (pair? (car V2313)) (let ((Parse_Byte (car (car V2313)))) (if (kl:= Parse_Byte 34) (kl:shen.pair (car (kl:shen.pair (cdr (car V2313)) (kl:shen.hdtl V2313))) Parse_Byte) (kl:fail))) (kl:fail))) (quote shen.<dbq>))
(begin (register-function-arity (quote shen.<strcontents>) 1) (define (kl:shen.<strcontents> V2315) (let ((YaccParse (let ((Parse_shen.<strc> (kl:shen.<strc> V2315))) (if (kl:not (kl:= (kl:fail) Parse_shen.<strc>)) (let ((Parse_shen.<strcontents> (kl:shen.<strcontents> Parse_shen.<strc>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<strcontents>)) (kl:shen.pair (car Parse_shen.<strcontents>) (cons (kl:shen.hdtl Parse_shen.<strc>) (kl:shen.hdtl Parse_shen.<strcontents>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2315))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<strcontents>))
(begin (register-function-arity (quote shen.<byte>) 1) (define (kl:shen.<byte> V2317) (if (pair? (car V2317)) (let ((Parse_Byte (car (car V2317)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2317)) (kl:shen.hdtl V2317))) (make-string 1 Parse_Byte))) (kl:fail))) (quote shen.<byte>))
(begin (register-function-arity (quote shen.<strc>) 1) (define (kl:shen.<strc> V2319) (if (pair? (car V2319)) (let ((Parse_Byte (car (car V2319)))) (if (kl:not (kl:= Parse_Byte 34)) (kl:shen.pair (car (kl:shen.pair (cdr (car V2319)) (kl:shen.hdtl V2319))) (make-string 1 Parse_Byte)) (kl:fail))) (kl:fail))) (quote shen.<strc>))
(begin (register-function-arity (quote shen.<number>) 1) (define (kl:shen.<number> V2321) (let ((YaccParse (let ((Parse_shen.<minus> (kl:shen.<minus> V2321))) (if (kl:not (kl:= (kl:fail) Parse_shen.<minus>)) (let ((Parse_shen.<number> (kl:shen.<number> Parse_shen.<minus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<number>)) (kl:shen.pair (car Parse_shen.<number>) (- 0 (kl:shen.hdtl Parse_shen.<number>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<plus> (kl:shen.<plus> V2321))) (if (kl:not (kl:= (kl:fail) Parse_shen.<plus>)) (let ((Parse_shen.<number> (kl:shen.<number> Parse_shen.<plus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<number>)) (kl:shen.pair (car Parse_shen.<number>) (kl:shen.hdtl Parse_shen.<number>)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<predigits> (kl:shen.<predigits> V2321))) (if (kl:not (kl:= (kl:fail) Parse_shen.<predigits>)) (let ((Parse_shen.<stop> (kl:shen.<stop> Parse_shen.<predigits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<stop>)) (let ((Parse_shen.<postdigits> (kl:shen.<postdigits> Parse_shen.<stop>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<postdigits>)) (let ((Parse_shen.<E> (kl:shen.<E> Parse_shen.<postdigits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<E>)) (let ((Parse_shen.<log10> (kl:shen.<log10> Parse_shen.<E>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<log10>)) (kl:shen.pair (car Parse_shen.<log10>) (* (kl:shen.expt 10 (kl:shen.hdtl Parse_shen.<log10>)) (+ (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<predigits>)) 0) (kl:shen.post (kl:shen.hdtl Parse_shen.<postdigits>) 1)))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<digits> (kl:shen.<digits> V2321))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (let ((Parse_shen.<E> (kl:shen.<E> Parse_shen.<digits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<E>)) (let ((Parse_shen.<log10> (kl:shen.<log10> Parse_shen.<E>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<log10>)) (kl:shen.pair (car Parse_shen.<log10>) (* (kl:shen.expt 10 (kl:shen.hdtl Parse_shen.<log10>)) (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<predigits> (kl:shen.<predigits> V2321))) (if (kl:not (kl:= (kl:fail) Parse_shen.<predigits>)) (let ((Parse_shen.<stop> (kl:shen.<stop> Parse_shen.<predigits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<stop>)) (let ((Parse_shen.<postdigits> (kl:shen.<postdigits> Parse_shen.<stop>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<postdigits>)) (kl:shen.pair (car Parse_shen.<postdigits>) (+ (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<predigits>)) 0) (kl:shen.post (kl:shen.hdtl Parse_shen.<postdigits>) 1))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<digits> (kl:shen.<digits> V2321))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0)) (kl:fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse))) (quote shen.<number>))
(begin (register-function-arity (quote shen.<E>) 1) (define (kl:shen.<E> V2323) (if (and (pair? (car V2323)) (kl:= 101 (car (car V2323)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2323)) (kl:shen.hdtl V2323))) (quote shen.skip)) (kl:fail))) (quote shen.<E>))
(begin (register-function-arity (quote shen.<log10>) 1) (define (kl:shen.<log10> V2325) (let ((YaccParse (let ((Parse_shen.<minus> (kl:shen.<minus> V2325))) (if (kl:not (kl:= (kl:fail) Parse_shen.<minus>)) (let ((Parse_shen.<digits> (kl:shen.<digits> Parse_shen.<minus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (- 0 (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<digits> (kl:shen.<digits> V2325))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0)) (kl:fail))) YaccParse))) (quote shen.<log10>))
(begin (register-function-arity (quote shen.<plus>) 1) (define (kl:shen.<plus> V2327) (if (pair? (car V2327)) (let ((Parse_Byte (car (car V2327)))) (if (kl:= Parse_Byte 43) (kl:shen.pair (car (kl:shen.pair (cdr (car V2327)) (kl:shen.hdtl V2327))) Parse_Byte) (kl:fail))) (kl:fail))) (quote shen.<plus>))
(begin (register-function-arity (quote shen.<stop>) 1) (define (kl:shen.<stop> V2329) (if (pair? (car V2329)) (let ((Parse_Byte (car (car V2329)))) (if (kl:= Parse_Byte 46) (kl:shen.pair (car (kl:shen.pair (cdr (car V2329)) (kl:shen.hdtl V2329))) Parse_Byte) (kl:fail))) (kl:fail))) (quote shen.<stop>))
(begin (register-function-arity (quote shen.<predigits>) 1) (define (kl:shen.<predigits> V2331) (let ((YaccParse (let ((Parse_shen.<digits> (kl:shen.<digits> V2331))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.hdtl Parse_shen.<digits>)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2331))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<predigits>))
(begin (register-function-arity (quote shen.<postdigits>) 1) (define (kl:shen.<postdigits> V2333) (let ((Parse_shen.<digits> (kl:shen.<digits> V2333))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.hdtl Parse_shen.<digits>)) (kl:fail)))) (quote shen.<postdigits>))
(begin (register-function-arity (quote shen.<digits>) 1) (define (kl:shen.<digits> V2335) (let ((YaccParse (let ((Parse_shen.<digit> (kl:shen.<digit> V2335))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digit>)) (let ((Parse_shen.<digits> (kl:shen.<digits> Parse_shen.<digit>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (cons (kl:shen.hdtl Parse_shen.<digit>) (kl:shen.hdtl Parse_shen.<digits>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<digit> (kl:shen.<digit> V2335))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digit>)) (kl:shen.pair (car Parse_shen.<digit>) (cons (kl:shen.hdtl Parse_shen.<digit>) (quote ()))) (kl:fail))) YaccParse))) (quote shen.<digits>))
(begin (register-function-arity (quote shen.<digit>) 1) (define (kl:shen.<digit> V2337) (if (pair? (car V2337)) (let ((Parse_X (car (car V2337)))) (if (assert-boolean (kl:shen.numbyte? Parse_X)) (kl:shen.pair (car (kl:shen.pair (cdr (car V2337)) (kl:shen.hdtl V2337))) (kl:shen.byte->digit Parse_X)) (kl:fail))) (kl:fail))) (quote shen.<digit>))
(begin (register-function-arity (quote shen.byte->digit) 1) (define (kl:shen.byte->digit V2339) (cond ((kl:= 48 V2339) 0) ((kl:= 49 V2339) 1) ((kl:= 50 V2339) 2) ((kl:= 51 V2339) 3) ((kl:= 52 V2339) 4) ((kl:= 53 V2339) 5) ((kl:= 54 V2339) 6) ((kl:= 55 V2339) 7) ((kl:= 56 V2339) 8) ((kl:= 57 V2339) 9) (#t (kl:shen.f_error (quote shen.byte->digit))))) (quote shen.byte->digit))
(begin (register-function-arity (quote shen.pre) 2) (define (kl:shen.pre V2344 V2345) (cond ((null? V2344) 0) ((pair? V2344) (+ (* (kl:shen.expt 10 V2345) (car V2344)) (kl:shen.pre (cdr V2344) (+ V2345 1)))) (#t (kl:shen.f_error (quote shen.pre))))) (quote shen.pre))
(begin (register-function-arity (quote shen.post) 2) (define (kl:shen.post V2350 V2351) (cond ((null? V2350) 0) ((pair? V2350) (+ (* (kl:shen.expt 10 (- 0 V2351)) (car V2350)) (kl:shen.post (cdr V2350) (+ V2351 1)))) (#t (kl:shen.f_error (quote shen.post))))) (quote shen.post))
(begin (register-function-arity (quote shen.expt) 2) (define (kl:shen.expt V2356 V2357) (cond ((kl:= 0 V2357) 1) ((> V2357 0) (* V2356 (kl:shen.expt V2356 (- V2357 1)))) (#t (* 1.000000 (/ (kl:shen.expt V2356 (+ V2357 1)) V2356))))) (quote shen.expt))
(begin (register-function-arity (quote shen.<st_input1>) 1) (define (kl:shen.<st_input1> V2359) (let ((Parse_shen.<st_input> (kl:shen.<st_input> V2359))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail)))) (quote shen.<st_input1>))
(begin (register-function-arity (quote shen.<st_input2>) 1) (define (kl:shen.<st_input2> V2361) (let ((Parse_shen.<st_input> (kl:shen.<st_input> V2361))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail)))) (quote shen.<st_input2>))
(begin (register-function-arity (quote shen.<comment>) 1) (define (kl:shen.<comment> V2363) (let ((YaccParse (let ((Parse_shen.<singleline> (kl:shen.<singleline> V2363))) (if (kl:not (kl:= (kl:fail) Parse_shen.<singleline>)) (kl:shen.pair (car Parse_shen.<singleline>) (quote shen.skip)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<multiline> (kl:shen.<multiline> V2363))) (if (kl:not (kl:= (kl:fail) Parse_shen.<multiline>)) (kl:shen.pair (car Parse_shen.<multiline>) (quote shen.skip)) (kl:fail))) YaccParse))) (quote shen.<comment>))
(begin (register-function-arity (quote shen.<singleline>) 1) (define (kl:shen.<singleline> V2365) (let ((Parse_shen.<backslash> (kl:shen.<backslash> V2365))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (let ((Parse_shen.<backslash> (kl:shen.<backslash> Parse_shen.<backslash>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (let ((Parse_shen.<anysingle> (kl:shen.<anysingle> Parse_shen.<backslash>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anysingle>)) (let ((Parse_shen.<return> (kl:shen.<return> Parse_shen.<anysingle>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<return>)) (kl:shen.pair (car Parse_shen.<return>) (quote shen.skip)) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail)))) (quote shen.<singleline>))
(begin (register-function-arity (quote shen.<backslash>) 1) (define (kl:shen.<backslash> V2367) (if (and (pair? (car V2367)) (kl:= 92 (car (car V2367)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2367)) (kl:shen.hdtl V2367))) (quote shen.skip)) (kl:fail))) (quote shen.<backslash>))
(begin (register-function-arity (quote shen.<anysingle>) 1) (define (kl:shen.<anysingle> V2369) (let ((YaccParse (let ((Parse_shen.<non-return> (kl:shen.<non-return> V2369))) (if (kl:not (kl:= (kl:fail) Parse_shen.<non-return>)) (let ((Parse_shen.<anysingle> (kl:shen.<anysingle> Parse_shen.<non-return>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anysingle>)) (kl:shen.pair (car Parse_shen.<anysingle>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V2369))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote shen.skip)) (kl:fail))) YaccParse))) (quote shen.<anysingle>))
(begin (register-function-arity (quote shen.<non-return>) 1) (define (kl:shen.<non-return> V2371) (if (pair? (car V2371)) (let ((Parse_X (car (car V2371)))) (if (kl:not (kl:element? Parse_X (cons 10 (cons 13 (quote ()))))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2371)) (kl:shen.hdtl V2371))) (quote shen.skip)) (kl:fail))) (kl:fail))) (quote shen.<non-return>))
(begin (register-function-arity (quote shen.<return>) 1) (define (kl:shen.<return> V2373) (if (pair? (car V2373)) (let ((Parse_X (car (car V2373)))) (if (kl:element? Parse_X (cons 10 (cons 13 (quote ())))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2373)) (kl:shen.hdtl V2373))) (quote shen.skip)) (kl:fail))) (kl:fail))) (quote shen.<return>))
(begin (register-function-arity (quote shen.<multiline>) 1) (define (kl:shen.<multiline> V2375) (let ((Parse_shen.<backslash> (kl:shen.<backslash> V2375))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (let ((Parse_shen.<times> (kl:shen.<times> Parse_shen.<backslash>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<times>)) (let ((Parse_shen.<anymulti> (kl:shen.<anymulti> Parse_shen.<times>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anymulti>)) (kl:shen.pair (car Parse_shen.<anymulti>) (quote shen.skip)) (kl:fail))) (kl:fail))) (kl:fail)))) (quote shen.<multiline>))
(begin (register-function-arity (quote shen.<times>) 1) (define (kl:shen.<times> V2377) (if (and (pair? (car V2377)) (kl:= 42 (car (car V2377)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2377)) (kl:shen.hdtl V2377))) (quote shen.skip)) (kl:fail))) (quote shen.<times>))
(begin (register-function-arity (quote shen.<anymulti>) 1) (define (kl:shen.<anymulti> V2379) (let ((YaccParse (let ((Parse_shen.<comment> (kl:shen.<comment> V2379))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comment>)) (let ((Parse_shen.<anymulti> (kl:shen.<anymulti> Parse_shen.<comment>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anymulti>)) (kl:shen.pair (car Parse_shen.<anymulti>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<times> (kl:shen.<times> V2379))) (if (kl:not (kl:= (kl:fail) Parse_shen.<times>)) (let ((Parse_shen.<backslash> (kl:shen.<backslash> Parse_shen.<times>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (kl:shen.pair (car Parse_shen.<backslash>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (if (pair? (car V2379)) (let ((Parse_X (car (car V2379)))) (let ((Parse_shen.<anymulti> (kl:shen.<anymulti> (kl:shen.pair (cdr (car V2379)) (kl:shen.hdtl V2379))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anymulti>)) (kl:shen.pair (car Parse_shen.<anymulti>) (quote shen.skip)) (kl:fail)))) (kl:fail)) YaccParse)) YaccParse))) (quote shen.<anymulti>))
(begin (register-function-arity (quote shen.<whitespaces>) 1) (define (kl:shen.<whitespaces> V2381) (let ((YaccParse (let ((Parse_shen.<whitespace> (kl:shen.<whitespace> V2381))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespace>)) (let ((Parse_shen.<whitespaces> (kl:shen.<whitespaces> Parse_shen.<whitespace>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespaces>)) (kl:shen.pair (car Parse_shen.<whitespaces>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<whitespace> (kl:shen.<whitespace> V2381))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespace>)) (kl:shen.pair (car Parse_shen.<whitespace>) (quote shen.skip)) (kl:fail))) YaccParse))) (quote shen.<whitespaces>))
(begin (register-function-arity (quote shen.<whitespace>) 1) (define (kl:shen.<whitespace> V2383) (if (pair? (car V2383)) (let ((Parse_X (car (car V2383)))) (if (assert-boolean (let ((Parse_Case Parse_X)) (or (kl:= Parse_Case 32) (or (kl:= Parse_Case 13) (or (kl:= Parse_Case 10) (kl:= Parse_Case 9)))))) (kl:shen.pair (car (kl:shen.pair (cdr (car V2383)) (kl:shen.hdtl V2383))) (quote shen.skip)) (kl:fail))) (kl:fail))) (quote shen.<whitespace>))
(begin (register-function-arity (quote shen.cons_form) 1) (define (kl:shen.cons_form V2385) (cond ((null? V2385) (quote ())) ((and (pair? V2385) (and (pair? (cdr V2385)) (and (pair? (cdr (cdr V2385))) (and (null? (cdr (cdr (cdr V2385)))) (eq? (car (cdr V2385)) (quote bar!)))))) (cons (quote cons) (cons (car V2385) (cdr (cdr V2385))))) ((pair? V2385) (cons (quote cons) (cons (car V2385) (cons (kl:shen.cons_form (cdr V2385)) (quote ()))))) (#t (kl:shen.f_error (quote shen.cons_form))))) (quote shen.cons_form))
(begin (register-function-arity (quote shen.package-macro) 2) (define (kl:shen.package-macro V2390 V2391) (cond ((and (pair? V2390) (and (eq? (quote _waspvm_dl_) (car V2390)) (and (pair? (cdr V2390)) (null? (cdr (cdr V2390)))))) (kl:append (kl:explode (car (cdr V2390))) V2391)) ((and (pair? V2390) (and (eq? (quote package) (car V2390)) (and (pair? (cdr V2390)) (and (eq? (quote null) (car (cdr V2390))) (pair? (cdr (cdr V2390))))))) (kl:append (cdr (cdr (cdr V2390))) V2391)) ((and (pair? V2390) (and (eq? (quote package) (car V2390)) (and (pair? (cdr V2390)) (pair? (cdr (cdr V2390)))))) (let ((ListofExceptions (kl:shen.eval-without-macros (car (cdr (cdr V2390)))))) (let ((External (kl:shen.record-exceptions ListofExceptions (car (cdr V2390))))) (let ((PackageNameDot (kl:intern (string-append (kl:str (car (cdr V2390))) ".")))) (let ((ExpPackageNameDot (kl:explode PackageNameDot))) (let ((Packaged (kl:shen.packageh PackageNameDot ListofExceptions (cdr (cdr (cdr V2390))) ExpPackageNameDot))) (let ((Internal (kl:shen.record-internal (car (cdr V2390)) (kl:shen.internal-symbols ExpPackageNameDot Packaged)))) (kl:append Packaged V2391)))))))) (#t (cons V2390 V2391)))) (quote shen.package-macro))
(begin (register-function-arity (quote shen.record-exceptions) 2) (define (kl:shen.record-exceptions V2394 V2395) (let ((CurrExceptions (guard (lambda (E) (quote ())) (kl:get V2395 (quote shen.external-symbols) (kl:value (quote *property-vector*)))))) (let ((AllExceptions (kl:union V2394 CurrExceptions))) (kl:put V2395 (quote shen.external-symbols) AllExceptions (kl:value (quote *property-vector*)))))) (quote shen.record-exceptions))
(begin (register-function-arity (quote shen.record-internal) 2) (define (kl:shen.record-internal V2398 V2399) (kl:put V2398 (quote shen.internal-symbols) (kl:union V2399 (guard (lambda (E) (quote ())) (kl:get V2398 (quote shen.internal-symbols) (kl:value (quote *property-vector*))))) (kl:value (quote *property-vector*)))) (quote shen.record-internal))
(begin (register-function-arity (quote shen.internal-symbols) 2) (define (kl:shen.internal-symbols V2410 V2411) (cond ((and (kl:symbol? V2411) (assert-boolean (kl:shen.prefix? V2410 (kl:explode V2411)))) (cons V2411 (quote ()))) ((pair? V2411) (kl:union (kl:shen.internal-symbols V2410 (car V2411)) (kl:shen.internal-symbols V2410 (cdr V2411)))) (#t (quote ())))) (quote shen.internal-symbols))
(begin (register-function-arity (quote shen.packageh) 4) (define (kl:shen.packageh V2428 V2429 V2430 V2431) (cond ((pair? V2430) (cons (kl:shen.packageh V2428 V2429 (car V2430) V2431) (kl:shen.packageh V2428 V2429 (cdr V2430) V2431))) ((or (assert-boolean (kl:shen.sysfunc? V2430)) (or (kl:variable? V2430) (or (kl:element? V2430 V2429) (or (assert-boolean (kl:shen.doubleunderline? V2430)) (assert-boolean (kl:shen.singleunderline? V2430)))))) V2430) ((and (kl:symbol? V2430) (assert-boolean (let ((ExplodeX (kl:explode V2430))) (and (kl:not (kl:shen.prefix? (cons "s" (cons "h" (cons "e" (cons "n" (cons "." (quote ())))))) ExplodeX)) (kl:not (kl:shen.prefix? V2431 ExplodeX)))))) (kl:concat V2428 V2430)) (#t V2430))) (quote shen.packageh))
