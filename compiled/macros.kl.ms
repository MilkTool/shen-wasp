"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote macroexpand) 1) (define (kl:macroexpand V1541) (let ((Y (kl:shen.compose (kl:value (quote *macros*)) V1541))) (if (kl:= V1541 Y) V1541 (kl:shen.walk (lambda (Z) (kl:macroexpand Z)) Y)))) (quote macroexpand))
(begin (register-function-arity (quote shen.error-macro) 1) (define (kl:shen.error-macro V1543) (cond ((and (pair? V1543) (and (eq? (quote error) (car V1543)) (pair? (cdr V1543)))) (cons (quote simple-error) (cons (kl:shen.mkstr (car (cdr V1543)) (cdr (cdr V1543))) (quote ())))) (#t V1543))) (quote shen.error-macro))
(begin (register-function-arity (quote shen.output-macro) 1) (define (kl:shen.output-macro V1545) (cond ((and (pair? V1545) (and (eq? (quote output) (car V1545)) (pair? (cdr V1545)))) (cons (quote shen.prhush) (cons (kl:shen.mkstr (car (cdr V1545)) (cdr (cdr V1545))) (cons (cons (quote stoutput) (quote ())) (quote ()))))) ((and (pair? V1545) (and (eq? (quote pr) (car V1545)) (and (pair? (cdr V1545)) (null? (cdr (cdr V1545)))))) (cons (quote pr) (cons (car (cdr V1545)) (cons (cons (quote stoutput) (quote ())) (quote ()))))) (#t V1545))) (quote shen.output-macro))
(begin (register-function-arity (quote shen.make-string-macro) 1) (define (kl:shen.make-string-macro V1547) (cond ((and (pair? V1547) (and (eq? (quote make-string) (car V1547)) (pair? (cdr V1547)))) (kl:shen.mkstr (car (cdr V1547)) (cdr (cdr V1547)))) (#t V1547))) (quote shen.make-string-macro))
(begin (register-function-arity (quote shen.input-macro) 1) (define (kl:shen.input-macro V1549) (cond ((and (pair? V1549) (and (eq? (quote lineread) (car V1549)) (null? (cdr V1549)))) (cons (quote lineread) (cons (cons (quote stinput) (quote ())) (quote ())))) ((and (pair? V1549) (and (eq? (quote input) (car V1549)) (null? (cdr V1549)))) (cons (quote input) (cons (cons (quote stinput) (quote ())) (quote ())))) ((and (pair? V1549) (and (eq? (quote read) (car V1549)) (null? (cdr V1549)))) (cons (quote read) (cons (cons (quote stinput) (quote ())) (quote ())))) ((and (pair? V1549) (and (eq? (quote input+) (car V1549)) (and (pair? (cdr V1549)) (null? (cdr (cdr V1549)))))) (cons (quote input+) (cons (car (cdr V1549)) (cons (cons (quote stinput) (quote ())) (quote ()))))) ((and (pair? V1549) (and (eq? (quote read-byte) (car V1549)) (null? (cdr V1549)))) (cons (quote read-byte) (cons (cons (quote stinput) (quote ())) (quote ())))) (#t V1549))) (quote shen.input-macro))
(begin (register-function-arity (quote shen.compose) 2) (define (kl:shen.compose V1552 V1553) (cond ((null? V1552) V1553) ((pair? V1552) (kl:shen.compose (cdr V1552) ((car V1552) V1553))) (#t (kl:shen.f_error (quote shen.compose))))) (quote shen.compose))
(begin (register-function-arity (quote shen.compile-macro) 1) (define (kl:shen.compile-macro V1555) (cond ((and (pair? V1555) (and (eq? (quote compile) (car V1555)) (and (pair? (cdr V1555)) (and (pair? (cdr (cdr V1555))) (null? (cdr (cdr (cdr V1555)))))))) (cons (quote compile) (cons (car (cdr V1555)) (cons (car (cdr (cdr V1555))) (cons (cons (quote lambda) (cons (quote E) (cons (cons (quote if) (cons (cons (quote cons?) (cons (quote E) (quote ()))) (cons (cons (quote error) (cons "parse error here: ~S~%" (cons (quote E) (quote ())))) (cons (cons (quote error) (cons "parse error~%" (quote ()))) (quote ()))))) (quote ())))) (quote ())))))) (#t V1555))) (quote shen.compile-macro))
(begin (register-function-arity (quote shen.prolog-macro) 1) (define (kl:shen.prolog-macro V1557) (cond ((and (pair? V1557) (eq? (quote prolog?) (car V1557))) (let ((F (kl:gensym (quote shen.f)))) (let ((Receive (kl:shen.receive-terms (cdr V1557)))) (let ((PrologDef (kl:eval (kl:append (cons (quote defprolog) (cons F (quote ()))) (kl:append Receive (kl:append (cons (quote <--) (quote ())) (kl:append (kl:shen.pass-literals (cdr V1557)) (cons (quote _waspvm_sc_) (quote ()))))))))) (let ((Query (cons F (kl:append Receive (cons (cons (quote shen.start-new-prolog-process) (quote ())) (cons (cons (quote freeze) (cons #t (quote ()))) (quote ()))))))) Query))))) (#t V1557))) (quote shen.prolog-macro))
(begin (register-function-arity (quote shen.receive-terms) 1) (define (kl:shen.receive-terms V1563) (cond ((null? V1563) (quote ())) ((and (pair? V1563) (and (pair? (car V1563)) (and (eq? (quote receive) (car (car V1563))) (and (pair? (cdr (car V1563))) (null? (cdr (cdr (car V1563)))))))) (cons (car (cdr (car V1563))) (kl:shen.receive-terms (cdr V1563)))) ((pair? V1563) (kl:shen.receive-terms (cdr V1563))) (#t (kl:shen.f_error (quote shen.receive-terms))))) (quote shen.receive-terms))
(begin (register-function-arity (quote shen.pass-literals) 1) (define (kl:shen.pass-literals V1567) (cond ((null? V1567) (quote ())) ((and (pair? V1567) (and (pair? (car V1567)) (and (eq? (quote receive) (car (car V1567))) (and (pair? (cdr (car V1567))) (null? (cdr (cdr (car V1567)))))))) (kl:shen.pass-literals (cdr V1567))) ((pair? V1567) (cons (car V1567) (kl:shen.pass-literals (cdr V1567)))) (#t (kl:shen.f_error (quote shen.pass-literals))))) (quote shen.pass-literals))
(begin (register-function-arity (quote shen.defprolog-macro) 1) (define (kl:shen.defprolog-macro V1569) (cond ((and (pair? V1569) (and (eq? (quote defprolog) (car V1569)) (pair? (cdr V1569)))) (kl:compile (lambda (Y) (kl:shen.<defprolog> Y)) (cdr V1569) (lambda (Y) (kl:shen.prolog-error (car (cdr V1569)) Y)))) (#t V1569))) (quote shen.defprolog-macro))
(begin (register-function-arity (quote shen.datatype-macro) 1) (define (kl:shen.datatype-macro V1571) (cond ((and (pair? V1571) (and (eq? (quote datatype) (car V1571)) (pair? (cdr V1571)))) (cons (quote shen.process-datatype) (cons (kl:shen.intern-type (car (cdr V1571))) (cons (cons (quote compile) (cons (cons (quote lambda) (cons (quote X) (cons (cons (quote shen.<datatype-rules>) (cons (quote X) (quote ()))) (quote ())))) (cons (kl:shen.rcons_form (cdr (cdr V1571))) (cons (cons (quote function) (cons (quote shen.datatype-error) (quote ()))) (quote ()))))) (quote ()))))) (#t V1571))) (quote shen.datatype-macro))
(begin (register-function-arity (quote shen.intern-type) 1) (define (kl:shen.intern-type V1573) (kl:intern (string-append "type#" (kl:str V1573)))) (quote shen.intern-type))
(begin (register-function-arity (quote shen._waspvm_at_s-macro) 1) (define (kl:shen._waspvm_at_s-macro V1575) (cond ((and (pair? V1575) (and (eq? (quote _waspvm_at_s) (car V1575)) (and (pair? (cdr V1575)) (and (pair? (cdr (cdr V1575))) (pair? (cdr (cdr (cdr V1575)))))))) (cons (quote _waspvm_at_s) (cons (car (cdr V1575)) (cons (kl:shen._waspvm_at_s-macro (cons (quote _waspvm_at_s) (cdr (cdr V1575)))) (quote ()))))) ((and (pair? V1575) (and (eq? (quote _waspvm_at_s) (car V1575)) (and (pair? (cdr V1575)) (and (pair? (cdr (cdr V1575))) (and (null? (cdr (cdr (cdr V1575)))) (string? (car (cdr V1575)))))))) (let ((E (kl:explode (car (cdr V1575))))) (if (> (kl:length E) 1) (kl:shen._waspvm_at_s-macro (cons (quote _waspvm_at_s) (kl:append E (cdr (cdr V1575))))) V1575))) (#t V1575))) (quote shen._waspvm_at_s-macro))
(begin (register-function-arity (quote shen.synonyms-macro) 1) (define (kl:shen.synonyms-macro V1577) (cond ((and (pair? V1577) (eq? (quote synonyms) (car V1577))) (cons (quote shen.synonyms-help) (cons (kl:shen.rcons_form (kl:shen.curry-synonyms (cdr V1577))) (quote ())))) (#t V1577))) (quote shen.synonyms-macro))
(begin (register-function-arity (quote shen.curry-synonyms) 1) (define (kl:shen.curry-synonyms V1579) (kl:map (lambda (X) (kl:shen.curry-type X)) V1579)) (quote shen.curry-synonyms))
(begin (register-function-arity (quote shen.nl-macro) 1) (define (kl:shen.nl-macro V1581) (cond ((and (pair? V1581) (and (eq? (quote nl) (car V1581)) (null? (cdr V1581)))) (cons (quote nl) (cons 1 (quote ())))) (#t V1581))) (quote shen.nl-macro))
(begin (register-function-arity (quote shen.assoc-macro) 1) (define (kl:shen.assoc-macro V1583) (cond ((and (pair? V1583) (and (pair? (cdr V1583)) (and (pair? (cdr (cdr V1583))) (and (pair? (cdr (cdr (cdr V1583)))) (kl:element? (car V1583) (cons (quote _waspvm_at_p) (cons (quote _waspvm_at_v) (cons (quote append) (cons (quote and) (cons (quote or) (cons (quote +) (cons (quote *) (cons (quote do) (quote ())))))))))))))) (cons (car V1583) (cons (car (cdr V1583)) (cons (kl:shen.assoc-macro (cons (car V1583) (cdr (cdr V1583)))) (quote ()))))) (#t V1583))) (quote shen.assoc-macro))
(begin (register-function-arity (quote shen.let-macro) 1) (define (kl:shen.let-macro V1585) (cond ((and (pair? V1585) (and (eq? (quote let) (car V1585)) (and (pair? (cdr V1585)) (and (pair? (cdr (cdr V1585))) (and (pair? (cdr (cdr (cdr V1585)))) (pair? (cdr (cdr (cdr (cdr V1585)))))))))) (cons (quote let) (cons (car (cdr V1585)) (cons (car (cdr (cdr V1585))) (cons (kl:shen.let-macro (cons (quote let) (cdr (cdr (cdr V1585))))) (quote ())))))) (#t V1585))) (quote shen.let-macro))
(begin (register-function-arity (quote shen.abs-macro) 1) (define (kl:shen.abs-macro V1587) (cond ((and (pair? V1587) (and (eq? (quote /.) (car V1587)) (and (pair? (cdr V1587)) (and (pair? (cdr (cdr V1587))) (pair? (cdr (cdr (cdr V1587)))))))) (cons (quote lambda) (cons (car (cdr V1587)) (cons (kl:shen.abs-macro (cons (quote /.) (cdr (cdr V1587)))) (quote ()))))) ((and (pair? V1587) (and (eq? (quote /.) (car V1587)) (and (pair? (cdr V1587)) (and (pair? (cdr (cdr V1587))) (null? (cdr (cdr (cdr V1587)))))))) (cons (quote lambda) (cdr V1587))) (#t V1587))) (quote shen.abs-macro))
(begin (register-function-arity (quote shen.cases-macro) 1) (define (kl:shen.cases-macro V1591) (cond ((and (pair? V1591) (and (eq? (quote cases) (car V1591)) (and (pair? (cdr V1591)) (and (kl:= #t (car (cdr V1591))) (pair? (cdr (cdr V1591))))))) (car (cdr (cdr V1591)))) ((and (pair? V1591) (and (eq? (quote cases) (car V1591)) (and (pair? (cdr V1591)) (and (pair? (cdr (cdr V1591))) (null? (cdr (cdr (cdr V1591)))))))) (cons (quote if) (cons (car (cdr V1591)) (cons (car (cdr (cdr V1591))) (cons (cons (quote simple-error) (cons "error: cases exhausted" (quote ()))) (quote ())))))) ((and (pair? V1591) (and (eq? (quote cases) (car V1591)) (and (pair? (cdr V1591)) (pair? (cdr (cdr V1591)))))) (cons (quote if) (cons (car (cdr V1591)) (cons (car (cdr (cdr V1591))) (cons (kl:shen.cases-macro (cons (quote cases) (cdr (cdr (cdr V1591))))) (quote ())))))) ((and (pair? V1591) (and (eq? (quote cases) (car V1591)) (and (pair? (cdr V1591)) (null? (cdr (cdr V1591)))))) (simple-error "error: odd number of case elements\n")) (#t V1591))) (quote shen.cases-macro))
(begin (register-function-arity (quote shen.timer-macro) 1) (define (kl:shen.timer-macro V1593) (cond ((and (pair? V1593) (and (eq? (quote time) (car V1593)) (and (pair? (cdr V1593)) (null? (cdr (cdr V1593)))))) (kl:shen.let-macro (cons (quote let) (cons (quote Start) (cons (cons (quote get-time) (cons (quote run) (quote ()))) (cons (quote Result) (cons (car (cdr V1593)) (cons (quote Finish) (cons (cons (quote get-time) (cons (quote run) (quote ()))) (cons (quote Time) (cons (cons (quote -) (cons (quote Finish) (cons (quote Start) (quote ())))) (cons (quote Message) (cons (cons (quote shen.prhush) (cons (cons (quote cn) (cons "\nrun time: " (cons (cons (quote cn) (cons (cons (quote str) (cons (quote Time) (quote ()))) (cons " secs\n" (quote ())))) (quote ())))) (cons (cons (quote stoutput) (quote ())) (quote ())))) (cons (quote Result) (quote ()))))))))))))))) (#t V1593))) (quote shen.timer-macro))
(begin (register-function-arity (quote shen.tuple-up) 1) (define (kl:shen.tuple-up V1595) (cond ((pair? V1595) (cons (quote _waspvm_at_p) (cons (car V1595) (cons (kl:shen.tuple-up (cdr V1595)) (quote ()))))) (#t V1595))) (quote shen.tuple-up))
(begin (register-function-arity (quote shen.put/get-macro) 1) (define (kl:shen.put/get-macro V1597) (cond ((and (pair? V1597) (and (eq? (quote put) (car V1597)) (and (pair? (cdr V1597)) (and (pair? (cdr (cdr V1597))) (and (pair? (cdr (cdr (cdr V1597)))) (null? (cdr (cdr (cdr (cdr V1597)))))))))) (cons (quote put) (cons (car (cdr V1597)) (cons (car (cdr (cdr V1597))) (cons (car (cdr (cdr (cdr V1597)))) (cons (cons (quote value) (cons (quote *property-vector*) (quote ()))) (quote ()))))))) ((and (pair? V1597) (and (eq? (quote get) (car V1597)) (and (pair? (cdr V1597)) (and (pair? (cdr (cdr V1597))) (null? (cdr (cdr (cdr V1597)))))))) (cons (quote get) (cons (car (cdr V1597)) (cons (car (cdr (cdr V1597))) (cons (cons (quote value) (cons (quote *property-vector*) (quote ()))) (quote ())))))) ((and (pair? V1597) (and (eq? (quote unput) (car V1597)) (and (pair? (cdr V1597)) (and (pair? (cdr (cdr V1597))) (null? (cdr (cdr (cdr V1597)))))))) (cons (quote unput) (cons (car (cdr V1597)) (cons (car (cdr (cdr V1597))) (cons (cons (quote value) (cons (quote *property-vector*) (quote ()))) (quote ())))))) (#t V1597))) (quote shen.put/get-macro))
(begin (register-function-arity (quote shen.function-macro) 1) (define (kl:shen.function-macro V1599) (cond ((and (pair? V1599) (and (eq? (quote function) (car V1599)) (and (pair? (cdr V1599)) (null? (cdr (cdr V1599)))))) (kl:shen.function-abstraction (car (cdr V1599)) (kl:arity (car (cdr V1599))))) (#t V1599))) (quote shen.function-macro))
(begin (register-function-arity (quote shen.function-abstraction) 2) (define (kl:shen.function-abstraction V1602 V1603) (cond ((kl:= 0 V1603) (simple-error (kl:shen.app V1602 " has no lambda form\n" (quote shen.a)))) ((kl:= -1 V1603) (cons (quote function) (cons V1602 (quote ())))) (#t (kl:shen.function-abstraction-help V1602 V1603 (quote ()))))) (quote shen.function-abstraction))
(begin (register-function-arity (quote shen.function-abstraction-help) 3) (define (kl:shen.function-abstraction-help V1607 V1608 V1609) (cond ((kl:= 0 V1608) (cons V1607 V1609)) (#t (let ((X (kl:gensym (quote V)))) (cons (quote /.) (cons X (cons (kl:shen.function-abstraction-help V1607 (- V1608 1) (kl:append V1609 (cons X (quote ())))) (quote ())))))))) (quote shen.function-abstraction-help))
(begin (register-function-arity (quote undefmacro) 1) (define (kl:undefmacro V1611) (let ((MacroReg (kl:value (quote shen.*macroreg*)))) (let ((Pos (kl:shen.findpos V1611 MacroReg))) (let ((Remove1 (kl:set (quote shen.*macroreg*) (kl:remove V1611 MacroReg)))) (let ((Remove2 (kl:set (quote *macros*) (kl:shen.remove-nth Pos (kl:value (quote *macros*)))))) V1611))))) (quote undefmacro))
(begin (register-function-arity (quote shen.findpos) 2) (define (kl:shen.findpos V1621 V1622) (cond ((null? V1622) (simple-error (kl:shen.app V1621 " is not a macro\n" (quote shen.a)))) ((and (pair? V1622) (kl:= (car V1622) V1621)) 1) ((pair? V1622) (+ 1 (kl:shen.findpos V1621 (cdr V1622)))) (#t (kl:shen.f_error (quote shen.findpos))))) (quote shen.findpos))
(begin (register-function-arity (quote shen.remove-nth) 2) (define (kl:shen.remove-nth V1627 V1628) (cond ((and (kl:= 1 V1627) (pair? V1628)) (cdr V1628)) ((pair? V1628) (cons (car V1628) (kl:shen.remove-nth (- V1627 1) (cdr V1628)))) (#t (kl:shen.f_error (quote shen.remove-nth))))) (quote shen.remove-nth))
