(module "compiled/macros.kl")
"Copyright (c) 2010-2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
(begin (register-function-arity (quote macroexpand) 1) (define (kl:macroexpand V1851) (let ((Y (kl:shen.compose (kl:value (quote *macros*)) V1851))) (if (kl:= V1851 Y) V1851 (kl:shen.walk (lambda (Z) (kl:macroexpand Z)) Y)))) (export macroexpand) (quote macroexpand))
(begin (register-function-arity (quote shen.error-macro) 1) (define (kl:shen.error-macro V1853) (cond ((and (pair? V1853) (and (eq? (quote error) (car V1853)) (pair? (cdr V1853)))) (cons (quote simple-error) (cons (kl:shen.mkstr (car (cdr V1853)) (cdr (cdr V1853))) (quote ())))) (#t V1853))) (export shen.error-macro) (quote shen.error-macro))
(begin (register-function-arity (quote shen.output-macro) 1) (define (kl:shen.output-macro V1855) (cond ((and (pair? V1855) (and (eq? (quote output) (car V1855)) (pair? (cdr V1855)))) (cons (quote shen.prhush) (cons (kl:shen.mkstr (car (cdr V1855)) (cdr (cdr V1855))) (cons (cons (quote stoutput) (quote ())) (quote ()))))) ((and (pair? V1855) (and (eq? (quote pr) (car V1855)) (and (pair? (cdr V1855)) (null? (cdr (cdr V1855)))))) (cons (quote pr) (cons (car (cdr V1855)) (cons (cons (quote stoutput) (quote ())) (quote ()))))) (#t V1855))) (export shen.output-macro) (quote shen.output-macro))
(begin (register-function-arity (quote shen.make-string-macro) 1) (define (kl:shen.make-string-macro V1857) (cond ((and (pair? V1857) (and (eq? (quote make-string) (car V1857)) (pair? (cdr V1857)))) (kl:shen.mkstr (car (cdr V1857)) (cdr (cdr V1857)))) (#t V1857))) (export shen.make-string-macro) (quote shen.make-string-macro))
(begin (register-function-arity (quote shen.input-macro) 1) (define (kl:shen.input-macro V1859) (cond ((and (pair? V1859) (and (eq? (quote lineread) (car V1859)) (null? (cdr V1859)))) (cons (quote lineread) (cons (cons (quote stinput) (quote ())) (quote ())))) ((and (pair? V1859) (and (eq? (quote input) (car V1859)) (null? (cdr V1859)))) (cons (quote input) (cons (cons (quote stinput) (quote ())) (quote ())))) ((and (pair? V1859) (and (eq? (quote read) (car V1859)) (null? (cdr V1859)))) (cons (quote read) (cons (cons (quote stinput) (quote ())) (quote ())))) ((and (pair? V1859) (and (eq? (quote input+) (car V1859)) (and (pair? (cdr V1859)) (null? (cdr (cdr V1859)))))) (cons (quote input+) (cons (car (cdr V1859)) (cons (cons (quote stinput) (quote ())) (quote ()))))) ((and (pair? V1859) (and (eq? (quote read-byte) (car V1859)) (null? (cdr V1859)))) (cons (quote read-byte) (cons (cons (quote stinput) (quote ())) (quote ())))) (#t V1859))) (export shen.input-macro) (quote shen.input-macro))
(begin (register-function-arity (quote shen.compose) 2) (define (kl:shen.compose V1862 V1863) (cond ((null? V1862) V1863) ((pair? V1862) (kl:shen.compose (cdr V1862) ((car V1862) V1863))) (#t (kl:shen.f_error (quote shen.compose))))) (export shen.compose) (quote shen.compose))
(begin (register-function-arity (quote shen.compile-macro) 1) (define (kl:shen.compile-macro V1865) (cond ((and (pair? V1865) (and (eq? (quote compile) (car V1865)) (and (pair? (cdr V1865)) (and (pair? (cdr (cdr V1865))) (null? (cdr (cdr (cdr V1865)))))))) (cons (quote compile) (cons (car (cdr V1865)) (cons (car (cdr (cdr V1865))) (cons (cons (quote lambda) (cons (quote E) (cons (cons (quote if) (cons (cons (quote cons?) (cons (quote E) (quote ()))) (cons (cons (quote error) (cons "parse error here: ~S~%" (cons (quote E) (quote ())))) (cons (cons (quote error) (cons "parse error~%" (quote ()))) (quote ()))))) (quote ())))) (quote ())))))) (#t V1865))) (export shen.compile-macro) (quote shen.compile-macro))
(begin (register-function-arity (quote shen.prolog-macro) 1) (define (kl:shen.prolog-macro V1867) (cond ((and (pair? V1867) (eq? (quote prolog?) (car V1867))) (cons (quote let) (cons (quote NPP) (cons (cons (quote shen.start-new-prolog-process) (quote ())) (cons (let ((Calls (kl:shen.bld-prolog-call (quote NPP) (cdr V1867)))) (let ((Vs (kl:shen.extract_vars (cdr V1867)))) (let ((External (kl:shen.externally-bound (cdr V1867)))) (let ((PrologVs (kl:difference Vs External))) (kl:shen.locally-bind-prolog-vs (quote NPP) PrologVs Calls))))) (quote ())))))) (#t V1867))) (export shen.prolog-macro) (quote shen.prolog-macro))
(begin (register-function-arity (quote shen.externally-bound) 1) (define (kl:shen.externally-bound V1873) (cond ((and (pair? V1873) (and (eq? (quote receive) (car V1873)) (and (pair? (cdr V1873)) (null? (cdr (cdr V1873)))))) (cdr V1873)) ((pair? V1873) (kl:union (kl:shen.externally-bound (car V1873)) (kl:shen.externally-bound (cdr V1873)))) (#t (quote ())))) (export shen.externally-bound) (quote shen.externally-bound))
(begin (register-function-arity (quote shen.locally-bind-prolog-vs) 3) (define (kl:shen.locally-bind-prolog-vs V1891 V1892 V1893) (cond ((null? V1892) V1893) ((pair? V1892) (cons (quote let) (cons (car V1892) (cons (cons (quote shen.newpv) (cons V1891 (quote ()))) (cons (kl:shen.locally-bind-prolog-vs V1891 (cdr V1892) V1893) (quote ())))))) (#t (simple-error "implementation error inp locally-bind-prolog-vs")))) (export shen.locally-bind-prolog-vs) (quote shen.locally-bind-prolog-vs))
(begin (register-function-arity (quote shen.bld-prolog-call) 2) (define (kl:shen.bld-prolog-call V1906 V1907) (cond ((null? V1907) #t) ((and (pair? V1907) (eq? (quote !) (car V1907))) (cons (quote cut) (cons #f (cons V1906 (cons (cons (quote freeze) (cons (kl:shen.bld-prolog-call V1906 (cdr V1907)) (quote ()))) (quote ())))))) ((and (pair? V1907) (and (pair? (car V1907)) (and (eq? (quote when) (car (car V1907))) (and (pair? (cdr (car V1907))) (null? (cdr (cdr (car V1907)))))))) (cons (quote fwhen) (cons (kl:shen.insert-deref (car (cdr (car V1907))) V1906) (cons V1906 (cons (cons (quote freeze) (cons (kl:shen.bld-prolog-call V1906 (cdr V1907)) (quote ()))) (quote ())))))) ((and (pair? V1907) (and (pair? (car V1907)) (and (eq? (quote is) (car (car V1907))) (and (pair? (cdr (car V1907))) (and (pair? (cdr (cdr (car V1907)))) (null? (cdr (cdr (cdr (car V1907)))))))))) (cons (quote bind) (cons (car (cdr (car V1907))) (cons (kl:shen.insert-deref (car (cdr (cdr (car V1907)))) V1906) (cons V1906 (cons (cons (quote freeze) (cons (kl:shen.bld-prolog-call V1906 (cdr V1907)) (quote ()))) (quote ()))))))) ((and (pair? V1907) (and (pair? (car V1907)) (and (eq? (quote receive) (car (car V1907))) (and (pair? (cdr (car V1907))) (null? (cdr (cdr (car V1907)))))))) (kl:shen.bld-prolog-call V1906 (cdr V1907))) ((and (pair? V1907) (and (pair? (car V1907)) (and (eq? (quote bind) (car (car V1907))) (and (pair? (cdr (car V1907))) (and (pair? (cdr (cdr (car V1907)))) (null? (cdr (cdr (cdr (car V1907)))))))))) (cons (quote bind) (cons (car (cdr (car V1907))) (cons (kl:shen.insert-lazyderef (car (cdr (cdr (car V1907)))) V1906) (cons V1906 (cons (cons (quote freeze) (cons (kl:shen.bld-prolog-call V1906 (cdr V1907)) (quote ()))) (quote ()))))))) ((and (pair? V1907) (and (pair? (car V1907)) (and (eq? (quote fwhen) (car (car V1907))) (and (pair? (cdr (car V1907))) (null? (cdr (cdr (car V1907)))))))) (cons (quote fwhen) (cons (kl:shen.insert-lazyderef (car (cdr (car V1907))) V1906) (cons V1906 (cons (cons (quote freeze) (cons (kl:shen.bld-prolog-call V1906 (cdr V1907)) (quote ()))) (quote ())))))) ((pair? V1907) (kl:append (car V1907) (cons V1906 (cons (cons (quote freeze) (cons (kl:shen.bld-prolog-call V1906 (cdr V1907)) (quote ()))) (quote ()))))) (#t (simple-error "implementation error in bld-prolog-call")))) (export shen.bld-prolog-call) (quote shen.bld-prolog-call))
(begin (register-function-arity (quote shen.defprolog-macro) 1) (define (kl:shen.defprolog-macro V1909) (cond ((and (pair? V1909) (and (eq? (quote defprolog) (car V1909)) (pair? (cdr V1909)))) (kl:compile (lambda (Y) (kl:shen.<defprolog> Y)) (cdr V1909) (lambda (Y) (kl:shen.prolog-error (car (cdr V1909)) Y)))) (#t V1909))) (export shen.defprolog-macro) (quote shen.defprolog-macro))
(begin (register-function-arity (quote shen.datatype-macro) 1) (define (kl:shen.datatype-macro V1911) (cond ((and (pair? V1911) (and (eq? (quote datatype) (car V1911)) (pair? (cdr V1911)))) (cons (quote shen.process-datatype) (cons (kl:shen.intern-type (car (cdr V1911))) (cons (cons (quote compile) (cons (cons (quote lambda) (cons (quote X) (cons (cons (quote shen.<datatype-rules>) (cons (quote X) (quote ()))) (quote ())))) (cons (kl:shen.rcons_form (cdr (cdr V1911))) (cons (cons (quote function) (cons (quote shen.datatype-error) (quote ()))) (quote ()))))) (quote ()))))) (#t V1911))) (export shen.datatype-macro) (quote shen.datatype-macro))
(begin (register-function-arity (quote shen.intern-type) 1) (define (kl:shen.intern-type V1913) (kl:intern (string-append (kl:str V1913) "#type"))) (export shen.intern-type) (quote shen.intern-type))
(begin (register-function-arity (quote shen._waspvm_at_s-macro) 1) (define (kl:shen._waspvm_at_s-macro V1915) (cond ((and (pair? V1915) (and (eq? (quote _waspvm_at_s) (car V1915)) (and (pair? (cdr V1915)) (and (pair? (cdr (cdr V1915))) (pair? (cdr (cdr (cdr V1915)))))))) (cons (quote _waspvm_at_s) (cons (car (cdr V1915)) (cons (kl:shen._waspvm_at_s-macro (cons (quote _waspvm_at_s) (cdr (cdr V1915)))) (quote ()))))) ((and (pair? V1915) (and (eq? (quote _waspvm_at_s) (car V1915)) (and (pair? (cdr V1915)) (and (pair? (cdr (cdr V1915))) (and (null? (cdr (cdr (cdr V1915)))) (string? (car (cdr V1915)))))))) (let ((E (kl:explode (car (cdr V1915))))) (if (> (kl:length E) 1) (kl:shen._waspvm_at_s-macro (cons (quote _waspvm_at_s) (kl:append E (cdr (cdr V1915))))) V1915))) (#t V1915))) (export shen._waspvm_at_s-macro) (quote shen._waspvm_at_s-macro))
(begin (register-function-arity (quote shen.synonyms-macro) 1) (define (kl:shen.synonyms-macro V1917) (cond ((and (pair? V1917) (eq? (quote synonyms) (car V1917))) (cons (quote shen.synonyms-help) (cons (kl:shen.rcons_form (kl:shen.curry-synonyms (cdr V1917))) (quote ())))) (#t V1917))) (export shen.synonyms-macro) (quote shen.synonyms-macro))
(begin (register-function-arity (quote shen.curry-synonyms) 1) (define (kl:shen.curry-synonyms V1919) (kl:map (lambda (X) (kl:shen.curry-type X)) V1919)) (export shen.curry-synonyms) (quote shen.curry-synonyms))
(begin (register-function-arity (quote shen.nl-macro) 1) (define (kl:shen.nl-macro V1921) (cond ((and (pair? V1921) (and (eq? (quote nl) (car V1921)) (null? (cdr V1921)))) (cons (quote nl) (cons 1 (quote ())))) (#t V1921))) (export shen.nl-macro) (quote shen.nl-macro))
(begin (register-function-arity (quote shen.assoc-macro) 1) (define (kl:shen.assoc-macro V1923) (cond ((and (pair? V1923) (and (pair? (cdr V1923)) (and (pair? (cdr (cdr V1923))) (and (pair? (cdr (cdr (cdr V1923)))) (kl:element? (car V1923) (cons (quote _waspvm_at_p) (cons (quote _waspvm_at_v) (cons (quote append) (cons (quote and) (cons (quote or) (cons (quote +) (cons (quote *) (cons (quote do) (quote ())))))))))))))) (cons (car V1923) (cons (car (cdr V1923)) (cons (kl:shen.assoc-macro (cons (car V1923) (cdr (cdr V1923)))) (quote ()))))) (#t V1923))) (export shen.assoc-macro) (quote shen.assoc-macro))
(begin (register-function-arity (quote shen.let-macro) 1) (define (kl:shen.let-macro V1925) (cond ((and (pair? V1925) (and (eq? (quote let) (car V1925)) (and (pair? (cdr V1925)) (and (pair? (cdr (cdr V1925))) (and (pair? (cdr (cdr (cdr V1925)))) (pair? (cdr (cdr (cdr (cdr V1925)))))))))) (cons (quote let) (cons (car (cdr V1925)) (cons (car (cdr (cdr V1925))) (cons (kl:shen.let-macro (cons (quote let) (cdr (cdr (cdr V1925))))) (quote ())))))) (#t V1925))) (export shen.let-macro) (quote shen.let-macro))
(begin (register-function-arity (quote shen.abs-macro) 1) (define (kl:shen.abs-macro V1927) (cond ((and (pair? V1927) (and (eq? (quote /.) (car V1927)) (and (pair? (cdr V1927)) (and (pair? (cdr (cdr V1927))) (pair? (cdr (cdr (cdr V1927)))))))) (cons (quote lambda) (cons (car (cdr V1927)) (cons (kl:shen.abs-macro (cons (quote /.) (cdr (cdr V1927)))) (quote ()))))) ((and (pair? V1927) (and (eq? (quote /.) (car V1927)) (and (pair? (cdr V1927)) (and (pair? (cdr (cdr V1927))) (null? (cdr (cdr (cdr V1927)))))))) (cons (quote lambda) (cdr V1927))) (#t V1927))) (export shen.abs-macro) (quote shen.abs-macro))
(begin (register-function-arity (quote shen.cases-macro) 1) (define (kl:shen.cases-macro V1931) (cond ((and (pair? V1931) (and (eq? (quote cases) (car V1931)) (and (pair? (cdr V1931)) (and (kl:= #t (car (cdr V1931))) (pair? (cdr (cdr V1931))))))) (car (cdr (cdr V1931)))) ((and (pair? V1931) (and (eq? (quote cases) (car V1931)) (and (pair? (cdr V1931)) (and (pair? (cdr (cdr V1931))) (null? (cdr (cdr (cdr V1931)))))))) (cons (quote if) (cons (car (cdr V1931)) (cons (car (cdr (cdr V1931))) (cons (cons (quote simple-error) (cons "error: cases exhausted" (quote ()))) (quote ())))))) ((and (pair? V1931) (and (eq? (quote cases) (car V1931)) (and (pair? (cdr V1931)) (pair? (cdr (cdr V1931)))))) (cons (quote if) (cons (car (cdr V1931)) (cons (car (cdr (cdr V1931))) (cons (kl:shen.cases-macro (cons (quote cases) (cdr (cdr (cdr V1931))))) (quote ())))))) ((and (pair? V1931) (and (eq? (quote cases) (car V1931)) (and (pair? (cdr V1931)) (null? (cdr (cdr V1931)))))) (simple-error "error: odd number of case elements\n")) (#t V1931))) (export shen.cases-macro) (quote shen.cases-macro))
(begin (register-function-arity (quote shen.timer-macro) 1) (define (kl:shen.timer-macro V1933) (cond ((and (pair? V1933) (and (eq? (quote time) (car V1933)) (and (pair? (cdr V1933)) (null? (cdr (cdr V1933)))))) (kl:shen.let-macro (cons (quote let) (cons (quote Start) (cons (cons (quote get-time) (cons (quote run) (quote ()))) (cons (quote Result) (cons (car (cdr V1933)) (cons (quote Finish) (cons (cons (quote get-time) (cons (quote run) (quote ()))) (cons (quote Time) (cons (cons (quote -) (cons (quote Finish) (cons (quote Start) (quote ())))) (cons (quote Message) (cons (cons (quote shen.prhush) (cons (cons (quote cn) (cons "\nrun time: " (cons (cons (quote cn) (cons (cons (quote str) (cons (quote Time) (quote ()))) (cons " secs\n" (quote ())))) (quote ())))) (cons (cons (quote stoutput) (quote ())) (quote ())))) (cons (quote Result) (quote ()))))))))))))))) (#t V1933))) (export shen.timer-macro) (quote shen.timer-macro))
(begin (register-function-arity (quote shen.tuple-up) 1) (define (kl:shen.tuple-up V1935) (cond ((pair? V1935) (cons (quote _waspvm_at_p) (cons (car V1935) (cons (kl:shen.tuple-up (cdr V1935)) (quote ()))))) (#t V1935))) (export shen.tuple-up) (quote shen.tuple-up))
(begin (register-function-arity (quote shen.put/get-macro) 1) (define (kl:shen.put/get-macro V1937) (cond ((and (pair? V1937) (and (eq? (quote put) (car V1937)) (and (pair? (cdr V1937)) (and (pair? (cdr (cdr V1937))) (and (pair? (cdr (cdr (cdr V1937)))) (null? (cdr (cdr (cdr (cdr V1937)))))))))) (cons (quote put) (cons (car (cdr V1937)) (cons (car (cdr (cdr V1937))) (cons (car (cdr (cdr (cdr V1937)))) (cons (cons (quote value) (cons (quote *property-vector*) (quote ()))) (quote ()))))))) ((and (pair? V1937) (and (eq? (quote get) (car V1937)) (and (pair? (cdr V1937)) (and (pair? (cdr (cdr V1937))) (null? (cdr (cdr (cdr V1937)))))))) (cons (quote get) (cons (car (cdr V1937)) (cons (car (cdr (cdr V1937))) (cons (cons (quote value) (cons (quote *property-vector*) (quote ()))) (quote ())))))) ((and (pair? V1937) (and (eq? (quote unput) (car V1937)) (and (pair? (cdr V1937)) (and (pair? (cdr (cdr V1937))) (null? (cdr (cdr (cdr V1937)))))))) (cons (quote unput) (cons (car (cdr V1937)) (cons (car (cdr (cdr V1937))) (cons (cons (quote value) (cons (quote *property-vector*) (quote ()))) (quote ())))))) (#t V1937))) (export shen.put/get-macro) (quote shen.put/get-macro))
(begin (register-function-arity (quote shen.function-macro) 1) (define (kl:shen.function-macro V1939) (cond ((and (pair? V1939) (and (eq? (quote function) (car V1939)) (and (pair? (cdr V1939)) (null? (cdr (cdr V1939)))))) (kl:shen.function-abstraction (car (cdr V1939)) (kl:arity (car (cdr V1939))))) (#t V1939))) (export shen.function-macro) (quote shen.function-macro))
(begin (register-function-arity (quote shen.function-abstraction) 2) (define (kl:shen.function-abstraction V1942 V1943) (cond ((kl:= 0 V1943) (simple-error (kl:shen.app V1942 " has no lambda form\n" (quote shen.a)))) ((kl:= -1 V1943) (cons (quote function) (cons V1942 (quote ())))) (#t (kl:shen.function-abstraction-help V1942 V1943 (quote ()))))) (export shen.function-abstraction) (quote shen.function-abstraction))
(begin (register-function-arity (quote shen.function-abstraction-help) 3) (define (kl:shen.function-abstraction-help V1947 V1948 V1949) (cond ((kl:= 0 V1948) (cons V1947 V1949)) (#t (let ((X (kl:gensym (quote V)))) (cons (quote /.) (cons X (cons (kl:shen.function-abstraction-help V1947 (- V1948 1) (kl:append V1949 (cons X (quote ())))) (quote ())))))))) (export shen.function-abstraction-help) (quote shen.function-abstraction-help))
(begin (register-function-arity (quote undefmacro) 1) (define (kl:undefmacro V1951) (let ((MacroReg (kl:value (quote shen.*macroreg*)))) (let ((Pos (kl:shen.findpos V1951 MacroReg))) (let ((Remove1 (kl:set (quote shen.*macroreg*) (kl:remove V1951 MacroReg)))) (let ((Remove2 (kl:set (quote *macros*) (kl:shen.remove-nth Pos (kl:value (quote *macros*)))))) V1951))))) (export undefmacro) (quote undefmacro))
(begin (register-function-arity (quote shen.findpos) 2) (define (kl:shen.findpos V1961 V1962) (cond ((null? V1962) (simple-error (kl:shen.app V1961 " is not a macro\n" (quote shen.a)))) ((and (pair? V1962) (kl:= (car V1962) V1961)) 1) ((pair? V1962) (+ 1 (kl:shen.findpos V1961 (cdr V1962)))) (#t (kl:shen.f_error (quote shen.findpos))))) (export shen.findpos) (quote shen.findpos))
(begin (register-function-arity (quote shen.remove-nth) 2) (define (kl:shen.remove-nth V1967 V1968) (cond ((and (kl:= 1 V1967) (pair? V1968)) (cdr V1968)) ((pair? V1968) (cons (car V1968) (kl:shen.remove-nth (- V1967 1) (cdr V1968)))) (#t (kl:shen.f_error (quote shen.remove-nth))))) (export shen.remove-nth) (quote shen.remove-nth))
