"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote macroexpand) 1) (define (kl:macroexpand V1698) (let ((Y (kl:shen.compose (kl:value (quote *macros*)) V1698))) (if (kl:= V1698 Y) V1698 (kl:shen.walk (lambda (Z) (kl:macroexpand Z)) Y)))) (quote macroexpand))
(begin (register-function-arity (quote shen.error-macro) 1) (define (kl:shen.error-macro V1700) (cond ((and (pair? V1700) (and (eq? (quote error) (car V1700)) (pair? (cdr V1700)))) (cons (quote simple-error) (cons (kl:shen.mkstr (car (cdr V1700)) (cdr (cdr V1700))) (quote ())))) (#t V1700))) (quote shen.error-macro))
(begin (register-function-arity (quote shen.output-macro) 1) (define (kl:shen.output-macro V1702) (cond ((and (pair? V1702) (and (eq? (quote output) (car V1702)) (pair? (cdr V1702)))) (cons (quote shen.prhush) (cons (kl:shen.mkstr (car (cdr V1702)) (cdr (cdr V1702))) (cons (cons (quote stoutput) (quote ())) (quote ()))))) ((and (pair? V1702) (and (eq? (quote pr) (car V1702)) (and (pair? (cdr V1702)) (null? (cdr (cdr V1702)))))) (cons (quote pr) (cons (car (cdr V1702)) (cons (cons (quote stoutput) (quote ())) (quote ()))))) (#t V1702))) (quote shen.output-macro))
(begin (register-function-arity (quote shen.make-string-macro) 1) (define (kl:shen.make-string-macro V1704) (cond ((and (pair? V1704) (and (eq? (quote make-string) (car V1704)) (pair? (cdr V1704)))) (kl:shen.mkstr (car (cdr V1704)) (cdr (cdr V1704)))) (#t V1704))) (quote shen.make-string-macro))
(begin (register-function-arity (quote shen.input-macro) 1) (define (kl:shen.input-macro V1706) (cond ((and (pair? V1706) (and (eq? (quote lineread) (car V1706)) (null? (cdr V1706)))) (cons (quote lineread) (cons (cons (quote stinput) (quote ())) (quote ())))) ((and (pair? V1706) (and (eq? (quote input) (car V1706)) (null? (cdr V1706)))) (cons (quote input) (cons (cons (quote stinput) (quote ())) (quote ())))) ((and (pair? V1706) (and (eq? (quote read) (car V1706)) (null? (cdr V1706)))) (cons (quote read) (cons (cons (quote stinput) (quote ())) (quote ())))) ((and (pair? V1706) (and (eq? (quote input+) (car V1706)) (and (pair? (cdr V1706)) (null? (cdr (cdr V1706)))))) (cons (quote input+) (cons (car (cdr V1706)) (cons (cons (quote stinput) (quote ())) (quote ()))))) ((and (pair? V1706) (and (eq? (quote read-byte) (car V1706)) (null? (cdr V1706)))) (cons (quote read-byte) (cons (cons (quote stinput) (quote ())) (quote ())))) ((and (pair? V1706) (and (eq? (quote read-char-code) (car V1706)) (null? (cdr V1706)))) (cons (quote read-char-code) (cons (cons (quote stinput) (quote ())) (quote ())))) (#t V1706))) (quote shen.input-macro))
(begin (register-function-arity (quote shen.compose) 2) (define (kl:shen.compose V1709 V1710) (cond ((null? V1709) V1710) ((pair? V1709) (kl:shen.compose (cdr V1709) ((car V1709) V1710))) (#t (kl:shen.f_error (quote shen.compose))))) (quote shen.compose))
(begin (register-function-arity (quote shen.compile-macro) 1) (define (kl:shen.compile-macro V1712) (cond ((and (pair? V1712) (and (eq? (quote compile) (car V1712)) (and (pair? (cdr V1712)) (and (pair? (cdr (cdr V1712))) (null? (cdr (cdr (cdr V1712)))))))) (cons (quote compile) (cons (car (cdr V1712)) (cons (car (cdr (cdr V1712))) (cons (cons (quote lambda) (cons (quote E) (cons (cons (quote if) (cons (cons (quote cons?) (cons (quote E) (quote ()))) (cons (cons (quote error) (cons "parse error here: ~S~%" (cons (quote E) (quote ())))) (cons (cons (quote error) (cons "parse error~%" (quote ()))) (quote ()))))) (quote ())))) (quote ())))))) (#t V1712))) (quote shen.compile-macro))
(begin (register-function-arity (quote shen.prolog-macro) 1) (define (kl:shen.prolog-macro V1714) (cond ((and (pair? V1714) (eq? (quote prolog?) (car V1714))) (let ((F (kl:gensym (quote shen.f)))) (let ((Receive (kl:shen.receive-terms (cdr V1714)))) (let ((PrologDef (kl:eval (kl:append (cons (quote defprolog) (cons F (quote ()))) (kl:append Receive (kl:append (cons (quote <--) (quote ())) (kl:append (kl:shen.pass-literals (cdr V1714)) (cons (quote _waspvm_sc_) (quote ()))))))))) (let ((Query (cons F (kl:append Receive (cons (cons (quote shen.start-new-prolog-process) (quote ())) (cons (cons (quote freeze) (cons #t (quote ()))) (quote ()))))))) Query))))) (#t V1714))) (quote shen.prolog-macro))
(begin (register-function-arity (quote shen.receive-terms) 1) (define (kl:shen.receive-terms V1720) (cond ((null? V1720) (quote ())) ((and (pair? V1720) (and (pair? (car V1720)) (and (eq? (quote receive) (car (car V1720))) (and (pair? (cdr (car V1720))) (null? (cdr (cdr (car V1720)))))))) (cons (car (cdr (car V1720))) (kl:shen.receive-terms (cdr V1720)))) ((pair? V1720) (kl:shen.receive-terms (cdr V1720))) (#t (kl:shen.f_error (quote shen.receive-terms))))) (quote shen.receive-terms))
(begin (register-function-arity (quote shen.pass-literals) 1) (define (kl:shen.pass-literals V1724) (cond ((null? V1724) (quote ())) ((and (pair? V1724) (and (pair? (car V1724)) (and (eq? (quote receive) (car (car V1724))) (and (pair? (cdr (car V1724))) (null? (cdr (cdr (car V1724)))))))) (kl:shen.pass-literals (cdr V1724))) ((pair? V1724) (cons (car V1724) (kl:shen.pass-literals (cdr V1724)))) (#t (kl:shen.f_error (quote shen.pass-literals))))) (quote shen.pass-literals))
(begin (register-function-arity (quote shen.defprolog-macro) 1) (define (kl:shen.defprolog-macro V1726) (cond ((and (pair? V1726) (and (eq? (quote defprolog) (car V1726)) (pair? (cdr V1726)))) (kl:compile (lambda (Y) (kl:shen.<defprolog> Y)) (cdr V1726) (lambda (Y) (kl:shen.prolog-error (car (cdr V1726)) Y)))) (#t V1726))) (quote shen.defprolog-macro))
(begin (register-function-arity (quote shen.datatype-macro) 1) (define (kl:shen.datatype-macro V1728) (cond ((and (pair? V1728) (and (eq? (quote datatype) (car V1728)) (pair? (cdr V1728)))) (cons (quote shen.process-datatype) (cons (kl:shen.intern-type (car (cdr V1728))) (cons (cons (quote compile) (cons (cons (quote lambda) (cons (quote X) (cons (cons (quote shen.<datatype-rules>) (cons (quote X) (quote ()))) (quote ())))) (cons (kl:shen.rcons_form (cdr (cdr V1728))) (cons (cons (quote function) (cons (quote shen.datatype-error) (quote ()))) (quote ()))))) (quote ()))))) (#t V1728))) (quote shen.datatype-macro))
(begin (register-function-arity (quote shen.intern-type) 1) (define (kl:shen.intern-type V1730) (kl:intern (string-append "type#" (kl:str V1730)))) (quote shen.intern-type))
(begin (register-function-arity (quote shen._waspvm_at_s-macro) 1) (define (kl:shen._waspvm_at_s-macro V1732) (cond ((and (pair? V1732) (and (eq? (quote _waspvm_at_s) (car V1732)) (and (pair? (cdr V1732)) (and (pair? (cdr (cdr V1732))) (pair? (cdr (cdr (cdr V1732)))))))) (cons (quote _waspvm_at_s) (cons (car (cdr V1732)) (cons (kl:shen._waspvm_at_s-macro (cons (quote _waspvm_at_s) (cdr (cdr V1732)))) (quote ()))))) ((and (pair? V1732) (and (eq? (quote _waspvm_at_s) (car V1732)) (and (pair? (cdr V1732)) (and (pair? (cdr (cdr V1732))) (and (null? (cdr (cdr (cdr V1732)))) (string? (car (cdr V1732)))))))) (let ((E (kl:explode (car (cdr V1732))))) (if (> (kl:length E) 1) (kl:shen._waspvm_at_s-macro (cons (quote _waspvm_at_s) (kl:append E (cdr (cdr V1732))))) V1732))) (#t V1732))) (quote shen._waspvm_at_s-macro))
(begin (register-function-arity (quote shen.synonyms-macro) 1) (define (kl:shen.synonyms-macro V1734) (cond ((and (pair? V1734) (eq? (quote synonyms) (car V1734))) (cons (quote shen.synonyms-help) (cons (kl:shen.rcons_form (kl:shen.curry-synonyms (cdr V1734))) (quote ())))) (#t V1734))) (quote shen.synonyms-macro))
(begin (register-function-arity (quote shen.curry-synonyms) 1) (define (kl:shen.curry-synonyms V1736) (kl:map (lambda (X) (kl:shen.curry-type X)) V1736)) (quote shen.curry-synonyms))
(begin (register-function-arity (quote shen.nl-macro) 1) (define (kl:shen.nl-macro V1738) (cond ((and (pair? V1738) (and (eq? (quote nl) (car V1738)) (null? (cdr V1738)))) (cons (quote nl) (cons 1 (quote ())))) (#t V1738))) (quote shen.nl-macro))
(begin (register-function-arity (quote shen.assoc-macro) 1) (define (kl:shen.assoc-macro V1740) (cond ((and (pair? V1740) (and (pair? (cdr V1740)) (and (pair? (cdr (cdr V1740))) (and (pair? (cdr (cdr (cdr V1740)))) (kl:element? (car V1740) (cons (quote _waspvm_at_p) (cons (quote _waspvm_at_v) (cons (quote append) (cons (quote and) (cons (quote or) (cons (quote +) (cons (quote *) (cons (quote do) (quote ())))))))))))))) (cons (car V1740) (cons (car (cdr V1740)) (cons (kl:shen.assoc-macro (cons (car V1740) (cdr (cdr V1740)))) (quote ()))))) (#t V1740))) (quote shen.assoc-macro))
(begin (register-function-arity (quote shen.let-macro) 1) (define (kl:shen.let-macro V1742) (cond ((and (pair? V1742) (and (eq? (quote let) (car V1742)) (and (pair? (cdr V1742)) (and (pair? (cdr (cdr V1742))) (and (pair? (cdr (cdr (cdr V1742)))) (pair? (cdr (cdr (cdr (cdr V1742)))))))))) (cons (quote let) (cons (car (cdr V1742)) (cons (car (cdr (cdr V1742))) (cons (kl:shen.let-macro (cons (quote let) (cdr (cdr (cdr V1742))))) (quote ())))))) (#t V1742))) (quote shen.let-macro))
(begin (register-function-arity (quote shen.abs-macro) 1) (define (kl:shen.abs-macro V1744) (cond ((and (pair? V1744) (and (eq? (quote /.) (car V1744)) (and (pair? (cdr V1744)) (and (pair? (cdr (cdr V1744))) (pair? (cdr (cdr (cdr V1744)))))))) (cons (quote lambda) (cons (car (cdr V1744)) (cons (kl:shen.abs-macro (cons (quote /.) (cdr (cdr V1744)))) (quote ()))))) ((and (pair? V1744) (and (eq? (quote /.) (car V1744)) (and (pair? (cdr V1744)) (and (pair? (cdr (cdr V1744))) (null? (cdr (cdr (cdr V1744)))))))) (cons (quote lambda) (cdr V1744))) (#t V1744))) (quote shen.abs-macro))
(begin (register-function-arity (quote shen.cases-macro) 1) (define (kl:shen.cases-macro V1748) (cond ((and (pair? V1748) (and (eq? (quote cases) (car V1748)) (and (pair? (cdr V1748)) (and (kl:= #t (car (cdr V1748))) (pair? (cdr (cdr V1748))))))) (car (cdr (cdr V1748)))) ((and (pair? V1748) (and (eq? (quote cases) (car V1748)) (and (pair? (cdr V1748)) (and (pair? (cdr (cdr V1748))) (null? (cdr (cdr (cdr V1748)))))))) (cons (quote if) (cons (car (cdr V1748)) (cons (car (cdr (cdr V1748))) (cons (cons (quote simple-error) (cons "error: cases exhausted" (quote ()))) (quote ())))))) ((and (pair? V1748) (and (eq? (quote cases) (car V1748)) (and (pair? (cdr V1748)) (pair? (cdr (cdr V1748)))))) (cons (quote if) (cons (car (cdr V1748)) (cons (car (cdr (cdr V1748))) (cons (kl:shen.cases-macro (cons (quote cases) (cdr (cdr (cdr V1748))))) (quote ())))))) ((and (pair? V1748) (and (eq? (quote cases) (car V1748)) (and (pair? (cdr V1748)) (null? (cdr (cdr V1748)))))) (simple-error "error: odd number of case elements\n")) (#t V1748))) (quote shen.cases-macro))
(begin (register-function-arity (quote shen.timer-macro) 1) (define (kl:shen.timer-macro V1750) (cond ((and (pair? V1750) (and (eq? (quote time) (car V1750)) (and (pair? (cdr V1750)) (null? (cdr (cdr V1750)))))) (kl:shen.let-macro (cons (quote let) (cons (quote Start) (cons (cons (quote get-time) (cons (quote run) (quote ()))) (cons (quote Result) (cons (car (cdr V1750)) (cons (quote Finish) (cons (cons (quote get-time) (cons (quote run) (quote ()))) (cons (quote Time) (cons (cons (quote -) (cons (quote Finish) (cons (quote Start) (quote ())))) (cons (quote Message) (cons (cons (quote shen.prhush) (cons (cons (quote cn) (cons "\nrun time: " (cons (cons (quote cn) (cons (cons (quote str) (cons (quote Time) (quote ()))) (cons " secs\n" (quote ())))) (quote ())))) (cons (cons (quote stoutput) (quote ())) (quote ())))) (cons (quote Result) (quote ()))))))))))))))) (#t V1750))) (quote shen.timer-macro))
(begin (register-function-arity (quote shen.tuple-up) 1) (define (kl:shen.tuple-up V1752) (cond ((pair? V1752) (cons (quote _waspvm_at_p) (cons (car V1752) (cons (kl:shen.tuple-up (cdr V1752)) (quote ()))))) (#t V1752))) (quote shen.tuple-up))
(begin (register-function-arity (quote shen.put/get-macro) 1) (define (kl:shen.put/get-macro V1754) (cond ((and (pair? V1754) (and (eq? (quote put) (car V1754)) (and (pair? (cdr V1754)) (and (pair? (cdr (cdr V1754))) (and (pair? (cdr (cdr (cdr V1754)))) (null? (cdr (cdr (cdr (cdr V1754)))))))))) (cons (quote put) (cons (car (cdr V1754)) (cons (car (cdr (cdr V1754))) (cons (car (cdr (cdr (cdr V1754)))) (cons (cons (quote value) (cons (quote *property-vector*) (quote ()))) (quote ()))))))) ((and (pair? V1754) (and (eq? (quote get) (car V1754)) (and (pair? (cdr V1754)) (and (pair? (cdr (cdr V1754))) (null? (cdr (cdr (cdr V1754)))))))) (cons (quote get) (cons (car (cdr V1754)) (cons (car (cdr (cdr V1754))) (cons (cons (quote value) (cons (quote *property-vector*) (quote ()))) (quote ())))))) ((and (pair? V1754) (and (eq? (quote get/or) (car V1754)) (and (pair? (cdr V1754)) (and (pair? (cdr (cdr V1754))) (and (pair? (cdr (cdr (cdr V1754)))) (null? (cdr (cdr (cdr (cdr V1754)))))))))) (cons (quote get/or) (cons (car (cdr V1754)) (cons (car (cdr (cdr V1754))) (cons (car (cdr (cdr (cdr V1754)))) (cons (cons (quote value) (cons (quote *property-vector*) (quote ()))) (quote ()))))))) ((and (pair? V1754) (and (eq? (quote unput) (car V1754)) (and (pair? (cdr V1754)) (and (pair? (cdr (cdr V1754))) (null? (cdr (cdr (cdr V1754)))))))) (cons (quote unput) (cons (car (cdr V1754)) (cons (car (cdr (cdr V1754))) (cons (cons (quote value) (cons (quote *property-vector*) (quote ()))) (quote ())))))) (#t V1754))) (quote shen.put/get-macro))
(begin (register-function-arity (quote shen.function-macro) 1) (define (kl:shen.function-macro V1756) (cond ((and (pair? V1756) (and (eq? (quote function) (car V1756)) (and (pair? (cdr V1756)) (null? (cdr (cdr V1756)))))) (kl:shen.function-abstraction (car (cdr V1756)) (kl:arity (car (cdr V1756))))) (#t V1756))) (quote shen.function-macro))
(begin (register-function-arity (quote shen.function-abstraction) 2) (define (kl:shen.function-abstraction V1759 V1760) (cond ((kl:= 0 V1760) (simple-error (kl:shen.app V1759 " has no lambda form\n" (quote shen.a)))) ((kl:= -1 V1760) (cons (quote function) (cons V1759 (quote ())))) (#t (kl:shen.function-abstraction-help V1759 V1760 (quote ()))))) (quote shen.function-abstraction))
(begin (register-function-arity (quote shen.function-abstraction-help) 3) (define (kl:shen.function-abstraction-help V1764 V1765 V1766) (cond ((kl:= 0 V1765) (cons V1764 V1766)) (#t (let ((X (kl:gensym (quote V)))) (cons (quote /.) (cons X (cons (kl:shen.function-abstraction-help V1764 (- V1765 1) (kl:append V1766 (cons X (quote ())))) (quote ())))))))) (quote shen.function-abstraction-help))
(begin (register-function-arity (quote undefmacro) 1) (define (kl:undefmacro V1768) (let ((MacroReg (kl:value (quote shen.*macroreg*)))) (let ((Pos (kl:shen.findpos V1768 MacroReg))) (let ((Remove1 (kl:set (quote shen.*macroreg*) (kl:remove V1768 MacroReg)))) (let ((Remove2 (kl:set (quote *macros*) (kl:shen.remove-nth Pos (kl:value (quote *macros*)))))) V1768))))) (quote undefmacro))
(begin (register-function-arity (quote shen.findpos) 2) (define (kl:shen.findpos V1778 V1779) (cond ((null? V1779) (simple-error (kl:shen.app V1778 " is not a macro\n" (quote shen.a)))) ((and (pair? V1779) (kl:= (car V1779) V1778)) 1) ((pair? V1779) (+ 1 (kl:shen.findpos V1778 (cdr V1779)))) (#t (kl:shen.f_error (quote shen.findpos))))) (quote shen.findpos))
(begin (register-function-arity (quote shen.remove-nth) 2) (define (kl:shen.remove-nth V1784 V1785) (cond ((and (kl:= 1 V1784) (pair? V1785)) (cdr V1785)) ((pair? V1785) (cons (car V1785) (kl:shen.remove-nth (- V1784 1) (cdr V1785)))) (#t (kl:shen.f_error (quote shen.remove-nth))))) (quote shen.remove-nth))
