"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote macroexpand) 1) (define (kl:macroexpand V1529) (let ((Y (kl:shen.compose (kl:value (quote *macros*)) V1529))) (if (kl:= V1529 Y) V1529 (kl:shen.walk (lambda (Z) (kl:macroexpand Z)) Y)))) (quote macroexpand))
(begin (register-function-arity (quote shen.error-macro) 1) (define (kl:shen.error-macro V1531) (cond ((and (pair? V1531) (and (eq? (quote error) (car V1531)) (pair? (cdr V1531)))) (cons (quote simple-error) (cons (kl:shen.mkstr (car (cdr V1531)) (cdr (cdr V1531))) (quote ())))) (#t V1531))) (quote shen.error-macro))
(begin (register-function-arity (quote shen.output-macro) 1) (define (kl:shen.output-macro V1533) (cond ((and (pair? V1533) (and (eq? (quote output) (car V1533)) (pair? (cdr V1533)))) (cons (quote shen.prhush) (cons (kl:shen.mkstr (car (cdr V1533)) (cdr (cdr V1533))) (cons (cons (quote stoutput) (quote ())) (quote ()))))) ((and (pair? V1533) (and (eq? (quote pr) (car V1533)) (and (pair? (cdr V1533)) (null? (cdr (cdr V1533)))))) (cons (quote pr) (cons (car (cdr V1533)) (cons (cons (quote stoutput) (quote ())) (quote ()))))) (#t V1533))) (quote shen.output-macro))
(begin (register-function-arity (quote shen.make-string-macro) 1) (define (kl:shen.make-string-macro V1535) (cond ((and (pair? V1535) (and (eq? (quote make-string) (car V1535)) (pair? (cdr V1535)))) (kl:shen.mkstr (car (cdr V1535)) (cdr (cdr V1535)))) (#t V1535))) (quote shen.make-string-macro))
(begin (register-function-arity (quote shen.input-macro) 1) (define (kl:shen.input-macro V1537) (cond ((and (pair? V1537) (and (eq? (quote lineread) (car V1537)) (null? (cdr V1537)))) (cons (quote lineread) (cons (cons (quote stinput) (quote ())) (quote ())))) ((and (pair? V1537) (and (eq? (quote input) (car V1537)) (null? (cdr V1537)))) (cons (quote input) (cons (cons (quote stinput) (quote ())) (quote ())))) ((and (pair? V1537) (and (eq? (quote read) (car V1537)) (null? (cdr V1537)))) (cons (quote read) (cons (cons (quote stinput) (quote ())) (quote ())))) ((and (pair? V1537) (and (eq? (quote input+) (car V1537)) (and (pair? (cdr V1537)) (null? (cdr (cdr V1537)))))) (cons (quote input+) (cons (car (cdr V1537)) (cons (cons (quote stinput) (quote ())) (quote ()))))) ((and (pair? V1537) (and (eq? (quote read-byte) (car V1537)) (null? (cdr V1537)))) (cons (quote read-byte) (cons (cons (quote stinput) (quote ())) (quote ())))) ((and (pair? V1537) (and (eq? (quote read-char-code) (car V1537)) (null? (cdr V1537)))) (cons (quote read-char-code) (cons (cons (quote stinput) (quote ())) (quote ())))) (#t V1537))) (quote shen.input-macro))
(begin (register-function-arity (quote shen.compose) 2) (define (kl:shen.compose V1540 V1541) (cond ((null? V1540) V1541) ((pair? V1540) (kl:shen.compose (cdr V1540) ((car V1540) V1541))) (#t (kl:shen.f_error (quote shen.compose))))) (quote shen.compose))
(begin (register-function-arity (quote shen.compile-macro) 1) (define (kl:shen.compile-macro V1543) (cond ((and (pair? V1543) (and (eq? (quote compile) (car V1543)) (and (pair? (cdr V1543)) (and (pair? (cdr (cdr V1543))) (null? (cdr (cdr (cdr V1543)))))))) (cons (quote compile) (cons (car (cdr V1543)) (cons (car (cdr (cdr V1543))) (cons (cons (quote lambda) (cons (quote E) (cons (cons (quote if) (cons (cons (quote cons?) (cons (quote E) (quote ()))) (cons (cons (quote error) (cons "parse error here: ~S~%" (cons (quote E) (quote ())))) (cons (cons (quote error) (cons "parse error~%" (quote ()))) (quote ()))))) (quote ())))) (quote ())))))) (#t V1543))) (quote shen.compile-macro))
(begin (register-function-arity (quote shen.prolog-macro) 1) (define (kl:shen.prolog-macro V1545) (cond ((and (pair? V1545) (eq? (quote prolog?) (car V1545))) (let ((F (kl:gensym (quote shen.f)))) (let ((Receive (kl:shen.receive-terms (cdr V1545)))) (let ((PrologDef (kl:eval (kl:append (cons (quote defprolog) (cons F (quote ()))) (kl:append Receive (kl:append (cons (quote <--) (quote ())) (kl:append (kl:shen.pass-literals (cdr V1545)) (cons (quote _waspvm_sc_) (quote ()))))))))) (let ((Query (cons F (kl:append Receive (cons (cons (quote shen.start-new-prolog-process) (quote ())) (cons (cons (quote freeze) (cons #t (quote ()))) (quote ()))))))) Query))))) (#t V1545))) (quote shen.prolog-macro))
(begin (register-function-arity (quote shen.receive-terms) 1) (define (kl:shen.receive-terms V1551) (cond ((null? V1551) (quote ())) ((and (pair? V1551) (and (pair? (car V1551)) (and (eq? (quote receive) (car (car V1551))) (and (pair? (cdr (car V1551))) (null? (cdr (cdr (car V1551)))))))) (cons (car (cdr (car V1551))) (kl:shen.receive-terms (cdr V1551)))) ((pair? V1551) (kl:shen.receive-terms (cdr V1551))) (#t (kl:shen.f_error (quote shen.receive-terms))))) (quote shen.receive-terms))
(begin (register-function-arity (quote shen.pass-literals) 1) (define (kl:shen.pass-literals V1555) (cond ((null? V1555) (quote ())) ((and (pair? V1555) (and (pair? (car V1555)) (and (eq? (quote receive) (car (car V1555))) (and (pair? (cdr (car V1555))) (null? (cdr (cdr (car V1555)))))))) (kl:shen.pass-literals (cdr V1555))) ((pair? V1555) (cons (car V1555) (kl:shen.pass-literals (cdr V1555)))) (#t (kl:shen.f_error (quote shen.pass-literals))))) (quote shen.pass-literals))
(begin (register-function-arity (quote shen.defprolog-macro) 1) (define (kl:shen.defprolog-macro V1557) (cond ((and (pair? V1557) (and (eq? (quote defprolog) (car V1557)) (pair? (cdr V1557)))) (kl:compile (lambda (Y) (kl:shen.<defprolog> Y)) (cdr V1557) (lambda (Y) (kl:shen.prolog-error (car (cdr V1557)) Y)))) (#t V1557))) (quote shen.defprolog-macro))
(begin (register-function-arity (quote shen.datatype-macro) 1) (define (kl:shen.datatype-macro V1559) (cond ((and (pair? V1559) (and (eq? (quote datatype) (car V1559)) (pair? (cdr V1559)))) (cons (quote shen.process-datatype) (cons (kl:shen.intern-type (car (cdr V1559))) (cons (cons (quote compile) (cons (cons (quote lambda) (cons (quote X) (cons (cons (quote shen.<datatype-rules>) (cons (quote X) (quote ()))) (quote ())))) (cons (kl:shen.rcons_form (cdr (cdr V1559))) (cons (cons (quote function) (cons (quote shen.datatype-error) (quote ()))) (quote ()))))) (quote ()))))) (#t V1559))) (quote shen.datatype-macro))
(begin (register-function-arity (quote shen.intern-type) 1) (define (kl:shen.intern-type V1561) (kl:intern (string-append "type#" (kl:str V1561)))) (quote shen.intern-type))
(begin (register-function-arity (quote shen._waspvm_at_s-macro) 1) (define (kl:shen._waspvm_at_s-macro V1563) (cond ((and (pair? V1563) (and (eq? (quote _waspvm_at_s) (car V1563)) (and (pair? (cdr V1563)) (and (pair? (cdr (cdr V1563))) (pair? (cdr (cdr (cdr V1563)))))))) (cons (quote _waspvm_at_s) (cons (car (cdr V1563)) (cons (kl:shen._waspvm_at_s-macro (cons (quote _waspvm_at_s) (cdr (cdr V1563)))) (quote ()))))) ((and (pair? V1563) (and (eq? (quote _waspvm_at_s) (car V1563)) (and (pair? (cdr V1563)) (and (pair? (cdr (cdr V1563))) (and (null? (cdr (cdr (cdr V1563)))) (string? (car (cdr V1563)))))))) (let ((E (kl:explode (car (cdr V1563))))) (if (> (kl:length E) 1) (kl:shen._waspvm_at_s-macro (cons (quote _waspvm_at_s) (kl:append E (cdr (cdr V1563))))) V1563))) (#t V1563))) (quote shen._waspvm_at_s-macro))
(begin (register-function-arity (quote shen.synonyms-macro) 1) (define (kl:shen.synonyms-macro V1565) (cond ((and (pair? V1565) (eq? (quote synonyms) (car V1565))) (cons (quote shen.synonyms-help) (cons (kl:shen.rcons_form (kl:shen.curry-synonyms (cdr V1565))) (quote ())))) (#t V1565))) (quote shen.synonyms-macro))
(begin (register-function-arity (quote shen.curry-synonyms) 1) (define (kl:shen.curry-synonyms V1567) (kl:map (lambda (X) (kl:shen.curry-type X)) V1567)) (quote shen.curry-synonyms))
(begin (register-function-arity (quote shen.nl-macro) 1) (define (kl:shen.nl-macro V1569) (cond ((and (pair? V1569) (and (eq? (quote nl) (car V1569)) (null? (cdr V1569)))) (cons (quote nl) (cons 1 (quote ())))) (#t V1569))) (quote shen.nl-macro))
(begin (register-function-arity (quote shen.assoc-macro) 1) (define (kl:shen.assoc-macro V1571) (cond ((and (pair? V1571) (and (pair? (cdr V1571)) (and (pair? (cdr (cdr V1571))) (and (pair? (cdr (cdr (cdr V1571)))) (kl:element? (car V1571) (cons (quote _waspvm_at_p) (cons (quote _waspvm_at_v) (cons (quote append) (cons (quote and) (cons (quote or) (cons (quote +) (cons (quote *) (cons (quote do) (quote ())))))))))))))) (cons (car V1571) (cons (car (cdr V1571)) (cons (kl:shen.assoc-macro (cons (car V1571) (cdr (cdr V1571)))) (quote ()))))) (#t V1571))) (quote shen.assoc-macro))
(begin (register-function-arity (quote shen.let-macro) 1) (define (kl:shen.let-macro V1573) (cond ((and (pair? V1573) (and (eq? (quote let) (car V1573)) (and (pair? (cdr V1573)) (and (pair? (cdr (cdr V1573))) (and (pair? (cdr (cdr (cdr V1573)))) (pair? (cdr (cdr (cdr (cdr V1573)))))))))) (cons (quote let) (cons (car (cdr V1573)) (cons (car (cdr (cdr V1573))) (cons (kl:shen.let-macro (cons (quote let) (cdr (cdr (cdr V1573))))) (quote ())))))) (#t V1573))) (quote shen.let-macro))
(begin (register-function-arity (quote shen.abs-macro) 1) (define (kl:shen.abs-macro V1575) (cond ((and (pair? V1575) (and (eq? (quote /.) (car V1575)) (and (pair? (cdr V1575)) (and (pair? (cdr (cdr V1575))) (pair? (cdr (cdr (cdr V1575)))))))) (cons (quote lambda) (cons (car (cdr V1575)) (cons (kl:shen.abs-macro (cons (quote /.) (cdr (cdr V1575)))) (quote ()))))) ((and (pair? V1575) (and (eq? (quote /.) (car V1575)) (and (pair? (cdr V1575)) (and (pair? (cdr (cdr V1575))) (null? (cdr (cdr (cdr V1575)))))))) (cons (quote lambda) (cdr V1575))) (#t V1575))) (quote shen.abs-macro))
(begin (register-function-arity (quote shen.cases-macro) 1) (define (kl:shen.cases-macro V1579) (cond ((and (pair? V1579) (and (eq? (quote cases) (car V1579)) (and (pair? (cdr V1579)) (and (kl:= #t (car (cdr V1579))) (pair? (cdr (cdr V1579))))))) (car (cdr (cdr V1579)))) ((and (pair? V1579) (and (eq? (quote cases) (car V1579)) (and (pair? (cdr V1579)) (and (pair? (cdr (cdr V1579))) (null? (cdr (cdr (cdr V1579)))))))) (cons (quote if) (cons (car (cdr V1579)) (cons (car (cdr (cdr V1579))) (cons (cons (quote simple-error) (cons "error: cases exhausted" (quote ()))) (quote ())))))) ((and (pair? V1579) (and (eq? (quote cases) (car V1579)) (and (pair? (cdr V1579)) (pair? (cdr (cdr V1579)))))) (cons (quote if) (cons (car (cdr V1579)) (cons (car (cdr (cdr V1579))) (cons (kl:shen.cases-macro (cons (quote cases) (cdr (cdr (cdr V1579))))) (quote ())))))) ((and (pair? V1579) (and (eq? (quote cases) (car V1579)) (and (pair? (cdr V1579)) (null? (cdr (cdr V1579)))))) (simple-error "error: odd number of case elements\n")) (#t V1579))) (quote shen.cases-macro))
(begin (register-function-arity (quote shen.timer-macro) 1) (define (kl:shen.timer-macro V1581) (cond ((and (pair? V1581) (and (eq? (quote time) (car V1581)) (and (pair? (cdr V1581)) (null? (cdr (cdr V1581)))))) (kl:shen.let-macro (cons (quote let) (cons (quote Start) (cons (cons (quote get-time) (cons (quote run) (quote ()))) (cons (quote Result) (cons (car (cdr V1581)) (cons (quote Finish) (cons (cons (quote get-time) (cons (quote run) (quote ()))) (cons (quote Time) (cons (cons (quote -) (cons (quote Finish) (cons (quote Start) (quote ())))) (cons (quote Message) (cons (cons (quote shen.prhush) (cons (cons (quote cn) (cons "\nrun time: " (cons (cons (quote cn) (cons (cons (quote str) (cons (quote Time) (quote ()))) (cons " secs\n" (quote ())))) (quote ())))) (cons (cons (quote stoutput) (quote ())) (quote ())))) (cons (quote Result) (quote ()))))))))))))))) (#t V1581))) (quote shen.timer-macro))
(begin (register-function-arity (quote shen.tuple-up) 1) (define (kl:shen.tuple-up V1583) (cond ((pair? V1583) (cons (quote _waspvm_at_p) (cons (car V1583) (cons (kl:shen.tuple-up (cdr V1583)) (quote ()))))) (#t V1583))) (quote shen.tuple-up))
(begin (register-function-arity (quote shen.put/get-macro) 1) (define (kl:shen.put/get-macro V1585) (cond ((and (pair? V1585) (and (eq? (quote put) (car V1585)) (and (pair? (cdr V1585)) (and (pair? (cdr (cdr V1585))) (and (pair? (cdr (cdr (cdr V1585)))) (null? (cdr (cdr (cdr (cdr V1585)))))))))) (cons (quote put) (cons (car (cdr V1585)) (cons (car (cdr (cdr V1585))) (cons (car (cdr (cdr (cdr V1585)))) (cons (cons (quote value) (cons (quote *property-vector*) (quote ()))) (quote ()))))))) ((and (pair? V1585) (and (eq? (quote get) (car V1585)) (and (pair? (cdr V1585)) (and (pair? (cdr (cdr V1585))) (null? (cdr (cdr (cdr V1585)))))))) (cons (quote get) (cons (car (cdr V1585)) (cons (car (cdr (cdr V1585))) (cons (cons (quote value) (cons (quote *property-vector*) (quote ()))) (quote ())))))) ((and (pair? V1585) (and (eq? (quote get/or) (car V1585)) (and (pair? (cdr V1585)) (and (pair? (cdr (cdr V1585))) (and (pair? (cdr (cdr (cdr V1585)))) (null? (cdr (cdr (cdr (cdr V1585)))))))))) (cons (quote get/or) (cons (car (cdr V1585)) (cons (car (cdr (cdr V1585))) (cons (car (cdr (cdr (cdr V1585)))) (cons (cons (quote value) (cons (quote *property-vector*) (quote ()))) (quote ()))))))) ((and (pair? V1585) (and (eq? (quote unput) (car V1585)) (and (pair? (cdr V1585)) (and (pair? (cdr (cdr V1585))) (null? (cdr (cdr (cdr V1585)))))))) (cons (quote unput) (cons (car (cdr V1585)) (cons (car (cdr (cdr V1585))) (cons (cons (quote value) (cons (quote *property-vector*) (quote ()))) (quote ())))))) (#t V1585))) (quote shen.put/get-macro))
(begin (register-function-arity (quote shen.function-macro) 1) (define (kl:shen.function-macro V1587) (cond ((and (pair? V1587) (and (eq? (quote function) (car V1587)) (and (pair? (cdr V1587)) (null? (cdr (cdr V1587)))))) (kl:shen.function-abstraction (car (cdr V1587)) (kl:arity (car (cdr V1587))))) (#t V1587))) (quote shen.function-macro))
(begin (register-function-arity (quote shen.function-abstraction) 2) (define (kl:shen.function-abstraction V1590 V1591) (cond ((kl:= 0 V1591) (simple-error (kl:shen.app V1590 " has no lambda form\n" (quote shen.a)))) ((kl:= -1 V1591) (cons (quote function) (cons V1590 (quote ())))) (#t (kl:shen.function-abstraction-help V1590 V1591 (quote ()))))) (quote shen.function-abstraction))
(begin (register-function-arity (quote shen.function-abstraction-help) 3) (define (kl:shen.function-abstraction-help V1595 V1596 V1597) (cond ((kl:= 0 V1596) (cons V1595 V1597)) (#t (let ((X (kl:gensym (quote V)))) (cons (quote /.) (cons X (cons (kl:shen.function-abstraction-help V1595 (- V1596 1) (kl:append V1597 (cons X (quote ())))) (quote ())))))))) (quote shen.function-abstraction-help))
(begin (register-function-arity (quote undefmacro) 1) (define (kl:undefmacro V1599) (let ((MacroReg (kl:value (quote shen.*macroreg*)))) (let ((Pos (kl:shen.findpos V1599 MacroReg))) (let ((Remove1 (kl:set (quote shen.*macroreg*) (kl:remove V1599 MacroReg)))) (let ((Remove2 (kl:set (quote *macros*) (kl:shen.remove-nth Pos (kl:value (quote *macros*)))))) V1599))))) (quote undefmacro))
(begin (register-function-arity (quote shen.findpos) 2) (define (kl:shen.findpos V1609 V1610) (cond ((null? V1610) (simple-error (kl:shen.app V1609 " is not a macro\n" (quote shen.a)))) ((and (pair? V1610) (kl:= (car V1610) V1609)) 1) ((pair? V1610) (+ 1 (kl:shen.findpos V1609 (cdr V1610)))) (#t (kl:shen.f_error (quote shen.findpos))))) (quote shen.findpos))
(begin (register-function-arity (quote shen.remove-nth) 2) (define (kl:shen.remove-nth V1615 V1616) (cond ((and (kl:= 1 V1615) (pair? V1616)) (cdr V1616)) ((pair? V1616) (cons (car V1616) (kl:shen.remove-nth (- V1615 1) (cdr V1616)))) (#t (kl:shen.f_error (quote shen.remove-nth))))) (quote shen.remove-nth))
