"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote macroexpand) 1) (define (kl:macroexpand V1536) (let ((Y (kl:shen.compose (kl:value (quote *macros*)) V1536))) (if (kl:= V1536 Y) V1536 (kl:shen.walk (lambda (Z) (kl:macroexpand Z)) Y)))) (quote macroexpand))
(begin (register-function-arity (quote shen.error-macro) 1) (define (kl:shen.error-macro V1538) (cond ((and (pair? V1538) (and (eq? (quote error) (car V1538)) (pair? (cdr V1538)))) (cons (quote simple-error) (cons (kl:shen.mkstr (car (cdr V1538)) (cdr (cdr V1538))) (quote ())))) (#t V1538))) (quote shen.error-macro))
(begin (register-function-arity (quote shen.output-macro) 1) (define (kl:shen.output-macro V1540) (cond ((and (pair? V1540) (and (eq? (quote output) (car V1540)) (pair? (cdr V1540)))) (cons (quote shen.prhush) (cons (kl:shen.mkstr (car (cdr V1540)) (cdr (cdr V1540))) (cons (cons (quote stoutput) (quote ())) (quote ()))))) ((and (pair? V1540) (and (eq? (quote pr) (car V1540)) (and (pair? (cdr V1540)) (null? (cdr (cdr V1540)))))) (cons (quote pr) (cons (car (cdr V1540)) (cons (cons (quote stoutput) (quote ())) (quote ()))))) (#t V1540))) (quote shen.output-macro))
(begin (register-function-arity (quote shen.make-string-macro) 1) (define (kl:shen.make-string-macro V1542) (cond ((and (pair? V1542) (and (eq? (quote make-string) (car V1542)) (pair? (cdr V1542)))) (kl:shen.mkstr (car (cdr V1542)) (cdr (cdr V1542)))) (#t V1542))) (quote shen.make-string-macro))
(begin (register-function-arity (quote shen.input-macro) 1) (define (kl:shen.input-macro V1544) (cond ((and (pair? V1544) (and (eq? (quote lineread) (car V1544)) (null? (cdr V1544)))) (cons (quote lineread) (cons (cons (quote stinput) (quote ())) (quote ())))) ((and (pair? V1544) (and (eq? (quote input) (car V1544)) (null? (cdr V1544)))) (cons (quote input) (cons (cons (quote stinput) (quote ())) (quote ())))) ((and (pair? V1544) (and (eq? (quote read) (car V1544)) (null? (cdr V1544)))) (cons (quote read) (cons (cons (quote stinput) (quote ())) (quote ())))) ((and (pair? V1544) (and (eq? (quote input+) (car V1544)) (and (pair? (cdr V1544)) (null? (cdr (cdr V1544)))))) (cons (quote input+) (cons (car (cdr V1544)) (cons (cons (quote stinput) (quote ())) (quote ()))))) ((and (pair? V1544) (and (eq? (quote read-byte) (car V1544)) (null? (cdr V1544)))) (cons (quote read-byte) (cons (cons (quote stinput) (quote ())) (quote ())))) (#t V1544))) (quote shen.input-macro))
(begin (register-function-arity (quote shen.compose) 2) (define (kl:shen.compose V1547 V1548) (cond ((null? V1547) V1548) ((pair? V1547) (kl:shen.compose (cdr V1547) ((car V1547) V1548))) (#t (kl:shen.f_error (quote shen.compose))))) (quote shen.compose))
(begin (register-function-arity (quote shen.compile-macro) 1) (define (kl:shen.compile-macro V1550) (cond ((and (pair? V1550) (and (eq? (quote compile) (car V1550)) (and (pair? (cdr V1550)) (and (pair? (cdr (cdr V1550))) (null? (cdr (cdr (cdr V1550)))))))) (cons (quote compile) (cons (car (cdr V1550)) (cons (car (cdr (cdr V1550))) (cons (cons (quote lambda) (cons (quote E) (cons (cons (quote if) (cons (cons (quote cons?) (cons (quote E) (quote ()))) (cons (cons (quote error) (cons "parse error here: ~S~%" (cons (quote E) (quote ())))) (cons (cons (quote error) (cons "parse error~%" (quote ()))) (quote ()))))) (quote ())))) (quote ())))))) (#t V1550))) (quote shen.compile-macro))
(begin (register-function-arity (quote shen.prolog-macro) 1) (define (kl:shen.prolog-macro V1552) (cond ((and (pair? V1552) (eq? (quote prolog?) (car V1552))) (let ((F (kl:gensym (quote shen.f)))) (let ((Receive (kl:shen.receive-terms (cdr V1552)))) (let ((PrologDef (kl:eval (kl:append (cons (quote defprolog) (cons F (quote ()))) (kl:append Receive (kl:append (cons (quote <--) (quote ())) (kl:append (kl:shen.pass-literals (cdr V1552)) (cons (quote _waspvm_sc_) (quote ()))))))))) (let ((Query (cons F (kl:append Receive (cons (cons (quote shen.start-new-prolog-process) (quote ())) (cons (cons (quote freeze) (cons #t (quote ()))) (quote ()))))))) Query))))) (#t V1552))) (quote shen.prolog-macro))
(begin (register-function-arity (quote shen.receive-terms) 1) (define (kl:shen.receive-terms V1558) (cond ((null? V1558) (quote ())) ((and (pair? V1558) (and (pair? (car V1558)) (and (eq? (quote receive) (car (car V1558))) (and (pair? (cdr (car V1558))) (null? (cdr (cdr (car V1558)))))))) (cons (car (cdr (car V1558))) (kl:shen.receive-terms (cdr V1558)))) ((pair? V1558) (kl:shen.receive-terms (cdr V1558))) (#t (kl:shen.f_error (quote shen.receive-terms))))) (quote shen.receive-terms))
(begin (register-function-arity (quote shen.pass-literals) 1) (define (kl:shen.pass-literals V1562) (cond ((null? V1562) (quote ())) ((and (pair? V1562) (and (pair? (car V1562)) (and (eq? (quote receive) (car (car V1562))) (and (pair? (cdr (car V1562))) (null? (cdr (cdr (car V1562)))))))) (kl:shen.pass-literals (cdr V1562))) ((pair? V1562) (cons (car V1562) (kl:shen.pass-literals (cdr V1562)))) (#t (kl:shen.f_error (quote shen.pass-literals))))) (quote shen.pass-literals))
(begin (register-function-arity (quote shen.defprolog-macro) 1) (define (kl:shen.defprolog-macro V1564) (cond ((and (pair? V1564) (and (eq? (quote defprolog) (car V1564)) (pair? (cdr V1564)))) (kl:compile (lambda (Y) (kl:shen.<defprolog> Y)) (cdr V1564) (lambda (Y) (kl:shen.prolog-error (car (cdr V1564)) Y)))) (#t V1564))) (quote shen.defprolog-macro))
(begin (register-function-arity (quote shen.datatype-macro) 1) (define (kl:shen.datatype-macro V1566) (cond ((and (pair? V1566) (and (eq? (quote datatype) (car V1566)) (pair? (cdr V1566)))) (cons (quote shen.process-datatype) (cons (kl:shen.intern-type (car (cdr V1566))) (cons (cons (quote compile) (cons (cons (quote lambda) (cons (quote X) (cons (cons (quote shen.<datatype-rules>) (cons (quote X) (quote ()))) (quote ())))) (cons (kl:shen.rcons_form (cdr (cdr V1566))) (cons (cons (quote function) (cons (quote shen.datatype-error) (quote ()))) (quote ()))))) (quote ()))))) (#t V1566))) (quote shen.datatype-macro))
(begin (register-function-arity (quote shen.intern-type) 1) (define (kl:shen.intern-type V1568) (kl:intern (string-append "type#" (kl:str V1568)))) (quote shen.intern-type))
(begin (register-function-arity (quote shen._waspvm_at_s-macro) 1) (define (kl:shen._waspvm_at_s-macro V1570) (cond ((and (pair? V1570) (and (eq? (quote _waspvm_at_s) (car V1570)) (and (pair? (cdr V1570)) (and (pair? (cdr (cdr V1570))) (pair? (cdr (cdr (cdr V1570)))))))) (cons (quote _waspvm_at_s) (cons (car (cdr V1570)) (cons (kl:shen._waspvm_at_s-macro (cons (quote _waspvm_at_s) (cdr (cdr V1570)))) (quote ()))))) ((and (pair? V1570) (and (eq? (quote _waspvm_at_s) (car V1570)) (and (pair? (cdr V1570)) (and (pair? (cdr (cdr V1570))) (and (null? (cdr (cdr (cdr V1570)))) (string? (car (cdr V1570)))))))) (let ((E (kl:explode (car (cdr V1570))))) (if (> (kl:length E) 1) (kl:shen._waspvm_at_s-macro (cons (quote _waspvm_at_s) (kl:append E (cdr (cdr V1570))))) V1570))) (#t V1570))) (quote shen._waspvm_at_s-macro))
(begin (register-function-arity (quote shen.synonyms-macro) 1) (define (kl:shen.synonyms-macro V1572) (cond ((and (pair? V1572) (eq? (quote synonyms) (car V1572))) (cons (quote shen.synonyms-help) (cons (kl:shen.rcons_form (kl:shen.curry-synonyms (cdr V1572))) (quote ())))) (#t V1572))) (quote shen.synonyms-macro))
(begin (register-function-arity (quote shen.curry-synonyms) 1) (define (kl:shen.curry-synonyms V1574) (kl:map (lambda (X) (kl:shen.curry-type X)) V1574)) (quote shen.curry-synonyms))
(begin (register-function-arity (quote shen.nl-macro) 1) (define (kl:shen.nl-macro V1576) (cond ((and (pair? V1576) (and (eq? (quote nl) (car V1576)) (null? (cdr V1576)))) (cons (quote nl) (cons 1 (quote ())))) (#t V1576))) (quote shen.nl-macro))
(begin (register-function-arity (quote shen.assoc-macro) 1) (define (kl:shen.assoc-macro V1578) (cond ((and (pair? V1578) (and (pair? (cdr V1578)) (and (pair? (cdr (cdr V1578))) (and (pair? (cdr (cdr (cdr V1578)))) (kl:element? (car V1578) (cons (quote _waspvm_at_p) (cons (quote _waspvm_at_v) (cons (quote append) (cons (quote and) (cons (quote or) (cons (quote +) (cons (quote *) (cons (quote do) (quote ())))))))))))))) (cons (car V1578) (cons (car (cdr V1578)) (cons (kl:shen.assoc-macro (cons (car V1578) (cdr (cdr V1578)))) (quote ()))))) (#t V1578))) (quote shen.assoc-macro))
(begin (register-function-arity (quote shen.let-macro) 1) (define (kl:shen.let-macro V1580) (cond ((and (pair? V1580) (and (eq? (quote let) (car V1580)) (and (pair? (cdr V1580)) (and (pair? (cdr (cdr V1580))) (and (pair? (cdr (cdr (cdr V1580)))) (pair? (cdr (cdr (cdr (cdr V1580)))))))))) (cons (quote let) (cons (car (cdr V1580)) (cons (car (cdr (cdr V1580))) (cons (kl:shen.let-macro (cons (quote let) (cdr (cdr (cdr V1580))))) (quote ())))))) (#t V1580))) (quote shen.let-macro))
(begin (register-function-arity (quote shen.abs-macro) 1) (define (kl:shen.abs-macro V1582) (cond ((and (pair? V1582) (and (eq? (quote /.) (car V1582)) (and (pair? (cdr V1582)) (and (pair? (cdr (cdr V1582))) (pair? (cdr (cdr (cdr V1582)))))))) (cons (quote lambda) (cons (car (cdr V1582)) (cons (kl:shen.abs-macro (cons (quote /.) (cdr (cdr V1582)))) (quote ()))))) ((and (pair? V1582) (and (eq? (quote /.) (car V1582)) (and (pair? (cdr V1582)) (and (pair? (cdr (cdr V1582))) (null? (cdr (cdr (cdr V1582)))))))) (cons (quote lambda) (cdr V1582))) (#t V1582))) (quote shen.abs-macro))
(begin (register-function-arity (quote shen.cases-macro) 1) (define (kl:shen.cases-macro V1586) (cond ((and (pair? V1586) (and (eq? (quote cases) (car V1586)) (and (pair? (cdr V1586)) (and (kl:= #t (car (cdr V1586))) (pair? (cdr (cdr V1586))))))) (car (cdr (cdr V1586)))) ((and (pair? V1586) (and (eq? (quote cases) (car V1586)) (and (pair? (cdr V1586)) (and (pair? (cdr (cdr V1586))) (null? (cdr (cdr (cdr V1586)))))))) (cons (quote if) (cons (car (cdr V1586)) (cons (car (cdr (cdr V1586))) (cons (cons (quote simple-error) (cons "error: cases exhausted" (quote ()))) (quote ())))))) ((and (pair? V1586) (and (eq? (quote cases) (car V1586)) (and (pair? (cdr V1586)) (pair? (cdr (cdr V1586)))))) (cons (quote if) (cons (car (cdr V1586)) (cons (car (cdr (cdr V1586))) (cons (kl:shen.cases-macro (cons (quote cases) (cdr (cdr (cdr V1586))))) (quote ())))))) ((and (pair? V1586) (and (eq? (quote cases) (car V1586)) (and (pair? (cdr V1586)) (null? (cdr (cdr V1586)))))) (simple-error "error: odd number of case elements\n")) (#t V1586))) (quote shen.cases-macro))
(begin (register-function-arity (quote shen.timer-macro) 1) (define (kl:shen.timer-macro V1588) (cond ((and (pair? V1588) (and (eq? (quote time) (car V1588)) (and (pair? (cdr V1588)) (null? (cdr (cdr V1588)))))) (kl:shen.let-macro (cons (quote let) (cons (quote Start) (cons (cons (quote get-time) (cons (quote run) (quote ()))) (cons (quote Result) (cons (car (cdr V1588)) (cons (quote Finish) (cons (cons (quote get-time) (cons (quote run) (quote ()))) (cons (quote Time) (cons (cons (quote -) (cons (quote Finish) (cons (quote Start) (quote ())))) (cons (quote Message) (cons (cons (quote shen.prhush) (cons (cons (quote cn) (cons "\nrun time: " (cons (cons (quote cn) (cons (cons (quote str) (cons (quote Time) (quote ()))) (cons " secs\n" (quote ())))) (quote ())))) (cons (cons (quote stoutput) (quote ())) (quote ())))) (cons (quote Result) (quote ()))))))))))))))) (#t V1588))) (quote shen.timer-macro))
(begin (register-function-arity (quote shen.tuple-up) 1) (define (kl:shen.tuple-up V1590) (cond ((pair? V1590) (cons (quote _waspvm_at_p) (cons (car V1590) (cons (kl:shen.tuple-up (cdr V1590)) (quote ()))))) (#t V1590))) (quote shen.tuple-up))
(begin (register-function-arity (quote shen.put/get-macro) 1) (define (kl:shen.put/get-macro V1592) (cond ((and (pair? V1592) (and (eq? (quote put) (car V1592)) (and (pair? (cdr V1592)) (and (pair? (cdr (cdr V1592))) (and (pair? (cdr (cdr (cdr V1592)))) (null? (cdr (cdr (cdr (cdr V1592)))))))))) (cons (quote put) (cons (car (cdr V1592)) (cons (car (cdr (cdr V1592))) (cons (car (cdr (cdr (cdr V1592)))) (cons (cons (quote value) (cons (quote *property-vector*) (quote ()))) (quote ()))))))) ((and (pair? V1592) (and (eq? (quote get) (car V1592)) (and (pair? (cdr V1592)) (and (pair? (cdr (cdr V1592))) (null? (cdr (cdr (cdr V1592)))))))) (cons (quote get) (cons (car (cdr V1592)) (cons (car (cdr (cdr V1592))) (cons (cons (quote value) (cons (quote *property-vector*) (quote ()))) (quote ())))))) ((and (pair? V1592) (and (eq? (quote unput) (car V1592)) (and (pair? (cdr V1592)) (and (pair? (cdr (cdr V1592))) (null? (cdr (cdr (cdr V1592)))))))) (cons (quote unput) (cons (car (cdr V1592)) (cons (car (cdr (cdr V1592))) (cons (cons (quote value) (cons (quote *property-vector*) (quote ()))) (quote ())))))) (#t V1592))) (quote shen.put/get-macro))
(begin (register-function-arity (quote shen.function-macro) 1) (define (kl:shen.function-macro V1594) (cond ((and (pair? V1594) (and (eq? (quote function) (car V1594)) (and (pair? (cdr V1594)) (null? (cdr (cdr V1594)))))) (kl:shen.function-abstraction (car (cdr V1594)) (kl:arity (car (cdr V1594))))) (#t V1594))) (quote shen.function-macro))
(begin (register-function-arity (quote shen.function-abstraction) 2) (define (kl:shen.function-abstraction V1597 V1598) (cond ((kl:= 0 V1598) (simple-error (kl:shen.app V1597 " has no lambda form\n" (quote shen.a)))) ((kl:= -1 V1598) (cons (quote function) (cons V1597 (quote ())))) (#t (kl:shen.function-abstraction-help V1597 V1598 (quote ()))))) (quote shen.function-abstraction))
(begin (register-function-arity (quote shen.function-abstraction-help) 3) (define (kl:shen.function-abstraction-help V1602 V1603 V1604) (cond ((kl:= 0 V1603) (cons V1602 V1604)) (#t (let ((X (kl:gensym (quote V)))) (cons (quote /.) (cons X (cons (kl:shen.function-abstraction-help V1602 (- V1603 1) (kl:append V1604 (cons X (quote ())))) (quote ())))))))) (quote shen.function-abstraction-help))
(begin (register-function-arity (quote undefmacro) 1) (define (kl:undefmacro V1606) (let ((MacroReg (kl:value (quote shen.*macroreg*)))) (let ((Pos (kl:shen.findpos V1606 MacroReg))) (let ((Remove1 (kl:set (quote shen.*macroreg*) (kl:remove V1606 MacroReg)))) (let ((Remove2 (kl:set (quote *macros*) (kl:shen.remove-nth Pos (kl:value (quote *macros*)))))) V1606))))) (quote undefmacro))
(begin (register-function-arity (quote shen.findpos) 2) (define (kl:shen.findpos V1616 V1617) (cond ((null? V1617) (simple-error (kl:shen.app V1616 " is not a macro\n" (quote shen.a)))) ((and (pair? V1617) (kl:= (car V1617) V1616)) 1) ((pair? V1617) (+ 1 (kl:shen.findpos V1616 (cdr V1617)))) (#t (kl:shen.f_error (quote shen.findpos))))) (quote shen.findpos))
(begin (register-function-arity (quote shen.remove-nth) 2) (define (kl:shen.remove-nth V1622 V1623) (cond ((and (kl:= 1 V1622) (pair? V1623)) (cdr V1623)) ((pair? V1623) (cons (car V1623) (kl:shen.remove-nth (- V1622 1) (cdr V1623)))) (#t (kl:shen.f_error (quote shen.remove-nth))))) (quote shen.remove-nth))
