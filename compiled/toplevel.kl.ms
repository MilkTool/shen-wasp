"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.shen) 0) (define (kl:shen.shen) (begin (kl:shen.credits) (kl:shen.loop))) (quote shen.shen))
(kl:set (quote shen.*continue-repl-loop*) #t)
(begin (register-function-arity (quote exit) 1) (define (kl:exit V3973) (kl:set (quote shen.*continue-repl-loop*) #f)) (quote exit))
(begin (register-function-arity (quote shen.loop) 0) (define (kl:shen.loop) (begin (kl:shen.initialise_environment) (begin (kl:shen.prompt) (begin (guard (lambda (E) (kl:pr (kl:error-to-string E) (kl:stoutput))) (kl:shen.read-evaluate-print)) (if (assert-boolean (kl:value (quote shen.*continue-repl-loop*))) (kl:shen.loop) (quote exit)))))) (quote shen.loop))
(begin (register-function-arity (quote shen.credits) 0) (define (kl:shen.credits) (begin (kl:shen.prhush "\nShen, copyright (C) 2010-2015 Mark Tarver\n" (kl:stoutput)) (begin (kl:shen.prhush (string-append "www.shenlanguage.org, " (kl:shen.app (kl:value (quote *version*)) "\n" (quote shen.a))) (kl:stoutput)) (begin (kl:shen.prhush (string-append "running under " (kl:shen.app (kl:value (quote *language*)) (string-append ", implementation: " (kl:shen.app (kl:value (quote *implementation*)) "" (quote shen.a))) (quote shen.a))) (kl:stoutput)) (kl:shen.prhush (string-append "\nport " (kl:shen.app (kl:value (quote *port*)) (string-append " ported by " (kl:shen.app (kl:value (quote *porters*)) "\n" (quote shen.a))) (quote shen.a))) (kl:stoutput)))))) (quote shen.credits))
(begin (register-function-arity (quote shen.initialise_environment) 0) (define (kl:shen.initialise_environment) (kl:shen.multiple-set (cons (quote shen.*call*) (cons 0 (cons (quote shen.*infs*) (cons 0 (cons (quote shen.*process-counter*) (cons 0 (cons (quote shen.*catch*) (cons 0 (quote ()))))))))))) (quote shen.initialise_environment))
(begin (register-function-arity (quote shen.multiple-set) 1) (define (kl:shen.multiple-set V3975) (cond ((null? V3975) (quote ())) ((and (pair? V3975) (pair? (cdr V3975))) (begin (kl:set (car V3975) (car (cdr V3975))) (kl:shen.multiple-set (cdr (cdr V3975))))) (#t (kl:shen.f_error (quote shen.multiple-set))))) (quote shen.multiple-set))
(begin (register-function-arity (quote destroy) 1) (define (kl:destroy V3977) (kl:declare V3977 (quote symbol))) (quote destroy))
(kl:set (quote shen.*history*) (quote ()))
(begin (register-function-arity (quote shen.read-evaluate-print) 0) (define (kl:shen.read-evaluate-print) (let ((Lineread (kl:shen.toplineread))) (let ((History (kl:value (quote shen.*history*)))) (let ((NewLineread (kl:shen.retrieve-from-history-if-needed Lineread History))) (let ((NewHistory (kl:shen.update_history NewLineread History))) (let ((Parsed (kl:fst NewLineread))) (kl:shen.toplevel Parsed))))))) (quote shen.read-evaluate-print))
(begin (register-function-arity (quote shen.retrieve-from-history-if-needed) 2) (define (kl:shen.retrieve-from-history-if-needed V3989 V3990) (cond ((and (kl:tuple? V3989) (and (pair? (kl:snd V3989)) (kl:element? (car (kl:snd V3989)) (cons (kl:shen.space) (cons (kl:shen.newline) (quote ())))))) (kl:shen.retrieve-from-history-if-needed (kl:_waspvm_at_p (kl:fst V3989) (cdr (kl:snd V3989))) V3990)) ((and (kl:tuple? V3989) (and (pair? (kl:snd V3989)) (and (pair? (cdr (kl:snd V3989))) (and (null? (cdr (cdr (kl:snd V3989)))) (and (pair? V3990) (and (kl:= (car (kl:snd V3989)) (kl:shen.exclamation)) (kl:= (car (cdr (kl:snd V3989))) (kl:shen.exclamation)))))))) (let ((PastPrint (kl:shen.prbytes (kl:snd (car V3990))))) (car V3990))) ((and (kl:tuple? V3989) (and (pair? (kl:snd V3989)) (kl:= (car (kl:snd V3989)) (kl:shen.exclamation)))) (let ((Key? (kl:shen.make-key (cdr (kl:snd V3989)) V3990))) (let ((Find (kl:head (kl:shen.find-past-inputs Key? V3990)))) (let ((PastPrint (kl:shen.prbytes (kl:snd Find)))) Find)))) ((and (kl:tuple? V3989) (and (pair? (kl:snd V3989)) (and (null? (cdr (kl:snd V3989))) (kl:= (car (kl:snd V3989)) (kl:shen.percent))))) (begin (kl:shen.print-past-inputs (lambda (X) #t) (kl:reverse V3990) 0) (kl:abort))) ((and (kl:tuple? V3989) (and (pair? (kl:snd V3989)) (kl:= (car (kl:snd V3989)) (kl:shen.percent)))) (let ((Key? (kl:shen.make-key (cdr (kl:snd V3989)) V3990))) (let ((Pastprint (kl:shen.print-past-inputs Key? (kl:reverse V3990) 0))) (kl:abort)))) (#t V3989))) (quote shen.retrieve-from-history-if-needed))
(begin (register-function-arity (quote shen.percent) 0) (define (kl:shen.percent) 37) (quote shen.percent))
(begin (register-function-arity (quote shen.exclamation) 0) (define (kl:shen.exclamation) 33) (quote shen.exclamation))
(begin (register-function-arity (quote shen.prbytes) 1) (define (kl:shen.prbytes V3992) (begin (kl:for-each (lambda (Byte) (kl:pr (make-string 1 Byte) (kl:stoutput))) V3992) (kl:nl 1))) (quote shen.prbytes))
(begin (register-function-arity (quote shen.update_history) 2) (define (kl:shen.update_history V3995 V3996) (kl:set (quote shen.*history*) (cons V3995 V3996))) (quote shen.update_history))
(begin (register-function-arity (quote shen.toplineread) 0) (define (kl:shen.toplineread) (kl:shen.toplineread_loop (kl:read-char-code (kl:stinput)) (quote ()))) (quote shen.toplineread))
(begin (register-function-arity (quote shen.toplineread_loop) 2) (define (kl:shen.toplineread_loop V4000 V4001) (cond ((and (kl:= -1 V4000) (null? V4001)) (kl:exit 0)) ((kl:= V4000 (kl:shen.hat)) (simple-error "line read aborted")) ((kl:element? V4000 (cons (kl:shen.newline) (cons (kl:shen.carriage-return) (quote ())))) (let ((Line (kl:compile (lambda (X) (kl:shen.<st_input> X)) V4001 (lambda (E) (quote shen.nextline))))) (let ((It (kl:shen.record-it V4001))) (if (or (eq? Line (quote shen.nextline)) (kl:empty? Line)) (kl:shen.toplineread_loop (kl:read-char-code (kl:stinput)) (kl:append V4001 (cons V4000 (quote ())))) (kl:_waspvm_at_p Line V4001))))) (#t (kl:shen.toplineread_loop (kl:read-char-code (kl:stinput)) (if (kl:= V4000 -1) V4001 (kl:append V4001 (cons V4000 (quote ())))))))) (quote shen.toplineread_loop))
(begin (register-function-arity (quote shen.hat) 0) (define (kl:shen.hat) 94) (quote shen.hat))
(begin (register-function-arity (quote shen.newline) 0) (define (kl:shen.newline) 10) (quote shen.newline))
(begin (register-function-arity (quote shen.carriage-return) 0) (define (kl:shen.carriage-return) 13) (quote shen.carriage-return))
(begin (register-function-arity (quote tc) 1) (define (kl:tc V4007) (cond ((eq? (quote +) V4007) (kl:set (quote shen.*tc*) #t)) ((eq? (quote -) V4007) (kl:set (quote shen.*tc*) #f)) (#t (simple-error "tc expects a + or -")))) (quote tc))
(begin (register-function-arity (quote shen.prompt) 0) (define (kl:shen.prompt) (if (assert-boolean (kl:value (quote shen.*tc*))) (kl:shen.prhush (string-append "\n\n(" (kl:shen.app (kl:length (kl:value (quote shen.*history*))) "+) " (quote shen.a))) (kl:stoutput)) (kl:shen.prhush (string-append "\n\n(" (kl:shen.app (kl:length (kl:value (quote shen.*history*))) "-) " (quote shen.a))) (kl:stoutput)))) (quote shen.prompt))
(begin (register-function-arity (quote shen.toplevel) 1) (define (kl:shen.toplevel V4009) (kl:shen.toplevel_evaluate V4009 (kl:value (quote shen.*tc*)))) (quote shen.toplevel))
(begin (register-function-arity (quote shen.find-past-inputs) 2) (define (kl:shen.find-past-inputs V4012 V4013) (let ((F (kl:shen.find V4012 V4013))) (if (kl:empty? F) (simple-error "input not found\n") F))) (quote shen.find-past-inputs))
(begin (register-function-arity (quote shen.make-key) 2) (define (kl:shen.make-key V4016 V4017) (let ((Atom (car (kl:compile (lambda (X) (kl:shen.<st_input> X)) V4016 (lambda (E) (if (pair? E) (simple-error (string-append "parse error here: " (kl:shen.app E "\n" (quote shen.s)))) (simple-error "parse error\n"))))))) (if (assert-boolean (kl:integer? Atom)) (lambda (X) (kl:= X (kl:nth (+ Atom 1) (kl:reverse V4017)))) (lambda (X) (kl:shen.prefix? V4016 (kl:shen.trim-gubbins (kl:snd X))))))) (quote shen.make-key))
(begin (register-function-arity (quote shen.trim-gubbins) 1) (define (kl:shen.trim-gubbins V4019) (cond ((and (pair? V4019) (kl:= (car V4019) (kl:shen.space))) (kl:shen.trim-gubbins (cdr V4019))) ((and (pair? V4019) (kl:= (car V4019) (kl:shen.newline))) (kl:shen.trim-gubbins (cdr V4019))) ((and (pair? V4019) (kl:= (car V4019) (kl:shen.carriage-return))) (kl:shen.trim-gubbins (cdr V4019))) ((and (pair? V4019) (kl:= (car V4019) (kl:shen.tab))) (kl:shen.trim-gubbins (cdr V4019))) ((and (pair? V4019) (kl:= (car V4019) (kl:shen.left-round))) (kl:shen.trim-gubbins (cdr V4019))) (#t V4019))) (quote shen.trim-gubbins))
(begin (register-function-arity (quote shen.space) 0) (define (kl:shen.space) 32) (quote shen.space))
(begin (register-function-arity (quote shen.tab) 0) (define (kl:shen.tab) 9) (quote shen.tab))
(begin (register-function-arity (quote shen.left-round) 0) (define (kl:shen.left-round) 40) (quote shen.left-round))
(begin (register-function-arity (quote shen.find) 2) (define (kl:shen.find V4028 V4029) (cond ((null? V4029) (quote ())) ((and (pair? V4029) (assert-boolean (V4028 (car V4029)))) (cons (car V4029) (kl:shen.find V4028 (cdr V4029)))) ((pair? V4029) (kl:shen.find V4028 (cdr V4029))) (#t (kl:shen.f_error (quote shen.find))))) (quote shen.find))
(begin (register-function-arity (quote shen.prefix?) 2) (define (kl:shen.prefix? V4043 V4044) (cond ((null? V4043) #t) ((and (pair? V4043) (and (pair? V4044) (kl:= (car V4044) (car V4043)))) (kl:shen.prefix? (cdr V4043) (cdr V4044))) (#t #f))) (quote shen.prefix?))
(begin (register-function-arity (quote shen.print-past-inputs) 3) (define (kl:shen.print-past-inputs V4056 V4057 V4058) (cond ((null? V4057) (quote _)) ((and (pair? V4057) (kl:not (V4056 (car V4057)))) (kl:shen.print-past-inputs V4056 (cdr V4057) (+ V4058 1))) ((and (pair? V4057) (kl:tuple? (car V4057))) (begin (kl:shen.prhush (kl:shen.app V4058 ". " (quote shen.a)) (kl:stoutput)) (begin (kl:shen.prbytes (kl:snd (car V4057))) (kl:shen.print-past-inputs V4056 (cdr V4057) (+ V4058 1))))) (#t (kl:shen.f_error (quote shen.print-past-inputs))))) (quote shen.print-past-inputs))
(begin (register-function-arity (quote shen.toplevel_evaluate) 2) (define (kl:shen.toplevel_evaluate V4061 V4062) (cond ((and (pair? V4061) (and (pair? (cdr V4061)) (and (eq? (quote :) (car (cdr V4061))) (and (pair? (cdr (cdr V4061))) (and (null? (cdr (cdr (cdr V4061)))) (kl:= #t V4062)))))) (kl:shen.typecheck-and-evaluate (car V4061) (car (cdr (cdr V4061))))) ((and (pair? V4061) (pair? (cdr V4061))) (begin (kl:shen.toplevel_evaluate (cons (car V4061) (quote ())) V4062) (begin (kl:nl 1) (kl:shen.toplevel_evaluate (cdr V4061) V4062)))) ((and (pair? V4061) (and (null? (cdr V4061)) (kl:= #t V4062))) (kl:shen.typecheck-and-evaluate (car V4061) (kl:gensym (quote A)))) ((and (pair? V4061) (and (null? (cdr V4061)) (kl:= #f V4062))) (let ((Eval (kl:shen.eval-without-macros (car V4061)))) (kl:print Eval))) (#t (kl:shen.f_error (quote shen.toplevel_evaluate))))) (quote shen.toplevel_evaluate))
(begin (register-function-arity (quote shen.typecheck-and-evaluate) 2) (define (kl:shen.typecheck-and-evaluate V4065 V4066) (let ((Typecheck (kl:shen.typecheck V4065 V4066))) (if (kl:= Typecheck #f) (simple-error "type error\n") (let ((Eval (kl:shen.eval-without-macros V4065))) (let ((Type (kl:shen.pretty-type Typecheck))) (kl:shen.prhush (kl:shen.app Eval (string-append " : " (kl:shen.app Type "" (quote shen.r))) (quote shen.s)) (kl:stoutput))))))) (quote shen.typecheck-and-evaluate))
(begin (register-function-arity (quote shen.pretty-type) 1) (define (kl:shen.pretty-type V4068) (kl:shen.mult_subst (kl:value (quote shen.*alphabet*)) (kl:shen.extract-pvars V4068) V4068)) (quote shen.pretty-type))
(begin (register-function-arity (quote shen.extract-pvars) 1) (define (kl:shen.extract-pvars V4074) (cond ((kl:shen.pvar? V4074) (cons V4074 (quote ()))) ((pair? V4074) (kl:union (kl:shen.extract-pvars (car V4074)) (kl:shen.extract-pvars (cdr V4074)))) (#t (quote ())))) (quote shen.extract-pvars))
(begin (register-function-arity (quote shen.mult_subst) 3) (define (kl:shen.mult_subst V4082 V4083 V4084) (cond ((null? V4082) V4084) ((null? V4083) V4084) ((and (pair? V4082) (pair? V4083)) (kl:shen.mult_subst (cdr V4082) (cdr V4083) (kl:subst (car V4082) (car V4083) V4084))) (#t (kl:shen.f_error (quote shen.mult_subst))))) (quote shen.mult_subst))
