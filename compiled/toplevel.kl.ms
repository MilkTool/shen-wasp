"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.shen) 0) (define (kl:shen.shen) (begin (kl:shen.credits) (kl:shen.loop))) (quote shen.shen))
(begin (register-function-arity (quote shen.loop) 0) (define (kl:shen.loop) (begin (kl:shen.initialise_environment) (begin (kl:shen.prompt) (begin (guard (lambda (E) (kl:shen.toplevel-display-exception E)) (kl:shen.read-evaluate-print)) (kl:shen.loop))))) (quote shen.loop))
(begin (register-function-arity (quote shen.toplevel-display-exception) 1) (define (kl:shen.toplevel-display-exception V3779) (kl:pr (kl:error-to-string V3779) (kl:stoutput))) (quote shen.toplevel-display-exception))
(begin (register-function-arity (quote shen.credits) 0) (define (kl:shen.credits) (begin (kl:shen.prhush "\nShen, copyright (C) 2010-2015 Mark Tarver\n" (kl:stoutput)) (begin (kl:shen.prhush (string-append "www.shenlanguage.org, " (kl:shen.app (kl:value (quote *version*)) "\n" (quote shen.a))) (kl:stoutput)) (begin (kl:shen.prhush (string-append "running under " (kl:shen.app (kl:value (quote *language*)) (string-append ", implementation: " (kl:shen.app (kl:value (quote *implementation*)) "" (quote shen.a))) (quote shen.a))) (kl:stoutput)) (kl:shen.prhush (string-append "\nport " (kl:shen.app (kl:value (quote *port*)) (string-append " ported by " (kl:shen.app (kl:value (quote *porters*)) "\n" (quote shen.a))) (quote shen.a))) (kl:stoutput)))))) (quote shen.credits))
(begin (register-function-arity (quote shen.initialise_environment) 0) (define (kl:shen.initialise_environment) (kl:shen.multiple-set (cons (quote shen.*call*) (cons 0 (cons (quote shen.*infs*) (cons 0 (cons (quote shen.*process-counter*) (cons 0 (cons (quote shen.*catch*) (cons 0 (quote ()))))))))))) (quote shen.initialise_environment))
(begin (register-function-arity (quote shen.multiple-set) 1) (define (kl:shen.multiple-set V3781) (cond ((null? V3781) (quote ())) ((and (pair? V3781) (pair? (cdr V3781))) (begin (kl:set (car V3781) (car (cdr V3781))) (kl:shen.multiple-set (cdr (cdr V3781))))) (#t (kl:shen.f_error (quote shen.multiple-set))))) (quote shen.multiple-set))
(begin (register-function-arity (quote destroy) 1) (define (kl:destroy V3783) (kl:declare V3783 (quote symbol))) (quote destroy))
(kl:set (quote shen.*history*) (quote ()))
(begin (register-function-arity (quote shen.read-evaluate-print) 0) (define (kl:shen.read-evaluate-print) (let ((Lineread (kl:shen.toplineread))) (let ((History (kl:value (quote shen.*history*)))) (let ((NewLineread (kl:shen.retrieve-from-history-if-needed Lineread History))) (let ((NewHistory (kl:shen.update_history NewLineread History))) (let ((Parsed (kl:fst NewLineread))) (kl:shen.toplevel Parsed))))))) (quote shen.read-evaluate-print))
(begin (register-function-arity (quote shen.retrieve-from-history-if-needed) 2) (define (kl:shen.retrieve-from-history-if-needed V3795 V3796) (cond ((and (kl:tuple? V3795) (and (pair? (kl:snd V3795)) (kl:element? (car (kl:snd V3795)) (cons (kl:shen.space) (cons (kl:shen.newline) (quote ())))))) (kl:shen.retrieve-from-history-if-needed (kl:_waspvm_at_p (kl:fst V3795) (cdr (kl:snd V3795))) V3796)) ((and (kl:tuple? V3795) (and (pair? (kl:snd V3795)) (and (pair? (cdr (kl:snd V3795))) (and (null? (cdr (cdr (kl:snd V3795)))) (and (pair? V3796) (and (kl:= (car (kl:snd V3795)) (kl:shen.exclamation)) (kl:= (car (cdr (kl:snd V3795))) (kl:shen.exclamation)))))))) (let ((PastPrint (kl:shen.prbytes (kl:snd (car V3796))))) (car V3796))) ((and (kl:tuple? V3795) (and (pair? (kl:snd V3795)) (kl:= (car (kl:snd V3795)) (kl:shen.exclamation)))) (let ((Key? (kl:shen.make-key (cdr (kl:snd V3795)) V3796))) (let ((Find (kl:head (kl:shen.find-past-inputs Key? V3796)))) (let ((PastPrint (kl:shen.prbytes (kl:snd Find)))) Find)))) ((and (kl:tuple? V3795) (and (pair? (kl:snd V3795)) (and (null? (cdr (kl:snd V3795))) (kl:= (car (kl:snd V3795)) (kl:shen.percent))))) (begin (kl:shen.print-past-inputs (lambda (X) #t) (kl:reverse V3796) 0) (kl:abort))) ((and (kl:tuple? V3795) (and (pair? (kl:snd V3795)) (kl:= (car (kl:snd V3795)) (kl:shen.percent)))) (let ((Key? (kl:shen.make-key (cdr (kl:snd V3795)) V3796))) (let ((Pastprint (kl:shen.print-past-inputs Key? (kl:reverse V3796) 0))) (kl:abort)))) (#t V3795))) (quote shen.retrieve-from-history-if-needed))
(begin (register-function-arity (quote shen.percent) 0) (define (kl:shen.percent) 37) (quote shen.percent))
(begin (register-function-arity (quote shen.exclamation) 0) (define (kl:shen.exclamation) 33) (quote shen.exclamation))
(begin (register-function-arity (quote shen.prbytes) 1) (define (kl:shen.prbytes V3798) (begin (kl:shen.for-each (lambda (Byte) (kl:pr (make-string 1 Byte) (kl:stoutput))) V3798) (kl:nl 1))) (quote shen.prbytes))
(begin (register-function-arity (quote shen.update_history) 2) (define (kl:shen.update_history V3801 V3802) (kl:set (quote shen.*history*) (cons V3801 V3802))) (quote shen.update_history))
(begin (register-function-arity (quote shen.toplineread) 0) (define (kl:shen.toplineread) (kl:shen.toplineread_loop (kl:shen.read-char-code (kl:stinput)) (quote ()))) (quote shen.toplineread))
(begin (register-function-arity (quote shen.toplineread_loop) 2) (define (kl:shen.toplineread_loop V3806 V3807) (cond ((kl:= V3806 (kl:shen.hat)) (simple-error "line read aborted")) ((kl:element? V3806 (cons (kl:shen.newline) (cons (kl:shen.carriage-return) (quote ())))) (let ((Line (kl:compile (lambda (X) (kl:shen.<st_input> X)) V3807 (lambda (E) (quote shen.nextline))))) (let ((It (kl:shen.record-it V3807))) (if (or (eq? Line (quote shen.nextline)) (kl:empty? Line)) (kl:shen.toplineread_loop (kl:shen.read-char-code (kl:stinput)) (kl:append V3807 (cons V3806 (quote ())))) (kl:_waspvm_at_p Line V3807))))) (#t (kl:shen.toplineread_loop (kl:shen.read-char-code (kl:stinput)) (if (kl:= V3806 -1) V3807 (kl:append V3807 (cons V3806 (quote ())))))))) (quote shen.toplineread_loop))
(begin (register-function-arity (quote shen.hat) 0) (define (kl:shen.hat) 94) (quote shen.hat))
(begin (register-function-arity (quote shen.newline) 0) (define (kl:shen.newline) 10) (quote shen.newline))
(begin (register-function-arity (quote shen.carriage-return) 0) (define (kl:shen.carriage-return) 13) (quote shen.carriage-return))
(begin (register-function-arity (quote tc) 1) (define (kl:tc V3813) (cond ((eq? (quote +) V3813) (kl:set (quote shen.*tc*) #t)) ((eq? (quote -) V3813) (kl:set (quote shen.*tc*) #f)) (#t (simple-error "tc expects a + or -")))) (quote tc))
(begin (register-function-arity (quote shen.prompt) 0) (define (kl:shen.prompt) (if (assert-boolean (kl:value (quote shen.*tc*))) (kl:shen.prhush (string-append "\n\n(" (kl:shen.app (kl:length (kl:value (quote shen.*history*))) "+) " (quote shen.a))) (kl:stoutput)) (kl:shen.prhush (string-append "\n\n(" (kl:shen.app (kl:length (kl:value (quote shen.*history*))) "-) " (quote shen.a))) (kl:stoutput)))) (quote shen.prompt))
(begin (register-function-arity (quote shen.toplevel) 1) (define (kl:shen.toplevel V3815) (kl:shen.toplevel_evaluate V3815 (kl:value (quote shen.*tc*)))) (quote shen.toplevel))
(begin (register-function-arity (quote shen.find-past-inputs) 2) (define (kl:shen.find-past-inputs V3818 V3819) (let ((F (kl:shen.find V3818 V3819))) (if (kl:empty? F) (simple-error "input not found\n") F))) (quote shen.find-past-inputs))
(begin (register-function-arity (quote shen.make-key) 2) (define (kl:shen.make-key V3822 V3823) (let ((Atom (car (kl:compile (lambda (X) (kl:shen.<st_input> X)) V3822 (lambda (E) (if (pair? E) (simple-error (string-append "parse error here: " (kl:shen.app E "\n" (quote shen.s)))) (simple-error "parse error\n"))))))) (if (assert-boolean (kl:integer? Atom)) (lambda (X) (kl:= X (kl:nth (+ Atom 1) (kl:reverse V3823)))) (lambda (X) (kl:shen.prefix? V3822 (kl:shen.trim-gubbins (kl:snd X))))))) (quote shen.make-key))
(begin (register-function-arity (quote shen.trim-gubbins) 1) (define (kl:shen.trim-gubbins V3825) (cond ((and (pair? V3825) (kl:= (car V3825) (kl:shen.space))) (kl:shen.trim-gubbins (cdr V3825))) ((and (pair? V3825) (kl:= (car V3825) (kl:shen.newline))) (kl:shen.trim-gubbins (cdr V3825))) ((and (pair? V3825) (kl:= (car V3825) (kl:shen.carriage-return))) (kl:shen.trim-gubbins (cdr V3825))) ((and (pair? V3825) (kl:= (car V3825) (kl:shen.tab))) (kl:shen.trim-gubbins (cdr V3825))) ((and (pair? V3825) (kl:= (car V3825) (kl:shen.left-round))) (kl:shen.trim-gubbins (cdr V3825))) (#t V3825))) (quote shen.trim-gubbins))
(begin (register-function-arity (quote shen.space) 0) (define (kl:shen.space) 32) (quote shen.space))
(begin (register-function-arity (quote shen.tab) 0) (define (kl:shen.tab) 9) (quote shen.tab))
(begin (register-function-arity (quote shen.left-round) 0) (define (kl:shen.left-round) 40) (quote shen.left-round))
(begin (register-function-arity (quote shen.find) 2) (define (kl:shen.find V3834 V3835) (cond ((null? V3835) (quote ())) ((and (pair? V3835) (assert-boolean (V3834 (car V3835)))) (cons (car V3835) (kl:shen.find V3834 (cdr V3835)))) ((pair? V3835) (kl:shen.find V3834 (cdr V3835))) (#t (kl:shen.f_error (quote shen.find))))) (quote shen.find))
(begin (register-function-arity (quote shen.prefix?) 2) (define (kl:shen.prefix? V3849 V3850) (cond ((null? V3849) #t) ((and (pair? V3849) (and (pair? V3850) (kl:= (car V3850) (car V3849)))) (kl:shen.prefix? (cdr V3849) (cdr V3850))) (#t #f))) (quote shen.prefix?))
(begin (register-function-arity (quote shen.print-past-inputs) 3) (define (kl:shen.print-past-inputs V3862 V3863 V3864) (cond ((null? V3863) (quote _)) ((and (pair? V3863) (kl:not (V3862 (car V3863)))) (kl:shen.print-past-inputs V3862 (cdr V3863) (+ V3864 1))) ((and (pair? V3863) (kl:tuple? (car V3863))) (begin (kl:shen.prhush (kl:shen.app V3864 ". " (quote shen.a)) (kl:stoutput)) (begin (kl:shen.prbytes (kl:snd (car V3863))) (kl:shen.print-past-inputs V3862 (cdr V3863) (+ V3864 1))))) (#t (kl:shen.f_error (quote shen.print-past-inputs))))) (quote shen.print-past-inputs))
(begin (register-function-arity (quote shen.toplevel_evaluate) 2) (define (kl:shen.toplevel_evaluate V3867 V3868) (cond ((and (pair? V3867) (and (pair? (cdr V3867)) (and (eq? (quote :) (car (cdr V3867))) (and (pair? (cdr (cdr V3867))) (and (null? (cdr (cdr (cdr V3867)))) (kl:= #t V3868)))))) (kl:shen.typecheck-and-evaluate (car V3867) (car (cdr (cdr V3867))))) ((and (pair? V3867) (pair? (cdr V3867))) (begin (kl:shen.toplevel_evaluate (cons (car V3867) (quote ())) V3868) (begin (kl:nl 1) (kl:shen.toplevel_evaluate (cdr V3867) V3868)))) ((and (pair? V3867) (and (null? (cdr V3867)) (kl:= #t V3868))) (kl:shen.typecheck-and-evaluate (car V3867) (kl:gensym (quote A)))) ((and (pair? V3867) (and (null? (cdr V3867)) (kl:= #f V3868))) (let ((Eval (kl:shen.eval-without-macros (car V3867)))) (kl:print Eval))) (#t (kl:shen.f_error (quote shen.toplevel_evaluate))))) (quote shen.toplevel_evaluate))
(begin (register-function-arity (quote shen.typecheck-and-evaluate) 2) (define (kl:shen.typecheck-and-evaluate V3871 V3872) (let ((Typecheck (kl:shen.typecheck V3871 V3872))) (if (kl:= Typecheck #f) (simple-error "type error\n") (let ((Eval (kl:shen.eval-without-macros V3871))) (let ((Type (kl:shen.pretty-type Typecheck))) (kl:shen.prhush (kl:shen.app Eval (string-append " : " (kl:shen.app Type "" (quote shen.r))) (quote shen.s)) (kl:stoutput))))))) (quote shen.typecheck-and-evaluate))
(begin (register-function-arity (quote shen.pretty-type) 1) (define (kl:shen.pretty-type V3874) (kl:shen.mult_subst (kl:value (quote shen.*alphabet*)) (kl:shen.extract-pvars V3874) V3874)) (quote shen.pretty-type))
(begin (register-function-arity (quote shen.extract-pvars) 1) (define (kl:shen.extract-pvars V3880) (cond ((kl:shen.pvar? V3880) (cons V3880 (quote ()))) ((pair? V3880) (kl:union (kl:shen.extract-pvars (car V3880)) (kl:shen.extract-pvars (cdr V3880)))) (#t (quote ())))) (quote shen.extract-pvars))
(begin (register-function-arity (quote shen.mult_subst) 3) (define (kl:shen.mult_subst V3888 V3889 V3890) (cond ((null? V3888) V3890) ((null? V3889) V3890) ((and (pair? V3888) (pair? V3889)) (kl:shen.mult_subst (cdr V3888) (cdr V3889) (kl:subst (car V3888) (car V3889) V3890))) (#t (kl:shen.f_error (quote shen.mult_subst))))) (quote shen.mult_subst))
