"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen) 0) (define (kl:shen) (begin (kl:shen.credits) (kl:shen.loop))) (quote shen))
(begin (register-function-arity (quote shen.loop) 0) (define (kl:shen.loop) (begin (kl:shen.initialise_environment) (begin (kl:shen.prompt) (begin (guard (lambda (E) (kl:pr (kl:error-to-string E) (kl:stoutput))) (kl:shen.read-evaluate-print)) (kl:shen.loop))))) (quote shen.loop))
(begin (register-function-arity (quote shen.credits) 0) (define (kl:shen.credits) (begin (kl:shen.prhush "\nShen, copyright (C) 2010-2015 Mark Tarver\n" (kl:stoutput)) (begin (kl:shen.prhush (string-append "www.shenlanguage.org, " (kl:shen.app (kl:value (quote *version*)) "\n" (quote shen.a))) (kl:stoutput)) (begin (kl:shen.prhush (string-append "running under " (kl:shen.app (kl:value (quote *language*)) (string-append ", implementation: " (kl:shen.app (kl:value (quote *implementation*)) "" (quote shen.a))) (quote shen.a))) (kl:stoutput)) (kl:shen.prhush (string-append "\nport " (kl:shen.app (kl:value (quote *port*)) (string-append " ported by " (kl:shen.app (kl:value (quote *porters*)) "\n" (quote shen.a))) (quote shen.a))) (kl:stoutput)))))) (quote shen.credits))
(begin (register-function-arity (quote shen.initialise_environment) 0) (define (kl:shen.initialise_environment) (kl:shen.multiple-set (cons (quote shen.*call*) (cons 0 (cons (quote shen.*infs*) (cons 0 (cons (quote shen.*process-counter*) (cons 0 (cons (quote shen.*catch*) (cons 0 (quote ()))))))))))) (quote shen.initialise_environment))
(begin (register-function-arity (quote shen.multiple-set) 1) (define (kl:shen.multiple-set V3677) (cond ((null? V3677) (quote ())) ((and (pair? V3677) (pair? (cdr V3677))) (begin (kl:set (car V3677) (car (cdr V3677))) (kl:shen.multiple-set (cdr (cdr V3677))))) (#t (kl:shen.f_error (quote shen.multiple-set))))) (quote shen.multiple-set))
(begin (register-function-arity (quote destroy) 1) (define (kl:destroy V3679) (kl:declare V3679 (quote symbol))) (quote destroy))
(kl:set (quote shen.*history*) (quote ()))
(begin (register-function-arity (quote shen.read-evaluate-print) 0) (define (kl:shen.read-evaluate-print) (let ((Lineread (kl:shen.toplineread))) (let ((History (kl:value (quote shen.*history*)))) (let ((NewLineread (kl:shen.retrieve-from-history-if-needed Lineread History))) (let ((NewHistory (kl:shen.update_history NewLineread History))) (let ((Parsed (kl:fst NewLineread))) (kl:shen.toplevel Parsed))))))) (quote shen.read-evaluate-print))
(begin (register-function-arity (quote shen.retrieve-from-history-if-needed) 2) (define (kl:shen.retrieve-from-history-if-needed V3691 V3692) (cond ((and (kl:tuple? V3691) (and (pair? (kl:snd V3691)) (kl:element? (car (kl:snd V3691)) (cons (kl:shen.space) (cons (kl:shen.newline) (quote ())))))) (kl:shen.retrieve-from-history-if-needed (kl:_waspvm_at_p (kl:fst V3691) (cdr (kl:snd V3691))) V3692)) ((and (kl:tuple? V3691) (and (pair? (kl:snd V3691)) (and (pair? (cdr (kl:snd V3691))) (and (null? (cdr (cdr (kl:snd V3691)))) (and (pair? V3692) (and (kl:= (car (kl:snd V3691)) (kl:shen.exclamation)) (kl:= (car (cdr (kl:snd V3691))) (kl:shen.exclamation)))))))) (let ((PastPrint (kl:shen.prbytes (kl:snd (car V3692))))) (car V3692))) ((and (kl:tuple? V3691) (and (pair? (kl:snd V3691)) (kl:= (car (kl:snd V3691)) (kl:shen.exclamation)))) (let ((Key? (kl:shen.make-key (cdr (kl:snd V3691)) V3692))) (let ((Find (kl:head (kl:shen.find-past-inputs Key? V3692)))) (let ((PastPrint (kl:shen.prbytes (kl:snd Find)))) Find)))) ((and (kl:tuple? V3691) (and (pair? (kl:snd V3691)) (and (null? (cdr (kl:snd V3691))) (kl:= (car (kl:snd V3691)) (kl:shen.percent))))) (begin (kl:shen.print-past-inputs (lambda (X) #t) (kl:reverse V3692) 0) (kl:abort))) ((and (kl:tuple? V3691) (and (pair? (kl:snd V3691)) (kl:= (car (kl:snd V3691)) (kl:shen.percent)))) (let ((Key? (kl:shen.make-key (cdr (kl:snd V3691)) V3692))) (let ((Pastprint (kl:shen.print-past-inputs Key? (kl:reverse V3692) 0))) (kl:abort)))) (#t V3691))) (quote shen.retrieve-from-history-if-needed))
(begin (register-function-arity (quote shen.percent) 0) (define (kl:shen.percent) 37) (quote shen.percent))
(begin (register-function-arity (quote shen.exclamation) 0) (define (kl:shen.exclamation) 33) (quote shen.exclamation))
(begin (register-function-arity (quote shen.prbytes) 1) (define (kl:shen.prbytes V3694) (begin (kl:map (lambda (Byte) (kl:pr (make-string 1 Byte) (kl:stoutput))) V3694) (kl:nl 1))) (quote shen.prbytes))
(begin (register-function-arity (quote shen.update_history) 2) (define (kl:shen.update_history V3697 V3698) (kl:set (quote shen.*history*) (cons V3697 V3698))) (quote shen.update_history))
(begin (register-function-arity (quote shen.toplineread) 0) (define (kl:shen.toplineread) (kl:shen.toplineread_loop (read-u8 (kl:stinput)) (quote ()))) (quote shen.toplineread))
(begin (register-function-arity (quote shen.toplineread_loop) 2) (define (kl:shen.toplineread_loop V3702 V3703) (cond ((kl:= V3702 (kl:shen.hat)) (simple-error "line read aborted")) ((kl:element? V3702 (cons (kl:shen.newline) (cons (kl:shen.carriage-return) (quote ())))) (let ((Line (kl:compile (lambda (X) (kl:shen.<st_input> X)) V3703 (lambda (E) (quote shen.nextline))))) (let ((It (kl:shen.record-it V3703))) (if (or (eq? Line (quote shen.nextline)) (kl:empty? Line)) (kl:shen.toplineread_loop (read-u8 (kl:stinput)) (kl:append V3703 (cons V3702 (quote ())))) (kl:_waspvm_at_p Line V3703))))) (#t (kl:shen.toplineread_loop (read-u8 (kl:stinput)) (kl:append V3703 (cons V3702 (quote ()))))))) (quote shen.toplineread_loop))
(begin (register-function-arity (quote shen.hat) 0) (define (kl:shen.hat) 94) (quote shen.hat))
(begin (register-function-arity (quote shen.newline) 0) (define (kl:shen.newline) 10) (quote shen.newline))
(begin (register-function-arity (quote shen.carriage-return) 0) (define (kl:shen.carriage-return) 13) (quote shen.carriage-return))
(begin (register-function-arity (quote tc) 1) (define (kl:tc V3709) (cond ((eq? (quote +) V3709) (kl:set (quote shen.*tc*) #t)) ((eq? (quote -) V3709) (kl:set (quote shen.*tc*) #f)) (#t (simple-error "tc expects a + or -")))) (quote tc))
(begin (register-function-arity (quote shen.prompt) 0) (define (kl:shen.prompt) (if (assert-boolean (kl:value (quote shen.*tc*))) (kl:shen.prhush (string-append "\n\n(" (kl:shen.app (kl:length (kl:value (quote shen.*history*))) "+) " (quote shen.a))) (kl:stoutput)) (kl:shen.prhush (string-append "\n\n(" (kl:shen.app (kl:length (kl:value (quote shen.*history*))) "-) " (quote shen.a))) (kl:stoutput)))) (quote shen.prompt))
(begin (register-function-arity (quote shen.toplevel) 1) (define (kl:shen.toplevel V3711) (kl:shen.toplevel_evaluate V3711 (kl:value (quote shen.*tc*)))) (quote shen.toplevel))
(begin (register-function-arity (quote shen.find-past-inputs) 2) (define (kl:shen.find-past-inputs V3714 V3715) (let ((F (kl:shen.find V3714 V3715))) (if (kl:empty? F) (simple-error "input not found\n") F))) (quote shen.find-past-inputs))
(begin (register-function-arity (quote shen.make-key) 2) (define (kl:shen.make-key V3718 V3719) (let ((Atom (car (kl:compile (lambda (X) (kl:shen.<st_input> X)) V3718 (lambda (E) (if (pair? E) (simple-error (string-append "parse error here: " (kl:shen.app E "\n" (quote shen.s)))) (simple-error "parse error\n"))))))) (if (assert-boolean (kl:integer? Atom)) (lambda (X) (kl:= X (kl:nth (+ Atom 1) (kl:reverse V3719)))) (lambda (X) (kl:shen.prefix? V3718 (kl:shen.trim-gubbins (kl:snd X))))))) (quote shen.make-key))
(begin (register-function-arity (quote shen.trim-gubbins) 1) (define (kl:shen.trim-gubbins V3721) (cond ((and (pair? V3721) (kl:= (car V3721) (kl:shen.space))) (kl:shen.trim-gubbins (cdr V3721))) ((and (pair? V3721) (kl:= (car V3721) (kl:shen.newline))) (kl:shen.trim-gubbins (cdr V3721))) ((and (pair? V3721) (kl:= (car V3721) (kl:shen.carriage-return))) (kl:shen.trim-gubbins (cdr V3721))) ((and (pair? V3721) (kl:= (car V3721) (kl:shen.tab))) (kl:shen.trim-gubbins (cdr V3721))) ((and (pair? V3721) (kl:= (car V3721) (kl:shen.left-round))) (kl:shen.trim-gubbins (cdr V3721))) (#t V3721))) (quote shen.trim-gubbins))
(begin (register-function-arity (quote shen.space) 0) (define (kl:shen.space) 32) (quote shen.space))
(begin (register-function-arity (quote shen.tab) 0) (define (kl:shen.tab) 9) (quote shen.tab))
(begin (register-function-arity (quote shen.left-round) 0) (define (kl:shen.left-round) 40) (quote shen.left-round))
(begin (register-function-arity (quote shen.find) 2) (define (kl:shen.find V3730 V3731) (cond ((null? V3731) (quote ())) ((and (pair? V3731) (assert-boolean (V3730 (car V3731)))) (cons (car V3731) (kl:shen.find V3730 (cdr V3731)))) ((pair? V3731) (kl:shen.find V3730 (cdr V3731))) (#t (kl:shen.f_error (quote shen.find))))) (quote shen.find))
(begin (register-function-arity (quote shen.prefix?) 2) (define (kl:shen.prefix? V3745 V3746) (cond ((null? V3745) #t) ((and (pair? V3745) (and (pair? V3746) (kl:= (car V3746) (car V3745)))) (kl:shen.prefix? (cdr V3745) (cdr V3746))) (#t #f))) (quote shen.prefix?))
(begin (register-function-arity (quote shen.print-past-inputs) 3) (define (kl:shen.print-past-inputs V3758 V3759 V3760) (cond ((null? V3759) (quote _)) ((and (pair? V3759) (kl:not (V3758 (car V3759)))) (kl:shen.print-past-inputs V3758 (cdr V3759) (+ V3760 1))) ((and (pair? V3759) (kl:tuple? (car V3759))) (begin (kl:shen.prhush (kl:shen.app V3760 ". " (quote shen.a)) (kl:stoutput)) (begin (kl:shen.prbytes (kl:snd (car V3759))) (kl:shen.print-past-inputs V3758 (cdr V3759) (+ V3760 1))))) (#t (kl:shen.f_error (quote shen.print-past-inputs))))) (quote shen.print-past-inputs))
(begin (register-function-arity (quote shen.toplevel_evaluate) 2) (define (kl:shen.toplevel_evaluate V3763 V3764) (cond ((and (pair? V3763) (and (pair? (cdr V3763)) (and (eq? (quote :) (car (cdr V3763))) (and (pair? (cdr (cdr V3763))) (and (null? (cdr (cdr (cdr V3763)))) (kl:= #t V3764)))))) (kl:shen.typecheck-and-evaluate (car V3763) (car (cdr (cdr V3763))))) ((and (pair? V3763) (pair? (cdr V3763))) (begin (kl:shen.toplevel_evaluate (cons (car V3763) (quote ())) V3764) (begin (kl:nl 1) (kl:shen.toplevel_evaluate (cdr V3763) V3764)))) ((and (pair? V3763) (and (null? (cdr V3763)) (kl:= #t V3764))) (kl:shen.typecheck-and-evaluate (car V3763) (kl:gensym (quote A)))) ((and (pair? V3763) (and (null? (cdr V3763)) (kl:= #f V3764))) (let ((Eval (kl:shen.eval-without-macros (car V3763)))) (kl:print Eval))) (#t (kl:shen.f_error (quote shen.toplevel_evaluate))))) (quote shen.toplevel_evaluate))
(begin (register-function-arity (quote shen.typecheck-and-evaluate) 2) (define (kl:shen.typecheck-and-evaluate V3767 V3768) (let ((Typecheck (kl:shen.typecheck V3767 V3768))) (if (kl:= Typecheck #f) (simple-error "type error\n") (let ((Eval (kl:shen.eval-without-macros V3767))) (let ((Type (kl:shen.pretty-type Typecheck))) (kl:shen.prhush (kl:shen.app Eval (string-append " : " (kl:shen.app Type "" (quote shen.r))) (quote shen.s)) (kl:stoutput))))))) (quote shen.typecheck-and-evaluate))
(begin (register-function-arity (quote shen.pretty-type) 1) (define (kl:shen.pretty-type V3770) (kl:shen.mult_subst (kl:value (quote shen.*alphabet*)) (kl:shen.extract-pvars V3770) V3770)) (quote shen.pretty-type))
(begin (register-function-arity (quote shen.extract-pvars) 1) (define (kl:shen.extract-pvars V3776) (cond ((assert-boolean (kl:shen.pvar? V3776)) (cons V3776 (quote ()))) ((pair? V3776) (kl:union (kl:shen.extract-pvars (car V3776)) (kl:shen.extract-pvars (cdr V3776)))) (#t (quote ())))) (quote shen.extract-pvars))
(begin (register-function-arity (quote shen.mult_subst) 3) (define (kl:shen.mult_subst V3784 V3785 V3786) (cond ((null? V3784) V3786) ((null? V3785) V3786) ((and (pair? V3784) (pair? V3785)) (kl:shen.mult_subst (cdr V3784) (cdr V3785) (kl:subst (car V3784) (car V3785) V3786))) (#t (kl:shen.f_error (quote shen.mult_subst))))) (quote shen.mult_subst))
