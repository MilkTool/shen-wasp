"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.shen) 0) (define (kl:shen.shen) (begin (kl:shen.credits) (kl:shen.loop))) (quote shen.shen))
(kl:set (quote shen.*continue-repl-loop*) #t)
(begin (register-function-arity (quote exit) 1) (define (kl:exit V3800) (kl:set (quote shen.*continue-repl-loop*) #f)) (quote exit))
(begin (register-function-arity (quote shen.loop) 0) (define (kl:shen.loop) (begin (kl:shen.initialise_environment) (begin (kl:shen.prompt) (begin (guard (lambda (E) (kl:pr (kl:error-to-string E) (kl:stoutput))) (kl:shen.read-evaluate-print)) (if (assert-boolean (kl:value (quote shen.*continue-repl-loop*))) (kl:shen.loop) (quote exit)))))) (quote shen.loop))
(begin (register-function-arity (quote shen.credits) 0) (define (kl:shen.credits) (begin (kl:shen.prhush "\nShen, copyright (C) 2010-2015 Mark Tarver\n" (kl:stoutput)) (begin (kl:shen.prhush (string-append "www.shenlanguage.org, " (kl:shen.app (kl:value (quote *version*)) "\n" (quote shen.a))) (kl:stoutput)) (begin (kl:shen.prhush (string-append "running under " (kl:shen.app (kl:value (quote *language*)) (string-append ", implementation: " (kl:shen.app (kl:value (quote *implementation*)) "" (quote shen.a))) (quote shen.a))) (kl:stoutput)) (kl:shen.prhush (string-append "\nport " (kl:shen.app (kl:value (quote *port*)) (string-append " ported by " (kl:shen.app (kl:value (quote *porters*)) "\n" (quote shen.a))) (quote shen.a))) (kl:stoutput)))))) (quote shen.credits))
(begin (register-function-arity (quote shen.initialise_environment) 0) (define (kl:shen.initialise_environment) (kl:shen.multiple-set (cons (quote shen.*call*) (cons 0 (cons (quote shen.*infs*) (cons 0 (cons (quote shen.*process-counter*) (cons 0 (cons (quote shen.*catch*) (cons 0 (quote ()))))))))))) (quote shen.initialise_environment))
(begin (register-function-arity (quote shen.multiple-set) 1) (define (kl:shen.multiple-set V3802) (cond ((null? V3802) (quote ())) ((and (pair? V3802) (pair? (cdr V3802))) (begin (kl:set (car V3802) (car (cdr V3802))) (kl:shen.multiple-set (cdr (cdr V3802))))) (#t (kl:shen.f_error (quote shen.multiple-set))))) (quote shen.multiple-set))
(begin (register-function-arity (quote destroy) 1) (define (kl:destroy V3804) (kl:declare V3804 (quote symbol))) (quote destroy))
(kl:set (quote shen.*history*) (quote ()))
(begin (register-function-arity (quote shen.read-evaluate-print) 0) (define (kl:shen.read-evaluate-print) (let ((Lineread (kl:shen.toplineread))) (let ((History (kl:value (quote shen.*history*)))) (let ((NewLineread (kl:shen.retrieve-from-history-if-needed Lineread History))) (let ((NewHistory (kl:shen.update_history NewLineread History))) (let ((Parsed (kl:fst NewLineread))) (kl:shen.toplevel Parsed))))))) (quote shen.read-evaluate-print))
(begin (register-function-arity (quote shen.retrieve-from-history-if-needed) 2) (define (kl:shen.retrieve-from-history-if-needed V3816 V3817) (cond ((and (kl:tuple? V3816) (and (pair? (kl:snd V3816)) (kl:element? (car (kl:snd V3816)) (cons (kl:shen.space) (cons (kl:shen.newline) (quote ())))))) (kl:shen.retrieve-from-history-if-needed (kl:_waspvm_at_p (kl:fst V3816) (cdr (kl:snd V3816))) V3817)) ((and (kl:tuple? V3816) (and (pair? (kl:snd V3816)) (and (pair? (cdr (kl:snd V3816))) (and (null? (cdr (cdr (kl:snd V3816)))) (and (pair? V3817) (and (kl:= (car (kl:snd V3816)) (kl:shen.exclamation)) (kl:= (car (cdr (kl:snd V3816))) (kl:shen.exclamation)))))))) (let ((PastPrint (kl:shen.prbytes (kl:snd (car V3817))))) (car V3817))) ((and (kl:tuple? V3816) (and (pair? (kl:snd V3816)) (kl:= (car (kl:snd V3816)) (kl:shen.exclamation)))) (let ((Key? (kl:shen.make-key (cdr (kl:snd V3816)) V3817))) (let ((Find (kl:head (kl:shen.find-past-inputs Key? V3817)))) (let ((PastPrint (kl:shen.prbytes (kl:snd Find)))) Find)))) ((and (kl:tuple? V3816) (and (pair? (kl:snd V3816)) (and (null? (cdr (kl:snd V3816))) (kl:= (car (kl:snd V3816)) (kl:shen.percent))))) (begin (kl:shen.print-past-inputs (lambda (X) #t) (kl:reverse V3817) 0) (kl:abort))) ((and (kl:tuple? V3816) (and (pair? (kl:snd V3816)) (kl:= (car (kl:snd V3816)) (kl:shen.percent)))) (let ((Key? (kl:shen.make-key (cdr (kl:snd V3816)) V3817))) (let ((Pastprint (kl:shen.print-past-inputs Key? (kl:reverse V3817) 0))) (kl:abort)))) (#t V3816))) (quote shen.retrieve-from-history-if-needed))
(begin (register-function-arity (quote shen.percent) 0) (define (kl:shen.percent) 37) (quote shen.percent))
(begin (register-function-arity (quote shen.exclamation) 0) (define (kl:shen.exclamation) 33) (quote shen.exclamation))
(begin (register-function-arity (quote shen.prbytes) 1) (define (kl:shen.prbytes V3819) (begin (kl:for-each (lambda (Byte) (kl:pr (make-string 1 Byte) (kl:stoutput))) V3819) (kl:nl 1))) (quote shen.prbytes))
(begin (register-function-arity (quote shen.update_history) 2) (define (kl:shen.update_history V3822 V3823) (kl:set (quote shen.*history*) (cons V3822 V3823))) (quote shen.update_history))
(begin (register-function-arity (quote shen.toplineread) 0) (define (kl:shen.toplineread) (kl:shen.toplineread_loop (kl:read-char-code (kl:stinput)) (quote ()))) (quote shen.toplineread))
(begin (register-function-arity (quote shen.toplineread_loop) 2) (define (kl:shen.toplineread_loop V3827 V3828) (cond ((and (kl:= -1 V3827) (null? V3828)) (kl:exit 0)) ((kl:= V3827 (kl:shen.hat)) (simple-error "line read aborted")) ((kl:element? V3827 (cons (kl:shen.newline) (cons (kl:shen.carriage-return) (quote ())))) (let ((Line (kl:compile (lambda (X) (kl:shen.<st_input> X)) V3828 (lambda (E) (quote shen.nextline))))) (let ((It (kl:shen.record-it V3828))) (if (or (eq? Line (quote shen.nextline)) (kl:empty? Line)) (kl:shen.toplineread_loop (kl:read-char-code (kl:stinput)) (kl:append V3828 (cons V3827 (quote ())))) (kl:_waspvm_at_p Line V3828))))) (#t (kl:shen.toplineread_loop (kl:read-char-code (kl:stinput)) (if (kl:= V3827 -1) V3828 (kl:append V3828 (cons V3827 (quote ())))))))) (quote shen.toplineread_loop))
(begin (register-function-arity (quote shen.hat) 0) (define (kl:shen.hat) 94) (quote shen.hat))
(begin (register-function-arity (quote shen.newline) 0) (define (kl:shen.newline) 10) (quote shen.newline))
(begin (register-function-arity (quote shen.carriage-return) 0) (define (kl:shen.carriage-return) 13) (quote shen.carriage-return))
(begin (register-function-arity (quote tc) 1) (define (kl:tc V3834) (cond ((eq? (quote +) V3834) (kl:set (quote shen.*tc*) #t)) ((eq? (quote -) V3834) (kl:set (quote shen.*tc*) #f)) (#t (simple-error "tc expects a + or -")))) (quote tc))
(begin (register-function-arity (quote shen.prompt) 0) (define (kl:shen.prompt) (if (assert-boolean (kl:value (quote shen.*tc*))) (kl:shen.prhush (string-append "\n\n(" (kl:shen.app (kl:length (kl:value (quote shen.*history*))) "+) " (quote shen.a))) (kl:stoutput)) (kl:shen.prhush (string-append "\n\n(" (kl:shen.app (kl:length (kl:value (quote shen.*history*))) "-) " (quote shen.a))) (kl:stoutput)))) (quote shen.prompt))
(begin (register-function-arity (quote shen.toplevel) 1) (define (kl:shen.toplevel V3836) (kl:shen.toplevel_evaluate V3836 (kl:value (quote shen.*tc*)))) (quote shen.toplevel))
(begin (register-function-arity (quote shen.find-past-inputs) 2) (define (kl:shen.find-past-inputs V3839 V3840) (let ((F (kl:shen.find V3839 V3840))) (if (kl:empty? F) (simple-error "input not found\n") F))) (quote shen.find-past-inputs))
(begin (register-function-arity (quote shen.make-key) 2) (define (kl:shen.make-key V3843 V3844) (let ((Atom (car (kl:compile (lambda (X) (kl:shen.<st_input> X)) V3843 (lambda (E) (if (pair? E) (simple-error (string-append "parse error here: " (kl:shen.app E "\n" (quote shen.s)))) (simple-error "parse error\n"))))))) (if (assert-boolean (kl:integer? Atom)) (lambda (X) (kl:= X (kl:nth (+ Atom 1) (kl:reverse V3844)))) (lambda (X) (kl:shen.prefix? V3843 (kl:shen.trim-gubbins (kl:snd X))))))) (quote shen.make-key))
(begin (register-function-arity (quote shen.trim-gubbins) 1) (define (kl:shen.trim-gubbins V3846) (cond ((and (pair? V3846) (kl:= (car V3846) (kl:shen.space))) (kl:shen.trim-gubbins (cdr V3846))) ((and (pair? V3846) (kl:= (car V3846) (kl:shen.newline))) (kl:shen.trim-gubbins (cdr V3846))) ((and (pair? V3846) (kl:= (car V3846) (kl:shen.carriage-return))) (kl:shen.trim-gubbins (cdr V3846))) ((and (pair? V3846) (kl:= (car V3846) (kl:shen.tab))) (kl:shen.trim-gubbins (cdr V3846))) ((and (pair? V3846) (kl:= (car V3846) (kl:shen.left-round))) (kl:shen.trim-gubbins (cdr V3846))) (#t V3846))) (quote shen.trim-gubbins))
(begin (register-function-arity (quote shen.space) 0) (define (kl:shen.space) 32) (quote shen.space))
(begin (register-function-arity (quote shen.tab) 0) (define (kl:shen.tab) 9) (quote shen.tab))
(begin (register-function-arity (quote shen.left-round) 0) (define (kl:shen.left-round) 40) (quote shen.left-round))
(begin (register-function-arity (quote shen.find) 2) (define (kl:shen.find V3855 V3856) (cond ((null? V3856) (quote ())) ((and (pair? V3856) (assert-boolean (V3855 (car V3856)))) (cons (car V3856) (kl:shen.find V3855 (cdr V3856)))) ((pair? V3856) (kl:shen.find V3855 (cdr V3856))) (#t (kl:shen.f_error (quote shen.find))))) (quote shen.find))
(begin (register-function-arity (quote shen.prefix?) 2) (define (kl:shen.prefix? V3870 V3871) (cond ((null? V3870) #t) ((and (pair? V3870) (and (pair? V3871) (kl:= (car V3871) (car V3870)))) (kl:shen.prefix? (cdr V3870) (cdr V3871))) (#t #f))) (quote shen.prefix?))
(begin (register-function-arity (quote shen.print-past-inputs) 3) (define (kl:shen.print-past-inputs V3883 V3884 V3885) (cond ((null? V3884) (quote _)) ((and (pair? V3884) (kl:not (V3883 (car V3884)))) (kl:shen.print-past-inputs V3883 (cdr V3884) (+ V3885 1))) ((and (pair? V3884) (kl:tuple? (car V3884))) (begin (kl:shen.prhush (kl:shen.app V3885 ". " (quote shen.a)) (kl:stoutput)) (begin (kl:shen.prbytes (kl:snd (car V3884))) (kl:shen.print-past-inputs V3883 (cdr V3884) (+ V3885 1))))) (#t (kl:shen.f_error (quote shen.print-past-inputs))))) (quote shen.print-past-inputs))
(begin (register-function-arity (quote shen.toplevel_evaluate) 2) (define (kl:shen.toplevel_evaluate V3888 V3889) (cond ((and (pair? V3888) (and (pair? (cdr V3888)) (and (eq? (quote :) (car (cdr V3888))) (and (pair? (cdr (cdr V3888))) (and (null? (cdr (cdr (cdr V3888)))) (kl:= #t V3889)))))) (kl:shen.typecheck-and-evaluate (car V3888) (car (cdr (cdr V3888))))) ((and (pair? V3888) (pair? (cdr V3888))) (begin (kl:shen.toplevel_evaluate (cons (car V3888) (quote ())) V3889) (begin (kl:nl 1) (kl:shen.toplevel_evaluate (cdr V3888) V3889)))) ((and (pair? V3888) (and (null? (cdr V3888)) (kl:= #t V3889))) (kl:shen.typecheck-and-evaluate (car V3888) (kl:gensym (quote A)))) ((and (pair? V3888) (and (null? (cdr V3888)) (kl:= #f V3889))) (let ((Eval (kl:shen.eval-without-macros (car V3888)))) (kl:print Eval))) (#t (kl:shen.f_error (quote shen.toplevel_evaluate))))) (quote shen.toplevel_evaluate))
(begin (register-function-arity (quote shen.typecheck-and-evaluate) 2) (define (kl:shen.typecheck-and-evaluate V3892 V3893) (let ((Typecheck (kl:shen.typecheck V3892 V3893))) (if (kl:= Typecheck #f) (simple-error "type error\n") (let ((Eval (kl:shen.eval-without-macros V3892))) (let ((Type (kl:shen.pretty-type Typecheck))) (kl:shen.prhush (kl:shen.app Eval (string-append " : " (kl:shen.app Type "" (quote shen.r))) (quote shen.s)) (kl:stoutput))))))) (quote shen.typecheck-and-evaluate))
(begin (register-function-arity (quote shen.pretty-type) 1) (define (kl:shen.pretty-type V3895) (kl:shen.mult_subst (kl:value (quote shen.*alphabet*)) (kl:shen.extract-pvars V3895) V3895)) (quote shen.pretty-type))
(begin (register-function-arity (quote shen.extract-pvars) 1) (define (kl:shen.extract-pvars V3901) (cond ((assert-boolean (kl:shen.pvar? V3901)) (cons V3901 (quote ()))) ((pair? V3901) (kl:union (kl:shen.extract-pvars (car V3901)) (kl:shen.extract-pvars (cdr V3901)))) (#t (quote ())))) (quote shen.extract-pvars))
(begin (register-function-arity (quote shen.mult_subst) 3) (define (kl:shen.mult_subst V3909 V3910 V3911) (cond ((null? V3909) V3911) ((null? V3910) V3911) ((and (pair? V3909) (pair? V3910)) (kl:shen.mult_subst (cdr V3909) (cdr V3910) (kl:subst (car V3909) (car V3910) V3911))) (#t (kl:shen.f_error (quote shen.mult_subst))))) (quote shen.mult_subst))
