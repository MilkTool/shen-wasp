(module "compiled/sys.kl")
"Copyright (c) 2010-2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
(begin (register-function-arity (quote thaw) 1) (define (kl:thaw V3023) (V3023)) (export thaw) (quote thaw))
(begin (register-function-arity (quote eval) 1) (define (kl:eval V3025) (let ((Macroexpand (kl:shen.walk (lambda (Y) (kl:macroexpand Y)) V3025))) (if (assert-boolean (kl:shen.packaged? Macroexpand)) (kl:map (lambda (Z) (kl:shen.eval-without-macros Z)) (kl:shen.package-contents Macroexpand)) (kl:shen.eval-without-macros Macroexpand)))) (export eval) (quote eval))
(begin (register-function-arity (quote shen.eval-without-macros) 1) (define (kl:shen.eval-without-macros V3027) (kl:eval-kl (kl:shen.elim-def (kl:shen.proc-input+ V3027)))) (export shen.eval-without-macros) (quote shen.eval-without-macros))
(begin (register-function-arity (quote shen.proc-input+) 1) (define (kl:shen.proc-input+ V3029) (cond ((and (pair? V3029) (and (eq? (quote input+) (car V3029)) (and (pair? (cdr V3029)) (and (pair? (cdr (cdr V3029))) (null? (cdr (cdr (cdr V3029)))))))) (cons (quote input+) (cons (kl:shen.rcons_form (car (cdr V3029))) (cdr (cdr V3029))))) ((and (pair? V3029) (and (eq? (quote shen.read+) (car V3029)) (and (pair? (cdr V3029)) (and (pair? (cdr (cdr V3029))) (null? (cdr (cdr (cdr V3029)))))))) (cons (quote shen.read+) (cons (kl:shen.rcons_form (car (cdr V3029))) (cdr (cdr V3029))))) ((pair? V3029) (kl:map (lambda (Z) (kl:shen.proc-input+ Z)) V3029)) (#t V3029))) (export shen.proc-input+) (quote shen.proc-input+))
(begin (register-function-arity (quote shen.elim-def) 1) (define (kl:shen.elim-def V3031) (cond ((and (pair? V3031) (and (eq? (quote define) (car V3031)) (pair? (cdr V3031)))) (kl:shen.shen->kl (car (cdr V3031)) (cdr (cdr V3031)))) ((and (pair? V3031) (and (eq? (quote defmacro) (car V3031)) (pair? (cdr V3031)))) (let ((Default (cons (quote X) (cons (quote ->) (cons (quote X) (quote ())))))) (let ((Def (kl:shen.elim-def (cons (quote define) (cons (car (cdr V3031)) (kl:append (cdr (cdr V3031)) Default)))))) (let ((MacroAdd (kl:shen.add-macro (car (cdr V3031))))) Def)))) ((and (pair? V3031) (and (eq? (quote defcc) (car V3031)) (pair? (cdr V3031)))) (kl:shen.elim-def (kl:shen.yacc V3031))) ((pair? V3031) (kl:map (lambda (Z) (kl:shen.elim-def Z)) V3031)) (#t V3031))) (export shen.elim-def) (quote shen.elim-def))
(begin (register-function-arity (quote shen.add-macro) 1) (define (kl:shen.add-macro V3033) (let ((MacroReg (kl:value (quote shen.*macroreg*)))) (let ((NewMacroReg (kl:set (quote shen.*macroreg*) (kl:adjoin V3033 (kl:value (quote shen.*macroreg*)))))) (if (kl:= MacroReg NewMacroReg) (quote shen.skip) (kl:set (quote *macros*) (cons (kl:function V3033) (kl:value (quote *macros*)))))))) (export shen.add-macro) (quote shen.add-macro))
(begin (register-function-arity (quote shen.packaged?) 1) (define (kl:shen.packaged? V3041) (cond ((and (pair? V3041) (and (eq? (quote package) (car V3041)) (and (pair? (cdr V3041)) (pair? (cdr (cdr V3041)))))) #t) (#t #f))) (export shen.packaged?) (quote shen.packaged?))
(begin (register-function-arity (quote external) 1) (define (kl:external V3043) (guard (lambda (E) (simple-error (string-append "package " (kl:shen.app V3043 " has not been used.\n" (quote shen.a))))) (kl:get V3043 (quote shen.external-symbols) (kl:value (quote *property-vector*))))) (export external) (quote external))
(begin (register-function-arity (quote internal) 1) (define (kl:internal V3045) (guard (lambda (E) (simple-error (string-append "package " (kl:shen.app V3045 " has not been used.\n" (quote shen.a))))) (kl:get V3045 (quote shen.internal-symbols) (kl:value (quote *property-vector*))))) (export internal) (quote internal))
(begin (register-function-arity (quote shen.package-contents) 1) (define (kl:shen.package-contents V3049) (cond ((and (pair? V3049) (and (eq? (quote package) (car V3049)) (and (pair? (cdr V3049)) (and (eq? (quote null) (car (cdr V3049))) (pair? (cdr (cdr V3049))))))) (cdr (cdr (cdr V3049)))) ((and (pair? V3049) (and (eq? (quote package) (car V3049)) (and (pair? (cdr V3049)) (pair? (cdr (cdr V3049)))))) (let ((PackageNameDot (kl:intern (string-append (kl:str (car (cdr V3049))) ".")))) (let ((ExpPackageNameDot (kl:explode PackageNameDot))) (kl:shen.packageh (car (cdr V3049)) (car (cdr (cdr V3049))) (cdr (cdr (cdr V3049))) ExpPackageNameDot)))) (#t (kl:shen.f_error (quote shen.package-contents))))) (export shen.package-contents) (quote shen.package-contents))
(begin (register-function-arity (quote shen.walk) 2) (define (kl:shen.walk V3052 V3053) (cond ((pair? V3053) (V3052 (kl:map (lambda (Z) (kl:shen.walk V3052 Z)) V3053))) (#t (V3052 V3053)))) (export shen.walk) (quote shen.walk))
(begin (register-function-arity (quote compile) 3) (define (kl:compile V3057 V3058 V3059) (let ((O (V3057 (cons V3058 (cons (quote ()) (quote ())))))) (if (or (kl:= (kl:fail) O) (kl:not (kl:empty? (car O)))) (V3059 O) (kl:shen.hdtl O)))) (export compile) (quote compile))
(begin (register-function-arity (quote fail-if) 2) (define (kl:fail-if V3062 V3063) (if (assert-boolean (V3062 V3063)) (kl:fail) V3063)) (export fail-if) (quote fail-if))
(begin (register-function-arity (quote _waspvm_at_s) 2) (define (kl:_waspvm_at_s V3066 V3067) (string-append V3066 V3067)) (export _waspvm_at_s) (quote _waspvm_at_s))
(begin (register-function-arity (quote tc?) 0) (define (kl:tc?) (kl:value (quote shen.*tc*))) (export tc?) (quote tc?))
(begin (register-function-arity (quote ps) 1) (define (kl:ps V3069) (guard (lambda (E) (simple-error (kl:shen.app V3069 " not found.\n" (quote shen.a)))) (kl:get V3069 (quote shen.source) (kl:value (quote *property-vector*))))) (export ps) (quote ps))
(begin (register-function-arity (quote stinput) 0) (define (kl:stinput) (kl:value (quote *stinput*))) (export stinput) (quote stinput))
(begin (register-function-arity (quote vector) 1) (define (kl:vector V3071) (let ((Vector (make-vector (+ V3071 1) (quote (quote shen.fail!))))) (let ((ZeroStamp (let ((_tmp Vector)) (vector-set! _tmp 0 V3071) _tmp))) (let ((Standard (if (kl:= V3071 0) ZeroStamp (kl:shen.fillvector ZeroStamp 1 V3071 (kl:fail))))) Standard)))) (export vector) (quote vector))
(begin (register-function-arity (quote shen.fillvector) 4) (define (kl:shen.fillvector V3077 V3078 V3079 V3080) (cond ((kl:= V3079 V3078) (let ((_tmp V3077)) (vector-set! _tmp V3079 V3080) _tmp)) (#t (kl:shen.fillvector (let ((_tmp V3077)) (vector-set! _tmp V3078 V3080) _tmp) (+ 1 V3078) V3079 V3080)))) (export shen.fillvector) (quote shen.fillvector))
(begin (register-function-arity (quote vector?) 1) (define (kl:vector? V3082) (and (vector? V3082) (assert-boolean (let ((X (guard (lambda (E) -1) (vector-ref V3082 0)))) (and (number? X) (>= X 0)))))) (export vector?) (quote vector?))
(begin (register-function-arity (quote vector->) 3) (define (kl:vector-> V3086 V3087 V3088) (if (kl:= V3087 0) (simple-error "cannot access 0th element of a vector\n") (let ((_tmp V3086)) (vector-set! _tmp V3087 V3088) _tmp))) (export vector->) (quote vector->))
(begin (register-function-arity (quote <-vector) 2) (define (kl:<-vector V3091 V3092) (if (kl:= V3092 0) (simple-error "cannot access 0th element of a vector\n") (let ((VectorElement (vector-ref V3091 V3092))) (if (kl:= VectorElement (kl:fail)) (simple-error "vector element not found\n") VectorElement)))) (export <-vector) (quote <-vector))
(begin (register-function-arity (quote shen.posint?) 1) (define (kl:shen.posint? V3094) (and (assert-boolean (kl:integer? V3094)) (>= V3094 0))) (export shen.posint?) (quote shen.posint?))
(begin (register-function-arity (quote limit) 1) (define (kl:limit V3096) (vector-ref V3096 0)) (export limit) (quote limit))
(begin (register-function-arity (quote symbol?) 1) (define (kl:symbol? V3098) (cond ((or (kl:boolean? V3098) (or (number? V3098) (string? V3098))) #f) (#t (guard (lambda (E) #f) (let ((String (kl:str V3098))) (kl:shen.analyse-symbol? String)))))) (export symbol?) (quote symbol?))
(begin (register-function-arity (quote shen.analyse-symbol?) 1) (define (kl:shen.analyse-symbol? V3100) (cond ((equal? "" V3100) #f) ((assert-boolean (kl:shen.+string? V3100)) (and (assert-boolean (kl:shen.alpha? (make-string 1 (string-ref V3100 0)))) (assert-boolean (kl:shen.alphanums? (string-tail V3100 1))))) (#t (kl:shen.f_error (quote shen.analyse-symbol?))))) (export shen.analyse-symbol?) (quote shen.analyse-symbol?))
(begin (register-function-arity (quote shen.alpha?) 1) (define (kl:shen.alpha? V3102) (kl:element? V3102 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" (cons "a" (cons "b" (cons "c" (cons "d" (cons "e" (cons "f" (cons "g" (cons "h" (cons "i" (cons "j" (cons "k" (cons "l" (cons "m" (cons "n" (cons "o" (cons "p" (cons "q" (cons "r" (cons "s" (cons "t" (cons "u" (cons "v" (cons "w" (cons "x" (cons "y" (cons "z" (cons "=" (cons "*" (cons "/" (cons "+" (cons "-" (cons "_" (cons "?" (cons "$" (cons "!" (cons "@" (cons "~" (cons ">" (cons "<" (cons "&" (cons "%" (cons "{" (cons "}" (cons ":" (cons ";" (cons "`" (cons "#" (cons "'" (cons "." (quote ())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (export shen.alpha?) (quote shen.alpha?))
(begin (register-function-arity (quote shen.alphanums?) 1) (define (kl:shen.alphanums? V3104) (cond ((equal? "" V3104) #t) ((assert-boolean (kl:shen.+string? V3104)) (and (assert-boolean (kl:shen.alphanum? (make-string 1 (string-ref V3104 0)))) (assert-boolean (kl:shen.alphanums? (string-tail V3104 1))))) (#t (kl:shen.f_error (quote shen.alphanums?))))) (export shen.alphanums?) (quote shen.alphanums?))
(begin (register-function-arity (quote shen.alphanum?) 1) (define (kl:shen.alphanum? V3106) (or (assert-boolean (kl:shen.alpha? V3106)) (assert-boolean (kl:shen.digit? V3106)))) (export shen.alphanum?) (quote shen.alphanum?))
(begin (register-function-arity (quote shen.digit?) 1) (define (kl:shen.digit? V3108) (kl:element? V3108 (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" (quote ()))))))))))))) (export shen.digit?) (quote shen.digit?))
(begin (register-function-arity (quote variable?) 1) (define (kl:variable? V3110) (cond ((or (kl:boolean? V3110) (or (number? V3110) (string? V3110))) #f) (#t (guard (lambda (E) #f) (let ((String (kl:str V3110))) (kl:shen.analyse-variable? String)))))) (export variable?) (quote variable?))
(begin (register-function-arity (quote shen.analyse-variable?) 1) (define (kl:shen.analyse-variable? V3112) (cond ((assert-boolean (kl:shen.+string? V3112)) (and (assert-boolean (kl:shen.uppercase? (make-string 1 (string-ref V3112 0)))) (assert-boolean (kl:shen.alphanums? (string-tail V3112 1))))) (#t (kl:shen.f_error (quote shen.analyse-variable?))))) (export shen.analyse-variable?) (quote shen.analyse-variable?))
(begin (register-function-arity (quote shen.uppercase?) 1) (define (kl:shen.uppercase? V3114) (kl:element? V3114 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" (quote ()))))))))))))))))))))))))))))) (export shen.uppercase?) (quote shen.uppercase?))
(begin (register-function-arity (quote gensym) 1) (define (kl:gensym V3116) (kl:concat V3116 (kl:set (quote shen.*gensym*) (+ 1 (kl:value (quote shen.*gensym*)))))) (export gensym) (quote gensym))
(begin (register-function-arity (quote concat) 2) (define (kl:concat V3119 V3120) (kl:intern (string-append (kl:str V3119) (kl:str V3120)))) (export concat) (quote concat))
(begin (register-function-arity (quote _waspvm_at_p) 2) (define (kl:_waspvm_at_p V3123 V3124) (let ((Vector (make-vector 3 (quote (quote shen.fail!))))) (let ((Tag (let ((_tmp Vector)) (vector-set! _tmp 0 (quote shen.tuple)) _tmp))) (let ((Fst (let ((_tmp Vector)) (vector-set! _tmp 1 V3123) _tmp))) (let ((Snd (let ((_tmp Vector)) (vector-set! _tmp 2 V3124) _tmp))) Vector))))) (export _waspvm_at_p) (quote _waspvm_at_p))
(begin (register-function-arity (quote fst) 1) (define (kl:fst V3126) (vector-ref V3126 1)) (export fst) (quote fst))
(begin (register-function-arity (quote snd) 1) (define (kl:snd V3128) (vector-ref V3128 2)) (export snd) (quote snd))
(begin (register-function-arity (quote tuple?) 1) (define (kl:tuple? V3130) (and (vector? V3130) (eq? (quote shen.tuple) (guard (lambda (E) (quote shen.not-tuple)) (vector-ref V3130 0))))) (export tuple?) (quote tuple?))
(begin (register-function-arity (quote append) 2) (define (kl:append V3133 V3134) (cond ((null? V3133) V3134) ((pair? V3133) (cons (car V3133) (kl:append (cdr V3133) V3134))) (#t (kl:shen.f_error (quote append))))) (export append) (quote append))
(begin (register-function-arity (quote _waspvm_at_v) 2) (define (kl:_waspvm_at_v V3137 V3138) (let ((Limit (kl:limit V3138))) (let ((NewVector (kl:vector (+ Limit 1)))) (let ((X+NewVector (kl:vector-> NewVector 1 V3137))) (if (kl:= Limit 0) X+NewVector (kl:shen._waspvm_at_v-help V3138 1 Limit X+NewVector)))))) (export _waspvm_at_v) (quote _waspvm_at_v))
(begin (register-function-arity (quote shen._waspvm_at_v-help) 4) (define (kl:shen._waspvm_at_v-help V3144 V3145 V3146 V3147) (cond ((kl:= V3146 V3145) (kl:shen.copyfromvector V3144 V3147 V3146 (+ V3146 1))) (#t (kl:shen._waspvm_at_v-help V3144 (+ V3145 1) V3146 (kl:shen.copyfromvector V3144 V3147 V3145 (+ V3145 1)))))) (export shen._waspvm_at_v-help) (quote shen._waspvm_at_v-help))
(begin (register-function-arity (quote shen.copyfromvector) 4) (define (kl:shen.copyfromvector V3152 V3153 V3154 V3155) (guard (lambda (E) V3153) (kl:vector-> V3153 V3155 (kl:<-vector V3152 V3154)))) (export shen.copyfromvector) (quote shen.copyfromvector))
(begin (register-function-arity (quote hdv) 1) (define (kl:hdv V3157) (guard (lambda (E) (simple-error (string-append "hdv needs a non-empty vector as an argument; not " (kl:shen.app V3157 "\n" (quote shen.s))))) (kl:<-vector V3157 1))) (export hdv) (quote hdv))
(begin (register-function-arity (quote tlv) 1) (define (kl:tlv V3159) (let ((Limit (kl:limit V3159))) (if (kl:= Limit 0) (simple-error "cannot take the tail of the empty vector\n") (if (kl:= Limit 1) (kl:vector 0) (let ((NewVector (kl:vector (- Limit 1)))) (kl:shen.tlv-help V3159 2 Limit (kl:vector (- Limit 1)))))))) (export tlv) (quote tlv))
(begin (register-function-arity (quote shen.tlv-help) 4) (define (kl:shen.tlv-help V3165 V3166 V3167 V3168) (cond ((kl:= V3167 V3166) (kl:shen.copyfromvector V3165 V3168 V3167 (- V3167 1))) (#t (kl:shen.tlv-help V3165 (+ V3166 1) V3167 (kl:shen.copyfromvector V3165 V3168 V3166 (- V3166 1)))))) (export shen.tlv-help) (quote shen.tlv-help))
(begin (register-function-arity (quote assoc) 2) (define (kl:assoc V3180 V3181) (cond ((null? V3181) (quote ())) ((and (pair? V3181) (and (pair? (car V3181)) (kl:= (car (car V3181)) V3180))) (car V3181)) ((pair? V3181) (kl:assoc V3180 (cdr V3181))) (#t (kl:shen.f_error (quote assoc))))) (export assoc) (quote assoc))
(begin (register-function-arity (quote shen.assoc-set) 3) (define (kl:shen.assoc-set V3188 V3189 V3190) (cond ((null? V3190) (cons (cons V3188 V3189) (quote ()))) ((and (pair? V3190) (and (pair? (car V3190)) (kl:= (car (car V3190)) V3188))) (cons (cons (car (car V3190)) V3189) (cdr V3190))) ((pair? V3190) (cons (car V3190) (kl:shen.assoc-set V3188 V3189 (cdr V3190)))) (#t (kl:shen.f_error (quote shen.assoc-set))))) (export shen.assoc-set) (quote shen.assoc-set))
(begin (register-function-arity (quote shen.assoc-rm) 2) (define (kl:shen.assoc-rm V3196 V3197) (cond ((null? V3197) (quote ())) ((and (pair? V3197) (and (pair? (car V3197)) (kl:= (car (car V3197)) V3196))) (cdr V3197)) ((pair? V3197) (cons (car V3197) (kl:shen.assoc-rm V3196 (cdr V3197)))) (#t (kl:shen.f_error (quote shen.assoc-rm))))) (export shen.assoc-rm) (quote shen.assoc-rm))
(begin (register-function-arity (quote boolean?) 1) (define (kl:boolean? V3203) (cond ((kl:= #t V3203) #t) ((kl:= #f V3203) #t) (#t #f))) (export boolean?) (quote boolean?))
(begin (register-function-arity (quote nl) 1) (define (kl:nl V3205) (cond ((kl:= 0 V3205) 0) (#t (begin (kl:shen.prhush "\n" (kl:stoutput)) (kl:nl (- V3205 1)))))) (export nl) (quote nl))
(begin (register-function-arity (quote difference) 2) (define (kl:difference V3210 V3211) (cond ((null? V3210) (quote ())) ((pair? V3210) (if (kl:element? (car V3210) V3211) (kl:difference (cdr V3210) V3211) (cons (car V3210) (kl:difference (cdr V3210) V3211)))) (#t (kl:shen.f_error (quote difference))))) (export difference) (quote difference))
(begin (register-function-arity (quote do) 2) (define (kl:do V3214 V3215) V3215) (export do) (quote do))
(begin (register-function-arity (quote element?) 2) (define (kl:element? V3227 V3228) (cond ((null? V3228) #f) ((and (pair? V3228) (kl:= (car V3228) V3227)) #t) ((pair? V3228) (kl:element? V3227 (cdr V3228))) (#t (kl:shen.f_error (quote element?))))) (export element?) (quote element?))
(begin (register-function-arity (quote empty?) 1) (define (kl:empty? V3234) (cond ((null? V3234) #t) (#t #f))) (export empty?) (quote empty?))
(begin (register-function-arity (quote fix) 2) (define (kl:fix V3237 V3238) (kl:shen.fix-help V3237 V3238 (V3237 V3238))) (export fix) (quote fix))
(begin (register-function-arity (quote shen.fix-help) 3) (define (kl:shen.fix-help V3249 V3250 V3251) (cond ((kl:= V3251 V3250) V3251) (#t (kl:shen.fix-help V3249 V3251 (V3249 V3251))))) (export shen.fix-help) (quote shen.fix-help))
(begin (register-function-arity (quote put) 4) (define (kl:put V3256 V3257 V3258 V3259) (let ((Curr (guard (lambda (E) (quote ())) (kl:shen.<-dict V3259 V3256)))) (let ((Added (kl:shen.assoc-set V3257 V3258 Curr))) (let ((Update (kl:shen.dict-> V3259 V3256 Added))) V3258)))) (export put) (quote put))
(begin (register-function-arity (quote unput) 3) (define (kl:unput V3263 V3264 V3265) (let ((Curr (guard (lambda (E) (quote ())) (kl:shen.<-dict V3265 V3263)))) (let ((Removed (kl:shen.assoc-rm V3264 Curr))) (let ((Update (kl:shen.dict-> V3265 V3263 Removed))) V3263)))) (export unput) (quote unput))
(begin (register-function-arity (quote get) 3) (define (kl:get V3269 V3270 V3271) (let ((Entry (guard (lambda (E) (quote ())) (kl:shen.<-dict V3271 V3269)))) (let ((Result (kl:assoc V3270 Entry))) (if (kl:empty? Result) (simple-error "value not found\n") (cdr Result))))) (export get) (quote get))
(begin (register-function-arity (quote hash) 2) (define (kl:hash V3274 V3275) (kl:shen.mod (kl:sum (kl:map (lambda (X) (string-ref X 0)) (kl:explode V3274))) V3275)) (export hash) (quote hash))
(begin (register-function-arity (quote shen.mod) 2) (define (kl:shen.mod V3278 V3279) (kl:shen.modh V3278 (kl:shen.multiples V3278 (cons V3279 (quote ()))))) (export shen.mod) (quote shen.mod))
(begin (register-function-arity (quote shen.multiples) 2) (define (kl:shen.multiples V3282 V3283) (cond ((and (pair? V3283) (> (car V3283) V3282)) (cdr V3283)) ((pair? V3283) (kl:shen.multiples V3282 (cons (* 2 (car V3283)) V3283))) (#t (kl:shen.f_error (quote shen.multiples))))) (export shen.multiples) (quote shen.multiples))
(begin (register-function-arity (quote shen.modh) 2) (define (kl:shen.modh V3288 V3289) (cond ((kl:= 0 V3288) 0) ((null? V3289) V3288) ((and (pair? V3289) (> (car V3289) V3288)) (if (kl:empty? (cdr V3289)) V3288 (kl:shen.modh V3288 (cdr V3289)))) ((pair? V3289) (kl:shen.modh (- V3288 (car V3289)) V3289)) (#t (kl:shen.f_error (quote shen.modh))))) (export shen.modh) (quote shen.modh))
(begin (register-function-arity (quote sum) 1) (define (kl:sum V3291) (cond ((null? V3291) 0) ((pair? V3291) (+ (car V3291) (kl:sum (cdr V3291)))) (#t (kl:shen.f_error (quote sum))))) (export sum) (quote sum))
(begin (register-function-arity (quote head) 1) (define (kl:head V3299) (cond ((pair? V3299) (car V3299)) (#t (simple-error "head expects a non-empty list")))) (export head) (quote head))
(begin (register-function-arity (quote tail) 1) (define (kl:tail V3307) (cond ((pair? V3307) (cdr V3307)) (#t (simple-error "tail expects a non-empty list")))) (export tail) (quote tail))
(begin (register-function-arity (quote hdstr) 1) (define (kl:hdstr V3309) (make-string 1 (string-ref V3309 0))) (export hdstr) (quote hdstr))
(begin (register-function-arity (quote intersection) 2) (define (kl:intersection V3314 V3315) (cond ((null? V3314) (quote ())) ((pair? V3314) (if (kl:element? (car V3314) V3315) (cons (car V3314) (kl:intersection (cdr V3314) V3315)) (kl:intersection (cdr V3314) V3315))) (#t (kl:shen.f_error (quote intersection))))) (export intersection) (quote intersection))
(begin (register-function-arity (quote reverse) 1) (define (kl:reverse V3317) (kl:shen.reverse_help V3317 (quote ()))) (export reverse) (quote reverse))
(begin (register-function-arity (quote shen.reverse_help) 2) (define (kl:shen.reverse_help V3320 V3321) (cond ((null? V3320) V3321) ((pair? V3320) (kl:shen.reverse_help (cdr V3320) (cons (car V3320) V3321))) (#t (kl:shen.f_error (quote shen.reverse_help))))) (export shen.reverse_help) (quote shen.reverse_help))
(begin (register-function-arity (quote union) 2) (define (kl:union V3324 V3325) (cond ((null? V3324) V3325) ((pair? V3324) (if (kl:element? (car V3324) V3325) (kl:union (cdr V3324) V3325) (cons (car V3324) (kl:union (cdr V3324) V3325)))) (#t (kl:shen.f_error (quote union))))) (export union) (quote union))
(begin (register-function-arity (quote y-or-n?) 1) (define (kl:y-or-n? V3327) (let ((Message (kl:shen.prhush (kl:shen.proc-nl V3327) (kl:stoutput)))) (let ((Y-or-N (kl:shen.prhush " (y/n) " (kl:stoutput)))) (let ((Input (kl:shen.app (kl:read (kl:stinput)) "" (quote shen.s)))) (if (equal? "y" Input) #t (if (equal? "n" Input) #f (begin (kl:shen.prhush "please answer y or n\n" (kl:stoutput)) (kl:y-or-n? V3327)))))))) (export y-or-n?) (quote y-or-n?))
(begin (register-function-arity (quote not) 1) (define (kl:not V3329) (if (assert-boolean V3329) #f #t)) (export not) (quote not))
(begin (register-function-arity (quote subst) 3) (define (kl:subst V3342 V3343 V3344) (cond ((kl:= V3344 V3343) V3342) ((pair? V3344) (kl:map (lambda (W) (kl:subst V3342 V3343 W)) V3344)) (#t V3344))) (export subst) (quote subst))
(begin (register-function-arity (quote explode) 1) (define (kl:explode V3346) (kl:shen.explode-h (kl:shen.app V3346 "" (quote shen.a)))) (export explode) (quote explode))
(begin (register-function-arity (quote shen.explode-h) 1) (define (kl:shen.explode-h V3348) (cond ((equal? "" V3348) (quote ())) ((assert-boolean (kl:shen.+string? V3348)) (cons (make-string 1 (string-ref V3348 0)) (kl:shen.explode-h (string-tail V3348 1)))) (#t (kl:shen.f_error (quote shen.explode-h))))) (export shen.explode-h) (quote shen.explode-h))
(begin (register-function-arity (quote cd) 1) (define (kl:cd V3350) (kl:set (quote *home-directory*) (if (equal? V3350 "") "" (kl:shen.app V3350 "/" (quote shen.a))))) (export cd) (quote cd))
(begin (register-function-arity (quote shen.for-each) 2) (define (kl:shen.for-each V3353 V3354) (cond ((null? V3354) #t) ((pair? V3354) (let ((_ (V3353 (car V3354)))) (kl:shen.for-each V3353 (cdr V3354)))) (#t (kl:shen.f_error (quote shen.for-each))))) (export shen.for-each) (quote shen.for-each))
(begin (register-function-arity (quote map) 2) (define (kl:map V3359 V3360) (cond ((null? V3360) (quote ())) ((pair? V3360) (cons (V3359 (car V3360)) (kl:map V3359 (cdr V3360)))) (#t (V3359 V3360)))) (export map) (quote map))
(begin (register-function-arity (quote length) 1) (define (kl:length V3362) (kl:shen.length-h V3362 0)) (export length) (quote length))
(begin (register-function-arity (quote shen.length-h) 2) (define (kl:shen.length-h V3365 V3366) (cond ((null? V3365) V3366) (#t (kl:shen.length-h (cdr V3365) (+ V3366 1))))) (export shen.length-h) (quote shen.length-h))
(begin (register-function-arity (quote occurrences) 2) (define (kl:occurrences V3378 V3379) (cond ((kl:= V3379 V3378) 1) ((pair? V3379) (+ (kl:occurrences V3378 (car V3379)) (kl:occurrences V3378 (cdr V3379)))) (#t 0))) (export occurrences) (quote occurrences))
(begin (register-function-arity (quote nth) 2) (define (kl:nth V3386 V3387) (cond ((and (kl:= 1 V3386) (pair? V3387)) (car V3387)) ((pair? V3387) (kl:nth (- V3386 1) (cdr V3387))) (#t (simple-error (string-append "nth applied to " (kl:shen.app V3386 (string-append ", " (kl:shen.app V3387 "\n" (quote shen.a))) (quote shen.a))))))) (export nth) (quote nth))
(begin (register-function-arity (quote integer?) 1) (define (kl:integer? V3389) (and (number? V3389) (assert-boolean (let ((Abs (kl:shen.abs V3389))) (kl:shen.integer-test? Abs (kl:shen.magless Abs 1)))))) (export integer?) (quote integer?))
(begin (register-function-arity (quote shen.abs) 1) (define (kl:shen.abs V3391) (if (> V3391 0) V3391 (- 0 V3391))) (export shen.abs) (quote shen.abs))
(begin (register-function-arity (quote shen.magless) 2) (define (kl:shen.magless V3394 V3395) (let ((Nx2 (* V3395 2))) (if (> Nx2 V3394) V3395 (kl:shen.magless V3394 Nx2)))) (export shen.magless) (quote shen.magless))
(begin (register-function-arity (quote shen.integer-test?) 2) (define (kl:shen.integer-test? V3401 V3402) (cond ((kl:= 0 V3401) #t) ((> 1 V3401) #f) (#t (let ((Abs-N (- V3401 V3402))) (if (> 0 Abs-N) (kl:integer? V3401) (kl:shen.integer-test? Abs-N V3402)))))) (export shen.integer-test?) (quote shen.integer-test?))
(begin (register-function-arity (quote mapcan) 2) (define (kl:mapcan V3407 V3408) (cond ((null? V3408) (quote ())) ((pair? V3408) (kl:append (V3407 (car V3408)) (kl:mapcan V3407 (cdr V3408)))) (#t (kl:shen.f_error (quote mapcan))))) (export mapcan) (quote mapcan))
(begin (register-function-arity (quote ==) 2) (define (kl:== V3420 V3421) (cond ((kl:= V3421 V3420) #t) (#t #f))) (export ==) (quote ==))
(begin (register-function-arity (quote abort) 0) (define (kl:abort) (simple-error "")) (export abort) (quote abort))
(begin (register-function-arity (quote bound?) 1) (define (kl:bound? V3423) (and (kl:symbol? V3423) (assert-boolean (let ((Val (guard (lambda (E) (quote shen.this-symbol-is-unbound)) (kl:value V3423)))) (if (eq? Val (quote shen.this-symbol-is-unbound)) #f #t))))) (export bound?) (quote bound?))
(begin (register-function-arity (quote shen.string->bytes) 1) (define (kl:shen.string->bytes V3425) (cond ((equal? "" V3425) (quote ())) (#t (cons (string-ref (make-string 1 (string-ref V3425 0)) 0) (kl:shen.string->bytes (string-tail V3425 1)))))) (export shen.string->bytes) (quote shen.string->bytes))
(begin (register-function-arity (quote maxinferences) 1) (define (kl:maxinferences V3427) (kl:set (quote shen.*maxinferences*) V3427)) (export maxinferences) (quote maxinferences))
(begin (register-function-arity (quote inferences) 0) (define (kl:inferences) (kl:value (quote shen.*infs*))) (export inferences) (quote inferences))
(begin (register-function-arity (quote protect) 1) (define (kl:protect V3429) V3429) (export protect) (quote protect))
(begin (register-function-arity (quote stoutput) 0) (define (kl:stoutput) (kl:value (quote *stoutput*))) (export stoutput) (quote stoutput))
(begin (register-function-arity (quote sterror) 0) (define (kl:sterror) (kl:value (quote *sterror*))) (export sterror) (quote sterror))
(begin (register-function-arity (quote string->symbol) 1) (define (kl:string->symbol V3431) (let ((Symbol (kl:intern V3431))) (if (kl:symbol? Symbol) Symbol (simple-error (string-append "cannot intern " (kl:shen.app V3431 " to a symbol" (quote shen.s))))))) (export string->symbol) (quote string->symbol))
(begin (register-function-arity (quote optimise) 1) (define (kl:optimise V3437) (cond ((eq? (quote +) V3437) (kl:set (quote shen.*optimise*) #t)) ((eq? (quote -) V3437) (kl:set (quote shen.*optimise*) #f)) (#t (simple-error "optimise expects a + or a -.\n")))) (export optimise) (quote optimise))
(begin (register-function-arity (quote os) 0) (define (kl:os) (kl:value (quote *os*))) (export os) (quote os))
(begin (register-function-arity (quote language) 0) (define (kl:language) (kl:value (quote *language*))) (export language) (quote language))
(begin (register-function-arity (quote version) 0) (define (kl:version) (kl:value (quote *version*))) (export version) (quote version))
(begin (register-function-arity (quote port) 0) (define (kl:port) (kl:value (quote *port*))) (export port) (quote port))
(begin (register-function-arity (quote porters) 0) (define (kl:porters) (kl:value (quote *porters*))) (export porters) (quote porters))
(begin (register-function-arity (quote implementation) 0) (define (kl:implementation) (kl:value (quote *implementation*))) (export implementation) (quote implementation))
(begin (register-function-arity (quote release) 0) (define (kl:release) (kl:value (quote *release*))) (export release) (quote release))
(begin (register-function-arity (quote package?) 1) (define (kl:package? V3439) (guard (lambda (E) #f) (begin (kl:external V3439) #t))) (export package?) (quote package?))
(begin (register-function-arity (quote function) 1) (define (kl:function V3441) (kl:shen.lookup-func V3441)) (export function) (quote function))
(begin (register-function-arity (quote shen.lookup-func) 1) (define (kl:shen.lookup-func V3443) (guard (lambda (E) (simple-error (kl:shen.app V3443 " has no lambda expansion\n" (quote shen.a)))) (kl:get V3443 (quote shen.lambda-form) (kl:value (quote *property-vector*))))) (export shen.lookup-func) (quote shen.lookup-func))
