"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote thaw) 1) (define (kl:thaw V2623) (V2623)) (quote thaw))
(begin (register-function-arity (quote eval) 1) (define (kl:eval V2625) (let ((Macroexpand (kl:shen.walk (lambda (Y) (kl:macroexpand Y)) V2625))) (if (assert-boolean (kl:shen.packaged? Macroexpand)) (kl:map (lambda (Z) (kl:shen.eval-without-macros Z)) (kl:shen.package-contents Macroexpand)) (kl:shen.eval-without-macros Macroexpand)))) (quote eval))
(begin (register-function-arity (quote shen.eval-without-macros) 1) (define (kl:shen.eval-without-macros V2627) (kl:eval-kl (kl:shen.elim-def (kl:shen.proc-input+ V2627)))) (quote shen.eval-without-macros))
(begin (register-function-arity (quote shen.proc-input+) 1) (define (kl:shen.proc-input+ V2629) (cond ((and (pair? V2629) (and (eq? (quote input+) (car V2629)) (and (pair? (cdr V2629)) (and (pair? (cdr (cdr V2629))) (null? (cdr (cdr (cdr V2629)))))))) (cons (quote input+) (cons (kl:shen.rcons_form (car (cdr V2629))) (cdr (cdr V2629))))) ((and (pair? V2629) (and (eq? (quote shen.read+) (car V2629)) (and (pair? (cdr V2629)) (and (pair? (cdr (cdr V2629))) (null? (cdr (cdr (cdr V2629)))))))) (cons (quote shen.read+) (cons (kl:shen.rcons_form (car (cdr V2629))) (cdr (cdr V2629))))) ((pair? V2629) (kl:map (lambda (Z) (kl:shen.proc-input+ Z)) V2629)) (#t V2629))) (quote shen.proc-input+))
(begin (register-function-arity (quote shen.elim-def) 1) (define (kl:shen.elim-def V2631) (cond ((and (pair? V2631) (and (eq? (quote define) (car V2631)) (pair? (cdr V2631)))) (kl:shen->kl (car (cdr V2631)) (cdr (cdr V2631)))) ((and (pair? V2631) (and (eq? (quote defmacro) (car V2631)) (pair? (cdr V2631)))) (let ((Default (cons (quote X) (cons (quote ->) (cons (quote X) (quote ())))))) (let ((Def (kl:shen.elim-def (cons (quote define) (cons (car (cdr V2631)) (kl:append (cdr (cdr V2631)) Default)))))) (let ((MacroAdd (kl:shen.add-macro (car (cdr V2631))))) Def)))) ((and (pair? V2631) (and (eq? (quote defcc) (car V2631)) (pair? (cdr V2631)))) (kl:shen.elim-def (kl:shen.yacc V2631))) ((pair? V2631) (kl:map (lambda (Z) (kl:shen.elim-def Z)) V2631)) (#t V2631))) (quote shen.elim-def))
(begin (register-function-arity (quote shen.add-macro) 1) (define (kl:shen.add-macro V2633) (let ((MacroReg (kl:value (quote shen.*macroreg*)))) (let ((NewMacroReg (kl:set (quote shen.*macroreg*) (kl:adjoin V2633 (kl:value (quote shen.*macroreg*)))))) (if (kl:= MacroReg NewMacroReg) (quote shen.skip) (kl:set (quote *macros*) (cons (kl:function V2633) (kl:value (quote *macros*)))))))) (quote shen.add-macro))
(begin (register-function-arity (quote shen.packaged?) 1) (define (kl:shen.packaged? V2641) (cond ((and (pair? V2641) (and (eq? (quote package) (car V2641)) (and (pair? (cdr V2641)) (pair? (cdr (cdr V2641)))))) #t) (#t #f))) (quote shen.packaged?))
(begin (register-function-arity (quote external) 1) (define (kl:external V2643) (guard (lambda (E) (simple-error (string-append "package " (kl:shen.app V2643 " has not been used.\n" (quote shen.a))))) (kl:get V2643 (quote shen.external-symbols) (kl:value (quote *property-vector*))))) (quote external))
(begin (register-function-arity (quote internal) 1) (define (kl:internal V2645) (guard (lambda (E) (simple-error (string-append "package " (kl:shen.app V2645 " has not been used.\n" (quote shen.a))))) (kl:get V2645 (quote shen.internal-symbols) (kl:value (quote *property-vector*))))) (quote internal))
(begin (register-function-arity (quote shen.package-contents) 1) (define (kl:shen.package-contents V2649) (cond ((and (pair? V2649) (and (eq? (quote package) (car V2649)) (and (pair? (cdr V2649)) (and (eq? (quote null) (car (cdr V2649))) (pair? (cdr (cdr V2649))))))) (cdr (cdr (cdr V2649)))) ((and (pair? V2649) (and (eq? (quote package) (car V2649)) (and (pair? (cdr V2649)) (pair? (cdr (cdr V2649)))))) ((((lambda (Y1) (lambda (Y2) (lambda (Y3) (lambda (Y4) (kl:shen.packageh Y1 Y2 Y3 Y4))))) (car (cdr V2649))) (car (cdr (cdr V2649)))) (cdr (cdr (cdr V2649))))) (#t (kl:shen.f_error (quote shen.package-contents))))) (quote shen.package-contents))
(begin (register-function-arity (quote shen.walk) 2) (define (kl:shen.walk V2652 V2653) (cond ((pair? V2653) (V2652 (kl:map (lambda (Z) (kl:shen.walk V2652 Z)) V2653))) (#t (V2652 V2653)))) (quote shen.walk))
(begin (register-function-arity (quote compile) 3) (define (kl:compile V2657 V2658 V2659) (let ((O (V2657 (cons V2658 (cons (quote ()) (quote ())))))) (if (or (kl:= (kl:fail) O) (kl:not (kl:empty? (car O)))) (V2659 O) (kl:shen.hdtl O)))) (quote compile))
(begin (register-function-arity (quote fail-if) 2) (define (kl:fail-if V2662 V2663) (if (assert-boolean (V2662 V2663)) (kl:fail) V2663)) (quote fail-if))
(begin (register-function-arity (quote _waspvm_at_s) 2) (define (kl:_waspvm_at_s V2666 V2667) (string-append V2666 V2667)) (quote _waspvm_at_s))
(begin (register-function-arity (quote tc?) 0) (define (kl:tc?) (kl:value (quote shen.*tc*))) (quote tc?))
(begin (register-function-arity (quote ps) 1) (define (kl:ps V2669) (guard (lambda (E) (simple-error (kl:shen.app V2669 " not found.\n" (quote shen.a)))) (kl:get V2669 (quote shen.source) (kl:value (quote *property-vector*))))) (quote ps))
(begin (register-function-arity (quote stinput) 0) (define (kl:stinput) (kl:value (quote *stinput*))) (quote stinput))
(begin (register-function-arity (quote shen.+vector?) 1) (define (kl:shen.+vector? V2671) (and (vector? V2671) (> (vector-ref V2671 0) 0))) (quote shen.+vector?))
(begin (register-function-arity (quote vector) 1) (define (kl:vector V2673) (let ((Vector (make-vector (+ V2673 1) (quote (quote shen.fail!))))) (let ((ZeroStamp (let ((_tmp Vector)) (vector-set! _tmp 0 V2673) _tmp))) (let ((Standard (if (kl:= V2673 0) ZeroStamp (kl:shen.fillvector ZeroStamp 1 V2673 (kl:fail))))) Standard)))) (quote vector))
(begin (register-function-arity (quote shen.fillvector) 4) (define (kl:shen.fillvector V2679 V2680 V2681 V2682) (cond ((kl:= V2681 V2680) (let ((_tmp V2679)) (vector-set! _tmp V2681 V2682) _tmp)) (#t (kl:shen.fillvector (let ((_tmp V2679)) (vector-set! _tmp V2680 V2682) _tmp) (+ 1 V2680) V2681 V2682)))) (quote shen.fillvector))
(begin (register-function-arity (quote vector?) 1) (define (kl:vector? V2684) (and (vector? V2684) (assert-boolean (guard (lambda (E) #f) (>= (vector-ref V2684 0) 0))))) (quote vector?))
(begin (register-function-arity (quote vector->) 3) (define (kl:vector-> V2688 V2689 V2690) (if (kl:= V2689 0) (simple-error "cannot access 0th element of a vector\n") (let ((_tmp V2688)) (vector-set! _tmp V2689 V2690) _tmp))) (quote vector->))
(begin (register-function-arity (quote <-vector) 2) (define (kl:<-vector V2693 V2694) (if (kl:= V2694 0) (simple-error "cannot access 0th element of a vector\n") (let ((VectorElement (vector-ref V2693 V2694))) (if (kl:= VectorElement (kl:fail)) (simple-error "vector element not found\n") VectorElement)))) (quote <-vector))
(begin (register-function-arity (quote shen.posint?) 1) (define (kl:shen.posint? V2696) (and (assert-boolean (kl:integer? V2696)) (>= V2696 0))) (quote shen.posint?))
(begin (register-function-arity (quote limit) 1) (define (kl:limit V2698) (vector-ref V2698 0)) (quote limit))
(begin (register-function-arity (quote symbol?) 1) (define (kl:symbol? V2700) (cond ((or (kl:boolean? V2700) (or (number? V2700) (string? V2700))) #f) (#t (guard (lambda (E) #f) (let ((String (kl:str V2700))) (kl:shen.analyse-symbol? String)))))) (quote symbol?))
(begin (register-function-arity (quote shen.analyse-symbol?) 1) (define (kl:shen.analyse-symbol? V2702) (cond ((assert-boolean (kl:shen.+string? V2702)) (and (assert-boolean (kl:shen.alpha? (make-string 1 (string-ref V2702 0)))) (assert-boolean (kl:shen.alphanums? (string-tail V2702 1))))) (#t (kl:shen.f_error (quote shen.analyse-symbol?))))) (quote shen.analyse-symbol?))
(begin (register-function-arity (quote shen.alpha?) 1) (define (kl:shen.alpha? V2704) (kl:element? V2704 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" (cons "a" (cons "b" (cons "c" (cons "d" (cons "e" (cons "f" (cons "g" (cons "h" (cons "i" (cons "j" (cons "k" (cons "l" (cons "m" (cons "n" (cons "o" (cons "p" (cons "q" (cons "r" (cons "s" (cons "t" (cons "u" (cons "v" (cons "w" (cons "x" (cons "y" (cons "z" (cons "=" (cons "*" (cons "/" (cons "+" (cons "-" (cons "_" (cons "?" (cons "$" (cons "!" (cons "@" (cons "~" (cons ">" (cons "<" (cons "&" (cons "%" (cons "{" (cons "}" (cons ":" (cons ";" (cons "`" (cons "#" (cons "'" (cons "." (quote ())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (quote shen.alpha?))
(begin (register-function-arity (quote shen.alphanums?) 1) (define (kl:shen.alphanums? V2706) (cond ((equal? "" V2706) #t) ((assert-boolean (kl:shen.+string? V2706)) (and (assert-boolean (kl:shen.alphanum? (make-string 1 (string-ref V2706 0)))) (assert-boolean (kl:shen.alphanums? (string-tail V2706 1))))) (#t (kl:shen.f_error (quote shen.alphanums?))))) (quote shen.alphanums?))
(begin (register-function-arity (quote shen.alphanum?) 1) (define (kl:shen.alphanum? V2708) (or (assert-boolean (kl:shen.alpha? V2708)) (assert-boolean (kl:shen.digit? V2708)))) (quote shen.alphanum?))
(begin (register-function-arity (quote shen.digit?) 1) (define (kl:shen.digit? V2710) (kl:element? V2710 (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" (quote ()))))))))))))) (quote shen.digit?))
(begin (register-function-arity (quote variable?) 1) (define (kl:variable? V2712) (cond ((or (kl:boolean? V2712) (or (number? V2712) (string? V2712))) #f) (#t (guard (lambda (E) #f) (let ((String (kl:str V2712))) (kl:shen.analyse-variable? String)))))) (quote variable?))
(begin (register-function-arity (quote shen.analyse-variable?) 1) (define (kl:shen.analyse-variable? V2714) (cond ((assert-boolean (kl:shen.+string? V2714)) (and (assert-boolean (kl:shen.uppercase? (make-string 1 (string-ref V2714 0)))) (assert-boolean (kl:shen.alphanums? (string-tail V2714 1))))) (#t (kl:shen.f_error (quote shen.analyse-variable?))))) (quote shen.analyse-variable?))
(begin (register-function-arity (quote shen.uppercase?) 1) (define (kl:shen.uppercase? V2716) (kl:element? V2716 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" (quote ()))))))))))))))))))))))))))))) (quote shen.uppercase?))
(begin (register-function-arity (quote gensym) 1) (define (kl:gensym V2718) (kl:concat V2718 (kl:set (quote shen.*gensym*) (+ 1 (kl:value (quote shen.*gensym*)))))) (quote gensym))
(begin (register-function-arity (quote concat) 2) (define (kl:concat V2721 V2722) (kl:intern (string-append (kl:str V2721) (kl:str V2722)))) (quote concat))
(begin (register-function-arity (quote _waspvm_at_p) 2) (define (kl:_waspvm_at_p V2725 V2726) (let ((Vector (make-vector 3 (quote (quote shen.fail!))))) (let ((Tag (let ((_tmp Vector)) (vector-set! _tmp 0 (quote shen.tuple)) _tmp))) (let ((Fst (let ((_tmp Vector)) (vector-set! _tmp 1 V2725) _tmp))) (let ((Snd (let ((_tmp Vector)) (vector-set! _tmp 2 V2726) _tmp))) Vector))))) (quote _waspvm_at_p))
(begin (register-function-arity (quote fst) 1) (define (kl:fst V2728) (vector-ref V2728 1)) (quote fst))
(begin (register-function-arity (quote snd) 1) (define (kl:snd V2730) (vector-ref V2730 2)) (quote snd))
(begin (register-function-arity (quote tuple?) 1) (define (kl:tuple? V2732) (guard (lambda (E) #f) (and (vector? V2732) (eq? (quote shen.tuple) (vector-ref V2732 0))))) (quote tuple?))
(begin (register-function-arity (quote append) 2) (define (kl:append V2735 V2736) (cond ((null? V2735) V2736) ((pair? V2735) (cons (car V2735) (kl:append (cdr V2735) V2736))) (#t (kl:shen.f_error (quote append))))) (quote append))
(begin (register-function-arity (quote _waspvm_at_v) 2) (define (kl:_waspvm_at_v V2739 V2740) (let ((Limit (kl:limit V2740))) (let ((NewVector (kl:vector (+ Limit 1)))) (let ((X+NewVector (kl:vector-> NewVector 1 V2739))) (if (kl:= Limit 0) X+NewVector (kl:shen._waspvm_at_v-help V2740 1 Limit X+NewVector)))))) (quote _waspvm_at_v))
(begin (register-function-arity (quote shen._waspvm_at_v-help) 4) (define (kl:shen._waspvm_at_v-help V2746 V2747 V2748 V2749) (cond ((kl:= V2748 V2747) (kl:shen.copyfromvector V2746 V2749 V2748 (+ V2748 1))) (#t (kl:shen._waspvm_at_v-help V2746 (+ V2747 1) V2748 (kl:shen.copyfromvector V2746 V2749 V2747 (+ V2747 1)))))) (quote shen._waspvm_at_v-help))
(begin (register-function-arity (quote shen.copyfromvector) 4) (define (kl:shen.copyfromvector V2754 V2755 V2756 V2757) (guard (lambda (E) V2755) (kl:vector-> V2755 V2757 (kl:<-vector V2754 V2756)))) (quote shen.copyfromvector))
(begin (register-function-arity (quote hdv) 1) (define (kl:hdv V2759) (guard (lambda (E) (simple-error (string-append "hdv needs a non-empty vector as an argument; not " (kl:shen.app V2759 "\n" (quote shen.s))))) (kl:<-vector V2759 1))) (quote hdv))
(begin (register-function-arity (quote tlv) 1) (define (kl:tlv V2761) (let ((Limit (kl:limit V2761))) (if (kl:= Limit 0) (simple-error "cannot take the tail of the empty vector\n") (if (kl:= Limit 1) (kl:vector 0) (let ((NewVector (kl:vector (- Limit 1)))) (kl:shen.tlv-help V2761 2 Limit (kl:vector (- Limit 1)))))))) (quote tlv))
(begin (register-function-arity (quote shen.tlv-help) 4) (define (kl:shen.tlv-help V2767 V2768 V2769 V2770) (cond ((kl:= V2769 V2768) (kl:shen.copyfromvector V2767 V2770 V2769 (- V2769 1))) (#t (kl:shen.tlv-help V2767 (+ V2768 1) V2769 (kl:shen.copyfromvector V2767 V2770 V2768 (- V2768 1)))))) (quote shen.tlv-help))
(begin (register-function-arity (quote assoc) 2) (define (kl:assoc V2782 V2783) (cond ((null? V2783) (quote ())) ((and (pair? V2783) (and (pair? (car V2783)) (kl:= (car (car V2783)) V2782))) (car V2783)) ((pair? V2783) (kl:assoc V2782 (cdr V2783))) (#t (kl:shen.f_error (quote assoc))))) (quote assoc))
(begin (register-function-arity (quote boolean?) 1) (define (kl:boolean? V2789) (cond ((kl:= #t V2789) #t) ((kl:= #f V2789) #t) (#t #f))) (quote boolean?))
(begin (register-function-arity (quote nl) 1) (define (kl:nl V2791) (cond ((kl:= 0 V2791) 0) (#t (begin (kl:shen.prhush "\n" (kl:stoutput)) (kl:nl (- V2791 1)))))) (quote nl))
(begin (register-function-arity (quote difference) 2) (define (kl:difference V2796 V2797) (cond ((null? V2796) (quote ())) ((pair? V2796) (if (kl:element? (car V2796) V2797) (kl:difference (cdr V2796) V2797) (cons (car V2796) (kl:difference (cdr V2796) V2797)))) (#t (kl:shen.f_error (quote difference))))) (quote difference))
(begin (register-function-arity (quote do) 2) (define (kl:do V2800 V2801) V2801) (quote do))
(begin (register-function-arity (quote element?) 2) (define (kl:element? V2813 V2814) (cond ((null? V2814) #f) ((and (pair? V2814) (kl:= (car V2814) V2813)) #t) ((pair? V2814) (kl:element? V2813 (cdr V2814))) (#t (kl:shen.f_error (quote element?))))) (quote element?))
(begin (register-function-arity (quote empty?) 1) (define (kl:empty? V2820) (cond ((null? V2820) #t) (#t #f))) (quote empty?))
(begin (register-function-arity (quote fix) 2) (define (kl:fix V2823 V2824) (kl:shen.fix-help V2823 V2824 (V2823 V2824))) (quote fix))
(begin (register-function-arity (quote shen.fix-help) 3) (define (kl:shen.fix-help V2835 V2836 V2837) (cond ((kl:= V2837 V2836) V2837) (#t (kl:shen.fix-help V2835 V2837 (V2835 V2837))))) (quote shen.fix-help))
(begin (register-function-arity (quote put) 4) (define (kl:put V2842 V2843 V2844 V2845) (let ((N (kl:hash V2842 (kl:limit V2845)))) (let ((Entry (guard (lambda (E) (quote ())) (kl:<-vector V2845 N)))) (let ((Change (kl:vector-> V2845 N (kl:shen.change-pointer-value V2842 V2843 V2844 Entry)))) V2844)))) (quote put))
(begin (register-function-arity (quote unput) 3) (define (kl:unput V2849 V2850 V2851) (let ((N (kl:hash V2849 (kl:limit V2851)))) (let ((Entry (guard (lambda (E) (quote ())) (kl:<-vector V2851 N)))) (let ((Change (kl:vector-> V2851 N (kl:shen.remove-pointer V2849 V2850 Entry)))) V2849)))) (quote unput))
(begin (register-function-arity (quote shen.remove-pointer) 3) (define (kl:shen.remove-pointer V2859 V2860 V2861) (cond ((null? V2861) (quote ())) ((and (pair? V2861) (and (pair? (car V2861)) (and (pair? (car (car V2861))) (and (pair? (cdr (car (car V2861)))) (and (null? (cdr (cdr (car (car V2861))))) (and (kl:= (car (cdr (car (car V2861)))) V2860) (kl:= (car (car (car V2861))) V2859))))))) (cdr V2861)) ((pair? V2861) (cons (car V2861) (kl:shen.remove-pointer V2859 V2860 (cdr V2861)))) (#t (kl:shen.f_error (quote shen.remove-pointer))))) (quote shen.remove-pointer))
(begin (register-function-arity (quote shen.change-pointer-value) 4) (define (kl:shen.change-pointer-value V2870 V2871 V2872 V2873) (cond ((null? V2873) (cons (cons (cons V2870 (cons V2871 (quote ()))) V2872) (quote ()))) ((and (pair? V2873) (and (pair? (car V2873)) (and (pair? (car (car V2873))) (and (pair? (cdr (car (car V2873)))) (and (null? (cdr (cdr (car (car V2873))))) (and (kl:= (car (cdr (car (car V2873)))) V2871) (kl:= (car (car (car V2873))) V2870))))))) (cons (cons (car (car V2873)) V2872) (cdr V2873))) ((pair? V2873) (cons (car V2873) (kl:shen.change-pointer-value V2870 V2871 V2872 (cdr V2873)))) (#t (kl:shen.f_error (quote shen.change-pointer-value))))) (quote shen.change-pointer-value))
(begin (register-function-arity (quote get) 3) (define (kl:get V2877 V2878 V2879) (let ((N (kl:hash V2877 (kl:limit V2879)))) (let ((Entry (guard (lambda (E) (simple-error "pointer not found\n")) (kl:<-vector V2879 N)))) (let ((Result (kl:assoc (cons V2877 (cons V2878 (quote ()))) Entry))) (if (kl:empty? Result) (simple-error "value not found\n") (cdr Result)))))) (quote get))
(begin (register-function-arity (quote hash) 2) (define (kl:hash V2882 V2883) (let ((Hash (kl:shen.mod (kl:sum (kl:map (lambda (X) (string-ref X 0)) (kl:explode V2882))) V2883))) (if (kl:= 0 Hash) 1 Hash))) (quote hash))
(begin (register-function-arity (quote shen.mod) 2) (define (kl:shen.mod V2886 V2887) (kl:shen.modh V2886 (kl:shen.multiples V2886 (cons V2887 (quote ()))))) (quote shen.mod))
(begin (register-function-arity (quote shen.multiples) 2) (define (kl:shen.multiples V2890 V2891) (cond ((and (pair? V2891) (> (car V2891) V2890)) (cdr V2891)) ((pair? V2891) (kl:shen.multiples V2890 (cons (* 2 (car V2891)) V2891))) (#t (kl:shen.f_error (quote shen.multiples))))) (quote shen.multiples))
(begin (register-function-arity (quote shen.modh) 2) (define (kl:shen.modh V2896 V2897) (cond ((kl:= 0 V2896) 0) ((null? V2897) V2896) ((and (pair? V2897) (> (car V2897) V2896)) (if (kl:empty? (cdr V2897)) V2896 (kl:shen.modh V2896 (cdr V2897)))) ((pair? V2897) (kl:shen.modh (- V2896 (car V2897)) V2897)) (#t (kl:shen.f_error (quote shen.modh))))) (quote shen.modh))
(begin (register-function-arity (quote sum) 1) (define (kl:sum V2899) (cond ((null? V2899) 0) ((pair? V2899) (+ (car V2899) (kl:sum (cdr V2899)))) (#t (kl:shen.f_error (quote sum))))) (quote sum))
(begin (register-function-arity (quote head) 1) (define (kl:head V2907) (cond ((pair? V2907) (car V2907)) (#t (simple-error "head expects a non-empty list")))) (quote head))
(begin (register-function-arity (quote tail) 1) (define (kl:tail V2915) (cond ((pair? V2915) (cdr V2915)) (#t (simple-error "tail expects a non-empty list")))) (quote tail))
(begin (register-function-arity (quote hdstr) 1) (define (kl:hdstr V2917) (make-string 1 (string-ref V2917 0))) (quote hdstr))
(begin (register-function-arity (quote intersection) 2) (define (kl:intersection V2922 V2923) (cond ((null? V2922) (quote ())) ((pair? V2922) (if (kl:element? (car V2922) V2923) (cons (car V2922) (kl:intersection (cdr V2922) V2923)) (kl:intersection (cdr V2922) V2923))) (#t (kl:shen.f_error (quote intersection))))) (quote intersection))
(begin (register-function-arity (quote reverse) 1) (define (kl:reverse V2925) (kl:shen.reverse_help V2925 (quote ()))) (quote reverse))
(begin (register-function-arity (quote shen.reverse_help) 2) (define (kl:shen.reverse_help V2928 V2929) (cond ((null? V2928) V2929) ((pair? V2928) (kl:shen.reverse_help (cdr V2928) (cons (car V2928) V2929))) (#t (kl:shen.f_error (quote shen.reverse_help))))) (quote shen.reverse_help))
(begin (register-function-arity (quote union) 2) (define (kl:union V2932 V2933) (cond ((null? V2932) V2933) ((pair? V2932) (if (kl:element? (car V2932) V2933) (kl:union (cdr V2932) V2933) (cons (car V2932) (kl:union (cdr V2932) V2933)))) (#t (kl:shen.f_error (quote union))))) (quote union))
(begin (register-function-arity (quote y-or-n?) 1) (define (kl:y-or-n? V2935) (let ((Message (kl:shen.prhush (kl:shen.proc-nl V2935) (kl:stoutput)))) (let ((Y-or-N (kl:shen.prhush " (y/n) " (kl:stoutput)))) (let ((Input (kl:shen.app (kl:read (kl:stinput)) "" (quote shen.s)))) (if (equal? "y" Input) #t (if (equal? "n" Input) #f (begin (kl:shen.prhush "please answer y or n\n" (kl:stoutput)) (kl:y-or-n? V2935)))))))) (quote y-or-n?))
(begin (register-function-arity (quote not) 1) (define (kl:not V2937) (if (assert-boolean V2937) #f #t)) (quote not))
(begin (register-function-arity (quote subst) 3) (define (kl:subst V2950 V2951 V2952) (cond ((kl:= V2952 V2951) V2950) ((pair? V2952) (kl:map (lambda (W) (kl:subst V2950 V2951 W)) V2952)) (#t V2952))) (quote subst))
(begin (register-function-arity (quote explode) 1) (define (kl:explode V2954) (kl:shen.explode-h (kl:shen.app V2954 "" (quote shen.a)))) (quote explode))
(begin (register-function-arity (quote shen.explode-h) 1) (define (kl:shen.explode-h V2956) (cond ((equal? "" V2956) (quote ())) ((assert-boolean (kl:shen.+string? V2956)) (cons (make-string 1 (string-ref V2956 0)) (kl:shen.explode-h (string-tail V2956 1)))) (#t (kl:shen.f_error (quote shen.explode-h))))) (quote shen.explode-h))
(begin (register-function-arity (quote cd) 1) (define (kl:cd V2958) (kl:set (quote *home-directory*) (if (equal? V2958 "") "" (kl:shen.app V2958 "/" (quote shen.a))))) (quote cd))
(begin (register-function-arity (quote map) 2) (define (kl:map V2961 V2962) (kl:shen.map-h V2961 V2962 (quote ()))) (quote map))
(begin (register-function-arity (quote shen.map-h) 3) (define (kl:shen.map-h V2968 V2969 V2970) (cond ((null? V2969) (kl:reverse V2970)) ((pair? V2969) (kl:shen.map-h V2968 (cdr V2969) (cons (V2968 (car V2969)) V2970))) (#t (kl:shen.f_error (quote shen.map-h))))) (quote shen.map-h))
(begin (register-function-arity (quote length) 1) (define (kl:length V2972) (kl:shen.length-h V2972 0)) (quote length))
(begin (register-function-arity (quote shen.length-h) 2) (define (kl:shen.length-h V2975 V2976) (cond ((null? V2975) V2976) (#t (kl:shen.length-h (cdr V2975) (+ V2976 1))))) (quote shen.length-h))
(begin (register-function-arity (quote occurrences) 2) (define (kl:occurrences V2988 V2989) (cond ((kl:= V2989 V2988) 1) ((pair? V2989) (+ (kl:occurrences V2988 (car V2989)) (kl:occurrences V2988 (cdr V2989)))) (#t 0))) (quote occurrences))
(begin (register-function-arity (quote nth) 2) (define (kl:nth V2998 V2999) (cond ((and (kl:= 1 V2998) (pair? V2999)) (car V2999)) ((pair? V2999) (kl:nth (- V2998 1) (cdr V2999))) (#t (kl:shen.f_error (quote nth))))) (quote nth))
(begin (register-function-arity (quote integer?) 1) (define (kl:integer? V3001) (and (number? V3001) (assert-boolean (let ((Abs (kl:shen.abs V3001))) (kl:shen.integer-test? Abs (kl:shen.magless Abs 1)))))) (quote integer?))
(begin (register-function-arity (quote shen.abs) 1) (define (kl:shen.abs V3003) (if (> V3003 0) V3003 (- 0 V3003))) (quote shen.abs))
(begin (register-function-arity (quote shen.magless) 2) (define (kl:shen.magless V3006 V3007) (let ((Nx2 (* V3007 2))) (if (> Nx2 V3006) V3007 (kl:shen.magless V3006 Nx2)))) (quote shen.magless))
(begin (register-function-arity (quote shen.integer-test?) 2) (define (kl:shen.integer-test? V3013 V3014) (cond ((kl:= 0 V3013) #t) ((> 1 V3013) #f) (#t (let ((Abs-N (- V3013 V3014))) (if (> 0 Abs-N) (kl:integer? V3013) (kl:shen.integer-test? Abs-N V3014)))))) (quote shen.integer-test?))
(begin (register-function-arity (quote mapcan) 2) (define (kl:mapcan V3019 V3020) (cond ((null? V3020) (quote ())) ((pair? V3020) (kl:append (V3019 (car V3020)) (kl:mapcan V3019 (cdr V3020)))) (#t (kl:shen.f_error (quote mapcan))))) (quote mapcan))
(begin (register-function-arity (quote ==) 2) (define (kl:== V3032 V3033) (cond ((kl:= V3033 V3032) #t) (#t #f))) (quote ==))
(begin (register-function-arity (quote abort) 0) (define (kl:abort) (simple-error "")) (quote abort))
(begin (register-function-arity (quote bound?) 1) (define (kl:bound? V3035) (and (kl:symbol? V3035) (assert-boolean (let ((Val (guard (lambda (E) (quote shen.this-symbol-is-unbound)) (kl:value V3035)))) (if (eq? Val (quote shen.this-symbol-is-unbound)) #f #t))))) (quote bound?))
(begin (register-function-arity (quote shen.string->bytes) 1) (define (kl:shen.string->bytes V3037) (cond ((equal? "" V3037) (quote ())) (#t (cons (string-ref (make-string 1 (string-ref V3037 0)) 0) (kl:shen.string->bytes (string-tail V3037 1)))))) (quote shen.string->bytes))
(begin (register-function-arity (quote maxinferences) 1) (define (kl:maxinferences V3039) (kl:set (quote shen.*maxinferences*) V3039)) (quote maxinferences))
(begin (register-function-arity (quote inferences) 0) (define (kl:inferences) (kl:value (quote shen.*infs*))) (quote inferences))
(begin (register-function-arity (quote protect) 1) (define (kl:protect V3041) V3041) (quote protect))
(begin (register-function-arity (quote stoutput) 0) (define (kl:stoutput) (kl:value (quote *stoutput*))) (quote stoutput))
(begin (register-function-arity (quote string->symbol) 1) (define (kl:string->symbol V3043) (let ((Symbol (kl:intern V3043))) (if (kl:symbol? Symbol) Symbol (simple-error (string-append "cannot intern " (kl:shen.app V3043 " to a symbol" (quote shen.s))))))) (quote string->symbol))
(begin (register-function-arity (quote optimise) 1) (define (kl:optimise V3049) (cond ((eq? (quote +) V3049) (kl:set (quote shen.*optimise*) #t)) ((eq? (quote -) V3049) (kl:set (quote shen.*optimise*) #f)) (#t (simple-error "optimise expects a + or a -.\n")))) (quote optimise))
(begin (register-function-arity (quote os) 0) (define (kl:os) (kl:value (quote *os*))) (quote os))
(begin (register-function-arity (quote language) 0) (define (kl:language) (kl:value (quote *language*))) (quote language))
(begin (register-function-arity (quote version) 0) (define (kl:version) (kl:value (quote *version*))) (quote version))
(begin (register-function-arity (quote port) 0) (define (kl:port) (kl:value (quote *port*))) (quote port))
(begin (register-function-arity (quote porters) 0) (define (kl:porters) (kl:value (quote *porters*))) (quote porters))
(begin (register-function-arity (quote implementation) 0) (define (kl:implementation) (kl:value (quote *implementation*))) (quote implementation))
(begin (register-function-arity (quote release) 0) (define (kl:release) (kl:value (quote *release*))) (quote release))
(begin (register-function-arity (quote package?) 1) (define (kl:package? V3051) (guard (lambda (E) #f) (begin (kl:external V3051) #t))) (quote package?))
(begin (register-function-arity (quote function) 1) (define (kl:function V3053) (kl:shen.lookup-func V3053 (kl:value (quote shen.*symbol-table*)))) (quote function))
(begin (register-function-arity (quote shen.lookup-func) 2) (define (kl:shen.lookup-func V3063 V3064) (cond ((null? V3064) (simple-error (kl:shen.app V3063 " has no lambda expansion\n" (quote shen.a)))) ((and (pair? V3064) (and (pair? (car V3064)) (kl:= (car (car V3064)) V3063))) (cdr (car V3064))) ((pair? V3064) (kl:shen.lookup-func V3063 (cdr V3064))) (#t (kl:shen.f_error (quote shen.lookup-func))))) (quote shen.lookup-func))
