"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote thaw) 1) (define (kl:thaw V2632) (V2632)) (quote thaw))
(begin (register-function-arity (quote eval) 1) (define (kl:eval V2634) (let ((Macroexpand (kl:shen.walk (lambda (Y) (kl:macroexpand Y)) V2634))) (if (assert-boolean (kl:shen.packaged? Macroexpand)) (kl:map (lambda (Z) (kl:shen.eval-without-macros Z)) (kl:shen.package-contents Macroexpand)) (kl:shen.eval-without-macros Macroexpand)))) (quote eval))
(begin (register-function-arity (quote shen.eval-without-macros) 1) (define (kl:shen.eval-without-macros V2636) (kl:eval-kl (kl:shen.elim-def (kl:shen.proc-input+ V2636)))) (quote shen.eval-without-macros))
(begin (register-function-arity (quote shen.proc-input+) 1) (define (kl:shen.proc-input+ V2638) (cond ((and (pair? V2638) (and (eq? (quote input+) (car V2638)) (and (pair? (cdr V2638)) (and (pair? (cdr (cdr V2638))) (null? (cdr (cdr (cdr V2638)))))))) (cons (quote input+) (cons (kl:shen.rcons_form (car (cdr V2638))) (cdr (cdr V2638))))) ((and (pair? V2638) (and (eq? (quote shen.read+) (car V2638)) (and (pair? (cdr V2638)) (and (pair? (cdr (cdr V2638))) (null? (cdr (cdr (cdr V2638)))))))) (cons (quote shen.read+) (cons (kl:shen.rcons_form (car (cdr V2638))) (cdr (cdr V2638))))) ((pair? V2638) (kl:map (lambda (Z) (kl:shen.proc-input+ Z)) V2638)) (#t V2638))) (quote shen.proc-input+))
(begin (register-function-arity (quote shen.elim-def) 1) (define (kl:shen.elim-def V2640) (cond ((and (pair? V2640) (and (eq? (quote define) (car V2640)) (pair? (cdr V2640)))) (kl:shen->kl (car (cdr V2640)) (cdr (cdr V2640)))) ((and (pair? V2640) (and (eq? (quote defmacro) (car V2640)) (pair? (cdr V2640)))) (let ((Default (cons (quote X) (cons (quote ->) (cons (quote X) (quote ())))))) (let ((Def (kl:shen.elim-def (cons (quote define) (cons (car (cdr V2640)) (kl:append (cdr (cdr V2640)) Default)))))) (let ((MacroAdd (kl:shen.add-macro (car (cdr V2640))))) Def)))) ((and (pair? V2640) (and (eq? (quote defcc) (car V2640)) (pair? (cdr V2640)))) (kl:shen.elim-def (kl:shen.yacc V2640))) ((pair? V2640) (kl:map (lambda (Z) (kl:shen.elim-def Z)) V2640)) (#t V2640))) (quote shen.elim-def))
(begin (register-function-arity (quote shen.add-macro) 1) (define (kl:shen.add-macro V2642) (let ((MacroReg (kl:value (quote shen.*macroreg*)))) (let ((NewMacroReg (kl:set (quote shen.*macroreg*) (kl:adjoin V2642 (kl:value (quote shen.*macroreg*)))))) (if (kl:= MacroReg NewMacroReg) (quote shen.skip) (kl:set (quote *macros*) (cons (kl:function V2642) (kl:value (quote *macros*)))))))) (quote shen.add-macro))
(begin (register-function-arity (quote shen.packaged?) 1) (define (kl:shen.packaged? V2650) (cond ((and (pair? V2650) (and (eq? (quote package) (car V2650)) (and (pair? (cdr V2650)) (pair? (cdr (cdr V2650)))))) #t) (#t #f))) (quote shen.packaged?))
(begin (register-function-arity (quote external) 1) (define (kl:external V2652) (kl:get/or V2652 (quote shen.external-symbols) (lambda () (simple-error (string-append "package " (kl:shen.app V2652 " has not been used.\n" (quote shen.a))))) (kl:value (quote *property-vector*)))) (quote external))
(begin (register-function-arity (quote internal) 1) (define (kl:internal V2654) (kl:get/or V2654 (quote shen.internal-symbols) (lambda () (simple-error (string-append "package " (kl:shen.app V2654 " has not been used.\n" (quote shen.a))))) (kl:value (quote *property-vector*)))) (quote internal))
(begin (register-function-arity (quote shen.package-contents) 1) (define (kl:shen.package-contents V2658) (cond ((and (pair? V2658) (and (eq? (quote package) (car V2658)) (and (pair? (cdr V2658)) (and (eq? (quote null) (car (cdr V2658))) (pair? (cdr (cdr V2658))))))) (cdr (cdr (cdr V2658)))) ((and (pair? V2658) (and (eq? (quote package) (car V2658)) (and (pair? (cdr V2658)) (pair? (cdr (cdr V2658)))))) (kl:shen.packageh (car (cdr V2658)) (car (cdr (cdr V2658))) (cdr (cdr (cdr V2658))))) (#t (kl:shen.f_error (quote shen.package-contents))))) (quote shen.package-contents))
(begin (register-function-arity (quote shen.walk) 2) (define (kl:shen.walk V2661 V2662) (cond ((pair? V2662) (V2661 (kl:map (lambda (Z) (kl:shen.walk V2661 Z)) V2662))) (#t (V2661 V2662)))) (quote shen.walk))
(begin (register-function-arity (quote compile) 3) (define (kl:compile V2666 V2667 V2668) (let ((O (V2666 (cons V2667 (cons (quote ()) (quote ())))))) (if (or (kl:= (kl:fail) O) (kl:not (kl:empty? (car O)))) (V2668 O) (kl:shen.hdtl O)))) (quote compile))
(begin (register-function-arity (quote fail-if) 2) (define (kl:fail-if V2671 V2672) (if (assert-boolean (V2671 V2672)) (kl:fail) V2672)) (quote fail-if))
(begin (register-function-arity (quote _waspvm_at_s) 2) (define (kl:_waspvm_at_s V2675 V2676) (string-append V2675 V2676)) (quote _waspvm_at_s))
(begin (register-function-arity (quote tc?) 0) (define (kl:tc?) (kl:value (quote shen.*tc*))) (quote tc?))
(begin (register-function-arity (quote ps) 1) (define (kl:ps V2678) (kl:get/or V2678 (quote shen.source) (lambda () (simple-error (kl:shen.app V2678 " not found.\n" (quote shen.a)))) (kl:value (quote *property-vector*)))) (quote ps))
(begin (register-function-arity (quote stinput) 0) (define (kl:stinput) (kl:value (quote *stinput*))) (quote stinput))
(begin (register-function-arity (quote <-address/or) 3) (define (kl:<-address/or V2682 V2683 V2684) (guard (lambda (E) (kl:thaw V2684)) (vector-ref V2682 V2683))) (quote <-address/or))
(begin (register-function-arity (quote value/or) 2) (define (kl:value/or V2687 V2688) (guard (lambda (E) (kl:thaw V2688)) (kl:value V2687))) (quote value/or))
(begin (register-function-arity (quote vector) 1) (define (kl:vector V2690) (let ((Vector (make-vector (+ V2690 1) (quote (quote shen.fail!))))) (let ((ZeroStamp (let ((_tmp Vector)) (vector-set! _tmp 0 V2690) _tmp))) (let ((Standard (if (kl:= V2690 0) ZeroStamp (kl:shen.fillvector ZeroStamp 1 V2690 (kl:fail))))) Standard)))) (quote vector))
(begin (register-function-arity (quote shen.fillvector) 4) (define (kl:shen.fillvector V2696 V2697 V2698 V2699) (cond ((kl:= V2698 V2697) (let ((_tmp V2696)) (vector-set! _tmp V2698 V2699) _tmp)) (#t (kl:shen.fillvector (let ((_tmp V2696)) (vector-set! _tmp V2697 V2699) _tmp) (+ 1 V2697) V2698 V2699)))) (quote shen.fillvector))
(begin (register-function-arity (quote vector?) 1) (define (kl:vector? V2701) (and (vector? V2701) (assert-boolean (let ((X (kl:<-address/or V2701 0 (lambda () -1)))) (and (number? X) (>= X 0)))))) (quote vector?))
(begin (register-function-arity (quote vector->) 3) (define (kl:vector-> V2705 V2706 V2707) (if (kl:= V2706 0) (simple-error "cannot access 0th element of a vector\n") (let ((_tmp V2705)) (vector-set! _tmp V2706 V2707) _tmp))) (quote vector->))
(begin (register-function-arity (quote <-vector) 2) (define (kl:<-vector V2710 V2711) (if (kl:= V2711 0) (simple-error "cannot access 0th element of a vector\n") (let ((VectorElement (vector-ref V2710 V2711))) (if (kl:= VectorElement (kl:fail)) (simple-error "vector element not found\n") VectorElement)))) (quote <-vector))
(begin (register-function-arity (quote <-vector/or) 3) (define (kl:<-vector/or V2715 V2716 V2717) (if (kl:= V2716 0) (simple-error "cannot access 0th element of a vector\n") (let ((VectorElement (kl:<-address/or V2715 V2716 V2717))) (if (kl:= VectorElement (kl:fail)) (kl:thaw V2717) VectorElement)))) (quote <-vector/or))
(begin (register-function-arity (quote shen.posint?) 1) (define (kl:shen.posint? V2719) (and (assert-boolean (kl:integer? V2719)) (>= V2719 0))) (quote shen.posint?))
(begin (register-function-arity (quote limit) 1) (define (kl:limit V2721) (vector-ref V2721 0)) (quote limit))
(begin (register-function-arity (quote symbol?) 1) (define (kl:symbol? V2723) (cond ((or (kl:boolean? V2723) (or (number? V2723) (string? V2723))) #f) (#t (guard (lambda (E) #f) (let ((String (kl:str V2723))) (kl:shen.analyse-symbol? String)))))) (quote symbol?))
(begin (register-function-arity (quote shen.analyse-symbol?) 1) (define (kl:shen.analyse-symbol? V2725) (cond ((equal? "" V2725) #f) ((assert-boolean (kl:shen.+string? V2725)) (and (assert-boolean (kl:shen.alpha? (make-string 1 (string-ref V2725 0)))) (assert-boolean (kl:shen.alphanums? (string-tail V2725 1))))) (#t (kl:shen.f_error (quote shen.analyse-symbol?))))) (quote shen.analyse-symbol?))
(begin (register-function-arity (quote shen.alpha?) 1) (define (kl:shen.alpha? V2727) (kl:element? V2727 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" (cons "a" (cons "b" (cons "c" (cons "d" (cons "e" (cons "f" (cons "g" (cons "h" (cons "i" (cons "j" (cons "k" (cons "l" (cons "m" (cons "n" (cons "o" (cons "p" (cons "q" (cons "r" (cons "s" (cons "t" (cons "u" (cons "v" (cons "w" (cons "x" (cons "y" (cons "z" (cons "=" (cons "*" (cons "/" (cons "+" (cons "-" (cons "_" (cons "?" (cons "$" (cons "!" (cons "@" (cons "~" (cons ">" (cons "<" (cons "&" (cons "%" (cons "{" (cons "}" (cons ":" (cons ";" (cons "`" (cons "#" (cons "'" (cons "." (quote ())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (quote shen.alpha?))
(begin (register-function-arity (quote shen.alphanums?) 1) (define (kl:shen.alphanums? V2729) (cond ((equal? "" V2729) #t) ((assert-boolean (kl:shen.+string? V2729)) (and (assert-boolean (kl:shen.alphanum? (make-string 1 (string-ref V2729 0)))) (assert-boolean (kl:shen.alphanums? (string-tail V2729 1))))) (#t (kl:shen.f_error (quote shen.alphanums?))))) (quote shen.alphanums?))
(begin (register-function-arity (quote shen.alphanum?) 1) (define (kl:shen.alphanum? V2731) (or (assert-boolean (kl:shen.alpha? V2731)) (assert-boolean (kl:shen.digit? V2731)))) (quote shen.alphanum?))
(begin (register-function-arity (quote shen.digit?) 1) (define (kl:shen.digit? V2733) (kl:element? V2733 (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" (quote ()))))))))))))) (quote shen.digit?))
(begin (register-function-arity (quote variable?) 1) (define (kl:variable? V2735) (cond ((or (kl:boolean? V2735) (or (number? V2735) (string? V2735))) #f) (#t (guard (lambda (E) #f) (let ((String (kl:str V2735))) (kl:shen.analyse-variable? String)))))) (quote variable?))
(begin (register-function-arity (quote shen.analyse-variable?) 1) (define (kl:shen.analyse-variable? V2737) (cond ((assert-boolean (kl:shen.+string? V2737)) (and (assert-boolean (kl:shen.uppercase? (make-string 1 (string-ref V2737 0)))) (assert-boolean (kl:shen.alphanums? (string-tail V2737 1))))) (#t (kl:shen.f_error (quote shen.analyse-variable?))))) (quote shen.analyse-variable?))
(begin (register-function-arity (quote shen.uppercase?) 1) (define (kl:shen.uppercase? V2739) (kl:element? V2739 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" (quote ()))))))))))))))))))))))))))))) (quote shen.uppercase?))
(begin (register-function-arity (quote gensym) 1) (define (kl:gensym V2741) (kl:concat V2741 (kl:set (quote shen.*gensym*) (+ 1 (kl:value (quote shen.*gensym*)))))) (quote gensym))
(begin (register-function-arity (quote concat) 2) (define (kl:concat V2744 V2745) (kl:intern (string-append (kl:str V2744) (kl:str V2745)))) (quote concat))
(begin (register-function-arity (quote _waspvm_at_p) 2) (define (kl:_waspvm_at_p V2748 V2749) (let ((Vector (make-vector 3 (quote (quote shen.fail!))))) (let ((Tag (let ((_tmp Vector)) (vector-set! _tmp 0 (quote shen.tuple)) _tmp))) (let ((Fst (let ((_tmp Vector)) (vector-set! _tmp 1 V2748) _tmp))) (let ((Snd (let ((_tmp Vector)) (vector-set! _tmp 2 V2749) _tmp))) Vector))))) (quote _waspvm_at_p))
(begin (register-function-arity (quote fst) 1) (define (kl:fst V2751) (vector-ref V2751 1)) (quote fst))
(begin (register-function-arity (quote snd) 1) (define (kl:snd V2753) (vector-ref V2753 2)) (quote snd))
(begin (register-function-arity (quote tuple?) 1) (define (kl:tuple? V2755) (and (vector? V2755) (eq? (quote shen.tuple) (kl:<-address/or V2755 0 (lambda () (quote shen.not-tuple)))))) (quote tuple?))
(begin (register-function-arity (quote append) 2) (define (kl:append V2758 V2759) (cond ((null? V2758) V2759) ((pair? V2758) (cons (car V2758) (kl:append (cdr V2758) V2759))) (#t (kl:shen.f_error (quote append))))) (quote append))
(begin (register-function-arity (quote _waspvm_at_v) 2) (define (kl:_waspvm_at_v V2762 V2763) (let ((Limit (kl:limit V2763))) (let ((NewVector (kl:vector (+ Limit 1)))) (let ((X+NewVector (kl:vector-> NewVector 1 V2762))) (if (kl:= Limit 0) X+NewVector (kl:shen._waspvm_at_v-help V2763 1 Limit X+NewVector)))))) (quote _waspvm_at_v))
(begin (register-function-arity (quote shen._waspvm_at_v-help) 4) (define (kl:shen._waspvm_at_v-help V2769 V2770 V2771 V2772) (cond ((kl:= V2771 V2770) (kl:shen.copyfromvector V2769 V2772 V2771 (+ V2771 1))) (#t (kl:shen._waspvm_at_v-help V2769 (+ V2770 1) V2771 (kl:shen.copyfromvector V2769 V2772 V2770 (+ V2770 1)))))) (quote shen._waspvm_at_v-help))
(begin (register-function-arity (quote shen.copyfromvector) 4) (define (kl:shen.copyfromvector V2777 V2778 V2779 V2780) (guard (lambda (E) V2778) (kl:vector-> V2778 V2780 (kl:<-vector V2777 V2779)))) (quote shen.copyfromvector))
(begin (register-function-arity (quote hdv) 1) (define (kl:hdv V2782) (kl:<-vector/or V2782 1 (lambda () (simple-error (string-append "hdv needs a non-empty vector as an argument; not " (kl:shen.app V2782 "\n" (quote shen.s))))))) (quote hdv))
(begin (register-function-arity (quote tlv) 1) (define (kl:tlv V2784) (let ((Limit (kl:limit V2784))) (if (kl:= Limit 0) (simple-error "cannot take the tail of the empty vector\n") (if (kl:= Limit 1) (kl:vector 0) (let ((NewVector (kl:vector (- Limit 1)))) (kl:shen.tlv-help V2784 2 Limit (kl:vector (- Limit 1)))))))) (quote tlv))
(begin (register-function-arity (quote shen.tlv-help) 4) (define (kl:shen.tlv-help V2790 V2791 V2792 V2793) (cond ((kl:= V2792 V2791) (kl:shen.copyfromvector V2790 V2793 V2792 (- V2792 1))) (#t (kl:shen.tlv-help V2790 (+ V2791 1) V2792 (kl:shen.copyfromvector V2790 V2793 V2791 (- V2791 1)))))) (quote shen.tlv-help))
(begin (register-function-arity (quote assoc) 2) (define (kl:assoc V2805 V2806) (cond ((null? V2806) (quote ())) ((and (pair? V2806) (and (pair? (car V2806)) (kl:= (car (car V2806)) V2805))) (car V2806)) ((pair? V2806) (kl:assoc V2805 (cdr V2806))) (#t (kl:shen.f_error (quote assoc))))) (quote assoc))
(begin (register-function-arity (quote boolean?) 1) (define (kl:boolean? V2812) (cond ((kl:= #t V2812) #t) ((kl:= #f V2812) #t) (#t #f))) (quote boolean?))
(begin (register-function-arity (quote nl) 1) (define (kl:nl V2814) (cond ((kl:= 0 V2814) 0) (#t (begin (kl:shen.prhush "\n" (kl:stoutput)) (kl:nl (- V2814 1)))))) (quote nl))
(begin (register-function-arity (quote difference) 2) (define (kl:difference V2819 V2820) (cond ((null? V2819) (quote ())) ((pair? V2819) (if (kl:element? (car V2819) V2820) (kl:difference (cdr V2819) V2820) (cons (car V2819) (kl:difference (cdr V2819) V2820)))) (#t (kl:shen.f_error (quote difference))))) (quote difference))
(begin (register-function-arity (quote do) 2) (define (kl:do V2823 V2824) V2824) (quote do))
(begin (register-function-arity (quote element?) 2) (define (kl:element? V2836 V2837) (cond ((null? V2837) #f) ((and (pair? V2837) (kl:= (car V2837) V2836)) #t) ((pair? V2837) (kl:element? V2836 (cdr V2837))) (#t (kl:shen.f_error (quote element?))))) (quote element?))
(begin (register-function-arity (quote empty?) 1) (define (kl:empty? V2843) (cond ((null? V2843) #t) (#t #f))) (quote empty?))
(begin (register-function-arity (quote fix) 2) (define (kl:fix V2846 V2847) (kl:shen.fix-help V2846 V2847 (V2846 V2847))) (quote fix))
(begin (register-function-arity (quote shen.fix-help) 3) (define (kl:shen.fix-help V2858 V2859 V2860) (cond ((kl:= V2860 V2859) V2860) (#t (kl:shen.fix-help V2858 V2860 (V2858 V2860))))) (quote shen.fix-help))
(begin (register-function-arity (quote dict) 1) (define (kl:dict V2862) (let ((D (make-vector (+ 3 V2862) (quote (quote shen.fail!))))) (let ((Tag (let ((_tmp D)) (vector-set! _tmp 0 (quote shen.dictionary)) _tmp))) (let ((Capacity (let ((_tmp D)) (vector-set! _tmp 1 V2862) _tmp))) (let ((Count (let ((_tmp D)) (vector-set! _tmp 2 0) _tmp))) (let ((Fill (kl:shen.fillvector D 3 (+ 2 V2862) (quote ())))) D)))))) (quote dict))
(begin (register-function-arity (quote dict?) 1) (define (kl:dict? V2864) (and (vector? V2864) (eq? (kl:<-address/or V2864 0 (lambda () (quote shen.not-dictionary))) (quote shen.dictionary)))) (quote dict?))
(begin (register-function-arity (quote shen.dict-capacity) 1) (define (kl:shen.dict-capacity V2866) (vector-ref V2866 1)) (quote shen.dict-capacity))
(begin (register-function-arity (quote dict-count) 1) (define (kl:dict-count V2868) (vector-ref V2868 2)) (quote dict-count))
(begin (register-function-arity (quote shen.dict-count->) 2) (define (kl:shen.dict-count-> V2871 V2872) (let ((_tmp V2871)) (vector-set! _tmp 2 V2872) _tmp)) (quote shen.dict-count->))
(begin (register-function-arity (quote shen.<-dict-bucket) 2) (define (kl:shen.<-dict-bucket V2875 V2876) (vector-ref V2875 (+ 3 V2876))) (quote shen.<-dict-bucket))
(begin (register-function-arity (quote shen.dict-bucket->) 3) (define (kl:shen.dict-bucket-> V2880 V2881 V2882) (let ((_tmp V2880)) (vector-set! _tmp (+ 3 V2881) V2882) _tmp)) (quote shen.dict-bucket->))
(begin (register-function-arity (quote shen.set-key-entry-value) 3) (define (kl:shen.set-key-entry-value V2889 V2890 V2891) (cond ((null? V2891) (cons (cons V2889 V2890) (quote ()))) ((and (pair? V2891) (and (pair? (car V2891)) (kl:= (car (car V2891)) V2889))) (cons (cons (car (car V2891)) V2890) (cdr V2891))) ((pair? V2891) (cons (car V2891) (kl:shen.set-key-entry-value V2889 V2890 (cdr V2891)))) (#t (kl:shen.f_error (quote shen.set-key-entry-value))))) (quote shen.set-key-entry-value))
(begin (register-function-arity (quote shen.remove-key-entry-value) 2) (define (kl:shen.remove-key-entry-value V2897 V2898) (cond ((null? V2898) (quote ())) ((and (pair? V2898) (and (pair? (car V2898)) (kl:= (car (car V2898)) V2897))) (cdr V2898)) ((pair? V2898) (cons (car V2898) (kl:shen.remove-key-entry-value V2897 (cdr V2898)))) (#t (kl:shen.f_error (quote shen.remove-key-entry-value))))) (quote shen.remove-key-entry-value))
(begin (register-function-arity (quote shen.dict-update-count) 3) (define (kl:shen.dict-update-count V2902 V2903 V2904) (let ((Diff (- (kl:length V2904) (kl:length V2903)))) (kl:shen.dict-count-> V2902 (+ Diff (kl:dict-count V2902))))) (quote shen.dict-update-count))
(begin (register-function-arity (quote dict->) 3) (define (kl:dict-> V2908 V2909 V2910) (let ((N (kl:hash V2909 (kl:shen.dict-capacity V2908)))) (let ((Bucket (kl:shen.<-dict-bucket V2908 N))) (let ((NewBucket (kl:shen.set-key-entry-value V2909 V2910 Bucket))) (let ((Change (kl:shen.dict-bucket-> V2908 N NewBucket))) (let ((Count (kl:shen.dict-update-count V2908 Bucket NewBucket))) V2910)))))) (quote dict->))
(begin (register-function-arity (quote <-dict/or) 3) (define (kl:<-dict/or V2914 V2915 V2916) (let ((N (kl:hash V2915 (kl:shen.dict-capacity V2914)))) (let ((Bucket (kl:shen.<-dict-bucket V2914 N))) (let ((Result (kl:assoc V2915 Bucket))) (if (kl:empty? Result) (kl:thaw V2916) (cdr Result)))))) (quote <-dict/or))
(begin (register-function-arity (quote <-dict) 2) (define (kl:<-dict V2919 V2920) (kl:<-dict/or V2919 V2920 (lambda () (simple-error "value not found\n")))) (quote <-dict))
(begin (register-function-arity (quote dict-rm) 2) (define (kl:dict-rm V2923 V2924) (let ((N (kl:hash V2924 (kl:shen.dict-capacity V2923)))) (let ((Bucket (kl:shen.<-dict-bucket V2923 N))) (let ((NewBucket (kl:shen.remove-key-entry-value V2924 Bucket))) (let ((Change (kl:shen.dict-bucket-> V2923 N NewBucket))) (let ((Count (kl:shen.dict-update-count V2923 Bucket NewBucket))) V2924)))))) (quote dict-rm))
(begin (register-function-arity (quote dict-fold) 3) (define (kl:dict-fold V2928 V2929 V2930) (let ((Limit (kl:shen.dict-capacity V2929))) (kl:shen.dict-fold-h V2928 V2929 V2930 0 Limit))) (quote dict-fold))
(begin (register-function-arity (quote shen.dict-fold-h) 5) (define (kl:shen.dict-fold-h V2937 V2938 V2939 V2940 V2941) (cond ((kl:= V2941 V2940) V2939) (#t (let ((B (kl:shen.<-dict-bucket V2938 V2940))) (let ((Acc (kl:shen.bucket-fold V2937 B V2939))) (kl:shen.dict-fold-h V2937 V2938 Acc (+ 1 V2940) V2941)))))) (quote shen.dict-fold-h))
(begin (register-function-arity (quote shen.bucket-fold) 3) (define (kl:shen.bucket-fold V2945 V2946 V2947) (cond ((null? V2946) V2947) ((and (pair? V2946) (pair? (car V2946))) (((V2945 (car (car V2946))) (cdr (car V2946))) (kl:fold-right V2945 (cdr V2946) V2947))) (#t (kl:shen.f_error (quote shen.bucket-fold))))) (quote shen.bucket-fold))
(begin (register-function-arity (quote dict-keys) 1) (define (kl:dict-keys V2949) (kl:dict-fold (lambda (K) (lambda (_) (lambda (Acc) (cons K Acc)))) V2949 (quote ()))) (quote dict-keys))
(begin (register-function-arity (quote dict-values) 1) (define (kl:dict-values V2951) (kl:dict-fold (lambda (_) (lambda (V) (lambda (Acc) (cons V Acc)))) V2951 (quote ()))) (quote dict-values))
(begin (register-function-arity (quote put) 4) (define (kl:put V2956 V2957 V2958 V2959) (let ((Curr (kl:<-dict/or V2959 V2956 (lambda () (quote ()))))) (let ((Added (kl:shen.set-key-entry-value V2957 V2958 Curr))) (let ((Update (kl:dict-> V2959 V2956 Added))) V2958)))) (quote put))
(begin (register-function-arity (quote unput) 3) (define (kl:unput V2963 V2964 V2965) (let ((Curr (kl:<-dict/or V2965 V2963 (lambda () (quote ()))))) (let ((Removed (kl:shen.remove-key-entry-value V2964 Curr))) (let ((Update (kl:dict-> V2965 V2963 Removed))) V2963)))) (quote unput))
(begin (register-function-arity (quote get/or) 4) (define (kl:get/or V2970 V2971 V2972 V2973) (let ((Entry (kl:<-dict/or V2973 V2970 (lambda () (quote ()))))) (let ((Result (kl:assoc V2971 Entry))) (if (kl:empty? Result) (kl:thaw V2972) (cdr Result))))) (quote get/or))
(begin (register-function-arity (quote get) 3) (define (kl:get V2977 V2978 V2979) (kl:get/or V2977 V2978 (lambda () (simple-error "value not found\n")) V2979)) (quote get))
(begin (register-function-arity (quote hash) 2) (define (kl:hash V2982 V2983) (kl:shen.mod (kl:sum (kl:map (lambda (X) (string-ref X 0)) (kl:explode V2982))) V2983)) (quote hash))
(begin (register-function-arity (quote shen.mod) 2) (define (kl:shen.mod V2986 V2987) (kl:shen.modh V2986 (kl:shen.multiples V2986 (cons V2987 (quote ()))))) (quote shen.mod))
(begin (register-function-arity (quote shen.multiples) 2) (define (kl:shen.multiples V2990 V2991) (cond ((and (pair? V2991) (> (car V2991) V2990)) (cdr V2991)) ((pair? V2991) (kl:shen.multiples V2990 (cons (* 2 (car V2991)) V2991))) (#t (kl:shen.f_error (quote shen.multiples))))) (quote shen.multiples))
(begin (register-function-arity (quote shen.modh) 2) (define (kl:shen.modh V2996 V2997) (cond ((kl:= 0 V2996) 0) ((null? V2997) V2996) ((and (pair? V2997) (> (car V2997) V2996)) (if (kl:empty? (cdr V2997)) V2996 (kl:shen.modh V2996 (cdr V2997)))) ((pair? V2997) (kl:shen.modh (- V2996 (car V2997)) V2997)) (#t (kl:shen.f_error (quote shen.modh))))) (quote shen.modh))
(begin (register-function-arity (quote sum) 1) (define (kl:sum V2999) (cond ((null? V2999) 0) ((pair? V2999) (+ (car V2999) (kl:sum (cdr V2999)))) (#t (kl:shen.f_error (quote sum))))) (quote sum))
(begin (register-function-arity (quote head) 1) (define (kl:head V3007) (cond ((pair? V3007) (car V3007)) (#t (simple-error "head expects a non-empty list")))) (quote head))
(begin (register-function-arity (quote tail) 1) (define (kl:tail V3015) (cond ((pair? V3015) (cdr V3015)) (#t (simple-error "tail expects a non-empty list")))) (quote tail))
(begin (register-function-arity (quote hdstr) 1) (define (kl:hdstr V3017) (make-string 1 (string-ref V3017 0))) (quote hdstr))
(begin (register-function-arity (quote intersection) 2) (define (kl:intersection V3022 V3023) (cond ((null? V3022) (quote ())) ((pair? V3022) (if (kl:element? (car V3022) V3023) (cons (car V3022) (kl:intersection (cdr V3022) V3023)) (kl:intersection (cdr V3022) V3023))) (#t (kl:shen.f_error (quote intersection))))) (quote intersection))
(begin (register-function-arity (quote reverse) 1) (define (kl:reverse V3025) (kl:shen.reverse_help V3025 (quote ()))) (quote reverse))
(begin (register-function-arity (quote shen.reverse_help) 2) (define (kl:shen.reverse_help V3028 V3029) (cond ((null? V3028) V3029) ((pair? V3028) (kl:shen.reverse_help (cdr V3028) (cons (car V3028) V3029))) (#t (kl:shen.f_error (quote shen.reverse_help))))) (quote shen.reverse_help))
(begin (register-function-arity (quote union) 2) (define (kl:union V3032 V3033) (cond ((null? V3032) V3033) ((pair? V3032) (if (kl:element? (car V3032) V3033) (kl:union (cdr V3032) V3033) (cons (car V3032) (kl:union (cdr V3032) V3033)))) (#t (kl:shen.f_error (quote union))))) (quote union))
(begin (register-function-arity (quote y-or-n?) 1) (define (kl:y-or-n? V3035) (let ((Message (kl:shen.prhush (kl:shen.proc-nl V3035) (kl:stoutput)))) (let ((Y-or-N (kl:shen.prhush " (y/n) " (kl:stoutput)))) (let ((Input (kl:shen.app (kl:read (kl:stinput)) "" (quote shen.s)))) (if (equal? "y" Input) #t (if (equal? "n" Input) #f (begin (kl:shen.prhush "please answer y or n\n" (kl:stoutput)) (kl:y-or-n? V3035)))))))) (quote y-or-n?))
(begin (register-function-arity (quote not) 1) (define (kl:not V3037) (if (assert-boolean V3037) #f #t)) (quote not))
(begin (register-function-arity (quote subst) 3) (define (kl:subst V3050 V3051 V3052) (cond ((kl:= V3052 V3051) V3050) ((pair? V3052) (kl:map (lambda (W) (kl:subst V3050 V3051 W)) V3052)) (#t V3052))) (quote subst))
(begin (register-function-arity (quote explode) 1) (define (kl:explode V3054) (kl:shen.explode-h (kl:shen.app V3054 "" (quote shen.a)))) (quote explode))
(begin (register-function-arity (quote shen.explode-h) 1) (define (kl:shen.explode-h V3056) (cond ((equal? "" V3056) (quote ())) ((assert-boolean (kl:shen.+string? V3056)) (cons (make-string 1 (string-ref V3056 0)) (kl:shen.explode-h (string-tail V3056 1)))) (#t (kl:shen.f_error (quote shen.explode-h))))) (quote shen.explode-h))
(begin (register-function-arity (quote cd) 1) (define (kl:cd V3058) (kl:set (quote *home-directory*) (if (equal? V3058 "") "" (kl:shen.app V3058 "/" (quote shen.a))))) (quote cd))
(begin (register-function-arity (quote for-each) 2) (define (kl:for-each V3061 V3062) (cond ((null? V3062) #t) ((pair? V3062) (let ((_ (V3061 (car V3062)))) (kl:for-each V3061 (cdr V3062)))) (#t (kl:shen.f_error (quote for-each))))) (quote for-each))
(begin (register-function-arity (quote fold-right) 3) (define (kl:fold-right V3066 V3067 V3068) (cond ((null? V3067) V3068) ((pair? V3067) ((V3066 (car V3067)) (kl:fold-right V3066 (cdr V3067) V3068))) (#t (kl:shen.f_error (quote fold-right))))) (quote fold-right))
(begin (register-function-arity (quote fold-left) 3) (define (kl:fold-left V3072 V3073 V3074) (cond ((null? V3074) V3073) ((pair? V3074) (kl:fold-left V3072 ((V3072 V3073) (car V3074)) (cdr V3074))) (#t (kl:shen.f_error (quote fold-left))))) (quote fold-left))
(begin (register-function-arity (quote filter) 2) (define (kl:filter V3077 V3078) (kl:shen.filter-h V3077 (quote ()) V3078)) (quote filter))
(begin (register-function-arity (quote shen.filter-h) 3) (define (kl:shen.filter-h V3088 V3089 V3090) (cond ((null? V3090) (kl:reverse V3089)) ((and (pair? V3090) (assert-boolean (V3088 (car V3090)))) (kl:shen.filter-h V3088 (cons (car V3090) V3089) (cdr V3090))) ((pair? V3090) (kl:shen.filter-h V3088 V3089 (cdr V3090))) (#t (kl:shen.f_error (quote shen.filter-h))))) (quote shen.filter-h))
(begin (register-function-arity (quote map) 2) (define (kl:map V3093 V3094) (kl:shen.map-h V3093 V3094 (quote ()))) (quote map))
(begin (register-function-arity (quote shen.map-h) 3) (define (kl:shen.map-h V3100 V3101 V3102) (cond ((null? V3101) (kl:reverse V3102)) ((pair? V3101) (kl:shen.map-h V3100 (cdr V3101) (cons (V3100 (car V3101)) V3102))) (#t (kl:shen.f_error (quote shen.map-h))))) (quote shen.map-h))
(begin (register-function-arity (quote length) 1) (define (kl:length V3104) (kl:shen.length-h V3104 0)) (quote length))
(begin (register-function-arity (quote shen.length-h) 2) (define (kl:shen.length-h V3107 V3108) (cond ((null? V3107) V3108) (#t (kl:shen.length-h (cdr V3107) (+ V3108 1))))) (quote shen.length-h))
(begin (register-function-arity (quote occurrences) 2) (define (kl:occurrences V3120 V3121) (cond ((kl:= V3121 V3120) 1) ((pair? V3121) (+ (kl:occurrences V3120 (car V3121)) (kl:occurrences V3120 (cdr V3121)))) (#t 0))) (quote occurrences))
(begin (register-function-arity (quote nth) 2) (define (kl:nth V3130 V3131) (cond ((and (kl:= 1 V3130) (pair? V3131)) (car V3131)) ((pair? V3131) (kl:nth (- V3130 1) (cdr V3131))) (#t (kl:shen.f_error (quote nth))))) (quote nth))
(begin (register-function-arity (quote integer?) 1) (define (kl:integer? V3133) (and (number? V3133) (assert-boolean (let ((Abs (kl:shen.abs V3133))) (kl:shen.integer-test? Abs (kl:shen.magless Abs 1)))))) (quote integer?))
(begin (register-function-arity (quote shen.abs) 1) (define (kl:shen.abs V3135) (if (> V3135 0) V3135 (- 0 V3135))) (quote shen.abs))
(begin (register-function-arity (quote shen.magless) 2) (define (kl:shen.magless V3138 V3139) (let ((Nx2 (* V3139 2))) (if (> Nx2 V3138) V3139 (kl:shen.magless V3138 Nx2)))) (quote shen.magless))
(begin (register-function-arity (quote shen.integer-test?) 2) (define (kl:shen.integer-test? V3145 V3146) (cond ((kl:= 0 V3145) #t) ((> 1 V3145) #f) (#t (let ((Abs-N (- V3145 V3146))) (if (> 0 Abs-N) (kl:integer? V3145) (kl:shen.integer-test? Abs-N V3146)))))) (quote shen.integer-test?))
(begin (register-function-arity (quote mapcan) 2) (define (kl:mapcan V3151 V3152) (cond ((null? V3152) (quote ())) ((pair? V3152) (kl:append (V3151 (car V3152)) (kl:mapcan V3151 (cdr V3152)))) (#t (kl:shen.f_error (quote mapcan))))) (quote mapcan))
(begin (register-function-arity (quote ==) 2) (define (kl:== V3164 V3165) (cond ((kl:= V3165 V3164) #t) (#t #f))) (quote ==))
(begin (register-function-arity (quote abort) 0) (define (kl:abort) (simple-error "")) (quote abort))
(begin (register-function-arity (quote bound?) 1) (define (kl:bound? V3167) (and (kl:symbol? V3167) (assert-boolean (let ((Val (kl:value/or V3167 (lambda () (quote shen.this-symbol-is-unbound))))) (if (eq? Val (quote shen.this-symbol-is-unbound)) #f #t))))) (quote bound?))
(begin (register-function-arity (quote shen.string->bytes) 1) (define (kl:shen.string->bytes V3169) (cond ((equal? "" V3169) (quote ())) (#t (cons (string-ref (make-string 1 (string-ref V3169 0)) 0) (kl:shen.string->bytes (string-tail V3169 1)))))) (quote shen.string->bytes))
(begin (register-function-arity (quote maxinferences) 1) (define (kl:maxinferences V3171) (kl:set (quote shen.*maxinferences*) V3171)) (quote maxinferences))
(begin (register-function-arity (quote inferences) 0) (define (kl:inferences) (kl:value (quote shen.*infs*))) (quote inferences))
(begin (register-function-arity (quote protect) 1) (define (kl:protect V3173) V3173) (quote protect))
(begin (register-function-arity (quote stoutput) 0) (define (kl:stoutput) (kl:value (quote *stoutput*))) (quote stoutput))
(begin (register-function-arity (quote sterror) 0) (define (kl:sterror) (kl:value (quote shen.*sterror*))) (quote sterror))
(begin (register-function-arity (quote string->symbol) 1) (define (kl:string->symbol V3175) (let ((Symbol (kl:intern V3175))) (if (kl:symbol? Symbol) Symbol (simple-error (string-append "cannot intern " (kl:shen.app V3175 " to a symbol" (quote shen.s))))))) (quote string->symbol))
(begin (register-function-arity (quote optimise) 1) (define (kl:optimise V3181) (cond ((eq? (quote +) V3181) (kl:set (quote shen.*optimise*) #t)) ((eq? (quote -) V3181) (kl:set (quote shen.*optimise*) #f)) (#t (simple-error "optimise expects a + or a -.\n")))) (quote optimise))
(begin (register-function-arity (quote os) 0) (define (kl:os) (kl:value (quote *os*))) (quote os))
(begin (register-function-arity (quote language) 0) (define (kl:language) (kl:value (quote *language*))) (quote language))
(begin (register-function-arity (quote version) 0) (define (kl:version) (kl:value (quote *version*))) (quote version))
(begin (register-function-arity (quote port) 0) (define (kl:port) (kl:value (quote *port*))) (quote port))
(begin (register-function-arity (quote porters) 0) (define (kl:porters) (kl:value (quote *porters*))) (quote porters))
(begin (register-function-arity (quote implementation) 0) (define (kl:implementation) (kl:value (quote *implementation*))) (quote implementation))
(begin (register-function-arity (quote release) 0) (define (kl:release) (kl:value (quote *release*))) (quote release))
(begin (register-function-arity (quote package?) 1) (define (kl:package? V3183) (guard (lambda (E) #f) (begin (kl:external V3183) #t))) (quote package?))
(begin (register-function-arity (quote function) 1) (define (kl:function V3185) (kl:shen.lookup-func V3185)) (quote function))
(begin (register-function-arity (quote shen.lookup-func) 1) (define (kl:shen.lookup-func V3187) (kl:get/or V3187 (quote shen.lambda-form) (lambda () (simple-error (kl:shen.app V3187 " has no lambda expansion\n" (quote shen.a)))) (kl:value (quote *property-vector*)))) (quote shen.lookup-func))
