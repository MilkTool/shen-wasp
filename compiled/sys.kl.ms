"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote thaw) 1) (define (kl:thaw V2805) (V2805)) (quote thaw))
(begin (register-function-arity (quote eval) 1) (define (kl:eval V2807) (let ((Macroexpand (kl:shen.walk (lambda (Y) (kl:macroexpand Y)) V2807))) (if (assert-boolean (kl:shen.packaged? Macroexpand)) (kl:map (lambda (Z) (kl:shen.eval-without-macros Z)) (kl:shen.package-contents Macroexpand)) (kl:shen.eval-without-macros Macroexpand)))) (quote eval))
(begin (register-function-arity (quote shen.eval-without-macros) 1) (define (kl:shen.eval-without-macros V2809) (kl:eval-kl (kl:shen.elim-def (kl:shen.proc-input+ V2809)))) (quote shen.eval-without-macros))
(begin (register-function-arity (quote shen.proc-input+) 1) (define (kl:shen.proc-input+ V2811) (cond ((and (pair? V2811) (and (eq? (quote input+) (car V2811)) (and (pair? (cdr V2811)) (and (pair? (cdr (cdr V2811))) (null? (cdr (cdr (cdr V2811)))))))) (cons (quote input+) (cons (kl:shen.rcons_form (car (cdr V2811))) (cdr (cdr V2811))))) ((and (pair? V2811) (and (eq? (quote shen.read+) (car V2811)) (and (pair? (cdr V2811)) (and (pair? (cdr (cdr V2811))) (null? (cdr (cdr (cdr V2811)))))))) (cons (quote shen.read+) (cons (kl:shen.rcons_form (car (cdr V2811))) (cdr (cdr V2811))))) ((pair? V2811) (kl:map (lambda (Z) (kl:shen.proc-input+ Z)) V2811)) (#t V2811))) (quote shen.proc-input+))
(begin (register-function-arity (quote shen.elim-def) 1) (define (kl:shen.elim-def V2813) (cond ((and (pair? V2813) (and (eq? (quote define) (car V2813)) (pair? (cdr V2813)))) (kl:shen.shen->kl (car (cdr V2813)) (cdr (cdr V2813)))) ((and (pair? V2813) (and (eq? (quote defmacro) (car V2813)) (pair? (cdr V2813)))) (let ((Default (cons (quote X) (cons (quote ->) (cons (quote X) (quote ())))))) (let ((Def (kl:shen.elim-def (cons (quote define) (cons (car (cdr V2813)) (kl:append (cdr (cdr V2813)) Default)))))) (let ((MacroAdd (kl:shen.add-macro (car (cdr V2813))))) Def)))) ((and (pair? V2813) (and (eq? (quote defcc) (car V2813)) (pair? (cdr V2813)))) (kl:shen.elim-def (kl:shen.yacc V2813))) ((pair? V2813) (kl:map (lambda (Z) (kl:shen.elim-def Z)) V2813)) (#t V2813))) (quote shen.elim-def))
(begin (register-function-arity (quote shen.add-macro) 1) (define (kl:shen.add-macro V2815) (let ((MacroReg (kl:value (quote shen.*macroreg*)))) (let ((NewMacroReg (kl:set (quote shen.*macroreg*) (kl:adjoin V2815 (kl:value (quote shen.*macroreg*)))))) (if (kl:= MacroReg NewMacroReg) (quote shen.skip) (kl:set (quote *macros*) (cons (kl:function V2815) (kl:value (quote *macros*)))))))) (quote shen.add-macro))
(begin (register-function-arity (quote shen.packaged?) 1) (define (kl:shen.packaged? V2823) (cond ((and (pair? V2823) (and (eq? (quote package) (car V2823)) (and (pair? (cdr V2823)) (pair? (cdr (cdr V2823)))))) #t) (#t #f))) (quote shen.packaged?))
(begin (register-function-arity (quote external) 1) (define (kl:external V2825) (kl:get/or V2825 (quote shen.external-symbols) (lambda () (simple-error (string-append "package " (kl:shen.app V2825 " has not been used.\n" (quote shen.a))))) (kl:value (quote *property-vector*)))) (quote external))
(begin (register-function-arity (quote internal) 1) (define (kl:internal V2827) (kl:get/or V2827 (quote shen.internal-symbols) (lambda () (simple-error (string-append "package " (kl:shen.app V2827 " has not been used.\n" (quote shen.a))))) (kl:value (quote *property-vector*)))) (quote internal))
(begin (register-function-arity (quote shen.package-contents) 1) (define (kl:shen.package-contents V2831) (cond ((and (pair? V2831) (and (eq? (quote package) (car V2831)) (and (pair? (cdr V2831)) (and (eq? (quote null) (car (cdr V2831))) (pair? (cdr (cdr V2831))))))) (cdr (cdr (cdr V2831)))) ((and (pair? V2831) (and (eq? (quote package) (car V2831)) (and (pair? (cdr V2831)) (pair? (cdr (cdr V2831)))))) (kl:shen.packageh (car (cdr V2831)) (car (cdr (cdr V2831))) (cdr (cdr (cdr V2831))))) (#t (kl:shen.f_error (quote shen.package-contents))))) (quote shen.package-contents))
(begin (register-function-arity (quote shen.walk) 2) (define (kl:shen.walk V2834 V2835) (cond ((pair? V2835) (V2834 (kl:map (lambda (Z) (kl:shen.walk V2834 Z)) V2835))) (#t (V2834 V2835)))) (quote shen.walk))
(begin (register-function-arity (quote compile) 3) (define (kl:compile V2839 V2840 V2841) (let ((O (V2839 (cons V2840 (cons (quote ()) (quote ())))))) (if (or (kl:= (kl:fail) O) (kl:not (kl:empty? (car O)))) (V2841 O) (kl:shen.hdtl O)))) (quote compile))
(begin (register-function-arity (quote fail-if) 2) (define (kl:fail-if V2844 V2845) (if (assert-boolean (V2844 V2845)) (kl:fail) V2845)) (quote fail-if))
(begin (register-function-arity (quote _waspvm_at_s) 2) (define (kl:_waspvm_at_s V2848 V2849) (string-append V2848 V2849)) (quote _waspvm_at_s))
(begin (register-function-arity (quote tc?) 0) (define (kl:tc?) (kl:value (quote shen.*tc*))) (quote tc?))
(begin (register-function-arity (quote ps) 1) (define (kl:ps V2851) (kl:get/or V2851 (quote shen.source) (lambda () (simple-error (kl:shen.app V2851 " not found.\n" (quote shen.a)))) (kl:value (quote *property-vector*)))) (quote ps))
(begin (register-function-arity (quote stinput) 0) (define (kl:stinput) (kl:value (quote *stinput*))) (quote stinput))
(begin (register-function-arity (quote <-address/or) 3) (define (kl:<-address/or V2855 V2856 V2857) (guard (lambda (E) (kl:thaw V2857)) (vector-ref V2855 V2856))) (quote <-address/or))
(begin (register-function-arity (quote value/or) 2) (define (kl:value/or V2860 V2861) (guard (lambda (E) (kl:thaw V2861)) (kl:value V2860))) (quote value/or))
(begin (register-function-arity (quote vector) 1) (define (kl:vector V2863) (let ((Vector (make-vector (+ V2863 1) (quote (quote shen.fail!))))) (let ((ZeroStamp (let ((_tmp Vector)) (vector-set! _tmp 0 V2863) _tmp))) (let ((Standard (if (kl:= V2863 0) ZeroStamp (kl:shen.fillvector ZeroStamp 1 V2863 (kl:fail))))) Standard)))) (quote vector))
(begin (register-function-arity (quote shen.fillvector) 4) (define (kl:shen.fillvector V2869 V2870 V2871 V2872) (cond ((kl:= V2871 V2870) (let ((_tmp V2869)) (vector-set! _tmp V2871 V2872) _tmp)) (#t (kl:shen.fillvector (let ((_tmp V2869)) (vector-set! _tmp V2870 V2872) _tmp) (+ 1 V2870) V2871 V2872)))) (quote shen.fillvector))
(begin (register-function-arity (quote vector?) 1) (define (kl:vector? V2874) (and (vector? V2874) (assert-boolean (let ((X (kl:<-address/or V2874 0 (lambda () -1)))) (and (number? X) (>= X 0)))))) (quote vector?))
(begin (register-function-arity (quote vector->) 3) (define (kl:vector-> V2878 V2879 V2880) (if (kl:= V2879 0) (simple-error "cannot access 0th element of a vector\n") (let ((_tmp V2878)) (vector-set! _tmp V2879 V2880) _tmp))) (quote vector->))
(begin (register-function-arity (quote <-vector) 2) (define (kl:<-vector V2883 V2884) (if (kl:= V2884 0) (simple-error "cannot access 0th element of a vector\n") (let ((VectorElement (vector-ref V2883 V2884))) (if (kl:= VectorElement (kl:fail)) (simple-error "vector element not found\n") VectorElement)))) (quote <-vector))
(begin (register-function-arity (quote <-vector/or) 3) (define (kl:<-vector/or V2888 V2889 V2890) (if (kl:= V2889 0) (simple-error "cannot access 0th element of a vector\n") (let ((VectorElement (kl:<-address/or V2888 V2889 V2890))) (if (kl:= VectorElement (kl:fail)) (kl:thaw V2890) VectorElement)))) (quote <-vector/or))
(begin (register-function-arity (quote shen.posint?) 1) (define (kl:shen.posint? V2892) (and (assert-boolean (kl:integer? V2892)) (>= V2892 0))) (quote shen.posint?))
(begin (register-function-arity (quote limit) 1) (define (kl:limit V2894) (vector-ref V2894 0)) (quote limit))
(begin (register-function-arity (quote symbol?) 1) (define (kl:symbol? V2896) (cond ((or (kl:boolean? V2896) (or (number? V2896) (string? V2896))) #f) (#t (guard (lambda (E) #f) (let ((String (kl:str V2896))) (kl:shen.analyse-symbol? String)))))) (quote symbol?))
(begin (register-function-arity (quote shen.analyse-symbol?) 1) (define (kl:shen.analyse-symbol? V2898) (cond ((equal? "" V2898) #f) ((assert-boolean (kl:shen.+string? V2898)) (and (assert-boolean (kl:shen.alpha? (make-string 1 (string-ref V2898 0)))) (assert-boolean (kl:shen.alphanums? (string-tail V2898 1))))) (#t (kl:shen.f_error (quote shen.analyse-symbol?))))) (quote shen.analyse-symbol?))
(begin (register-function-arity (quote shen.alpha?) 1) (define (kl:shen.alpha? V2900) (kl:element? V2900 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" (cons "a" (cons "b" (cons "c" (cons "d" (cons "e" (cons "f" (cons "g" (cons "h" (cons "i" (cons "j" (cons "k" (cons "l" (cons "m" (cons "n" (cons "o" (cons "p" (cons "q" (cons "r" (cons "s" (cons "t" (cons "u" (cons "v" (cons "w" (cons "x" (cons "y" (cons "z" (cons "=" (cons "*" (cons "/" (cons "+" (cons "-" (cons "_" (cons "?" (cons "$" (cons "!" (cons "@" (cons "~" (cons ">" (cons "<" (cons "&" (cons "%" (cons "{" (cons "}" (cons ":" (cons ";" (cons "`" (cons "#" (cons "'" (cons "." (quote ())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (quote shen.alpha?))
(begin (register-function-arity (quote shen.alphanums?) 1) (define (kl:shen.alphanums? V2902) (cond ((equal? "" V2902) #t) ((assert-boolean (kl:shen.+string? V2902)) (and (assert-boolean (kl:shen.alphanum? (make-string 1 (string-ref V2902 0)))) (assert-boolean (kl:shen.alphanums? (string-tail V2902 1))))) (#t (kl:shen.f_error (quote shen.alphanums?))))) (quote shen.alphanums?))
(begin (register-function-arity (quote shen.alphanum?) 1) (define (kl:shen.alphanum? V2904) (or (assert-boolean (kl:shen.alpha? V2904)) (assert-boolean (kl:shen.digit? V2904)))) (quote shen.alphanum?))
(begin (register-function-arity (quote shen.digit?) 1) (define (kl:shen.digit? V2906) (kl:element? V2906 (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" (quote ()))))))))))))) (quote shen.digit?))
(begin (register-function-arity (quote variable?) 1) (define (kl:variable? V2908) (cond ((or (kl:boolean? V2908) (or (number? V2908) (string? V2908))) #f) (#t (guard (lambda (E) #f) (let ((String (kl:str V2908))) (kl:shen.analyse-variable? String)))))) (quote variable?))
(begin (register-function-arity (quote shen.analyse-variable?) 1) (define (kl:shen.analyse-variable? V2910) (cond ((assert-boolean (kl:shen.+string? V2910)) (and (assert-boolean (kl:shen.uppercase? (make-string 1 (string-ref V2910 0)))) (assert-boolean (kl:shen.alphanums? (string-tail V2910 1))))) (#t (kl:shen.f_error (quote shen.analyse-variable?))))) (quote shen.analyse-variable?))
(begin (register-function-arity (quote shen.uppercase?) 1) (define (kl:shen.uppercase? V2912) (kl:element? V2912 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" (quote ()))))))))))))))))))))))))))))) (quote shen.uppercase?))
(begin (register-function-arity (quote gensym) 1) (define (kl:gensym V2914) (kl:concat V2914 (kl:set (quote shen.*gensym*) (+ 1 (kl:value (quote shen.*gensym*)))))) (quote gensym))
(begin (register-function-arity (quote concat) 2) (define (kl:concat V2917 V2918) (kl:intern (string-append (kl:str V2917) (kl:str V2918)))) (quote concat))
(begin (register-function-arity (quote _waspvm_at_p) 2) (define (kl:_waspvm_at_p V2921 V2922) (let ((Vector (make-vector 3 (quote (quote shen.fail!))))) (let ((Tag (let ((_tmp Vector)) (vector-set! _tmp 0 (quote shen.tuple)) _tmp))) (let ((Fst (let ((_tmp Vector)) (vector-set! _tmp 1 V2921) _tmp))) (let ((Snd (let ((_tmp Vector)) (vector-set! _tmp 2 V2922) _tmp))) Vector))))) (quote _waspvm_at_p))
(begin (register-function-arity (quote fst) 1) (define (kl:fst V2924) (vector-ref V2924 1)) (quote fst))
(begin (register-function-arity (quote snd) 1) (define (kl:snd V2926) (vector-ref V2926 2)) (quote snd))
(begin (register-function-arity (quote tuple?) 1) (define (kl:tuple? V2928) (and (vector? V2928) (eq? (quote shen.tuple) (kl:<-address/or V2928 0 (lambda () (quote shen.not-tuple)))))) (quote tuple?))
(begin (register-function-arity (quote append) 2) (define (kl:append V2931 V2932) (cond ((null? V2931) V2932) ((pair? V2931) (cons (car V2931) (kl:append (cdr V2931) V2932))) (#t (kl:shen.f_error (quote append))))) (quote append))
(begin (register-function-arity (quote _waspvm_at_v) 2) (define (kl:_waspvm_at_v V2935 V2936) (let ((Limit (kl:limit V2936))) (let ((NewVector (kl:vector (+ Limit 1)))) (let ((X+NewVector (kl:vector-> NewVector 1 V2935))) (if (kl:= Limit 0) X+NewVector (kl:shen._waspvm_at_v-help V2936 1 Limit X+NewVector)))))) (quote _waspvm_at_v))
(begin (register-function-arity (quote shen._waspvm_at_v-help) 4) (define (kl:shen._waspvm_at_v-help V2942 V2943 V2944 V2945) (cond ((kl:= V2944 V2943) (kl:shen.copyfromvector V2942 V2945 V2944 (+ V2944 1))) (#t (kl:shen._waspvm_at_v-help V2942 (+ V2943 1) V2944 (kl:shen.copyfromvector V2942 V2945 V2943 (+ V2943 1)))))) (quote shen._waspvm_at_v-help))
(begin (register-function-arity (quote shen.copyfromvector) 4) (define (kl:shen.copyfromvector V2950 V2951 V2952 V2953) (guard (lambda (E) V2951) (kl:vector-> V2951 V2953 (kl:<-vector V2950 V2952)))) (quote shen.copyfromvector))
(begin (register-function-arity (quote hdv) 1) (define (kl:hdv V2955) (kl:<-vector/or V2955 1 (lambda () (simple-error (string-append "hdv needs a non-empty vector as an argument; not " (kl:shen.app V2955 "\n" (quote shen.s))))))) (quote hdv))
(begin (register-function-arity (quote tlv) 1) (define (kl:tlv V2957) (let ((Limit (kl:limit V2957))) (if (kl:= Limit 0) (simple-error "cannot take the tail of the empty vector\n") (if (kl:= Limit 1) (kl:vector 0) (let ((NewVector (kl:vector (- Limit 1)))) (kl:shen.tlv-help V2957 2 Limit (kl:vector (- Limit 1)))))))) (quote tlv))
(begin (register-function-arity (quote shen.tlv-help) 4) (define (kl:shen.tlv-help V2963 V2964 V2965 V2966) (cond ((kl:= V2965 V2964) (kl:shen.copyfromvector V2963 V2966 V2965 (- V2965 1))) (#t (kl:shen.tlv-help V2963 (+ V2964 1) V2965 (kl:shen.copyfromvector V2963 V2966 V2964 (- V2964 1)))))) (quote shen.tlv-help))
(begin (register-function-arity (quote assoc) 2) (define (kl:assoc V2978 V2979) (cond ((null? V2979) (quote ())) ((and (pair? V2979) (and (pair? (car V2979)) (kl:= (car (car V2979)) V2978))) (car V2979)) ((pair? V2979) (kl:assoc V2978 (cdr V2979))) (#t (kl:shen.f_error (quote assoc))))) (quote assoc))
(begin (register-function-arity (quote boolean?) 1) (define (kl:boolean? V2985) (cond ((kl:= #t V2985) #t) ((kl:= #f V2985) #t) (#t #f))) (quote boolean?))
(begin (register-function-arity (quote nl) 1) (define (kl:nl V2987) (cond ((kl:= 0 V2987) 0) (#t (begin (kl:shen.prhush "\n" (kl:stoutput)) (kl:nl (- V2987 1)))))) (quote nl))
(begin (register-function-arity (quote difference) 2) (define (kl:difference V2992 V2993) (cond ((null? V2992) (quote ())) ((pair? V2992) (if (kl:element? (car V2992) V2993) (kl:difference (cdr V2992) V2993) (cons (car V2992) (kl:difference (cdr V2992) V2993)))) (#t (kl:shen.f_error (quote difference))))) (quote difference))
(begin (register-function-arity (quote do) 2) (define (kl:do V2996 V2997) V2997) (quote do))
(begin (register-function-arity (quote element?) 2) (define (kl:element? V3009 V3010) (cond ((null? V3010) #f) ((and (pair? V3010) (kl:= (car V3010) V3009)) #t) ((pair? V3010) (kl:element? V3009 (cdr V3010))) (#t (kl:shen.f_error (quote element?))))) (quote element?))
(begin (register-function-arity (quote empty?) 1) (define (kl:empty? V3016) (cond ((null? V3016) #t) (#t #f))) (quote empty?))
(begin (register-function-arity (quote fix) 2) (define (kl:fix V3019 V3020) (kl:shen.fix-help V3019 V3020 (V3019 V3020))) (quote fix))
(begin (register-function-arity (quote shen.fix-help) 3) (define (kl:shen.fix-help V3031 V3032 V3033) (cond ((kl:= V3033 V3032) V3033) (#t (kl:shen.fix-help V3031 V3033 (V3031 V3033))))) (quote shen.fix-help))
(begin (register-function-arity (quote dict) 1) (define (kl:dict V3035) (let ((D (make-vector (+ 3 V3035) (quote (quote shen.fail!))))) (let ((Tag (let ((_tmp D)) (vector-set! _tmp 0 (quote shen.dictionary)) _tmp))) (let ((Capacity (let ((_tmp D)) (vector-set! _tmp 1 V3035) _tmp))) (let ((Count (let ((_tmp D)) (vector-set! _tmp 2 0) _tmp))) (let ((Fill (kl:shen.fillvector D 3 (+ 2 V3035) (quote ())))) D)))))) (quote dict))
(begin (register-function-arity (quote dict?) 1) (define (kl:dict? V3037) (and (vector? V3037) (eq? (kl:<-address/or V3037 0 (lambda () (quote shen.not-dictionary))) (quote shen.dictionary)))) (quote dict?))
(begin (register-function-arity (quote shen.dict-capacity) 1) (define (kl:shen.dict-capacity V3039) (vector-ref V3039 1)) (quote shen.dict-capacity))
(begin (register-function-arity (quote dict-count) 1) (define (kl:dict-count V3041) (vector-ref V3041 2)) (quote dict-count))
(begin (register-function-arity (quote shen.dict-count->) 2) (define (kl:shen.dict-count-> V3044 V3045) (let ((_tmp V3044)) (vector-set! _tmp 2 V3045) _tmp)) (quote shen.dict-count->))
(begin (register-function-arity (quote shen.<-dict-bucket) 2) (define (kl:shen.<-dict-bucket V3048 V3049) (vector-ref V3048 (+ 3 V3049))) (quote shen.<-dict-bucket))
(begin (register-function-arity (quote shen.dict-bucket->) 3) (define (kl:shen.dict-bucket-> V3053 V3054 V3055) (let ((_tmp V3053)) (vector-set! _tmp (+ 3 V3054) V3055) _tmp)) (quote shen.dict-bucket->))
(begin (register-function-arity (quote shen.set-key-entry-value) 3) (define (kl:shen.set-key-entry-value V3062 V3063 V3064) (cond ((null? V3064) (cons (cons V3062 V3063) (quote ()))) ((and (pair? V3064) (and (pair? (car V3064)) (kl:= (car (car V3064)) V3062))) (cons (cons (car (car V3064)) V3063) (cdr V3064))) ((pair? V3064) (cons (car V3064) (kl:shen.set-key-entry-value V3062 V3063 (cdr V3064)))) (#t (kl:shen.f_error (quote shen.set-key-entry-value))))) (quote shen.set-key-entry-value))
(begin (register-function-arity (quote shen.remove-key-entry-value) 2) (define (kl:shen.remove-key-entry-value V3070 V3071) (cond ((null? V3071) (quote ())) ((and (pair? V3071) (and (pair? (car V3071)) (kl:= (car (car V3071)) V3070))) (cdr V3071)) ((pair? V3071) (cons (car V3071) (kl:shen.remove-key-entry-value V3070 (cdr V3071)))) (#t (kl:shen.f_error (quote shen.remove-key-entry-value))))) (quote shen.remove-key-entry-value))
(begin (register-function-arity (quote shen.dict-update-count) 3) (define (kl:shen.dict-update-count V3075 V3076 V3077) (let ((Diff (- (kl:length V3077) (kl:length V3076)))) (kl:shen.dict-count-> V3075 (+ Diff (kl:dict-count V3075))))) (quote shen.dict-update-count))
(begin (register-function-arity (quote dict->) 3) (define (kl:dict-> V3081 V3082 V3083) (let ((N (kl:hash V3082 (kl:shen.dict-capacity V3081)))) (let ((Bucket (kl:shen.<-dict-bucket V3081 N))) (let ((NewBucket (kl:shen.set-key-entry-value V3082 V3083 Bucket))) (let ((Change (kl:shen.dict-bucket-> V3081 N NewBucket))) (let ((Count (kl:shen.dict-update-count V3081 Bucket NewBucket))) V3083)))))) (quote dict->))
(begin (register-function-arity (quote <-dict/or) 3) (define (kl:<-dict/or V3087 V3088 V3089) (let ((N (kl:hash V3088 (kl:shen.dict-capacity V3087)))) (let ((Bucket (kl:shen.<-dict-bucket V3087 N))) (let ((Result (kl:assoc V3088 Bucket))) (if (kl:empty? Result) (kl:thaw V3089) (cdr Result)))))) (quote <-dict/or))
(begin (register-function-arity (quote <-dict) 2) (define (kl:<-dict V3092 V3093) (kl:<-dict/or V3092 V3093 (lambda () (simple-error "value not found\n")))) (quote <-dict))
(begin (register-function-arity (quote dict-rm) 2) (define (kl:dict-rm V3096 V3097) (let ((N (kl:hash V3097 (kl:shen.dict-capacity V3096)))) (let ((Bucket (kl:shen.<-dict-bucket V3096 N))) (let ((NewBucket (kl:shen.remove-key-entry-value V3097 Bucket))) (let ((Change (kl:shen.dict-bucket-> V3096 N NewBucket))) (let ((Count (kl:shen.dict-update-count V3096 Bucket NewBucket))) V3097)))))) (quote dict-rm))
(begin (register-function-arity (quote dict-fold) 3) (define (kl:dict-fold V3101 V3102 V3103) (let ((Limit (kl:shen.dict-capacity V3102))) (kl:shen.dict-fold-h V3101 V3102 V3103 0 Limit))) (quote dict-fold))
(begin (register-function-arity (quote shen.dict-fold-h) 5) (define (kl:shen.dict-fold-h V3110 V3111 V3112 V3113 V3114) (cond ((kl:= V3114 V3113) V3112) (#t (let ((B (kl:shen.<-dict-bucket V3111 V3113))) (let ((Acc (kl:shen.bucket-fold V3110 B V3112))) (kl:shen.dict-fold-h V3110 V3111 Acc (+ 1 V3113) V3114)))))) (quote shen.dict-fold-h))
(begin (register-function-arity (quote shen.bucket-fold) 3) (define (kl:shen.bucket-fold V3118 V3119 V3120) (cond ((null? V3119) V3120) ((and (pair? V3119) (pair? (car V3119))) (((V3118 (car (car V3119))) (cdr (car V3119))) (kl:shen.bucket-fold V3118 (cdr V3119) V3120))) (#t (kl:shen.f_error (quote shen.bucket-fold))))) (quote shen.bucket-fold))
(begin (register-function-arity (quote dict-keys) 1) (define (kl:dict-keys V3122) (kl:dict-fold (lambda (K) (lambda (_) (lambda (Acc) (cons K Acc)))) V3122 (quote ()))) (quote dict-keys))
(begin (register-function-arity (quote dict-values) 1) (define (kl:dict-values V3124) (kl:dict-fold (lambda (_) (lambda (V) (lambda (Acc) (cons V Acc)))) V3124 (quote ()))) (quote dict-values))
(begin (register-function-arity (quote put) 4) (define (kl:put V3129 V3130 V3131 V3132) (let ((Curr (kl:<-dict/or V3132 V3129 (lambda () (quote ()))))) (let ((Added (kl:shen.set-key-entry-value V3130 V3131 Curr))) (let ((Update (kl:dict-> V3132 V3129 Added))) V3131)))) (quote put))
(begin (register-function-arity (quote unput) 3) (define (kl:unput V3136 V3137 V3138) (let ((Curr (kl:<-dict/or V3138 V3136 (lambda () (quote ()))))) (let ((Removed (kl:shen.remove-key-entry-value V3137 Curr))) (let ((Update (kl:dict-> V3138 V3136 Removed))) V3136)))) (quote unput))
(begin (register-function-arity (quote get/or) 4) (define (kl:get/or V3143 V3144 V3145 V3146) (let ((Entry (kl:<-dict/or V3146 V3143 (lambda () (quote ()))))) (let ((Result (kl:assoc V3144 Entry))) (if (kl:empty? Result) (kl:thaw V3145) (cdr Result))))) (quote get/or))
(begin (register-function-arity (quote get) 3) (define (kl:get V3150 V3151 V3152) (kl:get/or V3150 V3151 (lambda () (simple-error "value not found\n")) V3152)) (quote get))
(begin (register-function-arity (quote hash) 2) (define (kl:hash V3155 V3156) (kl:shen.mod (kl:sum (kl:map (lambda (X) (string-ref X 0)) (kl:explode V3155))) V3156)) (quote hash))
(begin (register-function-arity (quote shen.mod) 2) (define (kl:shen.mod V3159 V3160) (kl:shen.modh V3159 (kl:shen.multiples V3159 (cons V3160 (quote ()))))) (quote shen.mod))
(begin (register-function-arity (quote shen.multiples) 2) (define (kl:shen.multiples V3163 V3164) (cond ((and (pair? V3164) (> (car V3164) V3163)) (cdr V3164)) ((pair? V3164) (kl:shen.multiples V3163 (cons (* 2 (car V3164)) V3164))) (#t (kl:shen.f_error (quote shen.multiples))))) (quote shen.multiples))
(begin (register-function-arity (quote shen.modh) 2) (define (kl:shen.modh V3169 V3170) (cond ((kl:= 0 V3169) 0) ((null? V3170) V3169) ((and (pair? V3170) (> (car V3170) V3169)) (if (kl:empty? (cdr V3170)) V3169 (kl:shen.modh V3169 (cdr V3170)))) ((pair? V3170) (kl:shen.modh (- V3169 (car V3170)) V3170)) (#t (kl:shen.f_error (quote shen.modh))))) (quote shen.modh))
(begin (register-function-arity (quote sum) 1) (define (kl:sum V3172) (cond ((null? V3172) 0) ((pair? V3172) (+ (car V3172) (kl:sum (cdr V3172)))) (#t (kl:shen.f_error (quote sum))))) (quote sum))
(begin (register-function-arity (quote head) 1) (define (kl:head V3180) (cond ((pair? V3180) (car V3180)) (#t (simple-error "head expects a non-empty list")))) (quote head))
(begin (register-function-arity (quote tail) 1) (define (kl:tail V3188) (cond ((pair? V3188) (cdr V3188)) (#t (simple-error "tail expects a non-empty list")))) (quote tail))
(begin (register-function-arity (quote hdstr) 1) (define (kl:hdstr V3190) (make-string 1 (string-ref V3190 0))) (quote hdstr))
(begin (register-function-arity (quote intersection) 2) (define (kl:intersection V3195 V3196) (cond ((null? V3195) (quote ())) ((pair? V3195) (if (kl:element? (car V3195) V3196) (cons (car V3195) (kl:intersection (cdr V3195) V3196)) (kl:intersection (cdr V3195) V3196))) (#t (kl:shen.f_error (quote intersection))))) (quote intersection))
(begin (register-function-arity (quote reverse) 1) (define (kl:reverse V3198) (kl:shen.reverse_help V3198 (quote ()))) (quote reverse))
(begin (register-function-arity (quote shen.reverse_help) 2) (define (kl:shen.reverse_help V3201 V3202) (cond ((null? V3201) V3202) ((pair? V3201) (kl:shen.reverse_help (cdr V3201) (cons (car V3201) V3202))) (#t (kl:shen.f_error (quote shen.reverse_help))))) (quote shen.reverse_help))
(begin (register-function-arity (quote union) 2) (define (kl:union V3205 V3206) (cond ((null? V3205) V3206) ((pair? V3205) (if (kl:element? (car V3205) V3206) (kl:union (cdr V3205) V3206) (cons (car V3205) (kl:union (cdr V3205) V3206)))) (#t (kl:shen.f_error (quote union))))) (quote union))
(begin (register-function-arity (quote y-or-n?) 1) (define (kl:y-or-n? V3208) (let ((Message (kl:shen.prhush (kl:shen.proc-nl V3208) (kl:stoutput)))) (let ((Y-or-N (kl:shen.prhush " (y/n) " (kl:stoutput)))) (let ((Input (kl:shen.app (kl:read (kl:stinput)) "" (quote shen.s)))) (if (equal? "y" Input) #t (if (equal? "n" Input) #f (begin (kl:shen.prhush "please answer y or n\n" (kl:stoutput)) (kl:y-or-n? V3208)))))))) (quote y-or-n?))
(begin (register-function-arity (quote not) 1) (define (kl:not V3210) (if (assert-boolean V3210) #f #t)) (quote not))
(begin (register-function-arity (quote subst) 3) (define (kl:subst V3223 V3224 V3225) (cond ((kl:= V3225 V3224) V3223) ((pair? V3225) (kl:map (lambda (W) (kl:subst V3223 V3224 W)) V3225)) (#t V3225))) (quote subst))
(begin (register-function-arity (quote explode) 1) (define (kl:explode V3227) (kl:shen.explode-h (kl:shen.app V3227 "" (quote shen.a)))) (quote explode))
(begin (register-function-arity (quote shen.explode-h) 1) (define (kl:shen.explode-h V3229) (cond ((equal? "" V3229) (quote ())) ((assert-boolean (kl:shen.+string? V3229)) (cons (make-string 1 (string-ref V3229 0)) (kl:shen.explode-h (string-tail V3229 1)))) (#t (kl:shen.f_error (quote shen.explode-h))))) (quote shen.explode-h))
(begin (register-function-arity (quote cd) 1) (define (kl:cd V3231) (kl:set (quote *home-directory*) (if (equal? V3231 "") "" (kl:shen.app V3231 "/" (quote shen.a))))) (quote cd))
(begin (register-function-arity (quote for-each) 2) (define (kl:for-each V3234 V3235) (cond ((null? V3235) #t) ((pair? V3235) (let ((_ (V3234 (car V3235)))) (kl:for-each V3234 (cdr V3235)))) (#t (kl:shen.f_error (quote for-each))))) (quote for-each))
(begin (register-function-arity (quote fold-right) 3) (define (kl:fold-right V3239 V3240 V3241) (cond ((null? V3240) V3241) ((pair? V3240) ((V3239 (car V3240)) (kl:fold-right V3239 (cdr V3240) V3241))) (#t (kl:shen.f_error (quote fold-right))))) (quote fold-right))
(begin (register-function-arity (quote fold-left) 3) (define (kl:fold-left V3245 V3246 V3247) (cond ((null? V3247) V3246) ((pair? V3247) (kl:fold-left V3245 ((V3245 V3246) (car V3247)) (cdr V3247))) (#t (kl:shen.f_error (quote fold-left))))) (quote fold-left))
(begin (register-function-arity (quote filter) 2) (define (kl:filter V3250 V3251) (kl:shen.filter-h V3250 (quote ()) V3251)) (quote filter))
(begin (register-function-arity (quote shen.filter-h) 3) (define (kl:shen.filter-h V3261 V3262 V3263) (cond ((null? V3263) (kl:reverse V3262)) ((and (pair? V3263) (assert-boolean (V3261 (car V3263)))) (kl:shen.filter-h V3261 (cons (car V3263) V3262) (cdr V3263))) ((pair? V3263) (kl:shen.filter-h V3261 V3262 (cdr V3263))) (#t (kl:shen.f_error (quote shen.filter-h))))) (quote shen.filter-h))
(begin (register-function-arity (quote map) 2) (define (kl:map V3266 V3267) (kl:shen.map-h V3266 V3267 (quote ()))) (quote map))
(begin (register-function-arity (quote shen.map-h) 3) (define (kl:shen.map-h V3273 V3274 V3275) (cond ((null? V3274) (kl:reverse V3275)) ((pair? V3274) (kl:shen.map-h V3273 (cdr V3274) (cons (V3273 (car V3274)) V3275))) (#t (kl:shen.f_error (quote shen.map-h))))) (quote shen.map-h))
(begin (register-function-arity (quote length) 1) (define (kl:length V3277) (kl:shen.length-h V3277 0)) (quote length))
(begin (register-function-arity (quote shen.length-h) 2) (define (kl:shen.length-h V3280 V3281) (cond ((null? V3280) V3281) (#t (kl:shen.length-h (cdr V3280) (+ V3281 1))))) (quote shen.length-h))
(begin (register-function-arity (quote occurrences) 2) (define (kl:occurrences V3293 V3294) (cond ((kl:= V3294 V3293) 1) ((pair? V3294) (+ (kl:occurrences V3293 (car V3294)) (kl:occurrences V3293 (cdr V3294)))) (#t 0))) (quote occurrences))
(begin (register-function-arity (quote nth) 2) (define (kl:nth V3303 V3304) (cond ((and (kl:= 1 V3303) (pair? V3304)) (car V3304)) ((pair? V3304) (kl:nth (- V3303 1) (cdr V3304))) (#t (kl:shen.f_error (quote nth))))) (quote nth))
(begin (register-function-arity (quote integer?) 1) (define (kl:integer? V3306) (and (number? V3306) (assert-boolean (let ((Abs (kl:shen.abs V3306))) (kl:shen.integer-test? Abs (kl:shen.magless Abs 1)))))) (quote integer?))
(begin (register-function-arity (quote shen.abs) 1) (define (kl:shen.abs V3308) (if (> V3308 0) V3308 (- 0 V3308))) (quote shen.abs))
(begin (register-function-arity (quote shen.magless) 2) (define (kl:shen.magless V3311 V3312) (let ((Nx2 (* V3312 2))) (if (> Nx2 V3311) V3312 (kl:shen.magless V3311 Nx2)))) (quote shen.magless))
(begin (register-function-arity (quote shen.integer-test?) 2) (define (kl:shen.integer-test? V3318 V3319) (cond ((kl:= 0 V3318) #t) ((> 1 V3318) #f) (#t (let ((Abs-N (- V3318 V3319))) (if (> 0 Abs-N) (kl:integer? V3318) (kl:shen.integer-test? Abs-N V3319)))))) (quote shen.integer-test?))
(begin (register-function-arity (quote mapcan) 2) (define (kl:mapcan V3324 V3325) (cond ((null? V3325) (quote ())) ((pair? V3325) (kl:append (V3324 (car V3325)) (kl:mapcan V3324 (cdr V3325)))) (#t (kl:shen.f_error (quote mapcan))))) (quote mapcan))
(begin (register-function-arity (quote ==) 2) (define (kl:== V3337 V3338) (cond ((kl:= V3338 V3337) #t) (#t #f))) (quote ==))
(begin (register-function-arity (quote abort) 0) (define (kl:abort) (simple-error "")) (quote abort))
(begin (register-function-arity (quote bound?) 1) (define (kl:bound? V3340) (and (kl:symbol? V3340) (assert-boolean (let ((Val (kl:value/or V3340 (lambda () (quote shen.this-symbol-is-unbound))))) (if (eq? Val (quote shen.this-symbol-is-unbound)) #f #t))))) (quote bound?))
(begin (register-function-arity (quote shen.string->bytes) 1) (define (kl:shen.string->bytes V3342) (cond ((equal? "" V3342) (quote ())) (#t (cons (string-ref (make-string 1 (string-ref V3342 0)) 0) (kl:shen.string->bytes (string-tail V3342 1)))))) (quote shen.string->bytes))
(begin (register-function-arity (quote maxinferences) 1) (define (kl:maxinferences V3344) (kl:set (quote shen.*maxinferences*) V3344)) (quote maxinferences))
(begin (register-function-arity (quote inferences) 0) (define (kl:inferences) (kl:value (quote shen.*infs*))) (quote inferences))
(begin (register-function-arity (quote protect) 1) (define (kl:protect V3346) V3346) (quote protect))
(begin (register-function-arity (quote stoutput) 0) (define (kl:stoutput) (kl:value (quote *stoutput*))) (quote stoutput))
(begin (register-function-arity (quote sterror) 0) (define (kl:sterror) (kl:value (quote *sterror*))) (quote sterror))
(begin (register-function-arity (quote command-line) 0) (define (kl:command-line) (kl:value (quote *argv*))) (quote command-line))
(begin (register-function-arity (quote string->symbol) 1) (define (kl:string->symbol V3348) (let ((Symbol (kl:intern V3348))) (if (kl:symbol? Symbol) Symbol (simple-error (string-append "cannot intern " (kl:shen.app V3348 " to a symbol" (quote shen.s))))))) (quote string->symbol))
(begin (register-function-arity (quote optimise) 1) (define (kl:optimise V3354) (cond ((eq? (quote +) V3354) (kl:set (quote shen.*optimise*) #t)) ((eq? (quote -) V3354) (kl:set (quote shen.*optimise*) #f)) (#t (simple-error "optimise expects a + or a -.\n")))) (quote optimise))
(begin (register-function-arity (quote os) 0) (define (kl:os) (kl:value (quote *os*))) (quote os))
(begin (register-function-arity (quote language) 0) (define (kl:language) (kl:value (quote *language*))) (quote language))
(begin (register-function-arity (quote version) 0) (define (kl:version) (kl:value (quote *version*))) (quote version))
(begin (register-function-arity (quote port) 0) (define (kl:port) (kl:value (quote *port*))) (quote port))
(begin (register-function-arity (quote porters) 0) (define (kl:porters) (kl:value (quote *porters*))) (quote porters))
(begin (register-function-arity (quote implementation) 0) (define (kl:implementation) (kl:value (quote *implementation*))) (quote implementation))
(begin (register-function-arity (quote release) 0) (define (kl:release) (kl:value (quote *release*))) (quote release))
(begin (register-function-arity (quote package?) 1) (define (kl:package? V3356) (guard (lambda (E) #f) (begin (kl:external V3356) #t))) (quote package?))
(begin (register-function-arity (quote function) 1) (define (kl:function V3358) (kl:shen.lookup-func V3358)) (quote function))
(begin (register-function-arity (quote shen.lookup-func) 1) (define (kl:shen.lookup-func V3360) (kl:get/or V3360 (quote shen.lambda-form) (lambda () (simple-error (kl:shen.app V3360 " has no lambda expansion\n" (quote shen.a)))) (kl:value (quote *property-vector*)))) (quote shen.lookup-func))
