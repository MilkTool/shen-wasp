"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote thaw) 1) (define (kl:thaw V2671) (V2671)) (quote thaw))
(begin (register-function-arity (quote eval) 1) (define (kl:eval V2673) (let ((Macroexpand (kl:shen.walk (lambda (Y) (kl:macroexpand Y)) V2673))) (if (assert-boolean (kl:shen.packaged? Macroexpand)) (kl:map (lambda (Z) (kl:shen.eval-without-macros Z)) (kl:shen.package-contents Macroexpand)) (kl:shen.eval-without-macros Macroexpand)))) (quote eval))
(begin (register-function-arity (quote shen.eval-without-macros) 1) (define (kl:shen.eval-without-macros V2675) (kl:eval-kl (kl:shen.elim-def (kl:shen.proc-input+ V2675)))) (quote shen.eval-without-macros))
(begin (register-function-arity (quote shen.proc-input+) 1) (define (kl:shen.proc-input+ V2677) (cond ((and (pair? V2677) (and (eq? (quote input+) (car V2677)) (and (pair? (cdr V2677)) (and (pair? (cdr (cdr V2677))) (null? (cdr (cdr (cdr V2677)))))))) (cons (quote input+) (cons (kl:shen.rcons_form (car (cdr V2677))) (cdr (cdr V2677))))) ((and (pair? V2677) (and (eq? (quote shen.read+) (car V2677)) (and (pair? (cdr V2677)) (and (pair? (cdr (cdr V2677))) (null? (cdr (cdr (cdr V2677)))))))) (cons (quote shen.read+) (cons (kl:shen.rcons_form (car (cdr V2677))) (cdr (cdr V2677))))) ((pair? V2677) (kl:map (lambda (Z) (kl:shen.proc-input+ Z)) V2677)) (#t V2677))) (quote shen.proc-input+))
(begin (register-function-arity (quote shen.elim-def) 1) (define (kl:shen.elim-def V2679) (cond ((and (pair? V2679) (and (eq? (quote define) (car V2679)) (pair? (cdr V2679)))) (kl:shen.shen->kl (car (cdr V2679)) (cdr (cdr V2679)))) ((and (pair? V2679) (and (eq? (quote defmacro) (car V2679)) (pair? (cdr V2679)))) (let ((Default (cons (quote X) (cons (quote ->) (cons (quote X) (quote ())))))) (let ((Def (kl:shen.elim-def (cons (quote define) (cons (car (cdr V2679)) (kl:append (cdr (cdr V2679)) Default)))))) (let ((MacroAdd (kl:shen.add-macro (car (cdr V2679))))) Def)))) ((and (pair? V2679) (and (eq? (quote defcc) (car V2679)) (pair? (cdr V2679)))) (kl:shen.elim-def (kl:shen.yacc V2679))) ((pair? V2679) (kl:map (lambda (Z) (kl:shen.elim-def Z)) V2679)) (#t V2679))) (quote shen.elim-def))
(begin (register-function-arity (quote shen.add-macro) 1) (define (kl:shen.add-macro V2681) (let ((MacroReg (kl:value (quote shen.*macroreg*)))) (let ((NewMacroReg (kl:set (quote shen.*macroreg*) (kl:adjoin V2681 (kl:value (quote shen.*macroreg*)))))) (if (kl:= MacroReg NewMacroReg) (quote shen.skip) (kl:set (quote *macros*) (cons (kl:function V2681) (kl:value (quote *macros*)))))))) (quote shen.add-macro))
(begin (register-function-arity (quote shen.packaged?) 1) (define (kl:shen.packaged? V2689) (cond ((and (pair? V2689) (and (eq? (quote package) (car V2689)) (and (pair? (cdr V2689)) (pair? (cdr (cdr V2689)))))) #t) (#t #f))) (quote shen.packaged?))
(begin (register-function-arity (quote external) 1) (define (kl:external V2691) (guard (lambda (E) (simple-error (string-append "package " (kl:shen.app V2691 " has not been used.\n" (quote shen.a))))) (kl:get V2691 (quote shen.external-symbols) (kl:value (quote *property-vector*))))) (quote external))
(begin (register-function-arity (quote internal) 1) (define (kl:internal V2693) (guard (lambda (E) (simple-error (string-append "package " (kl:shen.app V2693 " has not been used.\n" (quote shen.a))))) (kl:get V2693 (quote shen.internal-symbols) (kl:value (quote *property-vector*))))) (quote internal))
(begin (register-function-arity (quote shen.package-contents) 1) (define (kl:shen.package-contents V2697) (cond ((and (pair? V2697) (and (eq? (quote package) (car V2697)) (and (pair? (cdr V2697)) (and (eq? (quote null) (car (cdr V2697))) (pair? (cdr (cdr V2697))))))) (cdr (cdr (cdr V2697)))) ((and (pair? V2697) (and (eq? (quote package) (car V2697)) (and (pair? (cdr V2697)) (pair? (cdr (cdr V2697)))))) (let ((PackageNameDot (kl:intern (string-append (kl:str (car (cdr V2697))) ".")))) (let ((ExpPackageNameDot (kl:explode PackageNameDot))) (kl:shen.packageh (car (cdr V2697)) (car (cdr (cdr V2697))) (cdr (cdr (cdr V2697))) ExpPackageNameDot)))) (#t (kl:shen.f_error (quote shen.package-contents))))) (quote shen.package-contents))
(begin (register-function-arity (quote shen.walk) 2) (define (kl:shen.walk V2700 V2701) (cond ((pair? V2701) (V2700 (kl:map (lambda (Z) (kl:shen.walk V2700 Z)) V2701))) (#t (V2700 V2701)))) (quote shen.walk))
(begin (register-function-arity (quote compile) 3) (define (kl:compile V2705 V2706 V2707) (let ((O (V2705 (cons V2706 (cons (quote ()) (quote ())))))) (if (or (kl:= (kl:fail) O) (kl:not (kl:empty? (car O)))) (V2707 O) (kl:shen.hdtl O)))) (quote compile))
(begin (register-function-arity (quote fail-if) 2) (define (kl:fail-if V2710 V2711) (if (assert-boolean (V2710 V2711)) (kl:fail) V2711)) (quote fail-if))
(begin (register-function-arity (quote _waspvm_at_s) 2) (define (kl:_waspvm_at_s V2714 V2715) (string-append V2714 V2715)) (quote _waspvm_at_s))
(begin (register-function-arity (quote tc?) 0) (define (kl:tc?) (kl:value (quote shen.*tc*))) (quote tc?))
(begin (register-function-arity (quote ps) 1) (define (kl:ps V2717) (guard (lambda (E) (simple-error (kl:shen.app V2717 " not found.\n" (quote shen.a)))) (kl:get V2717 (quote shen.source) (kl:value (quote *property-vector*))))) (quote ps))
(begin (register-function-arity (quote stinput) 0) (define (kl:stinput) (kl:value (quote *stinput*))) (quote stinput))
(begin (register-function-arity (quote vector) 1) (define (kl:vector V2719) (let ((Vector (make-vector (+ V2719 1) (quote (quote shen.fail!))))) (let ((ZeroStamp (let ((_tmp Vector)) (vector-set! _tmp 0 V2719) _tmp))) (let ((Standard (if (kl:= V2719 0) ZeroStamp (kl:shen.fillvector ZeroStamp 1 V2719 (kl:fail))))) Standard)))) (quote vector))
(begin (register-function-arity (quote shen.fillvector) 4) (define (kl:shen.fillvector V2725 V2726 V2727 V2728) (cond ((kl:= V2727 V2726) (let ((_tmp V2725)) (vector-set! _tmp V2727 V2728) _tmp)) (#t (kl:shen.fillvector (let ((_tmp V2725)) (vector-set! _tmp V2726 V2728) _tmp) (+ 1 V2726) V2727 V2728)))) (quote shen.fillvector))
(begin (register-function-arity (quote vector?) 1) (define (kl:vector? V2730) (and (vector? V2730) (assert-boolean (let ((X (guard (lambda (E) -1) (vector-ref V2730 0)))) (and (number? X) (>= X 0)))))) (quote vector?))
(begin (register-function-arity (quote vector->) 3) (define (kl:vector-> V2734 V2735 V2736) (if (kl:= V2735 0) (simple-error "cannot access 0th element of a vector\n") (let ((_tmp V2734)) (vector-set! _tmp V2735 V2736) _tmp))) (quote vector->))
(begin (register-function-arity (quote <-vector) 2) (define (kl:<-vector V2739 V2740) (if (kl:= V2740 0) (simple-error "cannot access 0th element of a vector\n") (let ((VectorElement (vector-ref V2739 V2740))) (if (kl:= VectorElement (kl:fail)) (simple-error "vector element not found\n") VectorElement)))) (quote <-vector))
(begin (register-function-arity (quote shen.posint?) 1) (define (kl:shen.posint? V2742) (and (assert-boolean (kl:integer? V2742)) (>= V2742 0))) (quote shen.posint?))
(begin (register-function-arity (quote limit) 1) (define (kl:limit V2744) (vector-ref V2744 0)) (quote limit))
(begin (register-function-arity (quote symbol?) 1) (define (kl:symbol? V2746) (cond ((or (kl:boolean? V2746) (or (number? V2746) (string? V2746))) #f) (#t (guard (lambda (E) #f) (let ((String (kl:str V2746))) (kl:shen.analyse-symbol? String)))))) (quote symbol?))
(begin (register-function-arity (quote shen.analyse-symbol?) 1) (define (kl:shen.analyse-symbol? V2748) (cond ((equal? "" V2748) #f) ((assert-boolean (kl:shen.+string? V2748)) (and (assert-boolean (kl:shen.alpha? (make-string 1 (string-ref V2748 0)))) (assert-boolean (kl:shen.alphanums? (string-tail V2748 1))))) (#t (kl:shen.f_error (quote shen.analyse-symbol?))))) (quote shen.analyse-symbol?))
(begin (register-function-arity (quote shen.alpha?) 1) (define (kl:shen.alpha? V2750) (kl:element? V2750 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" (cons "a" (cons "b" (cons "c" (cons "d" (cons "e" (cons "f" (cons "g" (cons "h" (cons "i" (cons "j" (cons "k" (cons "l" (cons "m" (cons "n" (cons "o" (cons "p" (cons "q" (cons "r" (cons "s" (cons "t" (cons "u" (cons "v" (cons "w" (cons "x" (cons "y" (cons "z" (cons "=" (cons "*" (cons "/" (cons "+" (cons "-" (cons "_" (cons "?" (cons "$" (cons "!" (cons "@" (cons "~" (cons ">" (cons "<" (cons "&" (cons "%" (cons "{" (cons "}" (cons ":" (cons ";" (cons "`" (cons "#" (cons "'" (cons "." (quote ())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (quote shen.alpha?))
(begin (register-function-arity (quote shen.alphanums?) 1) (define (kl:shen.alphanums? V2752) (cond ((equal? "" V2752) #t) ((assert-boolean (kl:shen.+string? V2752)) (and (assert-boolean (kl:shen.alphanum? (make-string 1 (string-ref V2752 0)))) (assert-boolean (kl:shen.alphanums? (string-tail V2752 1))))) (#t (kl:shen.f_error (quote shen.alphanums?))))) (quote shen.alphanums?))
(begin (register-function-arity (quote shen.alphanum?) 1) (define (kl:shen.alphanum? V2754) (or (assert-boolean (kl:shen.alpha? V2754)) (assert-boolean (kl:shen.digit? V2754)))) (quote shen.alphanum?))
(begin (register-function-arity (quote shen.digit?) 1) (define (kl:shen.digit? V2756) (kl:element? V2756 (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" (quote ()))))))))))))) (quote shen.digit?))
(begin (register-function-arity (quote variable?) 1) (define (kl:variable? V2758) (cond ((or (kl:boolean? V2758) (or (number? V2758) (string? V2758))) #f) (#t (guard (lambda (E) #f) (let ((String (kl:str V2758))) (kl:shen.analyse-variable? String)))))) (quote variable?))
(begin (register-function-arity (quote shen.analyse-variable?) 1) (define (kl:shen.analyse-variable? V2760) (cond ((assert-boolean (kl:shen.+string? V2760)) (and (assert-boolean (kl:shen.uppercase? (make-string 1 (string-ref V2760 0)))) (assert-boolean (kl:shen.alphanums? (string-tail V2760 1))))) (#t (kl:shen.f_error (quote shen.analyse-variable?))))) (quote shen.analyse-variable?))
(begin (register-function-arity (quote shen.uppercase?) 1) (define (kl:shen.uppercase? V2762) (kl:element? V2762 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" (quote ()))))))))))))))))))))))))))))) (quote shen.uppercase?))
(begin (register-function-arity (quote gensym) 1) (define (kl:gensym V2764) (kl:concat V2764 (kl:set (quote shen.*gensym*) (+ 1 (kl:value (quote shen.*gensym*)))))) (quote gensym))
(begin (register-function-arity (quote concat) 2) (define (kl:concat V2767 V2768) (kl:intern (string-append (kl:str V2767) (kl:str V2768)))) (quote concat))
(begin (register-function-arity (quote _waspvm_at_p) 2) (define (kl:_waspvm_at_p V2771 V2772) (let ((Vector (make-vector 3 (quote (quote shen.fail!))))) (let ((Tag (let ((_tmp Vector)) (vector-set! _tmp 0 (quote shen.tuple)) _tmp))) (let ((Fst (let ((_tmp Vector)) (vector-set! _tmp 1 V2771) _tmp))) (let ((Snd (let ((_tmp Vector)) (vector-set! _tmp 2 V2772) _tmp))) Vector))))) (quote _waspvm_at_p))
(begin (register-function-arity (quote fst) 1) (define (kl:fst V2774) (vector-ref V2774 1)) (quote fst))
(begin (register-function-arity (quote snd) 1) (define (kl:snd V2776) (vector-ref V2776 2)) (quote snd))
(begin (register-function-arity (quote tuple?) 1) (define (kl:tuple? V2778) (and (vector? V2778) (eq? (quote shen.tuple) (guard (lambda (E) (quote shen.not-tuple)) (vector-ref V2778 0))))) (quote tuple?))
(begin (register-function-arity (quote append) 2) (define (kl:append V2781 V2782) (cond ((null? V2781) V2782) ((pair? V2781) (cons (car V2781) (kl:append (cdr V2781) V2782))) (#t (kl:shen.f_error (quote append))))) (quote append))
(begin (register-function-arity (quote _waspvm_at_v) 2) (define (kl:_waspvm_at_v V2785 V2786) (let ((Limit (kl:limit V2786))) (let ((NewVector (kl:vector (+ Limit 1)))) (let ((X+NewVector (kl:vector-> NewVector 1 V2785))) (if (kl:= Limit 0) X+NewVector (kl:shen._waspvm_at_v-help V2786 1 Limit X+NewVector)))))) (quote _waspvm_at_v))
(begin (register-function-arity (quote shen._waspvm_at_v-help) 4) (define (kl:shen._waspvm_at_v-help V2792 V2793 V2794 V2795) (cond ((kl:= V2794 V2793) (kl:shen.copyfromvector V2792 V2795 V2794 (+ V2794 1))) (#t (kl:shen._waspvm_at_v-help V2792 (+ V2793 1) V2794 (kl:shen.copyfromvector V2792 V2795 V2793 (+ V2793 1)))))) (quote shen._waspvm_at_v-help))
(begin (register-function-arity (quote shen.copyfromvector) 4) (define (kl:shen.copyfromvector V2800 V2801 V2802 V2803) (guard (lambda (E) V2801) (kl:vector-> V2801 V2803 (kl:<-vector V2800 V2802)))) (quote shen.copyfromvector))
(begin (register-function-arity (quote hdv) 1) (define (kl:hdv V2805) (guard (lambda (E) (simple-error (string-append "hdv needs a non-empty vector as an argument; not " (kl:shen.app V2805 "\n" (quote shen.s))))) (kl:<-vector V2805 1))) (quote hdv))
(begin (register-function-arity (quote tlv) 1) (define (kl:tlv V2807) (let ((Limit (kl:limit V2807))) (if (kl:= Limit 0) (simple-error "cannot take the tail of the empty vector\n") (if (kl:= Limit 1) (kl:vector 0) (let ((NewVector (kl:vector (- Limit 1)))) (kl:shen.tlv-help V2807 2 Limit (kl:vector (- Limit 1)))))))) (quote tlv))
(begin (register-function-arity (quote shen.tlv-help) 4) (define (kl:shen.tlv-help V2813 V2814 V2815 V2816) (cond ((kl:= V2815 V2814) (kl:shen.copyfromvector V2813 V2816 V2815 (- V2815 1))) (#t (kl:shen.tlv-help V2813 (+ V2814 1) V2815 (kl:shen.copyfromvector V2813 V2816 V2814 (- V2814 1)))))) (quote shen.tlv-help))
(begin (register-function-arity (quote assoc) 2) (define (kl:assoc V2828 V2829) (cond ((null? V2829) (quote ())) ((and (pair? V2829) (and (pair? (car V2829)) (kl:= (car (car V2829)) V2828))) (car V2829)) ((pair? V2829) (kl:assoc V2828 (cdr V2829))) (#t (kl:shen.f_error (quote assoc))))) (quote assoc))
(begin (register-function-arity (quote shen.assoc-set) 3) (define (kl:shen.assoc-set V2836 V2837 V2838) (cond ((null? V2838) (cons (cons V2836 V2837) (quote ()))) ((and (pair? V2838) (and (pair? (car V2838)) (kl:= (car (car V2838)) V2836))) (cons (cons (car (car V2838)) V2837) (cdr V2838))) ((pair? V2838) (cons (car V2838) (kl:shen.assoc-set V2836 V2837 (cdr V2838)))) (#t (kl:shen.f_error (quote shen.assoc-set))))) (quote shen.assoc-set))
(begin (register-function-arity (quote shen.assoc-rm) 2) (define (kl:shen.assoc-rm V2844 V2845) (cond ((null? V2845) (quote ())) ((and (pair? V2845) (and (pair? (car V2845)) (kl:= (car (car V2845)) V2844))) (cdr V2845)) ((pair? V2845) (cons (car V2845) (kl:shen.assoc-rm V2844 (cdr V2845)))) (#t (kl:shen.f_error (quote shen.assoc-rm))))) (quote shen.assoc-rm))
(begin (register-function-arity (quote boolean?) 1) (define (kl:boolean? V2851) (cond ((kl:= #t V2851) #t) ((kl:= #f V2851) #t) (#t #f))) (quote boolean?))
(begin (register-function-arity (quote nl) 1) (define (kl:nl V2853) (cond ((kl:= 0 V2853) 0) (#t (begin (kl:shen.prhush "\n" (kl:stoutput)) (kl:nl (- V2853 1)))))) (quote nl))
(begin (register-function-arity (quote difference) 2) (define (kl:difference V2858 V2859) (cond ((null? V2858) (quote ())) ((pair? V2858) (if (kl:element? (car V2858) V2859) (kl:difference (cdr V2858) V2859) (cons (car V2858) (kl:difference (cdr V2858) V2859)))) (#t (kl:shen.f_error (quote difference))))) (quote difference))
(begin (register-function-arity (quote do) 2) (define (kl:do V2862 V2863) V2863) (quote do))
(begin (register-function-arity (quote element?) 2) (define (kl:element? V2875 V2876) (cond ((null? V2876) #f) ((and (pair? V2876) (kl:= (car V2876) V2875)) #t) ((pair? V2876) (kl:element? V2875 (cdr V2876))) (#t (kl:shen.f_error (quote element?))))) (quote element?))
(begin (register-function-arity (quote empty?) 1) (define (kl:empty? V2882) (cond ((null? V2882) #t) (#t #f))) (quote empty?))
(begin (register-function-arity (quote fix) 2) (define (kl:fix V2885 V2886) (kl:shen.fix-help V2885 V2886 (V2885 V2886))) (quote fix))
(begin (register-function-arity (quote shen.fix-help) 3) (define (kl:shen.fix-help V2897 V2898 V2899) (cond ((kl:= V2899 V2898) V2899) (#t (kl:shen.fix-help V2897 V2899 (V2897 V2899))))) (quote shen.fix-help))
(begin (register-function-arity (quote put) 4) (define (kl:put V2904 V2905 V2906 V2907) (let ((Curr (guard (lambda (E) (quote ())) (kl:shen.<-dict V2907 V2904)))) (let ((Added (kl:shen.assoc-set V2905 V2906 Curr))) (let ((Update (kl:shen.dict-> V2907 V2904 Added))) V2906)))) (quote put))
(begin (register-function-arity (quote unput) 3) (define (kl:unput V2911 V2912 V2913) (let ((Curr (guard (lambda (E) (quote ())) (kl:shen.<-dict V2913 V2911)))) (let ((Removed (kl:shen.assoc-rm V2912 Curr))) (let ((Update (kl:shen.dict-> V2913 V2911 Removed))) V2911)))) (quote unput))
(begin (register-function-arity (quote get) 3) (define (kl:get V2917 V2918 V2919) (let ((Entry (guard (lambda (E) (quote ())) (kl:shen.<-dict V2919 V2917)))) (let ((Result (kl:assoc V2918 Entry))) (if (kl:empty? Result) (simple-error "value not found\n") (cdr Result))))) (quote get))
(begin (register-function-arity (quote hash) 2) (define (kl:hash V2922 V2923) (kl:shen.mod (kl:sum (kl:map (lambda (X) (string-ref X 0)) (kl:explode V2922))) V2923)) (quote hash))
(begin (register-function-arity (quote shen.mod) 2) (define (kl:shen.mod V2926 V2927) (kl:shen.modh V2926 (kl:shen.multiples V2926 (cons V2927 (quote ()))))) (quote shen.mod))
(begin (register-function-arity (quote shen.multiples) 2) (define (kl:shen.multiples V2930 V2931) (cond ((and (pair? V2931) (> (car V2931) V2930)) (cdr V2931)) ((pair? V2931) (kl:shen.multiples V2930 (cons (* 2 (car V2931)) V2931))) (#t (kl:shen.f_error (quote shen.multiples))))) (quote shen.multiples))
(begin (register-function-arity (quote shen.modh) 2) (define (kl:shen.modh V2936 V2937) (cond ((kl:= 0 V2936) 0) ((null? V2937) V2936) ((and (pair? V2937) (> (car V2937) V2936)) (if (kl:empty? (cdr V2937)) V2936 (kl:shen.modh V2936 (cdr V2937)))) ((pair? V2937) (kl:shen.modh (- V2936 (car V2937)) V2937)) (#t (kl:shen.f_error (quote shen.modh))))) (quote shen.modh))
(begin (register-function-arity (quote sum) 1) (define (kl:sum V2939) (cond ((null? V2939) 0) ((pair? V2939) (+ (car V2939) (kl:sum (cdr V2939)))) (#t (kl:shen.f_error (quote sum))))) (quote sum))
(begin (register-function-arity (quote head) 1) (define (kl:head V2947) (cond ((pair? V2947) (car V2947)) (#t (simple-error "head expects a non-empty list")))) (quote head))
(begin (register-function-arity (quote tail) 1) (define (kl:tail V2955) (cond ((pair? V2955) (cdr V2955)) (#t (simple-error "tail expects a non-empty list")))) (quote tail))
(begin (register-function-arity (quote hdstr) 1) (define (kl:hdstr V2957) (make-string 1 (string-ref V2957 0))) (quote hdstr))
(begin (register-function-arity (quote intersection) 2) (define (kl:intersection V2962 V2963) (cond ((null? V2962) (quote ())) ((pair? V2962) (if (kl:element? (car V2962) V2963) (cons (car V2962) (kl:intersection (cdr V2962) V2963)) (kl:intersection (cdr V2962) V2963))) (#t (kl:shen.f_error (quote intersection))))) (quote intersection))
(begin (register-function-arity (quote reverse) 1) (define (kl:reverse V2965) (kl:shen.reverse_help V2965 (quote ()))) (quote reverse))
(begin (register-function-arity (quote shen.reverse_help) 2) (define (kl:shen.reverse_help V2968 V2969) (cond ((null? V2968) V2969) ((pair? V2968) (kl:shen.reverse_help (cdr V2968) (cons (car V2968) V2969))) (#t (kl:shen.f_error (quote shen.reverse_help))))) (quote shen.reverse_help))
(begin (register-function-arity (quote union) 2) (define (kl:union V2972 V2973) (cond ((null? V2972) V2973) ((pair? V2972) (if (kl:element? (car V2972) V2973) (kl:union (cdr V2972) V2973) (cons (car V2972) (kl:union (cdr V2972) V2973)))) (#t (kl:shen.f_error (quote union))))) (quote union))
(begin (register-function-arity (quote y-or-n?) 1) (define (kl:y-or-n? V2975) (let ((Message (kl:shen.prhush (kl:shen.proc-nl V2975) (kl:stoutput)))) (let ((Y-or-N (kl:shen.prhush " (y/n) " (kl:stoutput)))) (let ((Input (kl:shen.app (kl:read (kl:stinput)) "" (quote shen.s)))) (if (equal? "y" Input) #t (if (equal? "n" Input) #f (begin (kl:shen.prhush "please answer y or n\n" (kl:stoutput)) (kl:y-or-n? V2975)))))))) (quote y-or-n?))
(begin (register-function-arity (quote not) 1) (define (kl:not V2977) (if (assert-boolean V2977) #f #t)) (quote not))
(begin (register-function-arity (quote subst) 3) (define (kl:subst V2990 V2991 V2992) (cond ((kl:= V2992 V2991) V2990) ((pair? V2992) (kl:map (lambda (W) (kl:subst V2990 V2991 W)) V2992)) (#t V2992))) (quote subst))
(begin (register-function-arity (quote explode) 1) (define (kl:explode V2994) (kl:shen.explode-h (kl:shen.app V2994 "" (quote shen.a)))) (quote explode))
(begin (register-function-arity (quote shen.explode-h) 1) (define (kl:shen.explode-h V2996) (cond ((equal? "" V2996) (quote ())) ((assert-boolean (kl:shen.+string? V2996)) (cons (make-string 1 (string-ref V2996 0)) (kl:shen.explode-h (string-tail V2996 1)))) (#t (kl:shen.f_error (quote shen.explode-h))))) (quote shen.explode-h))
(begin (register-function-arity (quote cd) 1) (define (kl:cd V2998) (kl:set (quote *home-directory*) (if (equal? V2998 "") "" (kl:shen.app V2998 "/" (quote shen.a))))) (quote cd))
(begin (register-function-arity (quote shen.for-each) 2) (define (kl:shen.for-each V3001 V3002) (cond ((null? V3002) #t) ((pair? V3002) (let ((_ (V3001 (car V3002)))) (kl:shen.for-each V3001 (cdr V3002)))) (#t (kl:shen.f_error (quote shen.for-each))))) (quote shen.for-each))
(begin (register-function-arity (quote map) 2) (define (kl:map V3005 V3006) (kl:shen.map-h V3005 V3006 (quote ()))) (quote map))
(begin (register-function-arity (quote shen.map-h) 3) (define (kl:shen.map-h V3012 V3013 V3014) (cond ((null? V3013) (kl:reverse V3014)) ((pair? V3013) (kl:shen.map-h V3012 (cdr V3013) (cons (V3012 (car V3013)) V3014))) (#t (kl:shen.f_error (quote shen.map-h))))) (quote shen.map-h))
(begin (register-function-arity (quote length) 1) (define (kl:length V3016) (kl:shen.length-h V3016 0)) (quote length))
(begin (register-function-arity (quote shen.length-h) 2) (define (kl:shen.length-h V3019 V3020) (cond ((null? V3019) V3020) (#t (kl:shen.length-h (cdr V3019) (+ V3020 1))))) (quote shen.length-h))
(begin (register-function-arity (quote occurrences) 2) (define (kl:occurrences V3032 V3033) (cond ((kl:= V3033 V3032) 1) ((pair? V3033) (+ (kl:occurrences V3032 (car V3033)) (kl:occurrences V3032 (cdr V3033)))) (#t 0))) (quote occurrences))
(begin (register-function-arity (quote nth) 2) (define (kl:nth V3040 V3041) (cond ((and (kl:= 1 V3040) (pair? V3041)) (car V3041)) ((pair? V3041) (kl:nth (- V3040 1) (cdr V3041))) (#t (simple-error (string-append "nth applied to " (kl:shen.app V3040 (string-append ", " (kl:shen.app V3041 "\n" (quote shen.a))) (quote shen.a))))))) (quote nth))
(begin (register-function-arity (quote integer?) 1) (define (kl:integer? V3043) (and (number? V3043) (assert-boolean (let ((Abs (kl:shen.abs V3043))) (kl:shen.integer-test? Abs (kl:shen.magless Abs 1)))))) (quote integer?))
(begin (register-function-arity (quote shen.abs) 1) (define (kl:shen.abs V3045) (if (> V3045 0) V3045 (- 0 V3045))) (quote shen.abs))
(begin (register-function-arity (quote shen.magless) 2) (define (kl:shen.magless V3048 V3049) (let ((Nx2 (* V3049 2))) (if (> Nx2 V3048) V3049 (kl:shen.magless V3048 Nx2)))) (quote shen.magless))
(begin (register-function-arity (quote shen.integer-test?) 2) (define (kl:shen.integer-test? V3055 V3056) (cond ((kl:= 0 V3055) #t) ((> 1 V3055) #f) (#t (let ((Abs-N (- V3055 V3056))) (if (> 0 Abs-N) (kl:integer? V3055) (kl:shen.integer-test? Abs-N V3056)))))) (quote shen.integer-test?))
(begin (register-function-arity (quote mapcan) 2) (define (kl:mapcan V3061 V3062) (cond ((null? V3062) (quote ())) ((pair? V3062) (kl:append (V3061 (car V3062)) (kl:mapcan V3061 (cdr V3062)))) (#t (kl:shen.f_error (quote mapcan))))) (quote mapcan))
(begin (register-function-arity (quote ==) 2) (define (kl:== V3074 V3075) (cond ((kl:= V3075 V3074) #t) (#t #f))) (quote ==))
(begin (register-function-arity (quote abort) 0) (define (kl:abort) (simple-error "")) (quote abort))
(begin (register-function-arity (quote bound?) 1) (define (kl:bound? V3077) (and (kl:symbol? V3077) (assert-boolean (let ((Val (guard (lambda (E) (quote shen.this-symbol-is-unbound)) (kl:value V3077)))) (if (eq? Val (quote shen.this-symbol-is-unbound)) #f #t))))) (quote bound?))
(begin (register-function-arity (quote shen.string->bytes) 1) (define (kl:shen.string->bytes V3079) (cond ((equal? "" V3079) (quote ())) (#t (cons (string-ref (make-string 1 (string-ref V3079 0)) 0) (kl:shen.string->bytes (string-tail V3079 1)))))) (quote shen.string->bytes))
(begin (register-function-arity (quote maxinferences) 1) (define (kl:maxinferences V3081) (kl:set (quote shen.*maxinferences*) V3081)) (quote maxinferences))
(begin (register-function-arity (quote inferences) 0) (define (kl:inferences) (kl:value (quote shen.*infs*))) (quote inferences))
(begin (register-function-arity (quote protect) 1) (define (kl:protect V3083) V3083) (quote protect))
(begin (register-function-arity (quote stoutput) 0) (define (kl:stoutput) (kl:value (quote *stoutput*))) (quote stoutput))
(begin (register-function-arity (quote sterror) 0) (define (kl:sterror) (kl:value (quote *sterror*))) (quote sterror))
(begin (register-function-arity (quote string->symbol) 1) (define (kl:string->symbol V3085) (let ((Symbol (kl:intern V3085))) (if (kl:symbol? Symbol) Symbol (simple-error (string-append "cannot intern " (kl:shen.app V3085 " to a symbol" (quote shen.s))))))) (quote string->symbol))
(begin (register-function-arity (quote optimise) 1) (define (kl:optimise V3091) (cond ((eq? (quote +) V3091) (kl:set (quote shen.*optimise*) #t)) ((eq? (quote -) V3091) (kl:set (quote shen.*optimise*) #f)) (#t (simple-error "optimise expects a + or a -.\n")))) (quote optimise))
(begin (register-function-arity (quote os) 0) (define (kl:os) (kl:value (quote *os*))) (quote os))
(begin (register-function-arity (quote language) 0) (define (kl:language) (kl:value (quote *language*))) (quote language))
(begin (register-function-arity (quote version) 0) (define (kl:version) (kl:value (quote *version*))) (quote version))
(begin (register-function-arity (quote port) 0) (define (kl:port) (kl:value (quote *port*))) (quote port))
(begin (register-function-arity (quote porters) 0) (define (kl:porters) (kl:value (quote *porters*))) (quote porters))
(begin (register-function-arity (quote implementation) 0) (define (kl:implementation) (kl:value (quote *implementation*))) (quote implementation))
(begin (register-function-arity (quote release) 0) (define (kl:release) (kl:value (quote *release*))) (quote release))
(begin (register-function-arity (quote package?) 1) (define (kl:package? V3093) (guard (lambda (E) #f) (begin (kl:external V3093) #t))) (quote package?))
(begin (register-function-arity (quote function) 1) (define (kl:function V3095) (kl:shen.lookup-func V3095)) (quote function))
(begin (register-function-arity (quote shen.lookup-func) 1) (define (kl:shen.lookup-func V3097) (guard (lambda (E) (simple-error (kl:shen.app V3097 " has no lambda expansion\n" (quote shen.a)))) (kl:get V3097 (quote shen.lambda-form) (kl:value (quote *property-vector*))))) (quote shen.lookup-func))
