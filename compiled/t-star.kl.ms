"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.typecheck) 2) (define (kl:shen.typecheck V3509 V3510) (let ((Curry (kl:shen.curry V3509))) (let ((ProcessN (kl:shen.start-new-prolog-process))) (let ((Type (kl:shen.insert-prolog-variables (kl:shen.demodulate (kl:shen.curry-type V3510)) ProcessN))) (let ((Continuation (lambda () (kl:return Type ProcessN (quote shen.void))))) (kl:shen.t* (cons Curry (cons (quote :) (cons Type (quote ())))) (quote ()) ProcessN Continuation)))))) (quote shen.typecheck))
(begin (register-function-arity (quote shen.curry) 1) (define (kl:shen.curry V3512) (cond ((and (pair? V3512) (assert-boolean (kl:shen.special? (car V3512)))) (cons (car V3512) (kl:map (lambda (Y) (kl:shen.curry Y)) (cdr V3512)))) ((and (pair? V3512) (and (pair? (cdr V3512)) (assert-boolean (kl:shen.extraspecial? (car V3512))))) V3512) ((and (pair? V3512) (and (eq? (quote type) (car V3512)) (and (pair? (cdr V3512)) (and (pair? (cdr (cdr V3512))) (null? (cdr (cdr (cdr V3512)))))))) (cons (quote type) (cons (kl:shen.curry (car (cdr V3512))) (cdr (cdr V3512))))) ((and (pair? V3512) (and (pair? (cdr V3512)) (pair? (cdr (cdr V3512))))) (kl:shen.curry (cons (cons (car V3512) (cons (car (cdr V3512)) (quote ()))) (cdr (cdr V3512))))) ((and (pair? V3512) (and (pair? (cdr V3512)) (null? (cdr (cdr V3512))))) (cons (kl:shen.curry (car V3512)) (cons (kl:shen.curry (car (cdr V3512))) (quote ())))) (#t V3512))) (quote shen.curry))
(begin (register-function-arity (quote shen.special?) 1) (define (kl:shen.special? V3514) (kl:element? V3514 (kl:value (quote shen.*special*)))) (quote shen.special?))
(begin (register-function-arity (quote shen.extraspecial?) 1) (define (kl:shen.extraspecial? V3516) (kl:element? V3516 (kl:value (quote shen.*extraspecial*)))) (quote shen.extraspecial?))
(begin (register-function-arity (quote shen.t*) 4) (define (kl:shen.t* V3521 V3522 V3523 V3524) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (let ((Error (kl:shen.newpv V3523))) (begin (kl:shen.incinfs) (kl:fwhen (kl:shen.maxinfexceeded?) V3523 (lambda () (kl:bind Error (kl:shen.errormaxinfs) V3523 V3524))))))) (if (kl:= Case #f) (let ((Case (let ((V3501 (kl:shen.lazyderef V3521 V3523))) (if (eq? (quote fail) V3501) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3523 (lambda () (kl:shen.prolog-failure V3523 V3524)))) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3502 (kl:shen.lazyderef V3521 V3523))) (if (pair? V3502) (let ((X (car V3502))) (let ((V3503 (kl:shen.lazyderef (cdr V3502) V3523))) (if (pair? V3503) (let ((V3504 (kl:shen.lazyderef (car V3503) V3523))) (if (eq? (quote :) V3504) (let ((V3505 (kl:shen.lazyderef (cdr V3503) V3523))) (if (pair? V3505) (let ((A (car V3505))) (let ((V3506 (kl:shen.lazyderef (cdr V3505) V3523))) (if (null? V3506) (begin (kl:shen.incinfs) (kl:fwhen (kl:shen.type-theory-enabled?) V3523 (lambda () (kl:cut Throwcontrol V3523 (lambda () (kl:shen.th* X A V3522 V3523 V3524)))))) #f))) #f)) #f)) #f))) #f)))) (if (kl:= Case #f) (let ((Datatypes (kl:shen.newpv V3523))) (begin (kl:shen.incinfs) (kl:shen.show V3521 V3522 V3523 (lambda () (kl:bind Datatypes (kl:value (quote shen.*datatypes*)) V3523 (lambda () (kl:shen.udefs* V3521 V3522 Datatypes V3523 V3524))))))) Case)) Case)) Case))))) (quote shen.t*))
(begin (register-function-arity (quote shen.type-theory-enabled?) 0) (define (kl:shen.type-theory-enabled?) (kl:value (quote shen.*shen-type-theory-enabled?*))) (quote shen.type-theory-enabled?))
(begin (register-function-arity (quote enable-type-theory) 1) (define (kl:enable-type-theory V3530) (cond ((eq? (quote +) V3530) (kl:set (quote shen.*shen-type-theory-enabled?*) #t)) ((eq? (quote -) V3530) (kl:set (quote shen.*shen-type-theory-enabled?*) #f)) (#t (simple-error "enable-type-theory expects a + or a -\n")))) (quote enable-type-theory))
(begin (register-function-arity (quote shen.prolog-failure) 2) (define (kl:shen.prolog-failure V3541 V3542) #f) (quote shen.prolog-failure))
(begin (register-function-arity (quote shen.maxinfexceeded?) 0) (define (kl:shen.maxinfexceeded?) (> (kl:inferences) (kl:value (quote shen.*maxinferences*)))) (quote shen.maxinfexceeded?))
(begin (register-function-arity (quote shen.errormaxinfs) 0) (define (kl:shen.errormaxinfs) (simple-error "maximum inferences exceeded~%")) (quote shen.errormaxinfs))
(begin (register-function-arity (quote shen.udefs*) 5) (define (kl:shen.udefs* V3548 V3549 V3550 V3551 V3552) (let ((Case (let ((V3497 (kl:shen.lazyderef V3550 V3551))) (if (pair? V3497) (let ((D (car V3497))) (begin (kl:shen.incinfs) (kl:call (cons D (cons V3548 (cons V3549 (quote ())))) V3551 V3552))) #f)))) (if (kl:= Case #f) (let ((V3498 (kl:shen.lazyderef V3550 V3551))) (if (pair? V3498) (let ((Ds (cdr V3498))) (begin (kl:shen.incinfs) (kl:shen.udefs* V3548 V3549 Ds V3551 V3552))) #f)) Case))) (quote shen.udefs*))
(begin (register-function-arity (quote shen.th*) 5) (define (kl:shen.th* V3558 V3559 V3560 V3561 V3562) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (begin (kl:shen.incinfs) (kl:shen.show (cons V3558 (cons (quote :) (cons V3559 (quote ())))) V3560 V3561 (lambda () (kl:fwhen #f V3561 V3562)))))) (if (kl:= Case #f) (let ((Case (let ((F (kl:shen.newpv V3561))) (begin (kl:shen.incinfs) (kl:fwhen (kl:shen.typedf? (kl:shen.lazyderef V3558 V3561)) V3561 (lambda () (kl:bind F (kl:shen.sigf (kl:shen.lazyderef V3558 V3561)) V3561 (lambda () (kl:call (cons F (cons V3559 (quote ()))) V3561 V3562))))))))) (if (kl:= Case #f) (let ((Case (begin (kl:shen.incinfs) (kl:shen.base V3558 V3559 V3561 V3562)))) (if (kl:= Case #f) (let ((Case (begin (kl:shen.incinfs) (kl:shen.by_hypothesis V3558 V3559 V3560 V3561 V3562)))) (if (kl:= Case #f) (let ((Case (let ((V3393 (kl:shen.lazyderef V3558 V3561))) (if (pair? V3393) (let ((F (car V3393))) (let ((V3394 (kl:shen.lazyderef (cdr V3393) V3561))) (if (null? V3394) (begin (kl:shen.incinfs) (kl:shen.th* F (cons (quote -->) (cons V3559 (quote ()))) V3560 V3561 V3562)) #f))) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3395 (kl:shen.lazyderef V3558 V3561))) (if (pair? V3395) (let ((F (car V3395))) (let ((V3396 (kl:shen.lazyderef (cdr V3395) V3561))) (if (pair? V3396) (let ((X (car V3396))) (let ((V3397 (kl:shen.lazyderef (cdr V3396) V3561))) (if (null? V3397) (let ((B (kl:shen.newpv V3561))) (begin (kl:shen.incinfs) (kl:shen.th* F (cons B (cons (quote -->) (cons V3559 (quote ())))) V3560 V3561 (lambda () (kl:shen.th* X B V3560 V3561 V3562))))) #f))) #f))) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3398 (kl:shen.lazyderef V3558 V3561))) (if (pair? V3398) (let ((V3399 (kl:shen.lazyderef (car V3398) V3561))) (if (eq? (quote cons) V3399) (let ((V3400 (kl:shen.lazyderef (cdr V3398) V3561))) (if (pair? V3400) (let ((X (car V3400))) (let ((V3401 (kl:shen.lazyderef (cdr V3400) V3561))) (if (pair? V3401) (let ((Y (car V3401))) (let ((V3402 (kl:shen.lazyderef (cdr V3401) V3561))) (if (null? V3402) (let ((V3403 (kl:shen.lazyderef V3559 V3561))) (if (pair? V3403) (let ((V3404 (kl:shen.lazyderef (car V3403) V3561))) (if (eq? (quote list) V3404) (let ((V3405 (kl:shen.lazyderef (cdr V3403) V3561))) (if (pair? V3405) (let ((A (car V3405))) (let ((V3406 (kl:shen.lazyderef (cdr V3405) V3561))) (if (null? V3406) (begin (kl:shen.incinfs) (kl:shen.th* X A V3560 V3561 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3560 V3561 V3562)))) (if (assert-boolean (kl:shen.pvar? V3406)) (begin (kl:shen.bindv V3406 (quote ()) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3560 V3561 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3560 V3561 V3562)))))) (begin (kl:shen.unbindv V3406 V3561) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3405)) (let ((A (kl:shen.newpv V3561))) (begin (kl:shen.bindv V3405 (cons A (quote ())) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3560 V3561 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3560 V3561 V3562)))))) (begin (kl:shen.unbindv V3405 V3561) Result)))) #f))) (if (assert-boolean (kl:shen.pvar? V3404)) (begin (kl:shen.bindv V3404 (quote list) V3561) (let ((Result (let ((V3407 (kl:shen.lazyderef (cdr V3403) V3561))) (if (pair? V3407) (let ((A (car V3407))) (let ((V3408 (kl:shen.lazyderef (cdr V3407) V3561))) (if (null? V3408) (begin (kl:shen.incinfs) (kl:shen.th* X A V3560 V3561 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3560 V3561 V3562)))) (if (assert-boolean (kl:shen.pvar? V3408)) (begin (kl:shen.bindv V3408 (quote ()) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3560 V3561 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3560 V3561 V3562)))))) (begin (kl:shen.unbindv V3408 V3561) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3407)) (let ((A (kl:shen.newpv V3561))) (begin (kl:shen.bindv V3407 (cons A (quote ())) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3560 V3561 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3560 V3561 V3562)))))) (begin (kl:shen.unbindv V3407 V3561) Result)))) #f))))) (begin (kl:shen.unbindv V3404 V3561) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3403)) (let ((A (kl:shen.newpv V3561))) (begin (kl:shen.bindv V3403 (cons (quote list) (cons A (quote ()))) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3560 V3561 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3560 V3561 V3562)))))) (begin (kl:shen.unbindv V3403 V3561) Result)))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3409 (kl:shen.lazyderef V3558 V3561))) (if (pair? V3409) (let ((V3410 (kl:shen.lazyderef (car V3409) V3561))) (if (eq? (quote _waspvm_at_p) V3410) (let ((V3411 (kl:shen.lazyderef (cdr V3409) V3561))) (if (pair? V3411) (let ((X (car V3411))) (let ((V3412 (kl:shen.lazyderef (cdr V3411) V3561))) (if (pair? V3412) (let ((Y (car V3412))) (let ((V3413 (kl:shen.lazyderef (cdr V3412) V3561))) (if (null? V3413) (let ((V3414 (kl:shen.lazyderef V3559 V3561))) (if (pair? V3414) (let ((A (car V3414))) (let ((V3415 (kl:shen.lazyderef (cdr V3414) V3561))) (if (pair? V3415) (let ((V3416 (kl:shen.lazyderef (car V3415) V3561))) (if (eq? (quote *) V3416) (let ((V3417 (kl:shen.lazyderef (cdr V3415) V3561))) (if (pair? V3417) (let ((B (car V3417))) (let ((V3418 (kl:shen.lazyderef (cdr V3417) V3561))) (if (null? V3418) (begin (kl:shen.incinfs) (kl:shen.th* X A V3560 V3561 (lambda () (kl:shen.th* Y B V3560 V3561 V3562)))) (if (assert-boolean (kl:shen.pvar? V3418)) (begin (kl:shen.bindv V3418 (quote ()) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3560 V3561 (lambda () (kl:shen.th* Y B V3560 V3561 V3562)))))) (begin (kl:shen.unbindv V3418 V3561) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3417)) (let ((B (kl:shen.newpv V3561))) (begin (kl:shen.bindv V3417 (cons B (quote ())) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3560 V3561 (lambda () (kl:shen.th* Y B V3560 V3561 V3562)))))) (begin (kl:shen.unbindv V3417 V3561) Result)))) #f))) (if (assert-boolean (kl:shen.pvar? V3416)) (begin (kl:shen.bindv V3416 (quote *) V3561) (let ((Result (let ((V3419 (kl:shen.lazyderef (cdr V3415) V3561))) (if (pair? V3419) (let ((B (car V3419))) (let ((V3420 (kl:shen.lazyderef (cdr V3419) V3561))) (if (null? V3420) (begin (kl:shen.incinfs) (kl:shen.th* X A V3560 V3561 (lambda () (kl:shen.th* Y B V3560 V3561 V3562)))) (if (assert-boolean (kl:shen.pvar? V3420)) (begin (kl:shen.bindv V3420 (quote ()) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3560 V3561 (lambda () (kl:shen.th* Y B V3560 V3561 V3562)))))) (begin (kl:shen.unbindv V3420 V3561) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3419)) (let ((B (kl:shen.newpv V3561))) (begin (kl:shen.bindv V3419 (cons B (quote ())) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3560 V3561 (lambda () (kl:shen.th* Y B V3560 V3561 V3562)))))) (begin (kl:shen.unbindv V3419 V3561) Result)))) #f))))) (begin (kl:shen.unbindv V3416 V3561) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3415)) (let ((B (kl:shen.newpv V3561))) (begin (kl:shen.bindv V3415 (cons (quote *) (cons B (quote ()))) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3560 V3561 (lambda () (kl:shen.th* Y B V3560 V3561 V3562)))))) (begin (kl:shen.unbindv V3415 V3561) Result)))) #f)))) (if (assert-boolean (kl:shen.pvar? V3414)) (let ((A (kl:shen.newpv V3561))) (let ((B (kl:shen.newpv V3561))) (begin (kl:shen.bindv V3414 (cons A (cons (quote *) (cons B (quote ())))) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3560 V3561 (lambda () (kl:shen.th* Y B V3560 V3561 V3562)))))) (begin (kl:shen.unbindv V3414 V3561) Result))))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3421 (kl:shen.lazyderef V3558 V3561))) (if (pair? V3421) (let ((V3422 (kl:shen.lazyderef (car V3421) V3561))) (if (eq? (quote _waspvm_at_v) V3422) (let ((V3423 (kl:shen.lazyderef (cdr V3421) V3561))) (if (pair? V3423) (let ((X (car V3423))) (let ((V3424 (kl:shen.lazyderef (cdr V3423) V3561))) (if (pair? V3424) (let ((Y (car V3424))) (let ((V3425 (kl:shen.lazyderef (cdr V3424) V3561))) (if (null? V3425) (let ((V3426 (kl:shen.lazyderef V3559 V3561))) (if (pair? V3426) (let ((V3427 (kl:shen.lazyderef (car V3426) V3561))) (if (eq? (quote vector) V3427) (let ((V3428 (kl:shen.lazyderef (cdr V3426) V3561))) (if (pair? V3428) (let ((A (car V3428))) (let ((V3429 (kl:shen.lazyderef (cdr V3428) V3561))) (if (null? V3429) (begin (kl:shen.incinfs) (kl:shen.th* X A V3560 V3561 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3560 V3561 V3562)))) (if (assert-boolean (kl:shen.pvar? V3429)) (begin (kl:shen.bindv V3429 (quote ()) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3560 V3561 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3560 V3561 V3562)))))) (begin (kl:shen.unbindv V3429 V3561) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3428)) (let ((A (kl:shen.newpv V3561))) (begin (kl:shen.bindv V3428 (cons A (quote ())) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3560 V3561 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3560 V3561 V3562)))))) (begin (kl:shen.unbindv V3428 V3561) Result)))) #f))) (if (assert-boolean (kl:shen.pvar? V3427)) (begin (kl:shen.bindv V3427 (quote vector) V3561) (let ((Result (let ((V3430 (kl:shen.lazyderef (cdr V3426) V3561))) (if (pair? V3430) (let ((A (car V3430))) (let ((V3431 (kl:shen.lazyderef (cdr V3430) V3561))) (if (null? V3431) (begin (kl:shen.incinfs) (kl:shen.th* X A V3560 V3561 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3560 V3561 V3562)))) (if (assert-boolean (kl:shen.pvar? V3431)) (begin (kl:shen.bindv V3431 (quote ()) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3560 V3561 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3560 V3561 V3562)))))) (begin (kl:shen.unbindv V3431 V3561) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3430)) (let ((A (kl:shen.newpv V3561))) (begin (kl:shen.bindv V3430 (cons A (quote ())) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3560 V3561 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3560 V3561 V3562)))))) (begin (kl:shen.unbindv V3430 V3561) Result)))) #f))))) (begin (kl:shen.unbindv V3427 V3561) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3426)) (let ((A (kl:shen.newpv V3561))) (begin (kl:shen.bindv V3426 (cons (quote vector) (cons A (quote ()))) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3560 V3561 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3560 V3561 V3562)))))) (begin (kl:shen.unbindv V3426 V3561) Result)))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3432 (kl:shen.lazyderef V3558 V3561))) (if (pair? V3432) (let ((V3433 (kl:shen.lazyderef (car V3432) V3561))) (if (eq? (quote _waspvm_at_s) V3433) (let ((V3434 (kl:shen.lazyderef (cdr V3432) V3561))) (if (pair? V3434) (let ((X (car V3434))) (let ((V3435 (kl:shen.lazyderef (cdr V3434) V3561))) (if (pair? V3435) (let ((Y (car V3435))) (let ((V3436 (kl:shen.lazyderef (cdr V3435) V3561))) (if (null? V3436) (let ((V3437 (kl:shen.lazyderef V3559 V3561))) (if (eq? (quote string) V3437) (begin (kl:shen.incinfs) (kl:shen.th* X (quote string) V3560 V3561 (lambda () (kl:shen.th* Y (quote string) V3560 V3561 V3562)))) (if (assert-boolean (kl:shen.pvar? V3437)) (begin (kl:shen.bindv V3437 (quote string) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X (quote string) V3560 V3561 (lambda () (kl:shen.th* Y (quote string) V3560 V3561 V3562)))))) (begin (kl:shen.unbindv V3437 V3561) Result))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3438 (kl:shen.lazyderef V3558 V3561))) (if (pair? V3438) (let ((V3439 (kl:shen.lazyderef (car V3438) V3561))) (if (eq? (quote lambda) V3439) (let ((V3440 (kl:shen.lazyderef (cdr V3438) V3561))) (if (pair? V3440) (let ((X (car V3440))) (let ((V3441 (kl:shen.lazyderef (cdr V3440) V3561))) (if (pair? V3441) (let ((Y (car V3441))) (let ((V3442 (kl:shen.lazyderef (cdr V3441) V3561))) (if (null? V3442) (let ((V3443 (kl:shen.lazyderef V3559 V3561))) (if (pair? V3443) (let ((A (car V3443))) (let ((V3444 (kl:shen.lazyderef (cdr V3443) V3561))) (if (pair? V3444) (let ((V3445 (kl:shen.lazyderef (car V3444) V3561))) (if (eq? (quote -->) V3445) (let ((V3446 (kl:shen.lazyderef (cdr V3444) V3561))) (if (pair? V3446) (let ((B (car V3446))) (let ((V3447 (kl:shen.lazyderef (cdr V3446) V3561))) (if (null? V3447) (let ((Z (kl:shen.newpv V3561))) (let ((X&& (kl:shen.newpv V3561))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3561 (lambda () (kl:bind X&& (kl:shen.placeholder) V3561 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3561) (kl:shen.lazyderef X V3561) (kl:shen.lazyderef Y V3561)) V3561 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3560) V3561 V3562)))))))))) (if (assert-boolean (kl:shen.pvar? V3447)) (begin (kl:shen.bindv V3447 (quote ()) V3561) (let ((Result (let ((Z (kl:shen.newpv V3561))) (let ((X&& (kl:shen.newpv V3561))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3561 (lambda () (kl:bind X&& (kl:shen.placeholder) V3561 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3561) (kl:shen.lazyderef X V3561) (kl:shen.lazyderef Y V3561)) V3561 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3560) V3561 V3562)))))))))))) (begin (kl:shen.unbindv V3447 V3561) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3446)) (let ((B (kl:shen.newpv V3561))) (begin (kl:shen.bindv V3446 (cons B (quote ())) V3561) (let ((Result (let ((Z (kl:shen.newpv V3561))) (let ((X&& (kl:shen.newpv V3561))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3561 (lambda () (kl:bind X&& (kl:shen.placeholder) V3561 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3561) (kl:shen.lazyderef X V3561) (kl:shen.lazyderef Y V3561)) V3561 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3560) V3561 V3562)))))))))))) (begin (kl:shen.unbindv V3446 V3561) Result)))) #f))) (if (assert-boolean (kl:shen.pvar? V3445)) (begin (kl:shen.bindv V3445 (quote -->) V3561) (let ((Result (let ((V3448 (kl:shen.lazyderef (cdr V3444) V3561))) (if (pair? V3448) (let ((B (car V3448))) (let ((V3449 (kl:shen.lazyderef (cdr V3448) V3561))) (if (null? V3449) (let ((Z (kl:shen.newpv V3561))) (let ((X&& (kl:shen.newpv V3561))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3561 (lambda () (kl:bind X&& (kl:shen.placeholder) V3561 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3561) (kl:shen.lazyderef X V3561) (kl:shen.lazyderef Y V3561)) V3561 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3560) V3561 V3562)))))))))) (if (assert-boolean (kl:shen.pvar? V3449)) (begin (kl:shen.bindv V3449 (quote ()) V3561) (let ((Result (let ((Z (kl:shen.newpv V3561))) (let ((X&& (kl:shen.newpv V3561))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3561 (lambda () (kl:bind X&& (kl:shen.placeholder) V3561 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3561) (kl:shen.lazyderef X V3561) (kl:shen.lazyderef Y V3561)) V3561 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3560) V3561 V3562)))))))))))) (begin (kl:shen.unbindv V3449 V3561) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3448)) (let ((B (kl:shen.newpv V3561))) (begin (kl:shen.bindv V3448 (cons B (quote ())) V3561) (let ((Result (let ((Z (kl:shen.newpv V3561))) (let ((X&& (kl:shen.newpv V3561))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3561 (lambda () (kl:bind X&& (kl:shen.placeholder) V3561 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3561) (kl:shen.lazyderef X V3561) (kl:shen.lazyderef Y V3561)) V3561 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3560) V3561 V3562)))))))))))) (begin (kl:shen.unbindv V3448 V3561) Result)))) #f))))) (begin (kl:shen.unbindv V3445 V3561) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3444)) (let ((B (kl:shen.newpv V3561))) (begin (kl:shen.bindv V3444 (cons (quote -->) (cons B (quote ()))) V3561) (let ((Result (let ((Z (kl:shen.newpv V3561))) (let ((X&& (kl:shen.newpv V3561))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3561 (lambda () (kl:bind X&& (kl:shen.placeholder) V3561 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3561) (kl:shen.lazyderef X V3561) (kl:shen.lazyderef Y V3561)) V3561 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3560) V3561 V3562)))))))))))) (begin (kl:shen.unbindv V3444 V3561) Result)))) #f)))) (if (assert-boolean (kl:shen.pvar? V3443)) (let ((A (kl:shen.newpv V3561))) (let ((B (kl:shen.newpv V3561))) (begin (kl:shen.bindv V3443 (cons A (cons (quote -->) (cons B (quote ())))) V3561) (let ((Result (let ((Z (kl:shen.newpv V3561))) (let ((X&& (kl:shen.newpv V3561))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3561 (lambda () (kl:bind X&& (kl:shen.placeholder) V3561 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3561) (kl:shen.lazyderef X V3561) (kl:shen.lazyderef Y V3561)) V3561 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3560) V3561 V3562)))))))))))) (begin (kl:shen.unbindv V3443 V3561) Result))))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3450 (kl:shen.lazyderef V3558 V3561))) (if (pair? V3450) (let ((V3451 (kl:shen.lazyderef (car V3450) V3561))) (if (eq? (quote let) V3451) (let ((V3452 (kl:shen.lazyderef (cdr V3450) V3561))) (if (pair? V3452) (let ((X (car V3452))) (let ((V3453 (kl:shen.lazyderef (cdr V3452) V3561))) (if (pair? V3453) (let ((Y (car V3453))) (let ((V3454 (kl:shen.lazyderef (cdr V3453) V3561))) (if (pair? V3454) (let ((Z (car V3454))) (let ((V3455 (kl:shen.lazyderef (cdr V3454) V3561))) (if (null? V3455) (let ((W (kl:shen.newpv V3561))) (let ((X&& (kl:shen.newpv V3561))) (let ((B (kl:shen.newpv V3561))) (begin (kl:shen.incinfs) (kl:shen.th* Y B V3560 V3561 (lambda () (kl:bind X&& (kl:shen.placeholder) V3561 (lambda () (kl:bind W (kl:shen.ebr (kl:shen.lazyderef X&& V3561) (kl:shen.lazyderef X V3561) (kl:shen.lazyderef Z V3561)) V3561 (lambda () (kl:shen.th* W V3559 (cons (cons X&& (cons (quote :) (cons B (quote ())))) V3560) V3561 V3562))))))))))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3456 (kl:shen.lazyderef V3558 V3561))) (if (pair? V3456) (let ((V3457 (kl:shen.lazyderef (car V3456) V3561))) (if (eq? (quote open) V3457) (let ((V3458 (kl:shen.lazyderef (cdr V3456) V3561))) (if (pair? V3458) (let ((FileName (car V3458))) (let ((V3459 (kl:shen.lazyderef (cdr V3458) V3561))) (if (pair? V3459) (let ((Direction3389 (car V3459))) (let ((V3460 (kl:shen.lazyderef (cdr V3459) V3561))) (if (null? V3460) (let ((V3461 (kl:shen.lazyderef V3559 V3561))) (if (pair? V3461) (let ((V3462 (kl:shen.lazyderef (car V3461) V3561))) (if (eq? (quote stream) V3462) (let ((V3463 (kl:shen.lazyderef (cdr V3461) V3561))) (if (pair? V3463) (let ((Direction (car V3463))) (let ((V3464 (kl:shen.lazyderef (cdr V3463) V3561))) (if (null? V3464) (begin (kl:shen.incinfs) (kl:unify! Direction Direction3389 V3561 (lambda () (kl:cut Throwcontrol V3561 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3561) (cons (quote in) (cons (quote out) (quote ())))) V3561 (lambda () (kl:shen.th* FileName (quote string) V3560 V3561 V3562)))))))) (if (assert-boolean (kl:shen.pvar? V3464)) (begin (kl:shen.bindv V3464 (quote ()) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3389 V3561 (lambda () (kl:cut Throwcontrol V3561 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3561) (cons (quote in) (cons (quote out) (quote ())))) V3561 (lambda () (kl:shen.th* FileName (quote string) V3560 V3561 V3562)))))))))) (begin (kl:shen.unbindv V3464 V3561) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3463)) (let ((Direction (kl:shen.newpv V3561))) (begin (kl:shen.bindv V3463 (cons Direction (quote ())) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3389 V3561 (lambda () (kl:cut Throwcontrol V3561 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3561) (cons (quote in) (cons (quote out) (quote ())))) V3561 (lambda () (kl:shen.th* FileName (quote string) V3560 V3561 V3562)))))))))) (begin (kl:shen.unbindv V3463 V3561) Result)))) #f))) (if (assert-boolean (kl:shen.pvar? V3462)) (begin (kl:shen.bindv V3462 (quote stream) V3561) (let ((Result (let ((V3465 (kl:shen.lazyderef (cdr V3461) V3561))) (if (pair? V3465) (let ((Direction (car V3465))) (let ((V3466 (kl:shen.lazyderef (cdr V3465) V3561))) (if (null? V3466) (begin (kl:shen.incinfs) (kl:unify! Direction Direction3389 V3561 (lambda () (kl:cut Throwcontrol V3561 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3561) (cons (quote in) (cons (quote out) (quote ())))) V3561 (lambda () (kl:shen.th* FileName (quote string) V3560 V3561 V3562)))))))) (if (assert-boolean (kl:shen.pvar? V3466)) (begin (kl:shen.bindv V3466 (quote ()) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3389 V3561 (lambda () (kl:cut Throwcontrol V3561 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3561) (cons (quote in) (cons (quote out) (quote ())))) V3561 (lambda () (kl:shen.th* FileName (quote string) V3560 V3561 V3562)))))))))) (begin (kl:shen.unbindv V3466 V3561) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3465)) (let ((Direction (kl:shen.newpv V3561))) (begin (kl:shen.bindv V3465 (cons Direction (quote ())) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3389 V3561 (lambda () (kl:cut Throwcontrol V3561 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3561) (cons (quote in) (cons (quote out) (quote ())))) V3561 (lambda () (kl:shen.th* FileName (quote string) V3560 V3561 V3562)))))))))) (begin (kl:shen.unbindv V3465 V3561) Result)))) #f))))) (begin (kl:shen.unbindv V3462 V3561) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3461)) (let ((Direction (kl:shen.newpv V3561))) (begin (kl:shen.bindv V3461 (cons (quote stream) (cons Direction (quote ()))) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3389 V3561 (lambda () (kl:cut Throwcontrol V3561 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3561) (cons (quote in) (cons (quote out) (quote ())))) V3561 (lambda () (kl:shen.th* FileName (quote string) V3560 V3561 V3562)))))))))) (begin (kl:shen.unbindv V3461 V3561) Result)))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3467 (kl:shen.lazyderef V3558 V3561))) (if (pair? V3467) (let ((V3468 (kl:shen.lazyderef (car V3467) V3561))) (if (eq? (quote type) V3468) (let ((V3469 (kl:shen.lazyderef (cdr V3467) V3561))) (if (pair? V3469) (let ((X (car V3469))) (let ((V3470 (kl:shen.lazyderef (cdr V3469) V3561))) (if (pair? V3470) (let ((A (car V3470))) (let ((V3471 (kl:shen.lazyderef (cdr V3470) V3561))) (if (null? V3471) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3561 (lambda () (kl:unify A V3559 V3561 (lambda () (kl:shen.th* X A V3560 V3561 V3562)))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3472 (kl:shen.lazyderef V3558 V3561))) (if (pair? V3472) (let ((V3473 (kl:shen.lazyderef (car V3472) V3561))) (if (eq? (quote input+) V3473) (let ((V3474 (kl:shen.lazyderef (cdr V3472) V3561))) (if (pair? V3474) (let ((A (car V3474))) (let ((V3475 (kl:shen.lazyderef (cdr V3474) V3561))) (if (pair? V3475) (let ((Stream (car V3475))) (let ((V3476 (kl:shen.lazyderef (cdr V3475) V3561))) (if (null? V3476) (let ((C (kl:shen.newpv V3561))) (begin (kl:shen.incinfs) (kl:bind C (kl:shen.demodulate (kl:shen.lazyderef A V3561)) V3561 (lambda () (kl:unify V3559 C V3561 (lambda () (kl:shen.th* Stream (cons (quote stream) (cons (quote in) (quote ()))) V3560 V3561 V3562))))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3477 (kl:shen.lazyderef V3558 V3561))) (if (pair? V3477) (let ((V3478 (kl:shen.lazyderef (car V3477) V3561))) (if (eq? (quote set) V3478) (let ((V3479 (kl:shen.lazyderef (cdr V3477) V3561))) (if (pair? V3479) (let ((Var (car V3479))) (let ((V3480 (kl:shen.lazyderef (cdr V3479) V3561))) (if (pair? V3480) (let ((Val (car V3480))) (let ((V3481 (kl:shen.lazyderef (cdr V3480) V3561))) (if (null? V3481) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3561 (lambda () (kl:shen.th* Var (quote symbol) V3560 V3561 (lambda () (kl:cut Throwcontrol V3561 (lambda () (kl:shen.th* (cons (quote value) (cons Var (quote ()))) V3559 V3560 V3561 (lambda () (kl:shen.th* Val V3559 V3560 V3561 V3562)))))))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((NewHyp (kl:shen.newpv V3561))) (begin (kl:shen.incinfs) (kl:shen.t*-hyps V3560 NewHyp V3561 (lambda () (kl:shen.th* V3558 V3559 NewHyp V3561 V3562))))))) (if (kl:= Case #f) (let ((Case (let ((V3482 (kl:shen.lazyderef V3558 V3561))) (if (pair? V3482) (let ((V3483 (kl:shen.lazyderef (car V3482) V3561))) (if (eq? (quote define) V3483) (let ((V3484 (kl:shen.lazyderef (cdr V3482) V3561))) (if (pair? V3484) (let ((F (car V3484))) (let ((X (cdr V3484))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3561 (lambda () (kl:shen.t*-def (cons (quote define) (cons F X)) V3559 V3560 V3561 V3562)))))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3485 (kl:shen.lazyderef V3558 V3561))) (if (pair? V3485) (let ((V3486 (kl:shen.lazyderef (car V3485) V3561))) (if (eq? (quote defmacro) V3486) (let ((V3487 (kl:shen.lazyderef V3559 V3561))) (if (eq? (quote unit) V3487) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3561 V3562)) (if (assert-boolean (kl:shen.pvar? V3487)) (begin (kl:shen.bindv V3487 (quote unit) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3561 V3562)))) (begin (kl:shen.unbindv V3487 V3561) Result))) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3488 (kl:shen.lazyderef V3558 V3561))) (if (pair? V3488) (let ((V3489 (kl:shen.lazyderef (car V3488) V3561))) (if (eq? (quote shen.process-datatype) V3489) (let ((V3490 (kl:shen.lazyderef V3559 V3561))) (if (eq? (quote symbol) V3490) (begin (kl:shen.incinfs) (kl:thaw V3562)) (if (assert-boolean (kl:shen.pvar? V3490)) (begin (kl:shen.bindv V3490 (quote symbol) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3562)))) (begin (kl:shen.unbindv V3490 V3561) Result))) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3491 (kl:shen.lazyderef V3558 V3561))) (if (pair? V3491) (let ((V3492 (kl:shen.lazyderef (car V3491) V3561))) (if (eq? (quote shen.synonyms-help) V3492) (let ((V3493 (kl:shen.lazyderef V3559 V3561))) (if (eq? (quote symbol) V3493) (begin (kl:shen.incinfs) (kl:thaw V3562)) (if (assert-boolean (kl:shen.pvar? V3493)) (begin (kl:shen.bindv V3493 (quote symbol) V3561) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3562)))) (begin (kl:shen.unbindv V3493 V3561) Result))) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((Datatypes (kl:shen.newpv V3561))) (begin (kl:shen.incinfs) (kl:bind Datatypes (kl:value (quote shen.*datatypes*)) V3561 (lambda () (kl:shen.udefs* (cons V3558 (cons (quote :) (cons V3559 (quote ())))) V3560 Datatypes V3561 V3562))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case))))) (quote shen.th*))
(begin (register-function-arity (quote shen.t*-hyps) 4) (define (kl:shen.t*-hyps V3567 V3568 V3569 V3570) (let ((Case (let ((V3304 (kl:shen.lazyderef V3567 V3569))) (if (pair? V3304) (let ((V3305 (kl:shen.lazyderef (car V3304) V3569))) (if (pair? V3305) (let ((V3306 (kl:shen.lazyderef (car V3305) V3569))) (if (pair? V3306) (let ((V3307 (kl:shen.lazyderef (car V3306) V3569))) (if (eq? (quote cons) V3307) (let ((V3308 (kl:shen.lazyderef (cdr V3306) V3569))) (if (pair? V3308) (let ((X (car V3308))) (let ((V3309 (kl:shen.lazyderef (cdr V3308) V3569))) (if (pair? V3309) (let ((Y (car V3309))) (let ((V3310 (kl:shen.lazyderef (cdr V3309) V3569))) (if (null? V3310) (let ((V3311 (kl:shen.lazyderef (cdr V3305) V3569))) (if (pair? V3311) (let ((V3312 (kl:shen.lazyderef (car V3311) V3569))) (if (eq? (quote :) V3312) (let ((V3313 (kl:shen.lazyderef (cdr V3311) V3569))) (if (pair? V3313) (let ((V3314 (kl:shen.lazyderef (car V3313) V3569))) (if (pair? V3314) (let ((V3315 (kl:shen.lazyderef (car V3314) V3569))) (if (eq? (quote list) V3315) (let ((V3316 (kl:shen.lazyderef (cdr V3314) V3569))) (if (pair? V3316) (let ((A (car V3316))) (let ((V3317 (kl:shen.lazyderef (cdr V3316) V3569))) (if (null? V3317) (let ((V3318 (kl:shen.lazyderef (cdr V3313) V3569))) (if (null? V3318) (let ((Hyp (cdr V3304))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3318)) (begin (kl:shen.bindv V3318 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3304))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3318 V3569) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3317)) (begin (kl:shen.bindv V3317 (quote ()) V3569) (let ((Result (let ((V3319 (kl:shen.lazyderef (cdr V3313) V3569))) (if (null? V3319) (let ((Hyp (cdr V3304))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3319)) (begin (kl:shen.bindv V3319 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3304))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3319 V3569) Result))) #f))))) (begin (kl:shen.unbindv V3317 V3569) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3316)) (let ((A (kl:shen.newpv V3569))) (begin (kl:shen.bindv V3316 (cons A (quote ())) V3569) (let ((Result (let ((V3320 (kl:shen.lazyderef (cdr V3313) V3569))) (if (null? V3320) (let ((Hyp (cdr V3304))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3320)) (begin (kl:shen.bindv V3320 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3304))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3320 V3569) Result))) #f))))) (begin (kl:shen.unbindv V3316 V3569) Result)))) #f))) (if (assert-boolean (kl:shen.pvar? V3315)) (begin (kl:shen.bindv V3315 (quote list) V3569) (let ((Result (let ((V3321 (kl:shen.lazyderef (cdr V3314) V3569))) (if (pair? V3321) (let ((A (car V3321))) (let ((V3322 (kl:shen.lazyderef (cdr V3321) V3569))) (if (null? V3322) (let ((V3323 (kl:shen.lazyderef (cdr V3313) V3569))) (if (null? V3323) (let ((Hyp (cdr V3304))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3323)) (begin (kl:shen.bindv V3323 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3304))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3323 V3569) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3322)) (begin (kl:shen.bindv V3322 (quote ()) V3569) (let ((Result (let ((V3324 (kl:shen.lazyderef (cdr V3313) V3569))) (if (null? V3324) (let ((Hyp (cdr V3304))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3324)) (begin (kl:shen.bindv V3324 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3304))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3324 V3569) Result))) #f))))) (begin (kl:shen.unbindv V3322 V3569) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3321)) (let ((A (kl:shen.newpv V3569))) (begin (kl:shen.bindv V3321 (cons A (quote ())) V3569) (let ((Result (let ((V3325 (kl:shen.lazyderef (cdr V3313) V3569))) (if (null? V3325) (let ((Hyp (cdr V3304))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3325)) (begin (kl:shen.bindv V3325 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3304))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3325 V3569) Result))) #f))))) (begin (kl:shen.unbindv V3321 V3569) Result)))) #f))))) (begin (kl:shen.unbindv V3315 V3569) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3314)) (let ((A (kl:shen.newpv V3569))) (begin (kl:shen.bindv V3314 (cons (quote list) (cons A (quote ()))) V3569) (let ((Result (let ((V3326 (kl:shen.lazyderef (cdr V3313) V3569))) (if (null? V3326) (let ((Hyp (cdr V3304))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3326)) (begin (kl:shen.bindv V3326 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3304))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3326 V3569) Result))) #f))))) (begin (kl:shen.unbindv V3314 V3569) Result)))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3327 (kl:shen.lazyderef V3567 V3569))) (if (pair? V3327) (let ((V3328 (kl:shen.lazyderef (car V3327) V3569))) (if (pair? V3328) (let ((V3329 (kl:shen.lazyderef (car V3328) V3569))) (if (pair? V3329) (let ((V3330 (kl:shen.lazyderef (car V3329) V3569))) (if (eq? (quote _waspvm_at_p) V3330) (let ((V3331 (kl:shen.lazyderef (cdr V3329) V3569))) (if (pair? V3331) (let ((X (car V3331))) (let ((V3332 (kl:shen.lazyderef (cdr V3331) V3569))) (if (pair? V3332) (let ((Y (car V3332))) (let ((V3333 (kl:shen.lazyderef (cdr V3332) V3569))) (if (null? V3333) (let ((V3334 (kl:shen.lazyderef (cdr V3328) V3569))) (if (pair? V3334) (let ((V3335 (kl:shen.lazyderef (car V3334) V3569))) (if (eq? (quote :) V3335) (let ((V3336 (kl:shen.lazyderef (cdr V3334) V3569))) (if (pair? V3336) (let ((V3337 (kl:shen.lazyderef (car V3336) V3569))) (if (pair? V3337) (let ((A (car V3337))) (let ((V3338 (kl:shen.lazyderef (cdr V3337) V3569))) (if (pair? V3338) (let ((V3339 (kl:shen.lazyderef (car V3338) V3569))) (if (eq? (quote *) V3339) (let ((V3340 (kl:shen.lazyderef (cdr V3338) V3569))) (if (pair? V3340) (let ((B (car V3340))) (let ((V3341 (kl:shen.lazyderef (cdr V3340) V3569))) (if (null? V3341) (let ((V3342 (kl:shen.lazyderef (cdr V3336) V3569))) (if (null? V3342) (let ((Hyp (cdr V3327))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (kl:shen.lazyderef B V3569) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3342)) (begin (kl:shen.bindv V3342 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3327))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (kl:shen.lazyderef B V3569) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3342 V3569) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3341)) (begin (kl:shen.bindv V3341 (quote ()) V3569) (let ((Result (let ((V3343 (kl:shen.lazyderef (cdr V3336) V3569))) (if (null? V3343) (let ((Hyp (cdr V3327))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (kl:shen.lazyderef B V3569) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3343)) (begin (kl:shen.bindv V3343 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3327))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (kl:shen.lazyderef B V3569) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3343 V3569) Result))) #f))))) (begin (kl:shen.unbindv V3341 V3569) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3340)) (let ((B (kl:shen.newpv V3569))) (begin (kl:shen.bindv V3340 (cons B (quote ())) V3569) (let ((Result (let ((V3344 (kl:shen.lazyderef (cdr V3336) V3569))) (if (null? V3344) (let ((Hyp (cdr V3327))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (kl:shen.lazyderef B V3569) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3344)) (begin (kl:shen.bindv V3344 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3327))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (kl:shen.lazyderef B V3569) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3344 V3569) Result))) #f))))) (begin (kl:shen.unbindv V3340 V3569) Result)))) #f))) (if (assert-boolean (kl:shen.pvar? V3339)) (begin (kl:shen.bindv V3339 (quote *) V3569) (let ((Result (let ((V3345 (kl:shen.lazyderef (cdr V3338) V3569))) (if (pair? V3345) (let ((B (car V3345))) (let ((V3346 (kl:shen.lazyderef (cdr V3345) V3569))) (if (null? V3346) (let ((V3347 (kl:shen.lazyderef (cdr V3336) V3569))) (if (null? V3347) (let ((Hyp (cdr V3327))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (kl:shen.lazyderef B V3569) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3347)) (begin (kl:shen.bindv V3347 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3327))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (kl:shen.lazyderef B V3569) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3347 V3569) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3346)) (begin (kl:shen.bindv V3346 (quote ()) V3569) (let ((Result (let ((V3348 (kl:shen.lazyderef (cdr V3336) V3569))) (if (null? V3348) (let ((Hyp (cdr V3327))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (kl:shen.lazyderef B V3569) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3348)) (begin (kl:shen.bindv V3348 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3327))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (kl:shen.lazyderef B V3569) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3348 V3569) Result))) #f))))) (begin (kl:shen.unbindv V3346 V3569) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3345)) (let ((B (kl:shen.newpv V3569))) (begin (kl:shen.bindv V3345 (cons B (quote ())) V3569) (let ((Result (let ((V3349 (kl:shen.lazyderef (cdr V3336) V3569))) (if (null? V3349) (let ((Hyp (cdr V3327))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (kl:shen.lazyderef B V3569) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3349)) (begin (kl:shen.bindv V3349 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3327))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (kl:shen.lazyderef B V3569) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3349 V3569) Result))) #f))))) (begin (kl:shen.unbindv V3345 V3569) Result)))) #f))))) (begin (kl:shen.unbindv V3339 V3569) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3338)) (let ((B (kl:shen.newpv V3569))) (begin (kl:shen.bindv V3338 (cons (quote *) (cons B (quote ()))) V3569) (let ((Result (let ((V3350 (kl:shen.lazyderef (cdr V3336) V3569))) (if (null? V3350) (let ((Hyp (cdr V3327))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (kl:shen.lazyderef B V3569) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3350)) (begin (kl:shen.bindv V3350 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3327))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (kl:shen.lazyderef B V3569) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3350 V3569) Result))) #f))))) (begin (kl:shen.unbindv V3338 V3569) Result)))) #f)))) (if (assert-boolean (kl:shen.pvar? V3337)) (let ((A (kl:shen.newpv V3569))) (let ((B (kl:shen.newpv V3569))) (begin (kl:shen.bindv V3337 (cons A (cons (quote *) (cons B (quote ())))) V3569) (let ((Result (let ((V3351 (kl:shen.lazyderef (cdr V3336) V3569))) (if (null? V3351) (let ((Hyp (cdr V3327))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (kl:shen.lazyderef B V3569) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3351)) (begin (kl:shen.bindv V3351 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3327))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (kl:shen.lazyderef B V3569) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3351 V3569) Result))) #f))))) (begin (kl:shen.unbindv V3337 V3569) Result))))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3352 (kl:shen.lazyderef V3567 V3569))) (if (pair? V3352) (let ((V3353 (kl:shen.lazyderef (car V3352) V3569))) (if (pair? V3353) (let ((V3354 (kl:shen.lazyderef (car V3353) V3569))) (if (pair? V3354) (let ((V3355 (kl:shen.lazyderef (car V3354) V3569))) (if (eq? (quote _waspvm_at_v) V3355) (let ((V3356 (kl:shen.lazyderef (cdr V3354) V3569))) (if (pair? V3356) (let ((X (car V3356))) (let ((V3357 (kl:shen.lazyderef (cdr V3356) V3569))) (if (pair? V3357) (let ((Y (car V3357))) (let ((V3358 (kl:shen.lazyderef (cdr V3357) V3569))) (if (null? V3358) (let ((V3359 (kl:shen.lazyderef (cdr V3353) V3569))) (if (pair? V3359) (let ((V3360 (kl:shen.lazyderef (car V3359) V3569))) (if (eq? (quote :) V3360) (let ((V3361 (kl:shen.lazyderef (cdr V3359) V3569))) (if (pair? V3361) (let ((V3362 (kl:shen.lazyderef (car V3361) V3569))) (if (pair? V3362) (let ((V3363 (kl:shen.lazyderef (car V3362) V3569))) (if (eq? (quote vector) V3363) (let ((V3364 (kl:shen.lazyderef (cdr V3362) V3569))) (if (pair? V3364) (let ((A (car V3364))) (let ((V3365 (kl:shen.lazyderef (cdr V3364) V3569))) (if (null? V3365) (let ((V3366 (kl:shen.lazyderef (cdr V3361) V3569))) (if (null? V3366) (let ((Hyp (cdr V3352))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3366)) (begin (kl:shen.bindv V3366 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3352))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3366 V3569) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3365)) (begin (kl:shen.bindv V3365 (quote ()) V3569) (let ((Result (let ((V3367 (kl:shen.lazyderef (cdr V3361) V3569))) (if (null? V3367) (let ((Hyp (cdr V3352))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3367)) (begin (kl:shen.bindv V3367 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3352))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3367 V3569) Result))) #f))))) (begin (kl:shen.unbindv V3365 V3569) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3364)) (let ((A (kl:shen.newpv V3569))) (begin (kl:shen.bindv V3364 (cons A (quote ())) V3569) (let ((Result (let ((V3368 (kl:shen.lazyderef (cdr V3361) V3569))) (if (null? V3368) (let ((Hyp (cdr V3352))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3368)) (begin (kl:shen.bindv V3368 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3352))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3368 V3569) Result))) #f))))) (begin (kl:shen.unbindv V3364 V3569) Result)))) #f))) (if (assert-boolean (kl:shen.pvar? V3363)) (begin (kl:shen.bindv V3363 (quote vector) V3569) (let ((Result (let ((V3369 (kl:shen.lazyderef (cdr V3362) V3569))) (if (pair? V3369) (let ((A (car V3369))) (let ((V3370 (kl:shen.lazyderef (cdr V3369) V3569))) (if (null? V3370) (let ((V3371 (kl:shen.lazyderef (cdr V3361) V3569))) (if (null? V3371) (let ((Hyp (cdr V3352))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3371)) (begin (kl:shen.bindv V3371 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3352))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3371 V3569) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3370)) (begin (kl:shen.bindv V3370 (quote ()) V3569) (let ((Result (let ((V3372 (kl:shen.lazyderef (cdr V3361) V3569))) (if (null? V3372) (let ((Hyp (cdr V3352))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3372)) (begin (kl:shen.bindv V3372 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3352))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3372 V3569) Result))) #f))))) (begin (kl:shen.unbindv V3370 V3569) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3369)) (let ((A (kl:shen.newpv V3569))) (begin (kl:shen.bindv V3369 (cons A (quote ())) V3569) (let ((Result (let ((V3373 (kl:shen.lazyderef (cdr V3361) V3569))) (if (null? V3373) (let ((Hyp (cdr V3352))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3373)) (begin (kl:shen.bindv V3373 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3352))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3373 V3569) Result))) #f))))) (begin (kl:shen.unbindv V3369 V3569) Result)))) #f))))) (begin (kl:shen.unbindv V3363 V3569) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3362)) (let ((A (kl:shen.newpv V3569))) (begin (kl:shen.bindv V3362 (cons (quote vector) (cons A (quote ()))) V3569) (let ((Result (let ((V3374 (kl:shen.lazyderef (cdr V3361) V3569))) (if (null? V3374) (let ((Hyp (cdr V3352))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3374)) (begin (kl:shen.bindv V3374 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3352))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (kl:shen.lazyderef A V3569) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3569) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3374 V3569) Result))) #f))))) (begin (kl:shen.unbindv V3362 V3569) Result)))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3375 (kl:shen.lazyderef V3567 V3569))) (if (pair? V3375) (let ((V3376 (kl:shen.lazyderef (car V3375) V3569))) (if (pair? V3376) (let ((V3377 (kl:shen.lazyderef (car V3376) V3569))) (if (pair? V3377) (let ((V3378 (kl:shen.lazyderef (car V3377) V3569))) (if (eq? (quote _waspvm_at_s) V3378) (let ((V3379 (kl:shen.lazyderef (cdr V3377) V3569))) (if (pair? V3379) (let ((X (car V3379))) (let ((V3380 (kl:shen.lazyderef (cdr V3379) V3569))) (if (pair? V3380) (let ((Y (car V3380))) (let ((V3381 (kl:shen.lazyderef (cdr V3380) V3569))) (if (null? V3381) (let ((V3382 (kl:shen.lazyderef (cdr V3376) V3569))) (if (pair? V3382) (let ((V3383 (kl:shen.lazyderef (car V3382) V3569))) (if (eq? (quote :) V3383) (let ((V3384 (kl:shen.lazyderef (cdr V3382) V3569))) (if (pair? V3384) (let ((V3385 (kl:shen.lazyderef (car V3384) V3569))) (if (eq? (quote string) V3385) (let ((V3386 (kl:shen.lazyderef (cdr V3384) V3569))) (if (null? V3386) (let ((Hyp (cdr V3375))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3386)) (begin (kl:shen.bindv V3386 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3375))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3386 V3569) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3385)) (begin (kl:shen.bindv V3385 (quote string) V3569) (let ((Result (let ((V3387 (kl:shen.lazyderef (cdr V3384) V3569))) (if (null? V3387) (let ((Hyp (cdr V3375))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))) (if (assert-boolean (kl:shen.pvar? V3387)) (begin (kl:shen.bindv V3387 (quote ()) V3569) (let ((Result (let ((Hyp (cdr V3375))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (cons (kl:shen.lazyderef X V3569) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3569) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V3569))) V3569 V3570))))) (begin (kl:shen.unbindv V3387 V3569) Result))) #f))))) (begin (kl:shen.unbindv V3385 V3569) Result))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((V3388 (kl:shen.lazyderef V3567 V3569))) (if (pair? V3388) (let ((X (car V3388))) (let ((Hyp (cdr V3388))) (let ((NewHyps (kl:shen.newpv V3569))) (begin (kl:shen.incinfs) (kl:bind V3568 (cons (kl:shen.lazyderef X V3569) (kl:shen.lazyderef NewHyps V3569)) V3569 (lambda () (kl:shen.t*-hyps Hyp NewHyps V3569 V3570))))))) #f)) Case)) Case)) Case)) Case))) (quote shen.t*-hyps))
(begin (register-function-arity (quote shen.show) 4) (define (kl:shen.show V3587 V3588 V3589 V3590) (cond ((assert-boolean (kl:value (quote shen.*spy*))) (begin (kl:shen.line) (begin (kl:shen.show-p (kl:shen.deref V3587 V3589)) (begin (kl:nl 1) (begin (kl:nl 1) (begin (kl:shen.show-assumptions (kl:shen.deref V3588 V3589) 1) (begin (kl:shen.prhush "\n> " (kl:stoutput)) (begin (kl:shen.pause-for-user) (kl:thaw V3590))))))))) (#t (kl:thaw V3590)))) (quote shen.show))
(begin (register-function-arity (quote shen.line) 0) (define (kl:shen.line) (let ((Infs (kl:inferences))) (kl:shen.prhush (string-append "____________________________________________________________ " (kl:shen.app Infs (string-append " inference" (kl:shen.app (if (kl:= 1 Infs) "" "s") " \n?- " (quote shen.a))) (quote shen.a))) (kl:stoutput)))) (quote shen.line))
(begin (register-function-arity (quote shen.show-p) 1) (define (kl:shen.show-p V3592) (cond ((and (pair? V3592) (and (pair? (cdr V3592)) (and (eq? (quote :) (car (cdr V3592))) (and (pair? (cdr (cdr V3592))) (null? (cdr (cdr (cdr V3592)))))))) (kl:shen.prhush (kl:shen.app (car V3592) (string-append " : " (kl:shen.app (car (cdr (cdr V3592))) "" (quote shen.r))) (quote shen.r)) (kl:stoutput))) (#t (kl:shen.prhush (kl:shen.app V3592 "" (quote shen.r)) (kl:stoutput))))) (quote shen.show-p))
(begin (register-function-arity (quote shen.show-assumptions) 2) (define (kl:shen.show-assumptions V3597 V3598) (cond ((null? V3597) (quote shen.skip)) ((pair? V3597) (begin (kl:shen.prhush (kl:shen.app V3598 ". " (quote shen.a)) (kl:stoutput)) (begin (kl:shen.show-p (car V3597)) (begin (kl:nl 1) (kl:shen.show-assumptions (cdr V3597) (+ V3598 1)))))) (#t (kl:shen.f_error (quote shen.show-assumptions))))) (quote shen.show-assumptions))
(begin (register-function-arity (quote shen.pause-for-user) 0) (define (kl:shen.pause-for-user) (let ((Byte (read-u8 (kl:stinput)))) (if (kl:= Byte 94) (simple-error "input aborted\n") (kl:nl 1)))) (quote shen.pause-for-user))
(begin (register-function-arity (quote shen.typedf?) 1) (define (kl:shen.typedf? V3600) (pair? (kl:assoc V3600 (kl:value (quote shen.*signedfuncs*))))) (quote shen.typedf?))
(begin (register-function-arity (quote shen.sigf) 1) (define (kl:shen.sigf V3602) (kl:concat (quote shen.type-signature-of-) V3602)) (quote shen.sigf))
(begin (register-function-arity (quote shen.placeholder) 0) (define (kl:shen.placeholder) (kl:gensym (quote &&))) (quote shen.placeholder))
(begin (register-function-arity (quote shen.base) 4) (define (kl:shen.base V3607 V3608 V3609 V3610) (let ((Case (let ((V3291 (kl:shen.lazyderef V3608 V3609))) (if (eq? (quote number) V3291) (begin (kl:shen.incinfs) (kl:fwhen (number? (kl:shen.lazyderef V3607 V3609)) V3609 V3610)) (if (assert-boolean (kl:shen.pvar? V3291)) (begin (kl:shen.bindv V3291 (quote number) V3609) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (number? (kl:shen.lazyderef V3607 V3609)) V3609 V3610)))) (begin (kl:shen.unbindv V3291 V3609) Result))) #f))))) (if (kl:= Case #f) (let ((Case (let ((V3292 (kl:shen.lazyderef V3608 V3609))) (if (eq? (quote boolean) V3292) (begin (kl:shen.incinfs) (kl:fwhen (kl:boolean? (kl:shen.lazyderef V3607 V3609)) V3609 V3610)) (if (assert-boolean (kl:shen.pvar? V3292)) (begin (kl:shen.bindv V3292 (quote boolean) V3609) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (kl:boolean? (kl:shen.lazyderef V3607 V3609)) V3609 V3610)))) (begin (kl:shen.unbindv V3292 V3609) Result))) #f))))) (if (kl:= Case #f) (let ((Case (let ((V3293 (kl:shen.lazyderef V3608 V3609))) (if (eq? (quote string) V3293) (begin (kl:shen.incinfs) (kl:fwhen (string? (kl:shen.lazyderef V3607 V3609)) V3609 V3610)) (if (assert-boolean (kl:shen.pvar? V3293)) (begin (kl:shen.bindv V3293 (quote string) V3609) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (string? (kl:shen.lazyderef V3607 V3609)) V3609 V3610)))) (begin (kl:shen.unbindv V3293 V3609) Result))) #f))))) (if (kl:= Case #f) (let ((Case (let ((V3294 (kl:shen.lazyderef V3608 V3609))) (if (eq? (quote symbol) V3294) (begin (kl:shen.incinfs) (kl:fwhen (kl:symbol? (kl:shen.lazyderef V3607 V3609)) V3609 (lambda () (kl:fwhen (kl:not (kl:shen.ue? (kl:shen.lazyderef V3607 V3609))) V3609 V3610)))) (if (assert-boolean (kl:shen.pvar? V3294)) (begin (kl:shen.bindv V3294 (quote symbol) V3609) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (kl:symbol? (kl:shen.lazyderef V3607 V3609)) V3609 (lambda () (kl:fwhen (kl:not (kl:shen.ue? (kl:shen.lazyderef V3607 V3609))) V3609 V3610)))))) (begin (kl:shen.unbindv V3294 V3609) Result))) #f))))) (if (kl:= Case #f) (let ((V3295 (kl:shen.lazyderef V3607 V3609))) (if (null? V3295) (let ((V3296 (kl:shen.lazyderef V3608 V3609))) (if (pair? V3296) (let ((V3297 (kl:shen.lazyderef (car V3296) V3609))) (if (eq? (quote list) V3297) (let ((V3298 (kl:shen.lazyderef (cdr V3296) V3609))) (if (pair? V3298) (let ((A (car V3298))) (let ((V3299 (kl:shen.lazyderef (cdr V3298) V3609))) (if (null? V3299) (begin (kl:shen.incinfs) (kl:thaw V3610)) (if (assert-boolean (kl:shen.pvar? V3299)) (begin (kl:shen.bindv V3299 (quote ()) V3609) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3610)))) (begin (kl:shen.unbindv V3299 V3609) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3298)) (let ((A (kl:shen.newpv V3609))) (begin (kl:shen.bindv V3298 (cons A (quote ())) V3609) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3610)))) (begin (kl:shen.unbindv V3298 V3609) Result)))) #f))) (if (assert-boolean (kl:shen.pvar? V3297)) (begin (kl:shen.bindv V3297 (quote list) V3609) (let ((Result (let ((V3300 (kl:shen.lazyderef (cdr V3296) V3609))) (if (pair? V3300) (let ((A (car V3300))) (let ((V3301 (kl:shen.lazyderef (cdr V3300) V3609))) (if (null? V3301) (begin (kl:shen.incinfs) (kl:thaw V3610)) (if (assert-boolean (kl:shen.pvar? V3301)) (begin (kl:shen.bindv V3301 (quote ()) V3609) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3610)))) (begin (kl:shen.unbindv V3301 V3609) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3300)) (let ((A (kl:shen.newpv V3609))) (begin (kl:shen.bindv V3300 (cons A (quote ())) V3609) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3610)))) (begin (kl:shen.unbindv V3300 V3609) Result)))) #f))))) (begin (kl:shen.unbindv V3297 V3609) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3296)) (let ((A (kl:shen.newpv V3609))) (begin (kl:shen.bindv V3296 (cons (quote list) (cons A (quote ()))) V3609) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3610)))) (begin (kl:shen.unbindv V3296 V3609) Result)))) #f))) #f)) Case)) Case)) Case)) Case))) (quote shen.base))
(begin (register-function-arity (quote shen.by_hypothesis) 5) (define (kl:shen.by_hypothesis V3616 V3617 V3618 V3619 V3620) (let ((Case (let ((V3282 (kl:shen.lazyderef V3618 V3619))) (if (pair? V3282) (let ((V3283 (kl:shen.lazyderef (car V3282) V3619))) (if (pair? V3283) (let ((Y (car V3283))) (let ((V3284 (kl:shen.lazyderef (cdr V3283) V3619))) (if (pair? V3284) (let ((V3285 (kl:shen.lazyderef (car V3284) V3619))) (if (eq? (quote :) V3285) (let ((V3286 (kl:shen.lazyderef (cdr V3284) V3619))) (if (pair? V3286) (let ((B (car V3286))) (let ((V3287 (kl:shen.lazyderef (cdr V3286) V3619))) (if (null? V3287) (begin (kl:shen.incinfs) (kl:identical V3616 Y V3619 (lambda () (kl:unify! V3617 B V3619 V3620)))) #f))) #f)) #f)) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((V3288 (kl:shen.lazyderef V3618 V3619))) (if (pair? V3288) (let ((Hyp (cdr V3288))) (begin (kl:shen.incinfs) (kl:shen.by_hypothesis V3616 V3617 Hyp V3619 V3620))) #f)) Case))) (quote shen.by_hypothesis))
(begin (register-function-arity (quote shen.t*-def) 5) (define (kl:shen.t*-def V3626 V3627 V3628 V3629 V3630) (let ((V3276 (kl:shen.lazyderef V3626 V3629))) (if (pair? V3276) (let ((V3277 (kl:shen.lazyderef (car V3276) V3629))) (if (eq? (quote define) V3277) (let ((V3278 (kl:shen.lazyderef (cdr V3276) V3629))) (if (pair? V3278) (let ((F (car V3278))) (let ((X (cdr V3278))) (let ((Y (kl:shen.newpv V3629))) (let ((E (kl:shen.newpv V3629))) (begin (kl:shen.incinfs) (kl:shen.t*-defh (kl:compile (lambda (Y) (kl:shen.<sig+rules> Y)) X (lambda (E) (if (pair? E) (simple-error (string-append "parse error here: " (kl:shen.app E "\n" (quote shen.s)))) (simple-error "parse error\n")))) F V3627 V3628 V3629 V3630)))))) #f)) #f)) #f))) (quote shen.t*-def))
(begin (register-function-arity (quote shen.t*-defh) 6) (define (kl:shen.t*-defh V3637 V3638 V3639 V3640 V3641 V3642) (let ((V3272 (kl:shen.lazyderef V3637 V3641))) (if (pair? V3272) (let ((Sig (car V3272))) (let ((Rules (cdr V3272))) (begin (kl:shen.incinfs) (kl:shen.t*-defhh Sig (kl:shen.ue-sig Sig) V3638 V3639 V3640 Rules V3641 V3642)))) #f))) (quote shen.t*-defh))
(begin (register-function-arity (quote shen.t*-defhh) 8) (define (kl:shen.t*-defhh V3651 V3652 V3653 V3654 V3655 V3656 V3657 V3658) (begin (kl:shen.incinfs) (kl:shen.t*-rules V3656 V3652 1 V3653 (cons (cons V3653 (cons (quote :) (cons V3652 (quote ())))) V3655) V3657 (lambda () (kl:shen.memo V3653 V3651 V3654 V3657 V3658))))) (quote shen.t*-defhh))
(begin (register-function-arity (quote shen.memo) 5) (define (kl:shen.memo V3664 V3665 V3666 V3667 V3668) (let ((Jnk (kl:shen.newpv V3667))) (begin (kl:shen.incinfs) (kl:unify! V3666 V3665 V3667 (lambda () (kl:bind Jnk (kl:declare (kl:shen.lazyderef V3664 V3667) (kl:shen.lazyderef V3666 V3667)) V3667 V3668)))))) (quote shen.memo))
(begin (register-function-arity (quote shen.<sig+rules>) 1) (define (kl:shen.<sig+rules> V3670) (let ((Parse_shen.<signature> (kl:shen.<signature> V3670))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature>)) (let ((Parse_shen.<non-ll-rules> (kl:shen.<non-ll-rules> Parse_shen.<signature>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<non-ll-rules>)) (kl:shen.pair (car Parse_shen.<non-ll-rules>) (cons (kl:shen.hdtl Parse_shen.<signature>) (kl:shen.hdtl Parse_shen.<non-ll-rules>))) (kl:fail))) (kl:fail)))) (quote shen.<sig+rules>))
(begin (register-function-arity (quote shen.<non-ll-rules>) 1) (define (kl:shen.<non-ll-rules> V3672) (let ((YaccParse (let ((Parse_shen.<rule> (kl:shen.<rule> V3672))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (let ((Parse_shen.<non-ll-rules> (kl:shen.<non-ll-rules> Parse_shen.<rule>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<non-ll-rules>)) (kl:shen.pair (car Parse_shen.<non-ll-rules>) (cons (kl:shen.hdtl Parse_shen.<rule>) (kl:shen.hdtl Parse_shen.<non-ll-rules>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<rule> (kl:shen.<rule> V3672))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (kl:shen.pair (car Parse_shen.<rule>) (cons (kl:shen.hdtl Parse_shen.<rule>) (quote ()))) (kl:fail))) YaccParse))) (quote shen.<non-ll-rules>))
(begin (register-function-arity (quote shen.ue) 1) (define (kl:shen.ue V3674) (cond ((and (pair? V3674) (and (pair? (cdr V3674)) (and (null? (cdr (cdr V3674))) (eq? (car V3674) (quote protect))))) V3674) ((pair? V3674) (kl:map (lambda (Z) (kl:shen.ue Z)) V3674)) ((kl:variable? V3674) (kl:concat (quote &&) V3674)) (#t V3674))) (quote shen.ue))
(begin (register-function-arity (quote shen.ue-sig) 1) (define (kl:shen.ue-sig V3676) (cond ((pair? V3676) (kl:map (lambda (Z) (kl:shen.ue-sig Z)) V3676)) ((kl:variable? V3676) (kl:concat (quote &&&) V3676)) (#t V3676))) (quote shen.ue-sig))
(begin (register-function-arity (quote shen.ues) 1) (define (kl:shen.ues V3682) (cond ((assert-boolean (kl:shen.ue? V3682)) (cons V3682 (quote ()))) ((pair? V3682) (kl:union (kl:shen.ues (car V3682)) (kl:shen.ues (cdr V3682)))) (#t (quote ())))) (quote shen.ues))
(begin (register-function-arity (quote shen.ue?) 1) (define (kl:shen.ue? V3684) (and (kl:symbol? V3684) (assert-boolean (kl:shen.ue-h? (kl:str V3684))))) (quote shen.ue?))
(begin (register-function-arity (quote shen.ue-h?) 1) (define (kl:shen.ue-h? V3692) (cond ((and (assert-boolean (kl:shen.+string? V3692)) (and (equal? "&" (make-string 1 (string-ref V3692 0))) (and (assert-boolean (kl:shen.+string? (string-tail V3692 1))) (equal? "&" (make-string 1 (string-ref (string-tail V3692 1) 0)))))) #t) (#t #f))) (quote shen.ue-h?))
(begin (register-function-arity (quote shen.t*-rules) 7) (define (kl:shen.t*-rules V3700 V3701 V3702 V3703 V3704 V3705 V3706) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (let ((V3256 (kl:shen.lazyderef V3700 V3705))) (if (null? V3256) (begin (kl:shen.incinfs) (kl:thaw V3706)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3257 (kl:shen.lazyderef V3700 V3705))) (if (pair? V3257) (let ((Rule (car V3257))) (let ((Rules (cdr V3257))) (begin (kl:shen.incinfs) (kl:shen.t*-rule (kl:shen.ue Rule) V3701 V3704 V3705 (lambda () (kl:cut Throwcontrol V3705 (lambda () (kl:shen.t*-rules Rules V3701 (+ V3702 1) V3703 V3704 V3705 V3706)))))))) #f)))) (if (kl:= Case #f) (let ((Err (kl:shen.newpv V3705))) (begin (kl:shen.incinfs) (kl:bind Err (simple-error (string-append "type error in rule " (kl:shen.app (kl:shen.lazyderef V3702 V3705) (string-append " of " (kl:shen.app (kl:shen.lazyderef V3703 V3705) "" (quote shen.a))) (quote shen.a)))) V3705 V3706))) Case)) Case))))) (quote shen.t*-rules))
(begin (register-function-arity (quote shen.t*-rule) 5) (define (kl:shen.t*-rule V3712 V3713 V3714 V3715 V3716) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((V3248 (kl:shen.lazyderef V3712 V3715))) (if (pair? V3248) (let ((Patterns (car V3248))) (let ((V3249 (kl:shen.lazyderef (cdr V3248) V3715))) (if (pair? V3249) (let ((Action (car V3249))) (let ((V3250 (kl:shen.lazyderef (cdr V3249) V3715))) (if (null? V3250) (let ((NewHyps (kl:shen.newpv V3715))) (begin (kl:shen.incinfs) (kl:shen.newhyps (kl:shen.placeholders Patterns) V3714 NewHyps V3715 (lambda () (kl:shen.t*-patterns Patterns V3713 NewHyps V3715 (lambda () (kl:cut Throwcontrol V3715 (lambda () (kl:shen.t*-action (kl:shen.curry (kl:shen.ue Action)) (kl:shen.result-type Patterns V3713) (kl:shen.patthyps Patterns V3713 V3714) V3715 V3716))))))))) #f))) #f))) #f))))) (quote shen.t*-rule))
(begin (register-function-arity (quote shen.placeholders) 1) (define (kl:shen.placeholders V3722) (cond ((assert-boolean (kl:shen.ue? V3722)) (cons V3722 (quote ()))) ((pair? V3722) (kl:union (kl:shen.placeholders (car V3722)) (kl:shen.placeholders (cdr V3722)))) (#t (quote ())))) (quote shen.placeholders))
(begin (register-function-arity (quote shen.newhyps) 5) (define (kl:shen.newhyps V3728 V3729 V3730 V3731 V3732) (let ((Case (let ((V3235 (kl:shen.lazyderef V3728 V3731))) (if (null? V3235) (begin (kl:shen.incinfs) (kl:unify! V3730 V3729 V3731 V3732)) #f)))) (if (kl:= Case #f) (let ((V3236 (kl:shen.lazyderef V3728 V3731))) (if (pair? V3236) (let ((V3231 (car V3236))) (let ((Vs (cdr V3236))) (let ((V3237 (kl:shen.lazyderef V3730 V3731))) (if (pair? V3237) (let ((V3238 (kl:shen.lazyderef (car V3237) V3731))) (if (pair? V3238) (let ((V (car V3238))) (let ((V3239 (kl:shen.lazyderef (cdr V3238) V3731))) (if (pair? V3239) (let ((V3240 (kl:shen.lazyderef (car V3239) V3731))) (if (eq? (quote :) V3240) (let ((V3241 (kl:shen.lazyderef (cdr V3239) V3731))) (if (pair? V3241) (let ((A (car V3241))) (let ((V3242 (kl:shen.lazyderef (cdr V3241) V3731))) (if (null? V3242) (let ((NewHyp (cdr V3237))) (begin (kl:shen.incinfs) (kl:unify! V V3231 V3731 (lambda () (kl:shen.newhyps Vs V3729 NewHyp V3731 V3732))))) (if (assert-boolean (kl:shen.pvar? V3242)) (begin (kl:shen.bindv V3242 (quote ()) V3731) (let ((Result (let ((NewHyp (cdr V3237))) (begin (kl:shen.incinfs) (kl:unify! V V3231 V3731 (lambda () (kl:shen.newhyps Vs V3729 NewHyp V3731 V3732))))))) (begin (kl:shen.unbindv V3242 V3731) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3241)) (let ((A (kl:shen.newpv V3731))) (begin (kl:shen.bindv V3241 (cons A (quote ())) V3731) (let ((Result (let ((NewHyp (cdr V3237))) (begin (kl:shen.incinfs) (kl:unify! V V3231 V3731 (lambda () (kl:shen.newhyps Vs V3729 NewHyp V3731 V3732))))))) (begin (kl:shen.unbindv V3241 V3731) Result)))) #f))) (if (assert-boolean (kl:shen.pvar? V3240)) (begin (kl:shen.bindv V3240 (quote :) V3731) (let ((Result (let ((V3243 (kl:shen.lazyderef (cdr V3239) V3731))) (if (pair? V3243) (let ((A (car V3243))) (let ((V3244 (kl:shen.lazyderef (cdr V3243) V3731))) (if (null? V3244) (let ((NewHyp (cdr V3237))) (begin (kl:shen.incinfs) (kl:unify! V V3231 V3731 (lambda () (kl:shen.newhyps Vs V3729 NewHyp V3731 V3732))))) (if (assert-boolean (kl:shen.pvar? V3244)) (begin (kl:shen.bindv V3244 (quote ()) V3731) (let ((Result (let ((NewHyp (cdr V3237))) (begin (kl:shen.incinfs) (kl:unify! V V3231 V3731 (lambda () (kl:shen.newhyps Vs V3729 NewHyp V3731 V3732))))))) (begin (kl:shen.unbindv V3244 V3731) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3243)) (let ((A (kl:shen.newpv V3731))) (begin (kl:shen.bindv V3243 (cons A (quote ())) V3731) (let ((Result (let ((NewHyp (cdr V3237))) (begin (kl:shen.incinfs) (kl:unify! V V3231 V3731 (lambda () (kl:shen.newhyps Vs V3729 NewHyp V3731 V3732))))))) (begin (kl:shen.unbindv V3243 V3731) Result)))) #f))))) (begin (kl:shen.unbindv V3240 V3731) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3239)) (let ((A (kl:shen.newpv V3731))) (begin (kl:shen.bindv V3239 (cons (quote :) (cons A (quote ()))) V3731) (let ((Result (let ((NewHyp (cdr V3237))) (begin (kl:shen.incinfs) (kl:unify! V V3231 V3731 (lambda () (kl:shen.newhyps Vs V3729 NewHyp V3731 V3732))))))) (begin (kl:shen.unbindv V3239 V3731) Result)))) #f)))) (if (assert-boolean (kl:shen.pvar? V3238)) (let ((V (kl:shen.newpv V3731))) (let ((A (kl:shen.newpv V3731))) (begin (kl:shen.bindv V3238 (cons V (cons (quote :) (cons A (quote ())))) V3731) (let ((Result (let ((NewHyp (cdr V3237))) (begin (kl:shen.incinfs) (kl:unify! V V3231 V3731 (lambda () (kl:shen.newhyps Vs V3729 NewHyp V3731 V3732))))))) (begin (kl:shen.unbindv V3238 V3731) Result))))) #f))) (if (assert-boolean (kl:shen.pvar? V3237)) (let ((V (kl:shen.newpv V3731))) (let ((A (kl:shen.newpv V3731))) (let ((NewHyp (kl:shen.newpv V3731))) (begin (kl:shen.bindv V3237 (cons (cons V (cons (quote :) (cons A (quote ())))) NewHyp) V3731) (let ((Result (begin (kl:shen.incinfs) (kl:unify! V V3231 V3731 (lambda () (kl:shen.newhyps Vs V3729 NewHyp V3731 V3732)))))) (begin (kl:shen.unbindv V3237 V3731) Result)))))) #f))))) #f)) Case))) (quote shen.newhyps))
(begin (register-function-arity (quote shen.patthyps) 3) (define (kl:shen.patthyps V3738 V3739 V3740) (cond ((null? V3738) V3740) ((and (pair? V3738) (and (pair? V3739) (and (pair? (cdr V3739)) (and (eq? (quote -->) (car (cdr V3739))) (and (pair? (cdr (cdr V3739))) (null? (cdr (cdr (cdr V3739))))))))) (kl:adjoin (cons (car V3738) (cons (quote :) (cons (car V3739) (quote ())))) (kl:shen.patthyps (cdr V3738) (car (cdr (cdr V3739))) V3740))) (#t (kl:shen.f_error (quote shen.patthyps))))) (quote shen.patthyps))
(begin (register-function-arity (quote shen.result-type) 2) (define (kl:shen.result-type V3747 V3748) (cond ((and (null? V3747) (and (pair? V3748) (and (eq? (quote -->) (car V3748)) (and (pair? (cdr V3748)) (null? (cdr (cdr V3748))))))) (car (cdr V3748))) ((null? V3747) V3748) ((and (pair? V3747) (and (pair? V3748) (and (pair? (cdr V3748)) (and (eq? (quote -->) (car (cdr V3748))) (and (pair? (cdr (cdr V3748))) (null? (cdr (cdr (cdr V3748))))))))) (kl:shen.result-type (cdr V3747) (car (cdr (cdr V3748))))) (#t (kl:shen.f_error (quote shen.result-type))))) (quote shen.result-type))
(begin (register-function-arity (quote shen.t*-patterns) 5) (define (kl:shen.t*-patterns V3754 V3755 V3756 V3757 V3758) (let ((Case (let ((V3223 (kl:shen.lazyderef V3754 V3757))) (if (null? V3223) (begin (kl:shen.incinfs) (kl:thaw V3758)) #f)))) (if (kl:= Case #f) (let ((V3224 (kl:shen.lazyderef V3754 V3757))) (if (pair? V3224) (let ((Pattern (car V3224))) (let ((Patterns (cdr V3224))) (let ((V3225 (kl:shen.lazyderef V3755 V3757))) (if (pair? V3225) (let ((A (car V3225))) (let ((V3226 (kl:shen.lazyderef (cdr V3225) V3757))) (if (pair? V3226) (let ((V3227 (kl:shen.lazyderef (car V3226) V3757))) (if (eq? (quote -->) V3227) (let ((V3228 (kl:shen.lazyderef (cdr V3226) V3757))) (if (pair? V3228) (let ((B (car V3228))) (let ((V3229 (kl:shen.lazyderef (cdr V3228) V3757))) (if (null? V3229) (begin (kl:shen.incinfs) (kl:shen.t* (cons Pattern (cons (quote :) (cons A (quote ())))) V3756 V3757 (lambda () (kl:shen.t*-patterns Patterns B V3756 V3757 V3758)))) #f))) #f)) #f)) #f))) #f)))) #f)) Case))) (quote shen.t*-patterns))
(begin (register-function-arity (quote shen.t*-action) 5) (define (kl:shen.t*-action V3764 V3765 V3766 V3767 V3768) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (let ((V3200 (kl:shen.lazyderef V3764 V3767))) (if (pair? V3200) (let ((V3201 (kl:shen.lazyderef (car V3200) V3767))) (if (eq? (quote where) V3201) (let ((V3202 (kl:shen.lazyderef (cdr V3200) V3767))) (if (pair? V3202) (let ((P (car V3202))) (let ((V3203 (kl:shen.lazyderef (cdr V3202) V3767))) (if (pair? V3203) (let ((Action (car V3203))) (let ((V3204 (kl:shen.lazyderef (cdr V3203) V3767))) (if (null? V3204) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3767 (lambda () (kl:shen.t* (cons P (cons (quote :) (cons (quote boolean) (quote ())))) V3766 V3767 (lambda () (kl:cut Throwcontrol V3767 (lambda () (kl:shen.t*-action Action V3765 (cons (cons P (cons (quote :) (cons (quote verified) (quote ())))) V3766) V3767 V3768)))))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3205 (kl:shen.lazyderef V3764 V3767))) (if (pair? V3205) (let ((V3206 (kl:shen.lazyderef (car V3205) V3767))) (if (eq? (quote shen.choicepoint!) V3206) (let ((V3207 (kl:shen.lazyderef (cdr V3205) V3767))) (if (pair? V3207) (let ((V3208 (kl:shen.lazyderef (car V3207) V3767))) (if (pair? V3208) (let ((V3209 (kl:shen.lazyderef (car V3208) V3767))) (if (pair? V3209) (let ((V3210 (kl:shen.lazyderef (car V3209) V3767))) (if (eq? (quote fail-if) V3210) (let ((V3211 (kl:shen.lazyderef (cdr V3209) V3767))) (if (pair? V3211) (let ((F (car V3211))) (let ((V3212 (kl:shen.lazyderef (cdr V3211) V3767))) (if (null? V3212) (let ((V3213 (kl:shen.lazyderef (cdr V3208) V3767))) (if (pair? V3213) (let ((Action (car V3213))) (let ((V3214 (kl:shen.lazyderef (cdr V3213) V3767))) (if (null? V3214) (let ((V3215 (kl:shen.lazyderef (cdr V3207) V3767))) (if (null? V3215) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3767 (lambda () (kl:shen.t*-action (cons (quote where) (cons (cons (quote not) (cons (cons F (cons Action (quote ()))) (quote ()))) (cons Action (quote ())))) V3765 V3766 V3767 V3768)))) #f)) #f))) #f)) #f))) #f)) #f)) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3216 (kl:shen.lazyderef V3764 V3767))) (if (pair? V3216) (let ((V3217 (kl:shen.lazyderef (car V3216) V3767))) (if (eq? (quote shen.choicepoint!) V3217) (let ((V3218 (kl:shen.lazyderef (cdr V3216) V3767))) (if (pair? V3218) (let ((Action (car V3218))) (let ((V3219 (kl:shen.lazyderef (cdr V3218) V3767))) (if (null? V3219) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3767 (lambda () (kl:shen.t*-action (cons (quote where) (cons (cons (quote not) (cons (cons (cons (quote =) (cons Action (quote ()))) (cons (cons (quote fail) (quote ())) (quote ()))) (quote ()))) (cons Action (quote ())))) V3765 V3766 V3767 V3768)))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (begin (kl:shen.incinfs) (kl:shen.t* (cons V3764 (cons (quote :) (cons V3765 (quote ())))) V3766 V3767 V3768)) Case)) Case)) Case))))) (quote shen.t*-action))
(begin (register-function-arity (quote findall) 5) (define (kl:findall V3774 V3775 V3776 V3777 V3778) (let ((B (kl:shen.newpv V3777))) (let ((A (kl:shen.newpv V3777))) (begin (kl:shen.incinfs) (kl:bind A (kl:gensym (quote shen.a)) V3777 (lambda () (kl:bind B (kl:set (kl:shen.lazyderef A V3777) (quote ())) V3777 (lambda () (kl:shen.findallhelp V3774 V3775 V3776 A V3777 V3778))))))))) (quote findall))
(begin (register-function-arity (quote shen.findallhelp) 6) (define (kl:shen.findallhelp V3785 V3786 V3787 V3788 V3789 V3790) (let ((Case (begin (kl:shen.incinfs) (kl:call V3786 V3789 (lambda () (kl:shen.remember V3788 V3785 V3789 (lambda () (kl:fwhen #f V3789 V3790)))))))) (if (kl:= Case #f) (begin (kl:shen.incinfs) (kl:bind V3787 (kl:value (kl:shen.lazyderef V3788 V3789)) V3789 V3790)) Case))) (quote shen.findallhelp))
(begin (register-function-arity (quote shen.remember) 4) (define (kl:shen.remember V3795 V3796 V3797 V3798) (let ((B (kl:shen.newpv V3797))) (begin (kl:shen.incinfs) (kl:bind B (kl:set (kl:shen.deref V3795 V3797) (cons (kl:shen.deref V3796 V3797) (kl:value (kl:shen.deref V3795 V3797)))) V3797 V3798)))) (quote shen.remember))
