"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.typecheck) 2) (define (kl:shen.typecheck V3682 V3683) (let ((Curry (kl:shen.curry V3682))) (let ((ProcessN (kl:shen.start-new-prolog-process))) (let ((Type (kl:shen.insert-prolog-variables (kl:shen.demodulate (kl:shen.curry-type V3683)) ProcessN))) (let ((Continuation (lambda () (kl:return Type ProcessN (quote shen.void))))) (kl:shen.t* (cons Curry (cons (quote :) (cons Type (quote ())))) (quote ()) ProcessN Continuation)))))) (quote shen.typecheck))
(begin (register-function-arity (quote shen.curry) 1) (define (kl:shen.curry V3685) (cond ((and (pair? V3685) (assert-boolean (kl:shen.special? (car V3685)))) (cons (car V3685) (kl:map (lambda (Y) (kl:shen.curry Y)) (cdr V3685)))) ((and (pair? V3685) (and (pair? (cdr V3685)) (assert-boolean (kl:shen.extraspecial? (car V3685))))) V3685) ((and (pair? V3685) (and (eq? (quote type) (car V3685)) (and (pair? (cdr V3685)) (and (pair? (cdr (cdr V3685))) (null? (cdr (cdr (cdr V3685)))))))) (cons (quote type) (cons (kl:shen.curry (car (cdr V3685))) (cdr (cdr V3685))))) ((and (pair? V3685) (and (pair? (cdr V3685)) (pair? (cdr (cdr V3685))))) (kl:shen.curry (cons (cons (car V3685) (cons (car (cdr V3685)) (quote ()))) (cdr (cdr V3685))))) ((and (pair? V3685) (and (pair? (cdr V3685)) (null? (cdr (cdr V3685))))) (cons (kl:shen.curry (car V3685)) (cons (kl:shen.curry (car (cdr V3685))) (quote ())))) (#t V3685))) (quote shen.curry))
(begin (register-function-arity (quote shen.special?) 1) (define (kl:shen.special? V3687) (kl:element? V3687 (kl:value (quote shen.*special*)))) (quote shen.special?))
(begin (register-function-arity (quote shen.extraspecial?) 1) (define (kl:shen.extraspecial? V3689) (kl:element? V3689 (kl:value (quote shen.*extraspecial*)))) (quote shen.extraspecial?))
(begin (register-function-arity (quote shen.t*) 4) (define (kl:shen.t* V3694 V3695 V3696 V3697) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (let ((Error (kl:shen.newpv V3696))) (begin (kl:shen.incinfs) (kl:fwhen (kl:shen.maxinfexceeded?) V3696 (lambda () (kl:bind Error (kl:shen.errormaxinfs) V3696 V3697))))))) (if (kl:= Case #f) (let ((Case (let ((V3674 (kl:shen.lazyderef V3694 V3696))) (if (eq? (quote fail) V3674) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3696 (lambda () (kl:shen.prolog-failure V3696 V3697)))) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3675 (kl:shen.lazyderef V3694 V3696))) (if (pair? V3675) (let ((X (car V3675))) (let ((V3676 (kl:shen.lazyderef (cdr V3675) V3696))) (if (pair? V3676) (let ((V3677 (kl:shen.lazyderef (car V3676) V3696))) (if (eq? (quote :) V3677) (let ((V3678 (kl:shen.lazyderef (cdr V3676) V3696))) (if (pair? V3678) (let ((A (car V3678))) (let ((V3679 (kl:shen.lazyderef (cdr V3678) V3696))) (if (null? V3679) (begin (kl:shen.incinfs) (kl:fwhen (kl:shen.type-theory-enabled?) V3696 (lambda () (kl:cut Throwcontrol V3696 (lambda () (kl:shen.th* X A V3695 V3696 V3697)))))) #f))) #f)) #f)) #f))) #f)))) (if (kl:= Case #f) (let ((Datatypes (kl:shen.newpv V3696))) (begin (kl:shen.incinfs) (kl:shen.show V3694 V3695 V3696 (lambda () (kl:bind Datatypes (kl:value (quote shen.*datatypes*)) V3696 (lambda () (kl:shen.udefs* V3694 V3695 Datatypes V3696 V3697))))))) Case)) Case)) Case))))) (quote shen.t*))
(begin (register-function-arity (quote shen.type-theory-enabled?) 0) (define (kl:shen.type-theory-enabled?) (kl:value (quote shen.*shen-type-theory-enabled?*))) (quote shen.type-theory-enabled?))
(begin (register-function-arity (quote enable-type-theory) 1) (define (kl:enable-type-theory V3703) (cond ((eq? (quote +) V3703) (kl:set (quote shen.*shen-type-theory-enabled?*) #t)) ((eq? (quote -) V3703) (kl:set (quote shen.*shen-type-theory-enabled?*) #f)) (#t (simple-error "enable-type-theory expects a + or a -\n")))) (quote enable-type-theory))
(begin (register-function-arity (quote shen.prolog-failure) 2) (define (kl:shen.prolog-failure V3714 V3715) #f) (quote shen.prolog-failure))
(begin (register-function-arity (quote shen.maxinfexceeded?) 0) (define (kl:shen.maxinfexceeded?) (> (kl:inferences) (kl:value (quote shen.*maxinferences*)))) (quote shen.maxinfexceeded?))
(begin (register-function-arity (quote shen.errormaxinfs) 0) (define (kl:shen.errormaxinfs) (simple-error "maximum inferences exceeded~%")) (quote shen.errormaxinfs))
(begin (register-function-arity (quote shen.udefs*) 5) (define (kl:shen.udefs* V3721 V3722 V3723 V3724 V3725) (let ((Case (let ((V3670 (kl:shen.lazyderef V3723 V3724))) (if (pair? V3670) (let ((D (car V3670))) (begin (kl:shen.incinfs) (kl:call (cons D (cons V3721 (cons V3722 (quote ())))) V3724 V3725))) #f)))) (if (kl:= Case #f) (let ((V3671 (kl:shen.lazyderef V3723 V3724))) (if (pair? V3671) (let ((Ds (cdr V3671))) (begin (kl:shen.incinfs) (kl:shen.udefs* V3721 V3722 Ds V3724 V3725))) #f)) Case))) (quote shen.udefs*))
(begin (register-function-arity (quote shen.th*) 5) (define (kl:shen.th* V3731 V3732 V3733 V3734 V3735) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (begin (kl:shen.incinfs) (kl:shen.show (cons V3731 (cons (quote :) (cons V3732 (quote ())))) V3733 V3734 (lambda () (kl:fwhen #f V3734 V3735)))))) (if (kl:= Case #f) (let ((Case (let ((F (kl:shen.newpv V3734))) (begin (kl:shen.incinfs) (kl:fwhen (kl:shen.typedf? (kl:shen.lazyderef V3731 V3734)) V3734 (lambda () (kl:bind F (kl:shen.sigf (kl:shen.lazyderef V3731 V3734)) V3734 (lambda () (kl:call (cons F (cons V3732 (quote ()))) V3734 V3735))))))))) (if (kl:= Case #f) (let ((Case (begin (kl:shen.incinfs) (kl:shen.base V3731 V3732 V3734 V3735)))) (if (kl:= Case #f) (let ((Case (begin (kl:shen.incinfs) (kl:shen.by_hypothesis V3731 V3732 V3733 V3734 V3735)))) (if (kl:= Case #f) (let ((Case (let ((V3566 (kl:shen.lazyderef V3731 V3734))) (if (pair? V3566) (let ((F (car V3566))) (let ((V3567 (kl:shen.lazyderef (cdr V3566) V3734))) (if (null? V3567) (begin (kl:shen.incinfs) (kl:shen.th* F (cons (quote -->) (cons V3732 (quote ()))) V3733 V3734 V3735)) #f))) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3568 (kl:shen.lazyderef V3731 V3734))) (if (pair? V3568) (let ((F (car V3568))) (let ((V3569 (kl:shen.lazyderef (cdr V3568) V3734))) (if (pair? V3569) (let ((X (car V3569))) (let ((V3570 (kl:shen.lazyderef (cdr V3569) V3734))) (if (null? V3570) (let ((B (kl:shen.newpv V3734))) (begin (kl:shen.incinfs) (kl:shen.th* F (cons B (cons (quote -->) (cons V3732 (quote ())))) V3733 V3734 (lambda () (kl:shen.th* X B V3733 V3734 V3735))))) #f))) #f))) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3571 (kl:shen.lazyderef V3731 V3734))) (if (pair? V3571) (let ((V3572 (kl:shen.lazyderef (car V3571) V3734))) (if (eq? (quote cons) V3572) (let ((V3573 (kl:shen.lazyderef (cdr V3571) V3734))) (if (pair? V3573) (let ((X (car V3573))) (let ((V3574 (kl:shen.lazyderef (cdr V3573) V3734))) (if (pair? V3574) (let ((Y (car V3574))) (let ((V3575 (kl:shen.lazyderef (cdr V3574) V3734))) (if (null? V3575) (let ((V3576 (kl:shen.lazyderef V3732 V3734))) (if (pair? V3576) (let ((V3577 (kl:shen.lazyderef (car V3576) V3734))) (if (eq? (quote list) V3577) (let ((V3578 (kl:shen.lazyderef (cdr V3576) V3734))) (if (pair? V3578) (let ((A (car V3578))) (let ((V3579 (kl:shen.lazyderef (cdr V3578) V3734))) (if (null? V3579) (begin (kl:shen.incinfs) (kl:shen.th* X A V3733 V3734 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3733 V3734 V3735)))) (if (kl:shen.pvar? V3579) (begin (kl:shen.bindv V3579 (quote ()) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3733 V3734 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3733 V3734 V3735)))))) (begin (kl:shen.unbindv V3579 V3734) Result))) #f)))) (if (kl:shen.pvar? V3578) (let ((A (kl:shen.newpv V3734))) (begin (kl:shen.bindv V3578 (cons A (quote ())) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3733 V3734 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3733 V3734 V3735)))))) (begin (kl:shen.unbindv V3578 V3734) Result)))) #f))) (if (kl:shen.pvar? V3577) (begin (kl:shen.bindv V3577 (quote list) V3734) (let ((Result (let ((V3580 (kl:shen.lazyderef (cdr V3576) V3734))) (if (pair? V3580) (let ((A (car V3580))) (let ((V3581 (kl:shen.lazyderef (cdr V3580) V3734))) (if (null? V3581) (begin (kl:shen.incinfs) (kl:shen.th* X A V3733 V3734 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3733 V3734 V3735)))) (if (kl:shen.pvar? V3581) (begin (kl:shen.bindv V3581 (quote ()) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3733 V3734 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3733 V3734 V3735)))))) (begin (kl:shen.unbindv V3581 V3734) Result))) #f)))) (if (kl:shen.pvar? V3580) (let ((A (kl:shen.newpv V3734))) (begin (kl:shen.bindv V3580 (cons A (quote ())) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3733 V3734 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3733 V3734 V3735)))))) (begin (kl:shen.unbindv V3580 V3734) Result)))) #f))))) (begin (kl:shen.unbindv V3577 V3734) Result))) #f))) (if (kl:shen.pvar? V3576) (let ((A (kl:shen.newpv V3734))) (begin (kl:shen.bindv V3576 (cons (quote list) (cons A (quote ()))) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3733 V3734 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3733 V3734 V3735)))))) (begin (kl:shen.unbindv V3576 V3734) Result)))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3582 (kl:shen.lazyderef V3731 V3734))) (if (pair? V3582) (let ((V3583 (kl:shen.lazyderef (car V3582) V3734))) (if (eq? (quote _waspvm_at_p) V3583) (let ((V3584 (kl:shen.lazyderef (cdr V3582) V3734))) (if (pair? V3584) (let ((X (car V3584))) (let ((V3585 (kl:shen.lazyderef (cdr V3584) V3734))) (if (pair? V3585) (let ((Y (car V3585))) (let ((V3586 (kl:shen.lazyderef (cdr V3585) V3734))) (if (null? V3586) (let ((V3587 (kl:shen.lazyderef V3732 V3734))) (if (pair? V3587) (let ((A (car V3587))) (let ((V3588 (kl:shen.lazyderef (cdr V3587) V3734))) (if (pair? V3588) (let ((V3589 (kl:shen.lazyderef (car V3588) V3734))) (if (eq? (quote *) V3589) (let ((V3590 (kl:shen.lazyderef (cdr V3588) V3734))) (if (pair? V3590) (let ((B (car V3590))) (let ((V3591 (kl:shen.lazyderef (cdr V3590) V3734))) (if (null? V3591) (begin (kl:shen.incinfs) (kl:shen.th* X A V3733 V3734 (lambda () (kl:shen.th* Y B V3733 V3734 V3735)))) (if (kl:shen.pvar? V3591) (begin (kl:shen.bindv V3591 (quote ()) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3733 V3734 (lambda () (kl:shen.th* Y B V3733 V3734 V3735)))))) (begin (kl:shen.unbindv V3591 V3734) Result))) #f)))) (if (kl:shen.pvar? V3590) (let ((B (kl:shen.newpv V3734))) (begin (kl:shen.bindv V3590 (cons B (quote ())) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3733 V3734 (lambda () (kl:shen.th* Y B V3733 V3734 V3735)))))) (begin (kl:shen.unbindv V3590 V3734) Result)))) #f))) (if (kl:shen.pvar? V3589) (begin (kl:shen.bindv V3589 (quote *) V3734) (let ((Result (let ((V3592 (kl:shen.lazyderef (cdr V3588) V3734))) (if (pair? V3592) (let ((B (car V3592))) (let ((V3593 (kl:shen.lazyderef (cdr V3592) V3734))) (if (null? V3593) (begin (kl:shen.incinfs) (kl:shen.th* X A V3733 V3734 (lambda () (kl:shen.th* Y B V3733 V3734 V3735)))) (if (kl:shen.pvar? V3593) (begin (kl:shen.bindv V3593 (quote ()) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3733 V3734 (lambda () (kl:shen.th* Y B V3733 V3734 V3735)))))) (begin (kl:shen.unbindv V3593 V3734) Result))) #f)))) (if (kl:shen.pvar? V3592) (let ((B (kl:shen.newpv V3734))) (begin (kl:shen.bindv V3592 (cons B (quote ())) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3733 V3734 (lambda () (kl:shen.th* Y B V3733 V3734 V3735)))))) (begin (kl:shen.unbindv V3592 V3734) Result)))) #f))))) (begin (kl:shen.unbindv V3589 V3734) Result))) #f))) (if (kl:shen.pvar? V3588) (let ((B (kl:shen.newpv V3734))) (begin (kl:shen.bindv V3588 (cons (quote *) (cons B (quote ()))) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3733 V3734 (lambda () (kl:shen.th* Y B V3733 V3734 V3735)))))) (begin (kl:shen.unbindv V3588 V3734) Result)))) #f)))) (if (kl:shen.pvar? V3587) (let ((A (kl:shen.newpv V3734))) (let ((B (kl:shen.newpv V3734))) (begin (kl:shen.bindv V3587 (cons A (cons (quote *) (cons B (quote ())))) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3733 V3734 (lambda () (kl:shen.th* Y B V3733 V3734 V3735)))))) (begin (kl:shen.unbindv V3587 V3734) Result))))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3594 (kl:shen.lazyderef V3731 V3734))) (if (pair? V3594) (let ((V3595 (kl:shen.lazyderef (car V3594) V3734))) (if (eq? (quote _waspvm_at_v) V3595) (let ((V3596 (kl:shen.lazyderef (cdr V3594) V3734))) (if (pair? V3596) (let ((X (car V3596))) (let ((V3597 (kl:shen.lazyderef (cdr V3596) V3734))) (if (pair? V3597) (let ((Y (car V3597))) (let ((V3598 (kl:shen.lazyderef (cdr V3597) V3734))) (if (null? V3598) (let ((V3599 (kl:shen.lazyderef V3732 V3734))) (if (pair? V3599) (let ((V3600 (kl:shen.lazyderef (car V3599) V3734))) (if (eq? (quote vector) V3600) (let ((V3601 (kl:shen.lazyderef (cdr V3599) V3734))) (if (pair? V3601) (let ((A (car V3601))) (let ((V3602 (kl:shen.lazyderef (cdr V3601) V3734))) (if (null? V3602) (begin (kl:shen.incinfs) (kl:shen.th* X A V3733 V3734 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3733 V3734 V3735)))) (if (kl:shen.pvar? V3602) (begin (kl:shen.bindv V3602 (quote ()) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3733 V3734 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3733 V3734 V3735)))))) (begin (kl:shen.unbindv V3602 V3734) Result))) #f)))) (if (kl:shen.pvar? V3601) (let ((A (kl:shen.newpv V3734))) (begin (kl:shen.bindv V3601 (cons A (quote ())) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3733 V3734 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3733 V3734 V3735)))))) (begin (kl:shen.unbindv V3601 V3734) Result)))) #f))) (if (kl:shen.pvar? V3600) (begin (kl:shen.bindv V3600 (quote vector) V3734) (let ((Result (let ((V3603 (kl:shen.lazyderef (cdr V3599) V3734))) (if (pair? V3603) (let ((A (car V3603))) (let ((V3604 (kl:shen.lazyderef (cdr V3603) V3734))) (if (null? V3604) (begin (kl:shen.incinfs) (kl:shen.th* X A V3733 V3734 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3733 V3734 V3735)))) (if (kl:shen.pvar? V3604) (begin (kl:shen.bindv V3604 (quote ()) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3733 V3734 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3733 V3734 V3735)))))) (begin (kl:shen.unbindv V3604 V3734) Result))) #f)))) (if (kl:shen.pvar? V3603) (let ((A (kl:shen.newpv V3734))) (begin (kl:shen.bindv V3603 (cons A (quote ())) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3733 V3734 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3733 V3734 V3735)))))) (begin (kl:shen.unbindv V3603 V3734) Result)))) #f))))) (begin (kl:shen.unbindv V3600 V3734) Result))) #f))) (if (kl:shen.pvar? V3599) (let ((A (kl:shen.newpv V3734))) (begin (kl:shen.bindv V3599 (cons (quote vector) (cons A (quote ()))) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3733 V3734 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3733 V3734 V3735)))))) (begin (kl:shen.unbindv V3599 V3734) Result)))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3605 (kl:shen.lazyderef V3731 V3734))) (if (pair? V3605) (let ((V3606 (kl:shen.lazyderef (car V3605) V3734))) (if (eq? (quote _waspvm_at_s) V3606) (let ((V3607 (kl:shen.lazyderef (cdr V3605) V3734))) (if (pair? V3607) (let ((X (car V3607))) (let ((V3608 (kl:shen.lazyderef (cdr V3607) V3734))) (if (pair? V3608) (let ((Y (car V3608))) (let ((V3609 (kl:shen.lazyderef (cdr V3608) V3734))) (if (null? V3609) (let ((V3610 (kl:shen.lazyderef V3732 V3734))) (if (eq? (quote string) V3610) (begin (kl:shen.incinfs) (kl:shen.th* X (quote string) V3733 V3734 (lambda () (kl:shen.th* Y (quote string) V3733 V3734 V3735)))) (if (kl:shen.pvar? V3610) (begin (kl:shen.bindv V3610 (quote string) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X (quote string) V3733 V3734 (lambda () (kl:shen.th* Y (quote string) V3733 V3734 V3735)))))) (begin (kl:shen.unbindv V3610 V3734) Result))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3611 (kl:shen.lazyderef V3731 V3734))) (if (pair? V3611) (let ((V3612 (kl:shen.lazyderef (car V3611) V3734))) (if (eq? (quote lambda) V3612) (let ((V3613 (kl:shen.lazyderef (cdr V3611) V3734))) (if (pair? V3613) (let ((X (car V3613))) (let ((V3614 (kl:shen.lazyderef (cdr V3613) V3734))) (if (pair? V3614) (let ((Y (car V3614))) (let ((V3615 (kl:shen.lazyderef (cdr V3614) V3734))) (if (null? V3615) (let ((V3616 (kl:shen.lazyderef V3732 V3734))) (if (pair? V3616) (let ((A (car V3616))) (let ((V3617 (kl:shen.lazyderef (cdr V3616) V3734))) (if (pair? V3617) (let ((V3618 (kl:shen.lazyderef (car V3617) V3734))) (if (eq? (quote -->) V3618) (let ((V3619 (kl:shen.lazyderef (cdr V3617) V3734))) (if (pair? V3619) (let ((B (car V3619))) (let ((V3620 (kl:shen.lazyderef (cdr V3619) V3734))) (if (null? V3620) (let ((Z (kl:shen.newpv V3734))) (let ((X&& (kl:shen.newpv V3734))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3734 (lambda () (kl:bind X&& (kl:shen.placeholder) V3734 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3734) (kl:shen.lazyderef X V3734) (kl:shen.lazyderef Y V3734)) V3734 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3733) V3734 V3735)))))))))) (if (kl:shen.pvar? V3620) (begin (kl:shen.bindv V3620 (quote ()) V3734) (let ((Result (let ((Z (kl:shen.newpv V3734))) (let ((X&& (kl:shen.newpv V3734))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3734 (lambda () (kl:bind X&& (kl:shen.placeholder) V3734 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3734) (kl:shen.lazyderef X V3734) (kl:shen.lazyderef Y V3734)) V3734 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3733) V3734 V3735)))))))))))) (begin (kl:shen.unbindv V3620 V3734) Result))) #f)))) (if (kl:shen.pvar? V3619) (let ((B (kl:shen.newpv V3734))) (begin (kl:shen.bindv V3619 (cons B (quote ())) V3734) (let ((Result (let ((Z (kl:shen.newpv V3734))) (let ((X&& (kl:shen.newpv V3734))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3734 (lambda () (kl:bind X&& (kl:shen.placeholder) V3734 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3734) (kl:shen.lazyderef X V3734) (kl:shen.lazyderef Y V3734)) V3734 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3733) V3734 V3735)))))))))))) (begin (kl:shen.unbindv V3619 V3734) Result)))) #f))) (if (kl:shen.pvar? V3618) (begin (kl:shen.bindv V3618 (quote -->) V3734) (let ((Result (let ((V3621 (kl:shen.lazyderef (cdr V3617) V3734))) (if (pair? V3621) (let ((B (car V3621))) (let ((V3622 (kl:shen.lazyderef (cdr V3621) V3734))) (if (null? V3622) (let ((Z (kl:shen.newpv V3734))) (let ((X&& (kl:shen.newpv V3734))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3734 (lambda () (kl:bind X&& (kl:shen.placeholder) V3734 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3734) (kl:shen.lazyderef X V3734) (kl:shen.lazyderef Y V3734)) V3734 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3733) V3734 V3735)))))))))) (if (kl:shen.pvar? V3622) (begin (kl:shen.bindv V3622 (quote ()) V3734) (let ((Result (let ((Z (kl:shen.newpv V3734))) (let ((X&& (kl:shen.newpv V3734))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3734 (lambda () (kl:bind X&& (kl:shen.placeholder) V3734 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3734) (kl:shen.lazyderef X V3734) (kl:shen.lazyderef Y V3734)) V3734 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3733) V3734 V3735)))))))))))) (begin (kl:shen.unbindv V3622 V3734) Result))) #f)))) (if (kl:shen.pvar? V3621) (let ((B (kl:shen.newpv V3734))) (begin (kl:shen.bindv V3621 (cons B (quote ())) V3734) (let ((Result (let ((Z (kl:shen.newpv V3734))) (let ((X&& (kl:shen.newpv V3734))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3734 (lambda () (kl:bind X&& (kl:shen.placeholder) V3734 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3734) (kl:shen.lazyderef X V3734) (kl:shen.lazyderef Y V3734)) V3734 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3733) V3734 V3735)))))))))))) (begin (kl:shen.unbindv V3621 V3734) Result)))) #f))))) (begin (kl:shen.unbindv V3618 V3734) Result))) #f))) (if (kl:shen.pvar? V3617) (let ((B (kl:shen.newpv V3734))) (begin (kl:shen.bindv V3617 (cons (quote -->) (cons B (quote ()))) V3734) (let ((Result (let ((Z (kl:shen.newpv V3734))) (let ((X&& (kl:shen.newpv V3734))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3734 (lambda () (kl:bind X&& (kl:shen.placeholder) V3734 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3734) (kl:shen.lazyderef X V3734) (kl:shen.lazyderef Y V3734)) V3734 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3733) V3734 V3735)))))))))))) (begin (kl:shen.unbindv V3617 V3734) Result)))) #f)))) (if (kl:shen.pvar? V3616) (let ((A (kl:shen.newpv V3734))) (let ((B (kl:shen.newpv V3734))) (begin (kl:shen.bindv V3616 (cons A (cons (quote -->) (cons B (quote ())))) V3734) (let ((Result (let ((Z (kl:shen.newpv V3734))) (let ((X&& (kl:shen.newpv V3734))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3734 (lambda () (kl:bind X&& (kl:shen.placeholder) V3734 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3734) (kl:shen.lazyderef X V3734) (kl:shen.lazyderef Y V3734)) V3734 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3733) V3734 V3735)))))))))))) (begin (kl:shen.unbindv V3616 V3734) Result))))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3623 (kl:shen.lazyderef V3731 V3734))) (if (pair? V3623) (let ((V3624 (kl:shen.lazyderef (car V3623) V3734))) (if (eq? (quote let) V3624) (let ((V3625 (kl:shen.lazyderef (cdr V3623) V3734))) (if (pair? V3625) (let ((X (car V3625))) (let ((V3626 (kl:shen.lazyderef (cdr V3625) V3734))) (if (pair? V3626) (let ((Y (car V3626))) (let ((V3627 (kl:shen.lazyderef (cdr V3626) V3734))) (if (pair? V3627) (let ((Z (car V3627))) (let ((V3628 (kl:shen.lazyderef (cdr V3627) V3734))) (if (null? V3628) (let ((W (kl:shen.newpv V3734))) (let ((X&& (kl:shen.newpv V3734))) (let ((B (kl:shen.newpv V3734))) (begin (kl:shen.incinfs) (kl:shen.th* Y B V3733 V3734 (lambda () (kl:bind X&& (kl:shen.placeholder) V3734 (lambda () (kl:bind W (kl:shen.ebr (kl:shen.lazyderef X&& V3734) (kl:shen.lazyderef X V3734) (kl:shen.lazyderef Z V3734)) V3734 (lambda () (kl:shen.th* W V3732 (cons (cons X&& (cons (quote :) (cons B (quote ())))) V3733) V3734 V3735))))))))))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3629 (kl:shen.lazyderef V3731 V3734))) (if (pair? V3629) (let ((V3630 (kl:shen.lazyderef (car V3629) V3734))) (if (eq? (quote open) V3630) (let ((V3631 (kl:shen.lazyderef (cdr V3629) V3734))) (if (pair? V3631) (let ((FileName (car V3631))) (let ((V3632 (kl:shen.lazyderef (cdr V3631) V3734))) (if (pair? V3632) (let ((Direction3562 (car V3632))) (let ((V3633 (kl:shen.lazyderef (cdr V3632) V3734))) (if (null? V3633) (let ((V3634 (kl:shen.lazyderef V3732 V3734))) (if (pair? V3634) (let ((V3635 (kl:shen.lazyderef (car V3634) V3734))) (if (eq? (quote stream) V3635) (let ((V3636 (kl:shen.lazyderef (cdr V3634) V3734))) (if (pair? V3636) (let ((Direction (car V3636))) (let ((V3637 (kl:shen.lazyderef (cdr V3636) V3734))) (if (null? V3637) (begin (kl:shen.incinfs) (kl:unify! Direction Direction3562 V3734 (lambda () (kl:cut Throwcontrol V3734 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3734) (cons (quote in) (cons (quote out) (quote ())))) V3734 (lambda () (kl:shen.th* FileName (quote string) V3733 V3734 V3735)))))))) (if (kl:shen.pvar? V3637) (begin (kl:shen.bindv V3637 (quote ()) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3562 V3734 (lambda () (kl:cut Throwcontrol V3734 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3734) (cons (quote in) (cons (quote out) (quote ())))) V3734 (lambda () (kl:shen.th* FileName (quote string) V3733 V3734 V3735)))))))))) (begin (kl:shen.unbindv V3637 V3734) Result))) #f)))) (if (kl:shen.pvar? V3636) (let ((Direction (kl:shen.newpv V3734))) (begin (kl:shen.bindv V3636 (cons Direction (quote ())) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3562 V3734 (lambda () (kl:cut Throwcontrol V3734 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3734) (cons (quote in) (cons (quote out) (quote ())))) V3734 (lambda () (kl:shen.th* FileName (quote string) V3733 V3734 V3735)))))))))) (begin (kl:shen.unbindv V3636 V3734) Result)))) #f))) (if (kl:shen.pvar? V3635) (begin (kl:shen.bindv V3635 (quote stream) V3734) (let ((Result (let ((V3638 (kl:shen.lazyderef (cdr V3634) V3734))) (if (pair? V3638) (let ((Direction (car V3638))) (let ((V3639 (kl:shen.lazyderef (cdr V3638) V3734))) (if (null? V3639) (begin (kl:shen.incinfs) (kl:unify! Direction Direction3562 V3734 (lambda () (kl:cut Throwcontrol V3734 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3734) (cons (quote in) (cons (quote out) (quote ())))) V3734 (lambda () (kl:shen.th* FileName (quote string) V3733 V3734 V3735)))))))) (if (kl:shen.pvar? V3639) (begin (kl:shen.bindv V3639 (quote ()) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3562 V3734 (lambda () (kl:cut Throwcontrol V3734 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3734) (cons (quote in) (cons (quote out) (quote ())))) V3734 (lambda () (kl:shen.th* FileName (quote string) V3733 V3734 V3735)))))))))) (begin (kl:shen.unbindv V3639 V3734) Result))) #f)))) (if (kl:shen.pvar? V3638) (let ((Direction (kl:shen.newpv V3734))) (begin (kl:shen.bindv V3638 (cons Direction (quote ())) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3562 V3734 (lambda () (kl:cut Throwcontrol V3734 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3734) (cons (quote in) (cons (quote out) (quote ())))) V3734 (lambda () (kl:shen.th* FileName (quote string) V3733 V3734 V3735)))))))))) (begin (kl:shen.unbindv V3638 V3734) Result)))) #f))))) (begin (kl:shen.unbindv V3635 V3734) Result))) #f))) (if (kl:shen.pvar? V3634) (let ((Direction (kl:shen.newpv V3734))) (begin (kl:shen.bindv V3634 (cons (quote stream) (cons Direction (quote ()))) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3562 V3734 (lambda () (kl:cut Throwcontrol V3734 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3734) (cons (quote in) (cons (quote out) (quote ())))) V3734 (lambda () (kl:shen.th* FileName (quote string) V3733 V3734 V3735)))))))))) (begin (kl:shen.unbindv V3634 V3734) Result)))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3640 (kl:shen.lazyderef V3731 V3734))) (if (pair? V3640) (let ((V3641 (kl:shen.lazyderef (car V3640) V3734))) (if (eq? (quote type) V3641) (let ((V3642 (kl:shen.lazyderef (cdr V3640) V3734))) (if (pair? V3642) (let ((X (car V3642))) (let ((V3643 (kl:shen.lazyderef (cdr V3642) V3734))) (if (pair? V3643) (let ((A (car V3643))) (let ((V3644 (kl:shen.lazyderef (cdr V3643) V3734))) (if (null? V3644) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3734 (lambda () (kl:unify A V3732 V3734 (lambda () (kl:shen.th* X A V3733 V3734 V3735)))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3645 (kl:shen.lazyderef V3731 V3734))) (if (pair? V3645) (let ((V3646 (kl:shen.lazyderef (car V3645) V3734))) (if (eq? (quote input+) V3646) (let ((V3647 (kl:shen.lazyderef (cdr V3645) V3734))) (if (pair? V3647) (let ((A (car V3647))) (let ((V3648 (kl:shen.lazyderef (cdr V3647) V3734))) (if (pair? V3648) (let ((Stream (car V3648))) (let ((V3649 (kl:shen.lazyderef (cdr V3648) V3734))) (if (null? V3649) (let ((C (kl:shen.newpv V3734))) (begin (kl:shen.incinfs) (kl:bind C (kl:shen.demodulate (kl:shen.lazyderef A V3734)) V3734 (lambda () (kl:unify V3732 C V3734 (lambda () (kl:shen.th* Stream (cons (quote stream) (cons (quote in) (quote ()))) V3733 V3734 V3735))))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3650 (kl:shen.lazyderef V3731 V3734))) (if (pair? V3650) (let ((V3651 (kl:shen.lazyderef (car V3650) V3734))) (if (eq? (quote set) V3651) (let ((V3652 (kl:shen.lazyderef (cdr V3650) V3734))) (if (pair? V3652) (let ((Var (car V3652))) (let ((V3653 (kl:shen.lazyderef (cdr V3652) V3734))) (if (pair? V3653) (let ((Val (car V3653))) (let ((V3654 (kl:shen.lazyderef (cdr V3653) V3734))) (if (null? V3654) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3734 (lambda () (kl:shen.th* Var (quote symbol) V3733 V3734 (lambda () (kl:cut Throwcontrol V3734 (lambda () (kl:shen.th* (cons (quote value) (cons Var (quote ()))) V3732 V3733 V3734 (lambda () (kl:shen.th* Val V3732 V3733 V3734 V3735)))))))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((NewHyp (kl:shen.newpv V3734))) (begin (kl:shen.incinfs) (kl:shen.t*-hyps V3733 NewHyp V3734 (lambda () (kl:shen.th* V3731 V3732 NewHyp V3734 V3735))))))) (if (kl:= Case #f) (let ((Case (let ((V3655 (kl:shen.lazyderef V3731 V3734))) (if (pair? V3655) (let ((V3656 (kl:shen.lazyderef (car V3655) V3734))) (if (eq? (quote define) V3656) (let ((V3657 (kl:shen.lazyderef (cdr V3655) V3734))) (if (pair? V3657) (let ((F (car V3657))) (let ((X (cdr V3657))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3734 (lambda () (kl:shen.t*-def (cons (quote define) (cons F X)) V3732 V3733 V3734 V3735)))))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3658 (kl:shen.lazyderef V3731 V3734))) (if (pair? V3658) (let ((V3659 (kl:shen.lazyderef (car V3658) V3734))) (if (eq? (quote defmacro) V3659) (let ((V3660 (kl:shen.lazyderef V3732 V3734))) (if (eq? (quote unit) V3660) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3734 V3735)) (if (kl:shen.pvar? V3660) (begin (kl:shen.bindv V3660 (quote unit) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3734 V3735)))) (begin (kl:shen.unbindv V3660 V3734) Result))) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3661 (kl:shen.lazyderef V3731 V3734))) (if (pair? V3661) (let ((V3662 (kl:shen.lazyderef (car V3661) V3734))) (if (eq? (quote shen.process-datatype) V3662) (let ((V3663 (kl:shen.lazyderef V3732 V3734))) (if (eq? (quote symbol) V3663) (begin (kl:shen.incinfs) (kl:thaw V3735)) (if (kl:shen.pvar? V3663) (begin (kl:shen.bindv V3663 (quote symbol) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3735)))) (begin (kl:shen.unbindv V3663 V3734) Result))) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3664 (kl:shen.lazyderef V3731 V3734))) (if (pair? V3664) (let ((V3665 (kl:shen.lazyderef (car V3664) V3734))) (if (eq? (quote shen.synonyms-help) V3665) (let ((V3666 (kl:shen.lazyderef V3732 V3734))) (if (eq? (quote symbol) V3666) (begin (kl:shen.incinfs) (kl:thaw V3735)) (if (kl:shen.pvar? V3666) (begin (kl:shen.bindv V3666 (quote symbol) V3734) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3735)))) (begin (kl:shen.unbindv V3666 V3734) Result))) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((Datatypes (kl:shen.newpv V3734))) (begin (kl:shen.incinfs) (kl:bind Datatypes (kl:value (quote shen.*datatypes*)) V3734 (lambda () (kl:shen.udefs* (cons V3731 (cons (quote :) (cons V3732 (quote ())))) V3733 Datatypes V3734 V3735))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case))))) (quote shen.th*))
(begin (register-function-arity (quote shen.t*-hyps) 4) (define (kl:shen.t*-hyps V3740 V3741 V3742 V3743) (let ((Case (let ((V3477 (kl:shen.lazyderef V3740 V3742))) (if (pair? V3477) (let ((V3478 (kl:shen.lazyderef (car V3477) V3742))) (if (pair? V3478) (let ((V3479 (kl:shen.lazyderef (car V3478) V3742))) (if (pair? V3479) (let ((V3480 (kl:shen.lazyderef (car V3479) V3742))) (if (eq? (quote cons) V3480) (let ((V3481 (kl:shen.lazyderef (cdr V3479) V3742))) (if (pair? V3481) (let ((X (car V3481))) (let ((V3482 (kl:shen.lazyderef (cdr V3481) V3742))) (if (pair? V3482) (let ((Y (car V3482))) (let ((V3483 (kl:shen.lazyderef (cdr V3482) V3742))) (if (null? V3483) (let ((V3484 (kl:shen.lazyderef (cdr V3478) V3742))) (if (pair? V3484) (let ((V3485 (kl:shen.lazyderef (car V3484) V3742))) (if (eq? (quote :) V3485) (let ((V3486 (kl:shen.lazyderef (cdr V3484) V3742))) (if (pair? V3486) (let ((V3487 (kl:shen.lazyderef (car V3486) V3742))) (if (pair? V3487) (let ((V3488 (kl:shen.lazyderef (car V3487) V3742))) (if (eq? (quote list) V3488) (let ((V3489 (kl:shen.lazyderef (cdr V3487) V3742))) (if (pair? V3489) (let ((A (car V3489))) (let ((V3490 (kl:shen.lazyderef (cdr V3489) V3742))) (if (null? V3490) (let ((V3491 (kl:shen.lazyderef (cdr V3486) V3742))) (if (null? V3491) (let ((Hyp (cdr V3477))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3491) (begin (kl:shen.bindv V3491 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3477))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3491 V3742) Result))) #f))) (if (kl:shen.pvar? V3490) (begin (kl:shen.bindv V3490 (quote ()) V3742) (let ((Result (let ((V3492 (kl:shen.lazyderef (cdr V3486) V3742))) (if (null? V3492) (let ((Hyp (cdr V3477))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3492) (begin (kl:shen.bindv V3492 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3477))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3492 V3742) Result))) #f))))) (begin (kl:shen.unbindv V3490 V3742) Result))) #f)))) (if (kl:shen.pvar? V3489) (let ((A (kl:shen.newpv V3742))) (begin (kl:shen.bindv V3489 (cons A (quote ())) V3742) (let ((Result (let ((V3493 (kl:shen.lazyderef (cdr V3486) V3742))) (if (null? V3493) (let ((Hyp (cdr V3477))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3493) (begin (kl:shen.bindv V3493 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3477))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3493 V3742) Result))) #f))))) (begin (kl:shen.unbindv V3489 V3742) Result)))) #f))) (if (kl:shen.pvar? V3488) (begin (kl:shen.bindv V3488 (quote list) V3742) (let ((Result (let ((V3494 (kl:shen.lazyderef (cdr V3487) V3742))) (if (pair? V3494) (let ((A (car V3494))) (let ((V3495 (kl:shen.lazyderef (cdr V3494) V3742))) (if (null? V3495) (let ((V3496 (kl:shen.lazyderef (cdr V3486) V3742))) (if (null? V3496) (let ((Hyp (cdr V3477))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3496) (begin (kl:shen.bindv V3496 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3477))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3496 V3742) Result))) #f))) (if (kl:shen.pvar? V3495) (begin (kl:shen.bindv V3495 (quote ()) V3742) (let ((Result (let ((V3497 (kl:shen.lazyderef (cdr V3486) V3742))) (if (null? V3497) (let ((Hyp (cdr V3477))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3497) (begin (kl:shen.bindv V3497 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3477))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3497 V3742) Result))) #f))))) (begin (kl:shen.unbindv V3495 V3742) Result))) #f)))) (if (kl:shen.pvar? V3494) (let ((A (kl:shen.newpv V3742))) (begin (kl:shen.bindv V3494 (cons A (quote ())) V3742) (let ((Result (let ((V3498 (kl:shen.lazyderef (cdr V3486) V3742))) (if (null? V3498) (let ((Hyp (cdr V3477))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3498) (begin (kl:shen.bindv V3498 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3477))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3498 V3742) Result))) #f))))) (begin (kl:shen.unbindv V3494 V3742) Result)))) #f))))) (begin (kl:shen.unbindv V3488 V3742) Result))) #f))) (if (kl:shen.pvar? V3487) (let ((A (kl:shen.newpv V3742))) (begin (kl:shen.bindv V3487 (cons (quote list) (cons A (quote ()))) V3742) (let ((Result (let ((V3499 (kl:shen.lazyderef (cdr V3486) V3742))) (if (null? V3499) (let ((Hyp (cdr V3477))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3499) (begin (kl:shen.bindv V3499 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3477))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3499 V3742) Result))) #f))))) (begin (kl:shen.unbindv V3487 V3742) Result)))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3500 (kl:shen.lazyderef V3740 V3742))) (if (pair? V3500) (let ((V3501 (kl:shen.lazyderef (car V3500) V3742))) (if (pair? V3501) (let ((V3502 (kl:shen.lazyderef (car V3501) V3742))) (if (pair? V3502) (let ((V3503 (kl:shen.lazyderef (car V3502) V3742))) (if (eq? (quote _waspvm_at_p) V3503) (let ((V3504 (kl:shen.lazyderef (cdr V3502) V3742))) (if (pair? V3504) (let ((X (car V3504))) (let ((V3505 (kl:shen.lazyderef (cdr V3504) V3742))) (if (pair? V3505) (let ((Y (car V3505))) (let ((V3506 (kl:shen.lazyderef (cdr V3505) V3742))) (if (null? V3506) (let ((V3507 (kl:shen.lazyderef (cdr V3501) V3742))) (if (pair? V3507) (let ((V3508 (kl:shen.lazyderef (car V3507) V3742))) (if (eq? (quote :) V3508) (let ((V3509 (kl:shen.lazyderef (cdr V3507) V3742))) (if (pair? V3509) (let ((V3510 (kl:shen.lazyderef (car V3509) V3742))) (if (pair? V3510) (let ((A (car V3510))) (let ((V3511 (kl:shen.lazyderef (cdr V3510) V3742))) (if (pair? V3511) (let ((V3512 (kl:shen.lazyderef (car V3511) V3742))) (if (eq? (quote *) V3512) (let ((V3513 (kl:shen.lazyderef (cdr V3511) V3742))) (if (pair? V3513) (let ((B (car V3513))) (let ((V3514 (kl:shen.lazyderef (cdr V3513) V3742))) (if (null? V3514) (let ((V3515 (kl:shen.lazyderef (cdr V3509) V3742))) (if (null? V3515) (let ((Hyp (cdr V3500))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (kl:shen.lazyderef B V3742) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3515) (begin (kl:shen.bindv V3515 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3500))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (kl:shen.lazyderef B V3742) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3515 V3742) Result))) #f))) (if (kl:shen.pvar? V3514) (begin (kl:shen.bindv V3514 (quote ()) V3742) (let ((Result (let ((V3516 (kl:shen.lazyderef (cdr V3509) V3742))) (if (null? V3516) (let ((Hyp (cdr V3500))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (kl:shen.lazyderef B V3742) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3516) (begin (kl:shen.bindv V3516 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3500))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (kl:shen.lazyderef B V3742) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3516 V3742) Result))) #f))))) (begin (kl:shen.unbindv V3514 V3742) Result))) #f)))) (if (kl:shen.pvar? V3513) (let ((B (kl:shen.newpv V3742))) (begin (kl:shen.bindv V3513 (cons B (quote ())) V3742) (let ((Result (let ((V3517 (kl:shen.lazyderef (cdr V3509) V3742))) (if (null? V3517) (let ((Hyp (cdr V3500))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (kl:shen.lazyderef B V3742) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3517) (begin (kl:shen.bindv V3517 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3500))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (kl:shen.lazyderef B V3742) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3517 V3742) Result))) #f))))) (begin (kl:shen.unbindv V3513 V3742) Result)))) #f))) (if (kl:shen.pvar? V3512) (begin (kl:shen.bindv V3512 (quote *) V3742) (let ((Result (let ((V3518 (kl:shen.lazyderef (cdr V3511) V3742))) (if (pair? V3518) (let ((B (car V3518))) (let ((V3519 (kl:shen.lazyderef (cdr V3518) V3742))) (if (null? V3519) (let ((V3520 (kl:shen.lazyderef (cdr V3509) V3742))) (if (null? V3520) (let ((Hyp (cdr V3500))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (kl:shen.lazyderef B V3742) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3520) (begin (kl:shen.bindv V3520 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3500))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (kl:shen.lazyderef B V3742) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3520 V3742) Result))) #f))) (if (kl:shen.pvar? V3519) (begin (kl:shen.bindv V3519 (quote ()) V3742) (let ((Result (let ((V3521 (kl:shen.lazyderef (cdr V3509) V3742))) (if (null? V3521) (let ((Hyp (cdr V3500))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (kl:shen.lazyderef B V3742) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3521) (begin (kl:shen.bindv V3521 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3500))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (kl:shen.lazyderef B V3742) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3521 V3742) Result))) #f))))) (begin (kl:shen.unbindv V3519 V3742) Result))) #f)))) (if (kl:shen.pvar? V3518) (let ((B (kl:shen.newpv V3742))) (begin (kl:shen.bindv V3518 (cons B (quote ())) V3742) (let ((Result (let ((V3522 (kl:shen.lazyderef (cdr V3509) V3742))) (if (null? V3522) (let ((Hyp (cdr V3500))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (kl:shen.lazyderef B V3742) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3522) (begin (kl:shen.bindv V3522 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3500))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (kl:shen.lazyderef B V3742) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3522 V3742) Result))) #f))))) (begin (kl:shen.unbindv V3518 V3742) Result)))) #f))))) (begin (kl:shen.unbindv V3512 V3742) Result))) #f))) (if (kl:shen.pvar? V3511) (let ((B (kl:shen.newpv V3742))) (begin (kl:shen.bindv V3511 (cons (quote *) (cons B (quote ()))) V3742) (let ((Result (let ((V3523 (kl:shen.lazyderef (cdr V3509) V3742))) (if (null? V3523) (let ((Hyp (cdr V3500))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (kl:shen.lazyderef B V3742) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3523) (begin (kl:shen.bindv V3523 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3500))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (kl:shen.lazyderef B V3742) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3523 V3742) Result))) #f))))) (begin (kl:shen.unbindv V3511 V3742) Result)))) #f)))) (if (kl:shen.pvar? V3510) (let ((A (kl:shen.newpv V3742))) (let ((B (kl:shen.newpv V3742))) (begin (kl:shen.bindv V3510 (cons A (cons (quote *) (cons B (quote ())))) V3742) (let ((Result (let ((V3524 (kl:shen.lazyderef (cdr V3509) V3742))) (if (null? V3524) (let ((Hyp (cdr V3500))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (kl:shen.lazyderef B V3742) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3524) (begin (kl:shen.bindv V3524 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3500))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (kl:shen.lazyderef B V3742) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3524 V3742) Result))) #f))))) (begin (kl:shen.unbindv V3510 V3742) Result))))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3525 (kl:shen.lazyderef V3740 V3742))) (if (pair? V3525) (let ((V3526 (kl:shen.lazyderef (car V3525) V3742))) (if (pair? V3526) (let ((V3527 (kl:shen.lazyderef (car V3526) V3742))) (if (pair? V3527) (let ((V3528 (kl:shen.lazyderef (car V3527) V3742))) (if (eq? (quote _waspvm_at_v) V3528) (let ((V3529 (kl:shen.lazyderef (cdr V3527) V3742))) (if (pair? V3529) (let ((X (car V3529))) (let ((V3530 (kl:shen.lazyderef (cdr V3529) V3742))) (if (pair? V3530) (let ((Y (car V3530))) (let ((V3531 (kl:shen.lazyderef (cdr V3530) V3742))) (if (null? V3531) (let ((V3532 (kl:shen.lazyderef (cdr V3526) V3742))) (if (pair? V3532) (let ((V3533 (kl:shen.lazyderef (car V3532) V3742))) (if (eq? (quote :) V3533) (let ((V3534 (kl:shen.lazyderef (cdr V3532) V3742))) (if (pair? V3534) (let ((V3535 (kl:shen.lazyderef (car V3534) V3742))) (if (pair? V3535) (let ((V3536 (kl:shen.lazyderef (car V3535) V3742))) (if (eq? (quote vector) V3536) (let ((V3537 (kl:shen.lazyderef (cdr V3535) V3742))) (if (pair? V3537) (let ((A (car V3537))) (let ((V3538 (kl:shen.lazyderef (cdr V3537) V3742))) (if (null? V3538) (let ((V3539 (kl:shen.lazyderef (cdr V3534) V3742))) (if (null? V3539) (let ((Hyp (cdr V3525))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3539) (begin (kl:shen.bindv V3539 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3525))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3539 V3742) Result))) #f))) (if (kl:shen.pvar? V3538) (begin (kl:shen.bindv V3538 (quote ()) V3742) (let ((Result (let ((V3540 (kl:shen.lazyderef (cdr V3534) V3742))) (if (null? V3540) (let ((Hyp (cdr V3525))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3540) (begin (kl:shen.bindv V3540 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3525))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3540 V3742) Result))) #f))))) (begin (kl:shen.unbindv V3538 V3742) Result))) #f)))) (if (kl:shen.pvar? V3537) (let ((A (kl:shen.newpv V3742))) (begin (kl:shen.bindv V3537 (cons A (quote ())) V3742) (let ((Result (let ((V3541 (kl:shen.lazyderef (cdr V3534) V3742))) (if (null? V3541) (let ((Hyp (cdr V3525))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3541) (begin (kl:shen.bindv V3541 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3525))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3541 V3742) Result))) #f))))) (begin (kl:shen.unbindv V3537 V3742) Result)))) #f))) (if (kl:shen.pvar? V3536) (begin (kl:shen.bindv V3536 (quote vector) V3742) (let ((Result (let ((V3542 (kl:shen.lazyderef (cdr V3535) V3742))) (if (pair? V3542) (let ((A (car V3542))) (let ((V3543 (kl:shen.lazyderef (cdr V3542) V3742))) (if (null? V3543) (let ((V3544 (kl:shen.lazyderef (cdr V3534) V3742))) (if (null? V3544) (let ((Hyp (cdr V3525))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3544) (begin (kl:shen.bindv V3544 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3525))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3544 V3742) Result))) #f))) (if (kl:shen.pvar? V3543) (begin (kl:shen.bindv V3543 (quote ()) V3742) (let ((Result (let ((V3545 (kl:shen.lazyderef (cdr V3534) V3742))) (if (null? V3545) (let ((Hyp (cdr V3525))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3545) (begin (kl:shen.bindv V3545 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3525))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3545 V3742) Result))) #f))))) (begin (kl:shen.unbindv V3543 V3742) Result))) #f)))) (if (kl:shen.pvar? V3542) (let ((A (kl:shen.newpv V3742))) (begin (kl:shen.bindv V3542 (cons A (quote ())) V3742) (let ((Result (let ((V3546 (kl:shen.lazyderef (cdr V3534) V3742))) (if (null? V3546) (let ((Hyp (cdr V3525))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3546) (begin (kl:shen.bindv V3546 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3525))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3546 V3742) Result))) #f))))) (begin (kl:shen.unbindv V3542 V3742) Result)))) #f))))) (begin (kl:shen.unbindv V3536 V3742) Result))) #f))) (if (kl:shen.pvar? V3535) (let ((A (kl:shen.newpv V3742))) (begin (kl:shen.bindv V3535 (cons (quote vector) (cons A (quote ()))) V3742) (let ((Result (let ((V3547 (kl:shen.lazyderef (cdr V3534) V3742))) (if (null? V3547) (let ((Hyp (cdr V3525))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3547) (begin (kl:shen.bindv V3547 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3525))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (kl:shen.lazyderef A V3742) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3742) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3547 V3742) Result))) #f))))) (begin (kl:shen.unbindv V3535 V3742) Result)))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3548 (kl:shen.lazyderef V3740 V3742))) (if (pair? V3548) (let ((V3549 (kl:shen.lazyderef (car V3548) V3742))) (if (pair? V3549) (let ((V3550 (kl:shen.lazyderef (car V3549) V3742))) (if (pair? V3550) (let ((V3551 (kl:shen.lazyderef (car V3550) V3742))) (if (eq? (quote _waspvm_at_s) V3551) (let ((V3552 (kl:shen.lazyderef (cdr V3550) V3742))) (if (pair? V3552) (let ((X (car V3552))) (let ((V3553 (kl:shen.lazyderef (cdr V3552) V3742))) (if (pair? V3553) (let ((Y (car V3553))) (let ((V3554 (kl:shen.lazyderef (cdr V3553) V3742))) (if (null? V3554) (let ((V3555 (kl:shen.lazyderef (cdr V3549) V3742))) (if (pair? V3555) (let ((V3556 (kl:shen.lazyderef (car V3555) V3742))) (if (eq? (quote :) V3556) (let ((V3557 (kl:shen.lazyderef (cdr V3555) V3742))) (if (pair? V3557) (let ((V3558 (kl:shen.lazyderef (car V3557) V3742))) (if (eq? (quote string) V3558) (let ((V3559 (kl:shen.lazyderef (cdr V3557) V3742))) (if (null? V3559) (let ((Hyp (cdr V3548))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3559) (begin (kl:shen.bindv V3559 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3548))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3559 V3742) Result))) #f))) (if (kl:shen.pvar? V3558) (begin (kl:shen.bindv V3558 (quote string) V3742) (let ((Result (let ((V3560 (kl:shen.lazyderef (cdr V3557) V3742))) (if (null? V3560) (let ((Hyp (cdr V3548))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))) (if (kl:shen.pvar? V3560) (begin (kl:shen.bindv V3560 (quote ()) V3742) (let ((Result (let ((Hyp (cdr V3548))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (cons (kl:shen.lazyderef X V3742) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3742) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V3742))) V3742 V3743))))) (begin (kl:shen.unbindv V3560 V3742) Result))) #f))))) (begin (kl:shen.unbindv V3558 V3742) Result))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((V3561 (kl:shen.lazyderef V3740 V3742))) (if (pair? V3561) (let ((X (car V3561))) (let ((Hyp (cdr V3561))) (let ((NewHyps (kl:shen.newpv V3742))) (begin (kl:shen.incinfs) (kl:bind V3741 (cons (kl:shen.lazyderef X V3742) (kl:shen.lazyderef NewHyps V3742)) V3742 (lambda () (kl:shen.t*-hyps Hyp NewHyps V3742 V3743))))))) #f)) Case)) Case)) Case)) Case))) (quote shen.t*-hyps))
(begin (register-function-arity (quote shen.show) 4) (define (kl:shen.show V3760 V3761 V3762 V3763) (cond ((assert-boolean (kl:value (quote shen.*spy*))) (begin (kl:shen.line) (begin (kl:shen.show-p (kl:shen.deref V3760 V3762)) (begin (kl:nl 1) (begin (kl:nl 1) (begin (kl:shen.show-assumptions (kl:shen.deref V3761 V3762) 1) (begin (kl:shen.prhush "\n> " (kl:stoutput)) (begin (kl:shen.pause-for-user) (kl:thaw V3763))))))))) (#t (kl:thaw V3763)))) (quote shen.show))
(begin (register-function-arity (quote shen.line) 0) (define (kl:shen.line) (let ((Infs (kl:inferences))) (kl:shen.prhush (string-append "____________________________________________________________ " (kl:shen.app Infs (string-append " inference" (kl:shen.app (if (kl:= 1 Infs) "" "s") " \n?- " (quote shen.a))) (quote shen.a))) (kl:stoutput)))) (quote shen.line))
(begin (register-function-arity (quote shen.show-p) 1) (define (kl:shen.show-p V3765) (cond ((and (pair? V3765) (and (pair? (cdr V3765)) (and (eq? (quote :) (car (cdr V3765))) (and (pair? (cdr (cdr V3765))) (null? (cdr (cdr (cdr V3765)))))))) (kl:shen.prhush (kl:shen.app (car V3765) (string-append " : " (kl:shen.app (car (cdr (cdr V3765))) "" (quote shen.r))) (quote shen.r)) (kl:stoutput))) (#t (kl:shen.prhush (kl:shen.app V3765 "" (quote shen.r)) (kl:stoutput))))) (quote shen.show-p))
(begin (register-function-arity (quote shen.show-assumptions) 2) (define (kl:shen.show-assumptions V3770 V3771) (cond ((null? V3770) (quote shen.skip)) ((pair? V3770) (begin (kl:shen.prhush (kl:shen.app V3771 ". " (quote shen.a)) (kl:stoutput)) (begin (kl:shen.show-p (car V3770)) (begin (kl:nl 1) (kl:shen.show-assumptions (cdr V3770) (+ V3771 1)))))) (#t (kl:shen.f_error (quote shen.show-assumptions))))) (quote shen.show-assumptions))
(begin (register-function-arity (quote shen.pause-for-user) 0) (define (kl:shen.pause-for-user) (let ((Byte (read-u8 (kl:stinput)))) (if (kl:= Byte 94) (simple-error "input aborted\n") (kl:nl 1)))) (quote shen.pause-for-user))
(begin (register-function-arity (quote shen.typedf?) 1) (define (kl:shen.typedf? V3773) (pair? (kl:assoc V3773 (kl:value (quote shen.*signedfuncs*))))) (quote shen.typedf?))
(begin (register-function-arity (quote shen.sigf) 1) (define (kl:shen.sigf V3775) (kl:concat (quote shen.type-signature-of-) V3775)) (quote shen.sigf))
(begin (register-function-arity (quote shen.placeholder) 0) (define (kl:shen.placeholder) (kl:gensym (quote &&))) (quote shen.placeholder))
(begin (register-function-arity (quote shen.base) 4) (define (kl:shen.base V3780 V3781 V3782 V3783) (let ((Case (let ((V3464 (kl:shen.lazyderef V3781 V3782))) (if (eq? (quote number) V3464) (begin (kl:shen.incinfs) (kl:fwhen (number? (kl:shen.lazyderef V3780 V3782)) V3782 V3783)) (if (kl:shen.pvar? V3464) (begin (kl:shen.bindv V3464 (quote number) V3782) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (number? (kl:shen.lazyderef V3780 V3782)) V3782 V3783)))) (begin (kl:shen.unbindv V3464 V3782) Result))) #f))))) (if (kl:= Case #f) (let ((Case (let ((V3465 (kl:shen.lazyderef V3781 V3782))) (if (eq? (quote boolean) V3465) (begin (kl:shen.incinfs) (kl:fwhen (kl:boolean? (kl:shen.lazyderef V3780 V3782)) V3782 V3783)) (if (kl:shen.pvar? V3465) (begin (kl:shen.bindv V3465 (quote boolean) V3782) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (kl:boolean? (kl:shen.lazyderef V3780 V3782)) V3782 V3783)))) (begin (kl:shen.unbindv V3465 V3782) Result))) #f))))) (if (kl:= Case #f) (let ((Case (let ((V3466 (kl:shen.lazyderef V3781 V3782))) (if (eq? (quote string) V3466) (begin (kl:shen.incinfs) (kl:fwhen (string? (kl:shen.lazyderef V3780 V3782)) V3782 V3783)) (if (kl:shen.pvar? V3466) (begin (kl:shen.bindv V3466 (quote string) V3782) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (string? (kl:shen.lazyderef V3780 V3782)) V3782 V3783)))) (begin (kl:shen.unbindv V3466 V3782) Result))) #f))))) (if (kl:= Case #f) (let ((Case (let ((V3467 (kl:shen.lazyderef V3781 V3782))) (if (eq? (quote symbol) V3467) (begin (kl:shen.incinfs) (kl:fwhen (kl:symbol? (kl:shen.lazyderef V3780 V3782)) V3782 (lambda () (kl:fwhen (kl:not (kl:shen.ue? (kl:shen.lazyderef V3780 V3782))) V3782 V3783)))) (if (kl:shen.pvar? V3467) (begin (kl:shen.bindv V3467 (quote symbol) V3782) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (kl:symbol? (kl:shen.lazyderef V3780 V3782)) V3782 (lambda () (kl:fwhen (kl:not (kl:shen.ue? (kl:shen.lazyderef V3780 V3782))) V3782 V3783)))))) (begin (kl:shen.unbindv V3467 V3782) Result))) #f))))) (if (kl:= Case #f) (let ((V3468 (kl:shen.lazyderef V3780 V3782))) (if (null? V3468) (let ((V3469 (kl:shen.lazyderef V3781 V3782))) (if (pair? V3469) (let ((V3470 (kl:shen.lazyderef (car V3469) V3782))) (if (eq? (quote list) V3470) (let ((V3471 (kl:shen.lazyderef (cdr V3469) V3782))) (if (pair? V3471) (let ((A (car V3471))) (let ((V3472 (kl:shen.lazyderef (cdr V3471) V3782))) (if (null? V3472) (begin (kl:shen.incinfs) (kl:thaw V3783)) (if (kl:shen.pvar? V3472) (begin (kl:shen.bindv V3472 (quote ()) V3782) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3783)))) (begin (kl:shen.unbindv V3472 V3782) Result))) #f)))) (if (kl:shen.pvar? V3471) (let ((A (kl:shen.newpv V3782))) (begin (kl:shen.bindv V3471 (cons A (quote ())) V3782) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3783)))) (begin (kl:shen.unbindv V3471 V3782) Result)))) #f))) (if (kl:shen.pvar? V3470) (begin (kl:shen.bindv V3470 (quote list) V3782) (let ((Result (let ((V3473 (kl:shen.lazyderef (cdr V3469) V3782))) (if (pair? V3473) (let ((A (car V3473))) (let ((V3474 (kl:shen.lazyderef (cdr V3473) V3782))) (if (null? V3474) (begin (kl:shen.incinfs) (kl:thaw V3783)) (if (kl:shen.pvar? V3474) (begin (kl:shen.bindv V3474 (quote ()) V3782) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3783)))) (begin (kl:shen.unbindv V3474 V3782) Result))) #f)))) (if (kl:shen.pvar? V3473) (let ((A (kl:shen.newpv V3782))) (begin (kl:shen.bindv V3473 (cons A (quote ())) V3782) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3783)))) (begin (kl:shen.unbindv V3473 V3782) Result)))) #f))))) (begin (kl:shen.unbindv V3470 V3782) Result))) #f))) (if (kl:shen.pvar? V3469) (let ((A (kl:shen.newpv V3782))) (begin (kl:shen.bindv V3469 (cons (quote list) (cons A (quote ()))) V3782) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3783)))) (begin (kl:shen.unbindv V3469 V3782) Result)))) #f))) #f)) Case)) Case)) Case)) Case))) (quote shen.base))
(begin (register-function-arity (quote shen.by_hypothesis) 5) (define (kl:shen.by_hypothesis V3789 V3790 V3791 V3792 V3793) (let ((Case (let ((V3455 (kl:shen.lazyderef V3791 V3792))) (if (pair? V3455) (let ((V3456 (kl:shen.lazyderef (car V3455) V3792))) (if (pair? V3456) (let ((Y (car V3456))) (let ((V3457 (kl:shen.lazyderef (cdr V3456) V3792))) (if (pair? V3457) (let ((V3458 (kl:shen.lazyderef (car V3457) V3792))) (if (eq? (quote :) V3458) (let ((V3459 (kl:shen.lazyderef (cdr V3457) V3792))) (if (pair? V3459) (let ((B (car V3459))) (let ((V3460 (kl:shen.lazyderef (cdr V3459) V3792))) (if (null? V3460) (begin (kl:shen.incinfs) (kl:identical V3789 Y V3792 (lambda () (kl:unify! V3790 B V3792 V3793)))) #f))) #f)) #f)) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((V3461 (kl:shen.lazyderef V3791 V3792))) (if (pair? V3461) (let ((Hyp (cdr V3461))) (begin (kl:shen.incinfs) (kl:shen.by_hypothesis V3789 V3790 Hyp V3792 V3793))) #f)) Case))) (quote shen.by_hypothesis))
(begin (register-function-arity (quote shen.t*-def) 5) (define (kl:shen.t*-def V3799 V3800 V3801 V3802 V3803) (let ((V3449 (kl:shen.lazyderef V3799 V3802))) (if (pair? V3449) (let ((V3450 (kl:shen.lazyderef (car V3449) V3802))) (if (eq? (quote define) V3450) (let ((V3451 (kl:shen.lazyderef (cdr V3449) V3802))) (if (pair? V3451) (let ((F (car V3451))) (let ((X (cdr V3451))) (let ((Y (kl:shen.newpv V3802))) (let ((E (kl:shen.newpv V3802))) (begin (kl:shen.incinfs) (kl:shen.t*-defh (kl:compile (lambda (Y) (kl:shen.<sig+rules> Y)) X (lambda (E) (if (pair? E) (simple-error (string-append "parse error here: " (kl:shen.app E "\n" (quote shen.s)))) (simple-error "parse error\n")))) F V3800 V3801 V3802 V3803)))))) #f)) #f)) #f))) (quote shen.t*-def))
(begin (register-function-arity (quote shen.t*-defh) 6) (define (kl:shen.t*-defh V3810 V3811 V3812 V3813 V3814 V3815) (let ((V3445 (kl:shen.lazyderef V3810 V3814))) (if (pair? V3445) (let ((Sig (car V3445))) (let ((Rules (cdr V3445))) (begin (kl:shen.incinfs) (kl:shen.t*-defhh Sig (kl:shen.ue-sig Sig) V3811 V3812 V3813 Rules V3814 V3815)))) #f))) (quote shen.t*-defh))
(begin (register-function-arity (quote shen.t*-defhh) 8) (define (kl:shen.t*-defhh V3824 V3825 V3826 V3827 V3828 V3829 V3830 V3831) (begin (kl:shen.incinfs) (kl:shen.t*-rules V3829 V3825 1 V3826 (cons (cons V3826 (cons (quote :) (cons V3825 (quote ())))) V3828) V3830 (lambda () (kl:shen.memo V3826 V3824 V3827 V3830 V3831))))) (quote shen.t*-defhh))
(begin (register-function-arity (quote shen.memo) 5) (define (kl:shen.memo V3837 V3838 V3839 V3840 V3841) (let ((Jnk (kl:shen.newpv V3840))) (begin (kl:shen.incinfs) (kl:unify! V3839 V3838 V3840 (lambda () (kl:bind Jnk (kl:declare (kl:shen.lazyderef V3837 V3840) (kl:shen.lazyderef V3839 V3840)) V3840 V3841)))))) (quote shen.memo))
(begin (register-function-arity (quote shen.<sig+rules>) 1) (define (kl:shen.<sig+rules> V3843) (let ((Parse_shen.<signature> (kl:shen.<signature> V3843))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature>)) (let ((Parse_shen.<non-ll-rules> (kl:shen.<non-ll-rules> Parse_shen.<signature>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<non-ll-rules>)) (kl:shen.pair (car Parse_shen.<non-ll-rules>) (cons (kl:shen.hdtl Parse_shen.<signature>) (kl:shen.hdtl Parse_shen.<non-ll-rules>))) (kl:fail))) (kl:fail)))) (quote shen.<sig+rules>))
(begin (register-function-arity (quote shen.<non-ll-rules>) 1) (define (kl:shen.<non-ll-rules> V3845) (let ((YaccParse (let ((Parse_shen.<rule> (kl:shen.<rule> V3845))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (let ((Parse_shen.<non-ll-rules> (kl:shen.<non-ll-rules> Parse_shen.<rule>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<non-ll-rules>)) (kl:shen.pair (car Parse_shen.<non-ll-rules>) (cons (kl:shen.hdtl Parse_shen.<rule>) (kl:shen.hdtl Parse_shen.<non-ll-rules>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<rule> (kl:shen.<rule> V3845))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (kl:shen.pair (car Parse_shen.<rule>) (cons (kl:shen.hdtl Parse_shen.<rule>) (quote ()))) (kl:fail))) YaccParse))) (quote shen.<non-ll-rules>))
(begin (register-function-arity (quote shen.ue) 1) (define (kl:shen.ue V3847) (cond ((and (pair? V3847) (and (pair? (cdr V3847)) (and (null? (cdr (cdr V3847))) (eq? (car V3847) (quote protect))))) V3847) ((pair? V3847) (kl:map (lambda (Z) (kl:shen.ue Z)) V3847)) ((kl:variable? V3847) (kl:concat (quote &&) V3847)) (#t V3847))) (quote shen.ue))
(begin (register-function-arity (quote shen.ue-sig) 1) (define (kl:shen.ue-sig V3849) (cond ((pair? V3849) (kl:map (lambda (Z) (kl:shen.ue-sig Z)) V3849)) ((kl:variable? V3849) (kl:concat (quote &&&) V3849)) (#t V3849))) (quote shen.ue-sig))
(begin (register-function-arity (quote shen.ues) 1) (define (kl:shen.ues V3855) (cond ((assert-boolean (kl:shen.ue? V3855)) (cons V3855 (quote ()))) ((pair? V3855) (kl:union (kl:shen.ues (car V3855)) (kl:shen.ues (cdr V3855)))) (#t (quote ())))) (quote shen.ues))
(begin (register-function-arity (quote shen.ue?) 1) (define (kl:shen.ue? V3857) (and (kl:symbol? V3857) (assert-boolean (kl:shen.ue-h? (kl:str V3857))))) (quote shen.ue?))
(begin (register-function-arity (quote shen.ue-h?) 1) (define (kl:shen.ue-h? V3865) (cond ((and (assert-boolean (kl:shen.+string? V3865)) (and (equal? "&" (make-string 1 (string-ref V3865 0))) (and (assert-boolean (kl:shen.+string? (string-tail V3865 1))) (equal? "&" (make-string 1 (string-ref (string-tail V3865 1) 0)))))) #t) (#t #f))) (quote shen.ue-h?))
(begin (register-function-arity (quote shen.t*-rules) 7) (define (kl:shen.t*-rules V3873 V3874 V3875 V3876 V3877 V3878 V3879) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (let ((V3429 (kl:shen.lazyderef V3873 V3878))) (if (null? V3429) (begin (kl:shen.incinfs) (kl:thaw V3879)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3430 (kl:shen.lazyderef V3873 V3878))) (if (pair? V3430) (let ((Rule (car V3430))) (let ((Rules (cdr V3430))) (begin (kl:shen.incinfs) (kl:shen.t*-rule (kl:shen.ue Rule) V3874 V3877 V3878 (lambda () (kl:cut Throwcontrol V3878 (lambda () (kl:shen.t*-rules Rules V3874 (+ V3875 1) V3876 V3877 V3878 V3879)))))))) #f)))) (if (kl:= Case #f) (let ((Err (kl:shen.newpv V3878))) (begin (kl:shen.incinfs) (kl:bind Err (simple-error (string-append "type error in rule " (kl:shen.app (kl:shen.lazyderef V3875 V3878) (string-append " of " (kl:shen.app (kl:shen.lazyderef V3876 V3878) "" (quote shen.a))) (quote shen.a)))) V3878 V3879))) Case)) Case))))) (quote shen.t*-rules))
(begin (register-function-arity (quote shen.t*-rule) 5) (define (kl:shen.t*-rule V3885 V3886 V3887 V3888 V3889) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((V3421 (kl:shen.lazyderef V3885 V3888))) (if (pair? V3421) (let ((Patterns (car V3421))) (let ((V3422 (kl:shen.lazyderef (cdr V3421) V3888))) (if (pair? V3422) (let ((Action (car V3422))) (let ((V3423 (kl:shen.lazyderef (cdr V3422) V3888))) (if (null? V3423) (let ((NewHyps (kl:shen.newpv V3888))) (begin (kl:shen.incinfs) (kl:shen.newhyps (kl:shen.placeholders Patterns) V3887 NewHyps V3888 (lambda () (kl:shen.t*-patterns Patterns V3886 NewHyps V3888 (lambda () (kl:cut Throwcontrol V3888 (lambda () (kl:shen.t*-action (kl:shen.curry (kl:shen.ue Action)) (kl:shen.result-type Patterns V3886) (kl:shen.patthyps Patterns V3886 V3887) V3888 V3889))))))))) #f))) #f))) #f))))) (quote shen.t*-rule))
(begin (register-function-arity (quote shen.placeholders) 1) (define (kl:shen.placeholders V3895) (cond ((assert-boolean (kl:shen.ue? V3895)) (cons V3895 (quote ()))) ((pair? V3895) (kl:union (kl:shen.placeholders (car V3895)) (kl:shen.placeholders (cdr V3895)))) (#t (quote ())))) (quote shen.placeholders))
(begin (register-function-arity (quote shen.newhyps) 5) (define (kl:shen.newhyps V3901 V3902 V3903 V3904 V3905) (let ((Case (let ((V3408 (kl:shen.lazyderef V3901 V3904))) (if (null? V3408) (begin (kl:shen.incinfs) (kl:unify! V3903 V3902 V3904 V3905)) #f)))) (if (kl:= Case #f) (let ((V3409 (kl:shen.lazyderef V3901 V3904))) (if (pair? V3409) (let ((V3404 (car V3409))) (let ((Vs (cdr V3409))) (let ((V3410 (kl:shen.lazyderef V3903 V3904))) (if (pair? V3410) (let ((V3411 (kl:shen.lazyderef (car V3410) V3904))) (if (pair? V3411) (let ((V (car V3411))) (let ((V3412 (kl:shen.lazyderef (cdr V3411) V3904))) (if (pair? V3412) (let ((V3413 (kl:shen.lazyderef (car V3412) V3904))) (if (eq? (quote :) V3413) (let ((V3414 (kl:shen.lazyderef (cdr V3412) V3904))) (if (pair? V3414) (let ((A (car V3414))) (let ((V3415 (kl:shen.lazyderef (cdr V3414) V3904))) (if (null? V3415) (let ((NewHyp (cdr V3410))) (begin (kl:shen.incinfs) (kl:unify! V V3404 V3904 (lambda () (kl:shen.newhyps Vs V3902 NewHyp V3904 V3905))))) (if (kl:shen.pvar? V3415) (begin (kl:shen.bindv V3415 (quote ()) V3904) (let ((Result (let ((NewHyp (cdr V3410))) (begin (kl:shen.incinfs) (kl:unify! V V3404 V3904 (lambda () (kl:shen.newhyps Vs V3902 NewHyp V3904 V3905))))))) (begin (kl:shen.unbindv V3415 V3904) Result))) #f)))) (if (kl:shen.pvar? V3414) (let ((A (kl:shen.newpv V3904))) (begin (kl:shen.bindv V3414 (cons A (quote ())) V3904) (let ((Result (let ((NewHyp (cdr V3410))) (begin (kl:shen.incinfs) (kl:unify! V V3404 V3904 (lambda () (kl:shen.newhyps Vs V3902 NewHyp V3904 V3905))))))) (begin (kl:shen.unbindv V3414 V3904) Result)))) #f))) (if (kl:shen.pvar? V3413) (begin (kl:shen.bindv V3413 (quote :) V3904) (let ((Result (let ((V3416 (kl:shen.lazyderef (cdr V3412) V3904))) (if (pair? V3416) (let ((A (car V3416))) (let ((V3417 (kl:shen.lazyderef (cdr V3416) V3904))) (if (null? V3417) (let ((NewHyp (cdr V3410))) (begin (kl:shen.incinfs) (kl:unify! V V3404 V3904 (lambda () (kl:shen.newhyps Vs V3902 NewHyp V3904 V3905))))) (if (kl:shen.pvar? V3417) (begin (kl:shen.bindv V3417 (quote ()) V3904) (let ((Result (let ((NewHyp (cdr V3410))) (begin (kl:shen.incinfs) (kl:unify! V V3404 V3904 (lambda () (kl:shen.newhyps Vs V3902 NewHyp V3904 V3905))))))) (begin (kl:shen.unbindv V3417 V3904) Result))) #f)))) (if (kl:shen.pvar? V3416) (let ((A (kl:shen.newpv V3904))) (begin (kl:shen.bindv V3416 (cons A (quote ())) V3904) (let ((Result (let ((NewHyp (cdr V3410))) (begin (kl:shen.incinfs) (kl:unify! V V3404 V3904 (lambda () (kl:shen.newhyps Vs V3902 NewHyp V3904 V3905))))))) (begin (kl:shen.unbindv V3416 V3904) Result)))) #f))))) (begin (kl:shen.unbindv V3413 V3904) Result))) #f))) (if (kl:shen.pvar? V3412) (let ((A (kl:shen.newpv V3904))) (begin (kl:shen.bindv V3412 (cons (quote :) (cons A (quote ()))) V3904) (let ((Result (let ((NewHyp (cdr V3410))) (begin (kl:shen.incinfs) (kl:unify! V V3404 V3904 (lambda () (kl:shen.newhyps Vs V3902 NewHyp V3904 V3905))))))) (begin (kl:shen.unbindv V3412 V3904) Result)))) #f)))) (if (kl:shen.pvar? V3411) (let ((V (kl:shen.newpv V3904))) (let ((A (kl:shen.newpv V3904))) (begin (kl:shen.bindv V3411 (cons V (cons (quote :) (cons A (quote ())))) V3904) (let ((Result (let ((NewHyp (cdr V3410))) (begin (kl:shen.incinfs) (kl:unify! V V3404 V3904 (lambda () (kl:shen.newhyps Vs V3902 NewHyp V3904 V3905))))))) (begin (kl:shen.unbindv V3411 V3904) Result))))) #f))) (if (kl:shen.pvar? V3410) (let ((V (kl:shen.newpv V3904))) (let ((A (kl:shen.newpv V3904))) (let ((NewHyp (kl:shen.newpv V3904))) (begin (kl:shen.bindv V3410 (cons (cons V (cons (quote :) (cons A (quote ())))) NewHyp) V3904) (let ((Result (begin (kl:shen.incinfs) (kl:unify! V V3404 V3904 (lambda () (kl:shen.newhyps Vs V3902 NewHyp V3904 V3905)))))) (begin (kl:shen.unbindv V3410 V3904) Result)))))) #f))))) #f)) Case))) (quote shen.newhyps))
(begin (register-function-arity (quote shen.patthyps) 3) (define (kl:shen.patthyps V3911 V3912 V3913) (cond ((null? V3911) V3913) ((and (pair? V3911) (and (pair? V3912) (and (pair? (cdr V3912)) (and (eq? (quote -->) (car (cdr V3912))) (and (pair? (cdr (cdr V3912))) (null? (cdr (cdr (cdr V3912))))))))) (kl:adjoin (cons (car V3911) (cons (quote :) (cons (car V3912) (quote ())))) (kl:shen.patthyps (cdr V3911) (car (cdr (cdr V3912))) V3913))) (#t (kl:shen.f_error (quote shen.patthyps))))) (quote shen.patthyps))
(begin (register-function-arity (quote shen.result-type) 2) (define (kl:shen.result-type V3920 V3921) (cond ((and (null? V3920) (and (pair? V3921) (and (eq? (quote -->) (car V3921)) (and (pair? (cdr V3921)) (null? (cdr (cdr V3921))))))) (car (cdr V3921))) ((null? V3920) V3921) ((and (pair? V3920) (and (pair? V3921) (and (pair? (cdr V3921)) (and (eq? (quote -->) (car (cdr V3921))) (and (pair? (cdr (cdr V3921))) (null? (cdr (cdr (cdr V3921))))))))) (kl:shen.result-type (cdr V3920) (car (cdr (cdr V3921))))) (#t (kl:shen.f_error (quote shen.result-type))))) (quote shen.result-type))
(begin (register-function-arity (quote shen.t*-patterns) 5) (define (kl:shen.t*-patterns V3927 V3928 V3929 V3930 V3931) (let ((Case (let ((V3396 (kl:shen.lazyderef V3927 V3930))) (if (null? V3396) (begin (kl:shen.incinfs) (kl:thaw V3931)) #f)))) (if (kl:= Case #f) (let ((V3397 (kl:shen.lazyderef V3927 V3930))) (if (pair? V3397) (let ((Pattern (car V3397))) (let ((Patterns (cdr V3397))) (let ((V3398 (kl:shen.lazyderef V3928 V3930))) (if (pair? V3398) (let ((A (car V3398))) (let ((V3399 (kl:shen.lazyderef (cdr V3398) V3930))) (if (pair? V3399) (let ((V3400 (kl:shen.lazyderef (car V3399) V3930))) (if (eq? (quote -->) V3400) (let ((V3401 (kl:shen.lazyderef (cdr V3399) V3930))) (if (pair? V3401) (let ((B (car V3401))) (let ((V3402 (kl:shen.lazyderef (cdr V3401) V3930))) (if (null? V3402) (begin (kl:shen.incinfs) (kl:shen.t* (cons Pattern (cons (quote :) (cons A (quote ())))) V3929 V3930 (lambda () (kl:shen.t*-patterns Patterns B V3929 V3930 V3931)))) #f))) #f)) #f)) #f))) #f)))) #f)) Case))) (quote shen.t*-patterns))
(begin (register-function-arity (quote shen.t*-action) 5) (define (kl:shen.t*-action V3937 V3938 V3939 V3940 V3941) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (let ((V3373 (kl:shen.lazyderef V3937 V3940))) (if (pair? V3373) (let ((V3374 (kl:shen.lazyderef (car V3373) V3940))) (if (eq? (quote where) V3374) (let ((V3375 (kl:shen.lazyderef (cdr V3373) V3940))) (if (pair? V3375) (let ((P (car V3375))) (let ((V3376 (kl:shen.lazyderef (cdr V3375) V3940))) (if (pair? V3376) (let ((Action (car V3376))) (let ((V3377 (kl:shen.lazyderef (cdr V3376) V3940))) (if (null? V3377) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3940 (lambda () (kl:shen.t* (cons P (cons (quote :) (cons (quote boolean) (quote ())))) V3939 V3940 (lambda () (kl:cut Throwcontrol V3940 (lambda () (kl:shen.t*-action Action V3938 (cons (cons P (cons (quote :) (cons (quote verified) (quote ())))) V3939) V3940 V3941)))))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3378 (kl:shen.lazyderef V3937 V3940))) (if (pair? V3378) (let ((V3379 (kl:shen.lazyderef (car V3378) V3940))) (if (eq? (quote shen.choicepoint!) V3379) (let ((V3380 (kl:shen.lazyderef (cdr V3378) V3940))) (if (pair? V3380) (let ((V3381 (kl:shen.lazyderef (car V3380) V3940))) (if (pair? V3381) (let ((V3382 (kl:shen.lazyderef (car V3381) V3940))) (if (pair? V3382) (let ((V3383 (kl:shen.lazyderef (car V3382) V3940))) (if (eq? (quote fail-if) V3383) (let ((V3384 (kl:shen.lazyderef (cdr V3382) V3940))) (if (pair? V3384) (let ((F (car V3384))) (let ((V3385 (kl:shen.lazyderef (cdr V3384) V3940))) (if (null? V3385) (let ((V3386 (kl:shen.lazyderef (cdr V3381) V3940))) (if (pair? V3386) (let ((Action (car V3386))) (let ((V3387 (kl:shen.lazyderef (cdr V3386) V3940))) (if (null? V3387) (let ((V3388 (kl:shen.lazyderef (cdr V3380) V3940))) (if (null? V3388) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3940 (lambda () (kl:shen.t*-action (cons (quote where) (cons (cons (quote not) (cons (cons F (cons Action (quote ()))) (quote ()))) (cons Action (quote ())))) V3938 V3939 V3940 V3941)))) #f)) #f))) #f)) #f))) #f)) #f)) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3389 (kl:shen.lazyderef V3937 V3940))) (if (pair? V3389) (let ((V3390 (kl:shen.lazyderef (car V3389) V3940))) (if (eq? (quote shen.choicepoint!) V3390) (let ((V3391 (kl:shen.lazyderef (cdr V3389) V3940))) (if (pair? V3391) (let ((Action (car V3391))) (let ((V3392 (kl:shen.lazyderef (cdr V3391) V3940))) (if (null? V3392) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3940 (lambda () (kl:shen.t*-action (cons (quote where) (cons (cons (quote not) (cons (cons (cons (quote =) (cons Action (quote ()))) (cons (cons (quote fail) (quote ())) (quote ()))) (quote ()))) (cons Action (quote ())))) V3938 V3939 V3940 V3941)))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (begin (kl:shen.incinfs) (kl:shen.t* (cons V3937 (cons (quote :) (cons V3938 (quote ())))) V3939 V3940 V3941)) Case)) Case)) Case))))) (quote shen.t*-action))
(begin (register-function-arity (quote findall) 5) (define (kl:findall V3947 V3948 V3949 V3950 V3951) (let ((B (kl:shen.newpv V3950))) (let ((A (kl:shen.newpv V3950))) (begin (kl:shen.incinfs) (kl:bind A (kl:gensym (quote shen.a)) V3950 (lambda () (kl:bind B (kl:set (kl:shen.lazyderef A V3950) (quote ())) V3950 (lambda () (kl:shen.findallhelp V3947 V3948 V3949 A V3950 V3951))))))))) (quote findall))
(begin (register-function-arity (quote shen.findallhelp) 6) (define (kl:shen.findallhelp V3958 V3959 V3960 V3961 V3962 V3963) (let ((Case (begin (kl:shen.incinfs) (kl:call V3959 V3962 (lambda () (kl:shen.remember V3961 V3958 V3962 (lambda () (kl:fwhen #f V3962 V3963)))))))) (if (kl:= Case #f) (begin (kl:shen.incinfs) (kl:bind V3960 (kl:value (kl:shen.lazyderef V3961 V3962)) V3962 V3963)) Case))) (quote shen.findallhelp))
(begin (register-function-arity (quote shen.remember) 4) (define (kl:shen.remember V3968 V3969 V3970 V3971) (let ((B (kl:shen.newpv V3970))) (begin (kl:shen.incinfs) (kl:bind B (kl:set (kl:shen.deref V3968 V3970) (cons (kl:shen.deref V3969 V3970) (kl:value (kl:shen.deref V3968 V3970)))) V3970 V3971)))) (quote shen.remember))
