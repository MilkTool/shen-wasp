"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.typecheck) 2) (define (kl:shen.typecheck V3488 V3489) (let ((Curry (kl:shen.curry V3488))) (let ((ProcessN (kl:shen.start-new-prolog-process))) (let ((Type (kl:shen.insert-prolog-variables (kl:shen.demodulate (kl:shen.curry-type V3489)) ProcessN))) (let ((Continuation (lambda () (kl:return Type ProcessN (quote shen.void))))) (kl:shen.t* (cons Curry (cons (quote :) (cons Type (quote ())))) (quote ()) ProcessN Continuation)))))) (quote shen.typecheck))
(begin (register-function-arity (quote shen.curry) 1) (define (kl:shen.curry V3491) (cond ((and (pair? V3491) (assert-boolean (kl:shen.special? (car V3491)))) (cons (car V3491) (kl:map (lambda (Y) (kl:shen.curry Y)) (cdr V3491)))) ((and (pair? V3491) (and (pair? (cdr V3491)) (assert-boolean (kl:shen.extraspecial? (car V3491))))) V3491) ((and (pair? V3491) (and (eq? (quote type) (car V3491)) (and (pair? (cdr V3491)) (and (pair? (cdr (cdr V3491))) (null? (cdr (cdr (cdr V3491)))))))) (cons (quote type) (cons (kl:shen.curry (car (cdr V3491))) (cdr (cdr V3491))))) ((and (pair? V3491) (and (pair? (cdr V3491)) (pair? (cdr (cdr V3491))))) (kl:shen.curry (cons (cons (car V3491) (cons (car (cdr V3491)) (quote ()))) (cdr (cdr V3491))))) ((and (pair? V3491) (and (pair? (cdr V3491)) (null? (cdr (cdr V3491))))) (cons (kl:shen.curry (car V3491)) (cons (kl:shen.curry (car (cdr V3491))) (quote ())))) (#t V3491))) (quote shen.curry))
(begin (register-function-arity (quote shen.special?) 1) (define (kl:shen.special? V3493) (kl:element? V3493 (kl:value (quote shen.*special*)))) (quote shen.special?))
(begin (register-function-arity (quote shen.extraspecial?) 1) (define (kl:shen.extraspecial? V3495) (kl:element? V3495 (kl:value (quote shen.*extraspecial*)))) (quote shen.extraspecial?))
(begin (register-function-arity (quote shen.t*) 4) (define (kl:shen.t* V3500 V3501 V3502 V3503) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (let ((Error (kl:shen.newpv V3502))) (begin (kl:shen.incinfs) (kl:fwhen (kl:shen.maxinfexceeded?) V3502 (lambda () (kl:bind Error (kl:shen.errormaxinfs) V3502 V3503))))))) (if (kl:= Case #f) (let ((Case (let ((V3480 (kl:shen.lazyderef V3500 V3502))) (if (eq? (quote fail) V3480) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3502 (lambda () (kl:shen.prolog-failure V3502 V3503)))) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3481 (kl:shen.lazyderef V3500 V3502))) (if (pair? V3481) (let ((X (car V3481))) (let ((V3482 (kl:shen.lazyderef (cdr V3481) V3502))) (if (pair? V3482) (let ((V3483 (kl:shen.lazyderef (car V3482) V3502))) (if (eq? (quote :) V3483) (let ((V3484 (kl:shen.lazyderef (cdr V3482) V3502))) (if (pair? V3484) (let ((A (car V3484))) (let ((V3485 (kl:shen.lazyderef (cdr V3484) V3502))) (if (null? V3485) (begin (kl:shen.incinfs) (kl:fwhen (kl:shen.type-theory-enabled?) V3502 (lambda () (kl:cut Throwcontrol V3502 (lambda () (kl:shen.th* X A V3501 V3502 V3503)))))) #f))) #f)) #f)) #f))) #f)))) (if (kl:= Case #f) (let ((Datatypes (kl:shen.newpv V3502))) (begin (kl:shen.incinfs) (kl:shen.show V3500 V3501 V3502 (lambda () (kl:bind Datatypes (kl:value (quote shen.*datatypes*)) V3502 (lambda () (kl:shen.udefs* V3500 V3501 Datatypes V3502 V3503))))))) Case)) Case)) Case))))) (quote shen.t*))
(begin (register-function-arity (quote shen.type-theory-enabled?) 0) (define (kl:shen.type-theory-enabled?) (kl:value (quote shen.*shen-type-theory-enabled?*))) (quote shen.type-theory-enabled?))
(begin (register-function-arity (quote enable-type-theory) 1) (define (kl:enable-type-theory V3509) (cond ((eq? (quote +) V3509) (kl:set (quote shen.*shen-type-theory-enabled?*) #t)) ((eq? (quote -) V3509) (kl:set (quote shen.*shen-type-theory-enabled?*) #f)) (#t (simple-error "enable-type-theory expects a + or a -\n")))) (quote enable-type-theory))
(begin (register-function-arity (quote shen.prolog-failure) 2) (define (kl:shen.prolog-failure V3520 V3521) #f) (quote shen.prolog-failure))
(begin (register-function-arity (quote shen.maxinfexceeded?) 0) (define (kl:shen.maxinfexceeded?) (> (kl:inferences) (kl:value (quote shen.*maxinferences*)))) (quote shen.maxinfexceeded?))
(begin (register-function-arity (quote shen.errormaxinfs) 0) (define (kl:shen.errormaxinfs) (simple-error "maximum inferences exceeded~%")) (quote shen.errormaxinfs))
(begin (register-function-arity (quote shen.udefs*) 5) (define (kl:shen.udefs* V3527 V3528 V3529 V3530 V3531) (let ((Case (let ((V3476 (kl:shen.lazyderef V3529 V3530))) (if (pair? V3476) (let ((D (car V3476))) (begin (kl:shen.incinfs) (kl:call (cons D (cons V3527 (cons V3528 (quote ())))) V3530 V3531))) #f)))) (if (kl:= Case #f) (let ((V3477 (kl:shen.lazyderef V3529 V3530))) (if (pair? V3477) (let ((Ds (cdr V3477))) (begin (kl:shen.incinfs) (kl:shen.udefs* V3527 V3528 Ds V3530 V3531))) #f)) Case))) (quote shen.udefs*))
(begin (register-function-arity (quote shen.th*) 5) (define (kl:shen.th* V3537 V3538 V3539 V3540 V3541) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (begin (kl:shen.incinfs) (kl:shen.show (cons V3537 (cons (quote :) (cons V3538 (quote ())))) V3539 V3540 (lambda () (kl:fwhen #f V3540 V3541)))))) (if (kl:= Case #f) (let ((Case (let ((F (kl:shen.newpv V3540))) (begin (kl:shen.incinfs) (kl:fwhen (kl:shen.typedf? (kl:shen.lazyderef V3537 V3540)) V3540 (lambda () (kl:bind F (kl:shen.sigf (kl:shen.lazyderef V3537 V3540)) V3540 (lambda () (kl:call (cons F (cons V3538 (quote ()))) V3540 V3541))))))))) (if (kl:= Case #f) (let ((Case (begin (kl:shen.incinfs) (kl:shen.base V3537 V3538 V3540 V3541)))) (if (kl:= Case #f) (let ((Case (begin (kl:shen.incinfs) (kl:shen.by_hypothesis V3537 V3538 V3539 V3540 V3541)))) (if (kl:= Case #f) (let ((Case (let ((V3372 (kl:shen.lazyderef V3537 V3540))) (if (pair? V3372) (let ((F (car V3372))) (let ((V3373 (kl:shen.lazyderef (cdr V3372) V3540))) (if (null? V3373) (begin (kl:shen.incinfs) (kl:shen.th* F (cons (quote -->) (cons V3538 (quote ()))) V3539 V3540 V3541)) #f))) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3374 (kl:shen.lazyderef V3537 V3540))) (if (pair? V3374) (let ((F (car V3374))) (let ((V3375 (kl:shen.lazyderef (cdr V3374) V3540))) (if (pair? V3375) (let ((X (car V3375))) (let ((V3376 (kl:shen.lazyderef (cdr V3375) V3540))) (if (null? V3376) (let ((B (kl:shen.newpv V3540))) (begin (kl:shen.incinfs) (kl:shen.th* F (cons B (cons (quote -->) (cons V3538 (quote ())))) V3539 V3540 (lambda () (kl:shen.th* X B V3539 V3540 V3541))))) #f))) #f))) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3377 (kl:shen.lazyderef V3537 V3540))) (if (pair? V3377) (let ((V3378 (kl:shen.lazyderef (car V3377) V3540))) (if (eq? (quote cons) V3378) (let ((V3379 (kl:shen.lazyderef (cdr V3377) V3540))) (if (pair? V3379) (let ((X (car V3379))) (let ((V3380 (kl:shen.lazyderef (cdr V3379) V3540))) (if (pair? V3380) (let ((Y (car V3380))) (let ((V3381 (kl:shen.lazyderef (cdr V3380) V3540))) (if (null? V3381) (let ((V3382 (kl:shen.lazyderef V3538 V3540))) (if (pair? V3382) (let ((V3383 (kl:shen.lazyderef (car V3382) V3540))) (if (eq? (quote list) V3383) (let ((V3384 (kl:shen.lazyderef (cdr V3382) V3540))) (if (pair? V3384) (let ((A (car V3384))) (let ((V3385 (kl:shen.lazyderef (cdr V3384) V3540))) (if (null? V3385) (begin (kl:shen.incinfs) (kl:shen.th* X A V3539 V3540 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3539 V3540 V3541)))) (if (kl:shen.pvar? V3385) (begin (kl:shen.bindv V3385 (quote ()) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3539 V3540 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3539 V3540 V3541)))))) (begin (kl:shen.unbindv V3385 V3540) Result))) #f)))) (if (kl:shen.pvar? V3384) (let ((A (kl:shen.newpv V3540))) (begin (kl:shen.bindv V3384 (cons A (quote ())) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3539 V3540 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3539 V3540 V3541)))))) (begin (kl:shen.unbindv V3384 V3540) Result)))) #f))) (if (kl:shen.pvar? V3383) (begin (kl:shen.bindv V3383 (quote list) V3540) (let ((Result (let ((V3386 (kl:shen.lazyderef (cdr V3382) V3540))) (if (pair? V3386) (let ((A (car V3386))) (let ((V3387 (kl:shen.lazyderef (cdr V3386) V3540))) (if (null? V3387) (begin (kl:shen.incinfs) (kl:shen.th* X A V3539 V3540 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3539 V3540 V3541)))) (if (kl:shen.pvar? V3387) (begin (kl:shen.bindv V3387 (quote ()) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3539 V3540 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3539 V3540 V3541)))))) (begin (kl:shen.unbindv V3387 V3540) Result))) #f)))) (if (kl:shen.pvar? V3386) (let ((A (kl:shen.newpv V3540))) (begin (kl:shen.bindv V3386 (cons A (quote ())) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3539 V3540 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3539 V3540 V3541)))))) (begin (kl:shen.unbindv V3386 V3540) Result)))) #f))))) (begin (kl:shen.unbindv V3383 V3540) Result))) #f))) (if (kl:shen.pvar? V3382) (let ((A (kl:shen.newpv V3540))) (begin (kl:shen.bindv V3382 (cons (quote list) (cons A (quote ()))) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3539 V3540 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3539 V3540 V3541)))))) (begin (kl:shen.unbindv V3382 V3540) Result)))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3388 (kl:shen.lazyderef V3537 V3540))) (if (pair? V3388) (let ((V3389 (kl:shen.lazyderef (car V3388) V3540))) (if (eq? (quote _waspvm_at_p) V3389) (let ((V3390 (kl:shen.lazyderef (cdr V3388) V3540))) (if (pair? V3390) (let ((X (car V3390))) (let ((V3391 (kl:shen.lazyderef (cdr V3390) V3540))) (if (pair? V3391) (let ((Y (car V3391))) (let ((V3392 (kl:shen.lazyderef (cdr V3391) V3540))) (if (null? V3392) (let ((V3393 (kl:shen.lazyderef V3538 V3540))) (if (pair? V3393) (let ((A (car V3393))) (let ((V3394 (kl:shen.lazyderef (cdr V3393) V3540))) (if (pair? V3394) (let ((V3395 (kl:shen.lazyderef (car V3394) V3540))) (if (eq? (quote *) V3395) (let ((V3396 (kl:shen.lazyderef (cdr V3394) V3540))) (if (pair? V3396) (let ((B (car V3396))) (let ((V3397 (kl:shen.lazyderef (cdr V3396) V3540))) (if (null? V3397) (begin (kl:shen.incinfs) (kl:shen.th* X A V3539 V3540 (lambda () (kl:shen.th* Y B V3539 V3540 V3541)))) (if (kl:shen.pvar? V3397) (begin (kl:shen.bindv V3397 (quote ()) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3539 V3540 (lambda () (kl:shen.th* Y B V3539 V3540 V3541)))))) (begin (kl:shen.unbindv V3397 V3540) Result))) #f)))) (if (kl:shen.pvar? V3396) (let ((B (kl:shen.newpv V3540))) (begin (kl:shen.bindv V3396 (cons B (quote ())) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3539 V3540 (lambda () (kl:shen.th* Y B V3539 V3540 V3541)))))) (begin (kl:shen.unbindv V3396 V3540) Result)))) #f))) (if (kl:shen.pvar? V3395) (begin (kl:shen.bindv V3395 (quote *) V3540) (let ((Result (let ((V3398 (kl:shen.lazyderef (cdr V3394) V3540))) (if (pair? V3398) (let ((B (car V3398))) (let ((V3399 (kl:shen.lazyderef (cdr V3398) V3540))) (if (null? V3399) (begin (kl:shen.incinfs) (kl:shen.th* X A V3539 V3540 (lambda () (kl:shen.th* Y B V3539 V3540 V3541)))) (if (kl:shen.pvar? V3399) (begin (kl:shen.bindv V3399 (quote ()) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3539 V3540 (lambda () (kl:shen.th* Y B V3539 V3540 V3541)))))) (begin (kl:shen.unbindv V3399 V3540) Result))) #f)))) (if (kl:shen.pvar? V3398) (let ((B (kl:shen.newpv V3540))) (begin (kl:shen.bindv V3398 (cons B (quote ())) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3539 V3540 (lambda () (kl:shen.th* Y B V3539 V3540 V3541)))))) (begin (kl:shen.unbindv V3398 V3540) Result)))) #f))))) (begin (kl:shen.unbindv V3395 V3540) Result))) #f))) (if (kl:shen.pvar? V3394) (let ((B (kl:shen.newpv V3540))) (begin (kl:shen.bindv V3394 (cons (quote *) (cons B (quote ()))) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3539 V3540 (lambda () (kl:shen.th* Y B V3539 V3540 V3541)))))) (begin (kl:shen.unbindv V3394 V3540) Result)))) #f)))) (if (kl:shen.pvar? V3393) (let ((A (kl:shen.newpv V3540))) (let ((B (kl:shen.newpv V3540))) (begin (kl:shen.bindv V3393 (cons A (cons (quote *) (cons B (quote ())))) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3539 V3540 (lambda () (kl:shen.th* Y B V3539 V3540 V3541)))))) (begin (kl:shen.unbindv V3393 V3540) Result))))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3400 (kl:shen.lazyderef V3537 V3540))) (if (pair? V3400) (let ((V3401 (kl:shen.lazyderef (car V3400) V3540))) (if (eq? (quote _waspvm_at_v) V3401) (let ((V3402 (kl:shen.lazyderef (cdr V3400) V3540))) (if (pair? V3402) (let ((X (car V3402))) (let ((V3403 (kl:shen.lazyderef (cdr V3402) V3540))) (if (pair? V3403) (let ((Y (car V3403))) (let ((V3404 (kl:shen.lazyderef (cdr V3403) V3540))) (if (null? V3404) (let ((V3405 (kl:shen.lazyderef V3538 V3540))) (if (pair? V3405) (let ((V3406 (kl:shen.lazyderef (car V3405) V3540))) (if (eq? (quote vector) V3406) (let ((V3407 (kl:shen.lazyderef (cdr V3405) V3540))) (if (pair? V3407) (let ((A (car V3407))) (let ((V3408 (kl:shen.lazyderef (cdr V3407) V3540))) (if (null? V3408) (begin (kl:shen.incinfs) (kl:shen.th* X A V3539 V3540 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3539 V3540 V3541)))) (if (kl:shen.pvar? V3408) (begin (kl:shen.bindv V3408 (quote ()) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3539 V3540 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3539 V3540 V3541)))))) (begin (kl:shen.unbindv V3408 V3540) Result))) #f)))) (if (kl:shen.pvar? V3407) (let ((A (kl:shen.newpv V3540))) (begin (kl:shen.bindv V3407 (cons A (quote ())) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3539 V3540 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3539 V3540 V3541)))))) (begin (kl:shen.unbindv V3407 V3540) Result)))) #f))) (if (kl:shen.pvar? V3406) (begin (kl:shen.bindv V3406 (quote vector) V3540) (let ((Result (let ((V3409 (kl:shen.lazyderef (cdr V3405) V3540))) (if (pair? V3409) (let ((A (car V3409))) (let ((V3410 (kl:shen.lazyderef (cdr V3409) V3540))) (if (null? V3410) (begin (kl:shen.incinfs) (kl:shen.th* X A V3539 V3540 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3539 V3540 V3541)))) (if (kl:shen.pvar? V3410) (begin (kl:shen.bindv V3410 (quote ()) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3539 V3540 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3539 V3540 V3541)))))) (begin (kl:shen.unbindv V3410 V3540) Result))) #f)))) (if (kl:shen.pvar? V3409) (let ((A (kl:shen.newpv V3540))) (begin (kl:shen.bindv V3409 (cons A (quote ())) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3539 V3540 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3539 V3540 V3541)))))) (begin (kl:shen.unbindv V3409 V3540) Result)))) #f))))) (begin (kl:shen.unbindv V3406 V3540) Result))) #f))) (if (kl:shen.pvar? V3405) (let ((A (kl:shen.newpv V3540))) (begin (kl:shen.bindv V3405 (cons (quote vector) (cons A (quote ()))) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3539 V3540 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3539 V3540 V3541)))))) (begin (kl:shen.unbindv V3405 V3540) Result)))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3411 (kl:shen.lazyderef V3537 V3540))) (if (pair? V3411) (let ((V3412 (kl:shen.lazyderef (car V3411) V3540))) (if (eq? (quote _waspvm_at_s) V3412) (let ((V3413 (kl:shen.lazyderef (cdr V3411) V3540))) (if (pair? V3413) (let ((X (car V3413))) (let ((V3414 (kl:shen.lazyderef (cdr V3413) V3540))) (if (pair? V3414) (let ((Y (car V3414))) (let ((V3415 (kl:shen.lazyderef (cdr V3414) V3540))) (if (null? V3415) (let ((V3416 (kl:shen.lazyderef V3538 V3540))) (if (eq? (quote string) V3416) (begin (kl:shen.incinfs) (kl:shen.th* X (quote string) V3539 V3540 (lambda () (kl:shen.th* Y (quote string) V3539 V3540 V3541)))) (if (kl:shen.pvar? V3416) (begin (kl:shen.bindv V3416 (quote string) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X (quote string) V3539 V3540 (lambda () (kl:shen.th* Y (quote string) V3539 V3540 V3541)))))) (begin (kl:shen.unbindv V3416 V3540) Result))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3417 (kl:shen.lazyderef V3537 V3540))) (if (pair? V3417) (let ((V3418 (kl:shen.lazyderef (car V3417) V3540))) (if (eq? (quote lambda) V3418) (let ((V3419 (kl:shen.lazyderef (cdr V3417) V3540))) (if (pair? V3419) (let ((X (car V3419))) (let ((V3420 (kl:shen.lazyderef (cdr V3419) V3540))) (if (pair? V3420) (let ((Y (car V3420))) (let ((V3421 (kl:shen.lazyderef (cdr V3420) V3540))) (if (null? V3421) (let ((V3422 (kl:shen.lazyderef V3538 V3540))) (if (pair? V3422) (let ((A (car V3422))) (let ((V3423 (kl:shen.lazyderef (cdr V3422) V3540))) (if (pair? V3423) (let ((V3424 (kl:shen.lazyderef (car V3423) V3540))) (if (eq? (quote -->) V3424) (let ((V3425 (kl:shen.lazyderef (cdr V3423) V3540))) (if (pair? V3425) (let ((B (car V3425))) (let ((V3426 (kl:shen.lazyderef (cdr V3425) V3540))) (if (null? V3426) (let ((Z (kl:shen.newpv V3540))) (let ((X&& (kl:shen.newpv V3540))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3540 (lambda () (kl:bind X&& (kl:shen.placeholder) V3540 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3540) (kl:shen.lazyderef X V3540) (kl:shen.lazyderef Y V3540)) V3540 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3539) V3540 V3541)))))))))) (if (kl:shen.pvar? V3426) (begin (kl:shen.bindv V3426 (quote ()) V3540) (let ((Result (let ((Z (kl:shen.newpv V3540))) (let ((X&& (kl:shen.newpv V3540))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3540 (lambda () (kl:bind X&& (kl:shen.placeholder) V3540 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3540) (kl:shen.lazyderef X V3540) (kl:shen.lazyderef Y V3540)) V3540 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3539) V3540 V3541)))))))))))) (begin (kl:shen.unbindv V3426 V3540) Result))) #f)))) (if (kl:shen.pvar? V3425) (let ((B (kl:shen.newpv V3540))) (begin (kl:shen.bindv V3425 (cons B (quote ())) V3540) (let ((Result (let ((Z (kl:shen.newpv V3540))) (let ((X&& (kl:shen.newpv V3540))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3540 (lambda () (kl:bind X&& (kl:shen.placeholder) V3540 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3540) (kl:shen.lazyderef X V3540) (kl:shen.lazyderef Y V3540)) V3540 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3539) V3540 V3541)))))))))))) (begin (kl:shen.unbindv V3425 V3540) Result)))) #f))) (if (kl:shen.pvar? V3424) (begin (kl:shen.bindv V3424 (quote -->) V3540) (let ((Result (let ((V3427 (kl:shen.lazyderef (cdr V3423) V3540))) (if (pair? V3427) (let ((B (car V3427))) (let ((V3428 (kl:shen.lazyderef (cdr V3427) V3540))) (if (null? V3428) (let ((Z (kl:shen.newpv V3540))) (let ((X&& (kl:shen.newpv V3540))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3540 (lambda () (kl:bind X&& (kl:shen.placeholder) V3540 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3540) (kl:shen.lazyderef X V3540) (kl:shen.lazyderef Y V3540)) V3540 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3539) V3540 V3541)))))))))) (if (kl:shen.pvar? V3428) (begin (kl:shen.bindv V3428 (quote ()) V3540) (let ((Result (let ((Z (kl:shen.newpv V3540))) (let ((X&& (kl:shen.newpv V3540))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3540 (lambda () (kl:bind X&& (kl:shen.placeholder) V3540 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3540) (kl:shen.lazyderef X V3540) (kl:shen.lazyderef Y V3540)) V3540 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3539) V3540 V3541)))))))))))) (begin (kl:shen.unbindv V3428 V3540) Result))) #f)))) (if (kl:shen.pvar? V3427) (let ((B (kl:shen.newpv V3540))) (begin (kl:shen.bindv V3427 (cons B (quote ())) V3540) (let ((Result (let ((Z (kl:shen.newpv V3540))) (let ((X&& (kl:shen.newpv V3540))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3540 (lambda () (kl:bind X&& (kl:shen.placeholder) V3540 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3540) (kl:shen.lazyderef X V3540) (kl:shen.lazyderef Y V3540)) V3540 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3539) V3540 V3541)))))))))))) (begin (kl:shen.unbindv V3427 V3540) Result)))) #f))))) (begin (kl:shen.unbindv V3424 V3540) Result))) #f))) (if (kl:shen.pvar? V3423) (let ((B (kl:shen.newpv V3540))) (begin (kl:shen.bindv V3423 (cons (quote -->) (cons B (quote ()))) V3540) (let ((Result (let ((Z (kl:shen.newpv V3540))) (let ((X&& (kl:shen.newpv V3540))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3540 (lambda () (kl:bind X&& (kl:shen.placeholder) V3540 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3540) (kl:shen.lazyderef X V3540) (kl:shen.lazyderef Y V3540)) V3540 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3539) V3540 V3541)))))))))))) (begin (kl:shen.unbindv V3423 V3540) Result)))) #f)))) (if (kl:shen.pvar? V3422) (let ((A (kl:shen.newpv V3540))) (let ((B (kl:shen.newpv V3540))) (begin (kl:shen.bindv V3422 (cons A (cons (quote -->) (cons B (quote ())))) V3540) (let ((Result (let ((Z (kl:shen.newpv V3540))) (let ((X&& (kl:shen.newpv V3540))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3540 (lambda () (kl:bind X&& (kl:shen.placeholder) V3540 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3540) (kl:shen.lazyderef X V3540) (kl:shen.lazyderef Y V3540)) V3540 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3539) V3540 V3541)))))))))))) (begin (kl:shen.unbindv V3422 V3540) Result))))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3429 (kl:shen.lazyderef V3537 V3540))) (if (pair? V3429) (let ((V3430 (kl:shen.lazyderef (car V3429) V3540))) (if (eq? (quote let) V3430) (let ((V3431 (kl:shen.lazyderef (cdr V3429) V3540))) (if (pair? V3431) (let ((X (car V3431))) (let ((V3432 (kl:shen.lazyderef (cdr V3431) V3540))) (if (pair? V3432) (let ((Y (car V3432))) (let ((V3433 (kl:shen.lazyderef (cdr V3432) V3540))) (if (pair? V3433) (let ((Z (car V3433))) (let ((V3434 (kl:shen.lazyderef (cdr V3433) V3540))) (if (null? V3434) (let ((W (kl:shen.newpv V3540))) (let ((X&& (kl:shen.newpv V3540))) (let ((B (kl:shen.newpv V3540))) (begin (kl:shen.incinfs) (kl:shen.th* Y B V3539 V3540 (lambda () (kl:bind X&& (kl:shen.placeholder) V3540 (lambda () (kl:bind W (kl:shen.ebr (kl:shen.lazyderef X&& V3540) (kl:shen.lazyderef X V3540) (kl:shen.lazyderef Z V3540)) V3540 (lambda () (kl:shen.th* W V3538 (cons (cons X&& (cons (quote :) (cons B (quote ())))) V3539) V3540 V3541))))))))))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3435 (kl:shen.lazyderef V3537 V3540))) (if (pair? V3435) (let ((V3436 (kl:shen.lazyderef (car V3435) V3540))) (if (eq? (quote open) V3436) (let ((V3437 (kl:shen.lazyderef (cdr V3435) V3540))) (if (pair? V3437) (let ((FileName (car V3437))) (let ((V3438 (kl:shen.lazyderef (cdr V3437) V3540))) (if (pair? V3438) (let ((Direction3368 (car V3438))) (let ((V3439 (kl:shen.lazyderef (cdr V3438) V3540))) (if (null? V3439) (let ((V3440 (kl:shen.lazyderef V3538 V3540))) (if (pair? V3440) (let ((V3441 (kl:shen.lazyderef (car V3440) V3540))) (if (eq? (quote stream) V3441) (let ((V3442 (kl:shen.lazyderef (cdr V3440) V3540))) (if (pair? V3442) (let ((Direction (car V3442))) (let ((V3443 (kl:shen.lazyderef (cdr V3442) V3540))) (if (null? V3443) (begin (kl:shen.incinfs) (kl:unify! Direction Direction3368 V3540 (lambda () (kl:cut Throwcontrol V3540 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3540) (cons (quote in) (cons (quote out) (quote ())))) V3540 (lambda () (kl:shen.th* FileName (quote string) V3539 V3540 V3541)))))))) (if (kl:shen.pvar? V3443) (begin (kl:shen.bindv V3443 (quote ()) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3368 V3540 (lambda () (kl:cut Throwcontrol V3540 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3540) (cons (quote in) (cons (quote out) (quote ())))) V3540 (lambda () (kl:shen.th* FileName (quote string) V3539 V3540 V3541)))))))))) (begin (kl:shen.unbindv V3443 V3540) Result))) #f)))) (if (kl:shen.pvar? V3442) (let ((Direction (kl:shen.newpv V3540))) (begin (kl:shen.bindv V3442 (cons Direction (quote ())) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3368 V3540 (lambda () (kl:cut Throwcontrol V3540 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3540) (cons (quote in) (cons (quote out) (quote ())))) V3540 (lambda () (kl:shen.th* FileName (quote string) V3539 V3540 V3541)))))))))) (begin (kl:shen.unbindv V3442 V3540) Result)))) #f))) (if (kl:shen.pvar? V3441) (begin (kl:shen.bindv V3441 (quote stream) V3540) (let ((Result (let ((V3444 (kl:shen.lazyderef (cdr V3440) V3540))) (if (pair? V3444) (let ((Direction (car V3444))) (let ((V3445 (kl:shen.lazyderef (cdr V3444) V3540))) (if (null? V3445) (begin (kl:shen.incinfs) (kl:unify! Direction Direction3368 V3540 (lambda () (kl:cut Throwcontrol V3540 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3540) (cons (quote in) (cons (quote out) (quote ())))) V3540 (lambda () (kl:shen.th* FileName (quote string) V3539 V3540 V3541)))))))) (if (kl:shen.pvar? V3445) (begin (kl:shen.bindv V3445 (quote ()) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3368 V3540 (lambda () (kl:cut Throwcontrol V3540 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3540) (cons (quote in) (cons (quote out) (quote ())))) V3540 (lambda () (kl:shen.th* FileName (quote string) V3539 V3540 V3541)))))))))) (begin (kl:shen.unbindv V3445 V3540) Result))) #f)))) (if (kl:shen.pvar? V3444) (let ((Direction (kl:shen.newpv V3540))) (begin (kl:shen.bindv V3444 (cons Direction (quote ())) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3368 V3540 (lambda () (kl:cut Throwcontrol V3540 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3540) (cons (quote in) (cons (quote out) (quote ())))) V3540 (lambda () (kl:shen.th* FileName (quote string) V3539 V3540 V3541)))))))))) (begin (kl:shen.unbindv V3444 V3540) Result)))) #f))))) (begin (kl:shen.unbindv V3441 V3540) Result))) #f))) (if (kl:shen.pvar? V3440) (let ((Direction (kl:shen.newpv V3540))) (begin (kl:shen.bindv V3440 (cons (quote stream) (cons Direction (quote ()))) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3368 V3540 (lambda () (kl:cut Throwcontrol V3540 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3540) (cons (quote in) (cons (quote out) (quote ())))) V3540 (lambda () (kl:shen.th* FileName (quote string) V3539 V3540 V3541)))))))))) (begin (kl:shen.unbindv V3440 V3540) Result)))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3446 (kl:shen.lazyderef V3537 V3540))) (if (pair? V3446) (let ((V3447 (kl:shen.lazyderef (car V3446) V3540))) (if (eq? (quote type) V3447) (let ((V3448 (kl:shen.lazyderef (cdr V3446) V3540))) (if (pair? V3448) (let ((X (car V3448))) (let ((V3449 (kl:shen.lazyderef (cdr V3448) V3540))) (if (pair? V3449) (let ((A (car V3449))) (let ((V3450 (kl:shen.lazyderef (cdr V3449) V3540))) (if (null? V3450) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3540 (lambda () (kl:unify A V3538 V3540 (lambda () (kl:shen.th* X A V3539 V3540 V3541)))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3451 (kl:shen.lazyderef V3537 V3540))) (if (pair? V3451) (let ((V3452 (kl:shen.lazyderef (car V3451) V3540))) (if (eq? (quote input+) V3452) (let ((V3453 (kl:shen.lazyderef (cdr V3451) V3540))) (if (pair? V3453) (let ((A (car V3453))) (let ((V3454 (kl:shen.lazyderef (cdr V3453) V3540))) (if (pair? V3454) (let ((Stream (car V3454))) (let ((V3455 (kl:shen.lazyderef (cdr V3454) V3540))) (if (null? V3455) (let ((C (kl:shen.newpv V3540))) (begin (kl:shen.incinfs) (kl:bind C (kl:shen.demodulate (kl:shen.lazyderef A V3540)) V3540 (lambda () (kl:unify V3538 C V3540 (lambda () (kl:shen.th* Stream (cons (quote stream) (cons (quote in) (quote ()))) V3539 V3540 V3541))))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3456 (kl:shen.lazyderef V3537 V3540))) (if (pair? V3456) (let ((V3457 (kl:shen.lazyderef (car V3456) V3540))) (if (eq? (quote set) V3457) (let ((V3458 (kl:shen.lazyderef (cdr V3456) V3540))) (if (pair? V3458) (let ((Var (car V3458))) (let ((V3459 (kl:shen.lazyderef (cdr V3458) V3540))) (if (pair? V3459) (let ((Val (car V3459))) (let ((V3460 (kl:shen.lazyderef (cdr V3459) V3540))) (if (null? V3460) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3540 (lambda () (kl:shen.th* Var (quote symbol) V3539 V3540 (lambda () (kl:cut Throwcontrol V3540 (lambda () (kl:shen.th* (cons (quote value) (cons Var (quote ()))) V3538 V3539 V3540 (lambda () (kl:shen.th* Val V3538 V3539 V3540 V3541)))))))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((NewHyp (kl:shen.newpv V3540))) (begin (kl:shen.incinfs) (kl:shen.t*-hyps V3539 NewHyp V3540 (lambda () (kl:shen.th* V3537 V3538 NewHyp V3540 V3541))))))) (if (kl:= Case #f) (let ((Case (let ((V3461 (kl:shen.lazyderef V3537 V3540))) (if (pair? V3461) (let ((V3462 (kl:shen.lazyderef (car V3461) V3540))) (if (eq? (quote define) V3462) (let ((V3463 (kl:shen.lazyderef (cdr V3461) V3540))) (if (pair? V3463) (let ((F (car V3463))) (let ((X (cdr V3463))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3540 (lambda () (kl:shen.t*-def (cons (quote define) (cons F X)) V3538 V3539 V3540 V3541)))))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3464 (kl:shen.lazyderef V3537 V3540))) (if (pair? V3464) (let ((V3465 (kl:shen.lazyderef (car V3464) V3540))) (if (eq? (quote defmacro) V3465) (let ((V3466 (kl:shen.lazyderef V3538 V3540))) (if (eq? (quote unit) V3466) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3540 V3541)) (if (kl:shen.pvar? V3466) (begin (kl:shen.bindv V3466 (quote unit) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3540 V3541)))) (begin (kl:shen.unbindv V3466 V3540) Result))) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3467 (kl:shen.lazyderef V3537 V3540))) (if (pair? V3467) (let ((V3468 (kl:shen.lazyderef (car V3467) V3540))) (if (eq? (quote shen.process-datatype) V3468) (let ((V3469 (kl:shen.lazyderef V3538 V3540))) (if (eq? (quote symbol) V3469) (begin (kl:shen.incinfs) (kl:thaw V3541)) (if (kl:shen.pvar? V3469) (begin (kl:shen.bindv V3469 (quote symbol) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3541)))) (begin (kl:shen.unbindv V3469 V3540) Result))) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3470 (kl:shen.lazyderef V3537 V3540))) (if (pair? V3470) (let ((V3471 (kl:shen.lazyderef (car V3470) V3540))) (if (eq? (quote shen.synonyms-help) V3471) (let ((V3472 (kl:shen.lazyderef V3538 V3540))) (if (eq? (quote symbol) V3472) (begin (kl:shen.incinfs) (kl:thaw V3541)) (if (kl:shen.pvar? V3472) (begin (kl:shen.bindv V3472 (quote symbol) V3540) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3541)))) (begin (kl:shen.unbindv V3472 V3540) Result))) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((Datatypes (kl:shen.newpv V3540))) (begin (kl:shen.incinfs) (kl:bind Datatypes (kl:value (quote shen.*datatypes*)) V3540 (lambda () (kl:shen.udefs* (cons V3537 (cons (quote :) (cons V3538 (quote ())))) V3539 Datatypes V3540 V3541))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case))))) (quote shen.th*))
(begin (register-function-arity (quote shen.t*-hyps) 4) (define (kl:shen.t*-hyps V3546 V3547 V3548 V3549) (let ((Case (let ((V3283 (kl:shen.lazyderef V3546 V3548))) (if (pair? V3283) (let ((V3284 (kl:shen.lazyderef (car V3283) V3548))) (if (pair? V3284) (let ((V3285 (kl:shen.lazyderef (car V3284) V3548))) (if (pair? V3285) (let ((V3286 (kl:shen.lazyderef (car V3285) V3548))) (if (eq? (quote cons) V3286) (let ((V3287 (kl:shen.lazyderef (cdr V3285) V3548))) (if (pair? V3287) (let ((X (car V3287))) (let ((V3288 (kl:shen.lazyderef (cdr V3287) V3548))) (if (pair? V3288) (let ((Y (car V3288))) (let ((V3289 (kl:shen.lazyderef (cdr V3288) V3548))) (if (null? V3289) (let ((V3290 (kl:shen.lazyderef (cdr V3284) V3548))) (if (pair? V3290) (let ((V3291 (kl:shen.lazyderef (car V3290) V3548))) (if (eq? (quote :) V3291) (let ((V3292 (kl:shen.lazyderef (cdr V3290) V3548))) (if (pair? V3292) (let ((V3293 (kl:shen.lazyderef (car V3292) V3548))) (if (pair? V3293) (let ((V3294 (kl:shen.lazyderef (car V3293) V3548))) (if (eq? (quote list) V3294) (let ((V3295 (kl:shen.lazyderef (cdr V3293) V3548))) (if (pair? V3295) (let ((A (car V3295))) (let ((V3296 (kl:shen.lazyderef (cdr V3295) V3548))) (if (null? V3296) (let ((V3297 (kl:shen.lazyderef (cdr V3292) V3548))) (if (null? V3297) (let ((Hyp (cdr V3283))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3297) (begin (kl:shen.bindv V3297 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3283))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3297 V3548) Result))) #f))) (if (kl:shen.pvar? V3296) (begin (kl:shen.bindv V3296 (quote ()) V3548) (let ((Result (let ((V3298 (kl:shen.lazyderef (cdr V3292) V3548))) (if (null? V3298) (let ((Hyp (cdr V3283))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3298) (begin (kl:shen.bindv V3298 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3283))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3298 V3548) Result))) #f))))) (begin (kl:shen.unbindv V3296 V3548) Result))) #f)))) (if (kl:shen.pvar? V3295) (let ((A (kl:shen.newpv V3548))) (begin (kl:shen.bindv V3295 (cons A (quote ())) V3548) (let ((Result (let ((V3299 (kl:shen.lazyderef (cdr V3292) V3548))) (if (null? V3299) (let ((Hyp (cdr V3283))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3299) (begin (kl:shen.bindv V3299 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3283))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3299 V3548) Result))) #f))))) (begin (kl:shen.unbindv V3295 V3548) Result)))) #f))) (if (kl:shen.pvar? V3294) (begin (kl:shen.bindv V3294 (quote list) V3548) (let ((Result (let ((V3300 (kl:shen.lazyderef (cdr V3293) V3548))) (if (pair? V3300) (let ((A (car V3300))) (let ((V3301 (kl:shen.lazyderef (cdr V3300) V3548))) (if (null? V3301) (let ((V3302 (kl:shen.lazyderef (cdr V3292) V3548))) (if (null? V3302) (let ((Hyp (cdr V3283))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3302) (begin (kl:shen.bindv V3302 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3283))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3302 V3548) Result))) #f))) (if (kl:shen.pvar? V3301) (begin (kl:shen.bindv V3301 (quote ()) V3548) (let ((Result (let ((V3303 (kl:shen.lazyderef (cdr V3292) V3548))) (if (null? V3303) (let ((Hyp (cdr V3283))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3303) (begin (kl:shen.bindv V3303 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3283))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3303 V3548) Result))) #f))))) (begin (kl:shen.unbindv V3301 V3548) Result))) #f)))) (if (kl:shen.pvar? V3300) (let ((A (kl:shen.newpv V3548))) (begin (kl:shen.bindv V3300 (cons A (quote ())) V3548) (let ((Result (let ((V3304 (kl:shen.lazyderef (cdr V3292) V3548))) (if (null? V3304) (let ((Hyp (cdr V3283))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3304) (begin (kl:shen.bindv V3304 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3283))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3304 V3548) Result))) #f))))) (begin (kl:shen.unbindv V3300 V3548) Result)))) #f))))) (begin (kl:shen.unbindv V3294 V3548) Result))) #f))) (if (kl:shen.pvar? V3293) (let ((A (kl:shen.newpv V3548))) (begin (kl:shen.bindv V3293 (cons (quote list) (cons A (quote ()))) V3548) (let ((Result (let ((V3305 (kl:shen.lazyderef (cdr V3292) V3548))) (if (null? V3305) (let ((Hyp (cdr V3283))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3305) (begin (kl:shen.bindv V3305 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3283))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3305 V3548) Result))) #f))))) (begin (kl:shen.unbindv V3293 V3548) Result)))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3306 (kl:shen.lazyderef V3546 V3548))) (if (pair? V3306) (let ((V3307 (kl:shen.lazyderef (car V3306) V3548))) (if (pair? V3307) (let ((V3308 (kl:shen.lazyderef (car V3307) V3548))) (if (pair? V3308) (let ((V3309 (kl:shen.lazyderef (car V3308) V3548))) (if (eq? (quote _waspvm_at_p) V3309) (let ((V3310 (kl:shen.lazyderef (cdr V3308) V3548))) (if (pair? V3310) (let ((X (car V3310))) (let ((V3311 (kl:shen.lazyderef (cdr V3310) V3548))) (if (pair? V3311) (let ((Y (car V3311))) (let ((V3312 (kl:shen.lazyderef (cdr V3311) V3548))) (if (null? V3312) (let ((V3313 (kl:shen.lazyderef (cdr V3307) V3548))) (if (pair? V3313) (let ((V3314 (kl:shen.lazyderef (car V3313) V3548))) (if (eq? (quote :) V3314) (let ((V3315 (kl:shen.lazyderef (cdr V3313) V3548))) (if (pair? V3315) (let ((V3316 (kl:shen.lazyderef (car V3315) V3548))) (if (pair? V3316) (let ((A (car V3316))) (let ((V3317 (kl:shen.lazyderef (cdr V3316) V3548))) (if (pair? V3317) (let ((V3318 (kl:shen.lazyderef (car V3317) V3548))) (if (eq? (quote *) V3318) (let ((V3319 (kl:shen.lazyderef (cdr V3317) V3548))) (if (pair? V3319) (let ((B (car V3319))) (let ((V3320 (kl:shen.lazyderef (cdr V3319) V3548))) (if (null? V3320) (let ((V3321 (kl:shen.lazyderef (cdr V3315) V3548))) (if (null? V3321) (let ((Hyp (cdr V3306))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (kl:shen.lazyderef B V3548) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3321) (begin (kl:shen.bindv V3321 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3306))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (kl:shen.lazyderef B V3548) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3321 V3548) Result))) #f))) (if (kl:shen.pvar? V3320) (begin (kl:shen.bindv V3320 (quote ()) V3548) (let ((Result (let ((V3322 (kl:shen.lazyderef (cdr V3315) V3548))) (if (null? V3322) (let ((Hyp (cdr V3306))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (kl:shen.lazyderef B V3548) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3322) (begin (kl:shen.bindv V3322 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3306))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (kl:shen.lazyderef B V3548) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3322 V3548) Result))) #f))))) (begin (kl:shen.unbindv V3320 V3548) Result))) #f)))) (if (kl:shen.pvar? V3319) (let ((B (kl:shen.newpv V3548))) (begin (kl:shen.bindv V3319 (cons B (quote ())) V3548) (let ((Result (let ((V3323 (kl:shen.lazyderef (cdr V3315) V3548))) (if (null? V3323) (let ((Hyp (cdr V3306))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (kl:shen.lazyderef B V3548) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3323) (begin (kl:shen.bindv V3323 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3306))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (kl:shen.lazyderef B V3548) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3323 V3548) Result))) #f))))) (begin (kl:shen.unbindv V3319 V3548) Result)))) #f))) (if (kl:shen.pvar? V3318) (begin (kl:shen.bindv V3318 (quote *) V3548) (let ((Result (let ((V3324 (kl:shen.lazyderef (cdr V3317) V3548))) (if (pair? V3324) (let ((B (car V3324))) (let ((V3325 (kl:shen.lazyderef (cdr V3324) V3548))) (if (null? V3325) (let ((V3326 (kl:shen.lazyderef (cdr V3315) V3548))) (if (null? V3326) (let ((Hyp (cdr V3306))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (kl:shen.lazyderef B V3548) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3326) (begin (kl:shen.bindv V3326 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3306))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (kl:shen.lazyderef B V3548) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3326 V3548) Result))) #f))) (if (kl:shen.pvar? V3325) (begin (kl:shen.bindv V3325 (quote ()) V3548) (let ((Result (let ((V3327 (kl:shen.lazyderef (cdr V3315) V3548))) (if (null? V3327) (let ((Hyp (cdr V3306))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (kl:shen.lazyderef B V3548) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3327) (begin (kl:shen.bindv V3327 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3306))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (kl:shen.lazyderef B V3548) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3327 V3548) Result))) #f))))) (begin (kl:shen.unbindv V3325 V3548) Result))) #f)))) (if (kl:shen.pvar? V3324) (let ((B (kl:shen.newpv V3548))) (begin (kl:shen.bindv V3324 (cons B (quote ())) V3548) (let ((Result (let ((V3328 (kl:shen.lazyderef (cdr V3315) V3548))) (if (null? V3328) (let ((Hyp (cdr V3306))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (kl:shen.lazyderef B V3548) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3328) (begin (kl:shen.bindv V3328 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3306))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (kl:shen.lazyderef B V3548) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3328 V3548) Result))) #f))))) (begin (kl:shen.unbindv V3324 V3548) Result)))) #f))))) (begin (kl:shen.unbindv V3318 V3548) Result))) #f))) (if (kl:shen.pvar? V3317) (let ((B (kl:shen.newpv V3548))) (begin (kl:shen.bindv V3317 (cons (quote *) (cons B (quote ()))) V3548) (let ((Result (let ((V3329 (kl:shen.lazyderef (cdr V3315) V3548))) (if (null? V3329) (let ((Hyp (cdr V3306))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (kl:shen.lazyderef B V3548) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3329) (begin (kl:shen.bindv V3329 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3306))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (kl:shen.lazyderef B V3548) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3329 V3548) Result))) #f))))) (begin (kl:shen.unbindv V3317 V3548) Result)))) #f)))) (if (kl:shen.pvar? V3316) (let ((A (kl:shen.newpv V3548))) (let ((B (kl:shen.newpv V3548))) (begin (kl:shen.bindv V3316 (cons A (cons (quote *) (cons B (quote ())))) V3548) (let ((Result (let ((V3330 (kl:shen.lazyderef (cdr V3315) V3548))) (if (null? V3330) (let ((Hyp (cdr V3306))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (kl:shen.lazyderef B V3548) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3330) (begin (kl:shen.bindv V3330 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3306))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (kl:shen.lazyderef B V3548) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3330 V3548) Result))) #f))))) (begin (kl:shen.unbindv V3316 V3548) Result))))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3331 (kl:shen.lazyderef V3546 V3548))) (if (pair? V3331) (let ((V3332 (kl:shen.lazyderef (car V3331) V3548))) (if (pair? V3332) (let ((V3333 (kl:shen.lazyderef (car V3332) V3548))) (if (pair? V3333) (let ((V3334 (kl:shen.lazyderef (car V3333) V3548))) (if (eq? (quote _waspvm_at_v) V3334) (let ((V3335 (kl:shen.lazyderef (cdr V3333) V3548))) (if (pair? V3335) (let ((X (car V3335))) (let ((V3336 (kl:shen.lazyderef (cdr V3335) V3548))) (if (pair? V3336) (let ((Y (car V3336))) (let ((V3337 (kl:shen.lazyderef (cdr V3336) V3548))) (if (null? V3337) (let ((V3338 (kl:shen.lazyderef (cdr V3332) V3548))) (if (pair? V3338) (let ((V3339 (kl:shen.lazyderef (car V3338) V3548))) (if (eq? (quote :) V3339) (let ((V3340 (kl:shen.lazyderef (cdr V3338) V3548))) (if (pair? V3340) (let ((V3341 (kl:shen.lazyderef (car V3340) V3548))) (if (pair? V3341) (let ((V3342 (kl:shen.lazyderef (car V3341) V3548))) (if (eq? (quote vector) V3342) (let ((V3343 (kl:shen.lazyderef (cdr V3341) V3548))) (if (pair? V3343) (let ((A (car V3343))) (let ((V3344 (kl:shen.lazyderef (cdr V3343) V3548))) (if (null? V3344) (let ((V3345 (kl:shen.lazyderef (cdr V3340) V3548))) (if (null? V3345) (let ((Hyp (cdr V3331))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3345) (begin (kl:shen.bindv V3345 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3331))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3345 V3548) Result))) #f))) (if (kl:shen.pvar? V3344) (begin (kl:shen.bindv V3344 (quote ()) V3548) (let ((Result (let ((V3346 (kl:shen.lazyderef (cdr V3340) V3548))) (if (null? V3346) (let ((Hyp (cdr V3331))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3346) (begin (kl:shen.bindv V3346 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3331))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3346 V3548) Result))) #f))))) (begin (kl:shen.unbindv V3344 V3548) Result))) #f)))) (if (kl:shen.pvar? V3343) (let ((A (kl:shen.newpv V3548))) (begin (kl:shen.bindv V3343 (cons A (quote ())) V3548) (let ((Result (let ((V3347 (kl:shen.lazyderef (cdr V3340) V3548))) (if (null? V3347) (let ((Hyp (cdr V3331))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3347) (begin (kl:shen.bindv V3347 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3331))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3347 V3548) Result))) #f))))) (begin (kl:shen.unbindv V3343 V3548) Result)))) #f))) (if (kl:shen.pvar? V3342) (begin (kl:shen.bindv V3342 (quote vector) V3548) (let ((Result (let ((V3348 (kl:shen.lazyderef (cdr V3341) V3548))) (if (pair? V3348) (let ((A (car V3348))) (let ((V3349 (kl:shen.lazyderef (cdr V3348) V3548))) (if (null? V3349) (let ((V3350 (kl:shen.lazyderef (cdr V3340) V3548))) (if (null? V3350) (let ((Hyp (cdr V3331))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3350) (begin (kl:shen.bindv V3350 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3331))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3350 V3548) Result))) #f))) (if (kl:shen.pvar? V3349) (begin (kl:shen.bindv V3349 (quote ()) V3548) (let ((Result (let ((V3351 (kl:shen.lazyderef (cdr V3340) V3548))) (if (null? V3351) (let ((Hyp (cdr V3331))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3351) (begin (kl:shen.bindv V3351 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3331))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3351 V3548) Result))) #f))))) (begin (kl:shen.unbindv V3349 V3548) Result))) #f)))) (if (kl:shen.pvar? V3348) (let ((A (kl:shen.newpv V3548))) (begin (kl:shen.bindv V3348 (cons A (quote ())) V3548) (let ((Result (let ((V3352 (kl:shen.lazyderef (cdr V3340) V3548))) (if (null? V3352) (let ((Hyp (cdr V3331))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3352) (begin (kl:shen.bindv V3352 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3331))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3352 V3548) Result))) #f))))) (begin (kl:shen.unbindv V3348 V3548) Result)))) #f))))) (begin (kl:shen.unbindv V3342 V3548) Result))) #f))) (if (kl:shen.pvar? V3341) (let ((A (kl:shen.newpv V3548))) (begin (kl:shen.bindv V3341 (cons (quote vector) (cons A (quote ()))) V3548) (let ((Result (let ((V3353 (kl:shen.lazyderef (cdr V3340) V3548))) (if (null? V3353) (let ((Hyp (cdr V3331))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3353) (begin (kl:shen.bindv V3353 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3331))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (kl:shen.lazyderef A V3548) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3548) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3353 V3548) Result))) #f))))) (begin (kl:shen.unbindv V3341 V3548) Result)))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3354 (kl:shen.lazyderef V3546 V3548))) (if (pair? V3354) (let ((V3355 (kl:shen.lazyderef (car V3354) V3548))) (if (pair? V3355) (let ((V3356 (kl:shen.lazyderef (car V3355) V3548))) (if (pair? V3356) (let ((V3357 (kl:shen.lazyderef (car V3356) V3548))) (if (eq? (quote _waspvm_at_s) V3357) (let ((V3358 (kl:shen.lazyderef (cdr V3356) V3548))) (if (pair? V3358) (let ((X (car V3358))) (let ((V3359 (kl:shen.lazyderef (cdr V3358) V3548))) (if (pair? V3359) (let ((Y (car V3359))) (let ((V3360 (kl:shen.lazyderef (cdr V3359) V3548))) (if (null? V3360) (let ((V3361 (kl:shen.lazyderef (cdr V3355) V3548))) (if (pair? V3361) (let ((V3362 (kl:shen.lazyderef (car V3361) V3548))) (if (eq? (quote :) V3362) (let ((V3363 (kl:shen.lazyderef (cdr V3361) V3548))) (if (pair? V3363) (let ((V3364 (kl:shen.lazyderef (car V3363) V3548))) (if (eq? (quote string) V3364) (let ((V3365 (kl:shen.lazyderef (cdr V3363) V3548))) (if (null? V3365) (let ((Hyp (cdr V3354))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3365) (begin (kl:shen.bindv V3365 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3354))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3365 V3548) Result))) #f))) (if (kl:shen.pvar? V3364) (begin (kl:shen.bindv V3364 (quote string) V3548) (let ((Result (let ((V3366 (kl:shen.lazyderef (cdr V3363) V3548))) (if (null? V3366) (let ((Hyp (cdr V3354))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))) (if (kl:shen.pvar? V3366) (begin (kl:shen.bindv V3366 (quote ()) V3548) (let ((Result (let ((Hyp (cdr V3354))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (cons (kl:shen.lazyderef X V3548) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3548) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V3548))) V3548 V3549))))) (begin (kl:shen.unbindv V3366 V3548) Result))) #f))))) (begin (kl:shen.unbindv V3364 V3548) Result))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((V3367 (kl:shen.lazyderef V3546 V3548))) (if (pair? V3367) (let ((X (car V3367))) (let ((Hyp (cdr V3367))) (let ((NewHyps (kl:shen.newpv V3548))) (begin (kl:shen.incinfs) (kl:bind V3547 (cons (kl:shen.lazyderef X V3548) (kl:shen.lazyderef NewHyps V3548)) V3548 (lambda () (kl:shen.t*-hyps Hyp NewHyps V3548 V3549))))))) #f)) Case)) Case)) Case)) Case))) (quote shen.t*-hyps))
(begin (register-function-arity (quote shen.show) 4) (define (kl:shen.show V3566 V3567 V3568 V3569) (cond ((assert-boolean (kl:value (quote shen.*spy*))) (begin (kl:shen.line) (begin (kl:shen.show-p (kl:shen.deref V3566 V3568)) (begin (kl:nl 1) (begin (kl:nl 1) (begin (kl:shen.show-assumptions (kl:shen.deref V3567 V3568) 1) (begin (kl:shen.prhush "\n> " (kl:stoutput)) (begin (kl:shen.pause-for-user) (kl:thaw V3569))))))))) (#t (kl:thaw V3569)))) (quote shen.show))
(begin (register-function-arity (quote shen.line) 0) (define (kl:shen.line) (let ((Infs (kl:inferences))) (kl:shen.prhush (string-append "____________________________________________________________ " (kl:shen.app Infs (string-append " inference" (kl:shen.app (if (kl:= 1 Infs) "" "s") " \n?- " (quote shen.a))) (quote shen.a))) (kl:stoutput)))) (quote shen.line))
(begin (register-function-arity (quote shen.show-p) 1) (define (kl:shen.show-p V3571) (cond ((and (pair? V3571) (and (pair? (cdr V3571)) (and (eq? (quote :) (car (cdr V3571))) (and (pair? (cdr (cdr V3571))) (null? (cdr (cdr (cdr V3571)))))))) (kl:shen.prhush (kl:shen.app (car V3571) (string-append " : " (kl:shen.app (car (cdr (cdr V3571))) "" (quote shen.r))) (quote shen.r)) (kl:stoutput))) (#t (kl:shen.prhush (kl:shen.app V3571 "" (quote shen.r)) (kl:stoutput))))) (quote shen.show-p))
(begin (register-function-arity (quote shen.show-assumptions) 2) (define (kl:shen.show-assumptions V3576 V3577) (cond ((null? V3576) (quote shen.skip)) ((pair? V3576) (begin (kl:shen.prhush (kl:shen.app V3577 ". " (quote shen.a)) (kl:stoutput)) (begin (kl:shen.show-p (car V3576)) (begin (kl:nl 1) (kl:shen.show-assumptions (cdr V3576) (+ V3577 1)))))) (#t (kl:shen.f_error (quote shen.show-assumptions))))) (quote shen.show-assumptions))
(begin (register-function-arity (quote shen.pause-for-user) 0) (define (kl:shen.pause-for-user) (let ((Byte (read-u8 (kl:stinput)))) (if (kl:= Byte 94) (simple-error "input aborted\n") (kl:nl 1)))) (quote shen.pause-for-user))
(begin (register-function-arity (quote shen.typedf?) 1) (define (kl:shen.typedf? V3579) (pair? (kl:assoc V3579 (kl:value (quote shen.*signedfuncs*))))) (quote shen.typedf?))
(begin (register-function-arity (quote shen.sigf) 1) (define (kl:shen.sigf V3581) (kl:concat (quote shen.type-signature-of-) V3581)) (quote shen.sigf))
(begin (register-function-arity (quote shen.placeholder) 0) (define (kl:shen.placeholder) (kl:gensym (quote &&))) (quote shen.placeholder))
(begin (register-function-arity (quote shen.base) 4) (define (kl:shen.base V3586 V3587 V3588 V3589) (let ((Case (let ((V3270 (kl:shen.lazyderef V3587 V3588))) (if (eq? (quote number) V3270) (begin (kl:shen.incinfs) (kl:fwhen (number? (kl:shen.lazyderef V3586 V3588)) V3588 V3589)) (if (kl:shen.pvar? V3270) (begin (kl:shen.bindv V3270 (quote number) V3588) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (number? (kl:shen.lazyderef V3586 V3588)) V3588 V3589)))) (begin (kl:shen.unbindv V3270 V3588) Result))) #f))))) (if (kl:= Case #f) (let ((Case (let ((V3271 (kl:shen.lazyderef V3587 V3588))) (if (eq? (quote boolean) V3271) (begin (kl:shen.incinfs) (kl:fwhen (kl:boolean? (kl:shen.lazyderef V3586 V3588)) V3588 V3589)) (if (kl:shen.pvar? V3271) (begin (kl:shen.bindv V3271 (quote boolean) V3588) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (kl:boolean? (kl:shen.lazyderef V3586 V3588)) V3588 V3589)))) (begin (kl:shen.unbindv V3271 V3588) Result))) #f))))) (if (kl:= Case #f) (let ((Case (let ((V3272 (kl:shen.lazyderef V3587 V3588))) (if (eq? (quote string) V3272) (begin (kl:shen.incinfs) (kl:fwhen (string? (kl:shen.lazyderef V3586 V3588)) V3588 V3589)) (if (kl:shen.pvar? V3272) (begin (kl:shen.bindv V3272 (quote string) V3588) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (string? (kl:shen.lazyderef V3586 V3588)) V3588 V3589)))) (begin (kl:shen.unbindv V3272 V3588) Result))) #f))))) (if (kl:= Case #f) (let ((Case (let ((V3273 (kl:shen.lazyderef V3587 V3588))) (if (eq? (quote symbol) V3273) (begin (kl:shen.incinfs) (kl:fwhen (kl:symbol? (kl:shen.lazyderef V3586 V3588)) V3588 (lambda () (kl:fwhen (kl:not (kl:shen.ue? (kl:shen.lazyderef V3586 V3588))) V3588 V3589)))) (if (kl:shen.pvar? V3273) (begin (kl:shen.bindv V3273 (quote symbol) V3588) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (kl:symbol? (kl:shen.lazyderef V3586 V3588)) V3588 (lambda () (kl:fwhen (kl:not (kl:shen.ue? (kl:shen.lazyderef V3586 V3588))) V3588 V3589)))))) (begin (kl:shen.unbindv V3273 V3588) Result))) #f))))) (if (kl:= Case #f) (let ((V3274 (kl:shen.lazyderef V3586 V3588))) (if (null? V3274) (let ((V3275 (kl:shen.lazyderef V3587 V3588))) (if (pair? V3275) (let ((V3276 (kl:shen.lazyderef (car V3275) V3588))) (if (eq? (quote list) V3276) (let ((V3277 (kl:shen.lazyderef (cdr V3275) V3588))) (if (pair? V3277) (let ((A (car V3277))) (let ((V3278 (kl:shen.lazyderef (cdr V3277) V3588))) (if (null? V3278) (begin (kl:shen.incinfs) (kl:thaw V3589)) (if (kl:shen.pvar? V3278) (begin (kl:shen.bindv V3278 (quote ()) V3588) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3589)))) (begin (kl:shen.unbindv V3278 V3588) Result))) #f)))) (if (kl:shen.pvar? V3277) (let ((A (kl:shen.newpv V3588))) (begin (kl:shen.bindv V3277 (cons A (quote ())) V3588) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3589)))) (begin (kl:shen.unbindv V3277 V3588) Result)))) #f))) (if (kl:shen.pvar? V3276) (begin (kl:shen.bindv V3276 (quote list) V3588) (let ((Result (let ((V3279 (kl:shen.lazyderef (cdr V3275) V3588))) (if (pair? V3279) (let ((A (car V3279))) (let ((V3280 (kl:shen.lazyderef (cdr V3279) V3588))) (if (null? V3280) (begin (kl:shen.incinfs) (kl:thaw V3589)) (if (kl:shen.pvar? V3280) (begin (kl:shen.bindv V3280 (quote ()) V3588) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3589)))) (begin (kl:shen.unbindv V3280 V3588) Result))) #f)))) (if (kl:shen.pvar? V3279) (let ((A (kl:shen.newpv V3588))) (begin (kl:shen.bindv V3279 (cons A (quote ())) V3588) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3589)))) (begin (kl:shen.unbindv V3279 V3588) Result)))) #f))))) (begin (kl:shen.unbindv V3276 V3588) Result))) #f))) (if (kl:shen.pvar? V3275) (let ((A (kl:shen.newpv V3588))) (begin (kl:shen.bindv V3275 (cons (quote list) (cons A (quote ()))) V3588) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3589)))) (begin (kl:shen.unbindv V3275 V3588) Result)))) #f))) #f)) Case)) Case)) Case)) Case))) (quote shen.base))
(begin (register-function-arity (quote shen.by_hypothesis) 5) (define (kl:shen.by_hypothesis V3595 V3596 V3597 V3598 V3599) (let ((Case (let ((V3261 (kl:shen.lazyderef V3597 V3598))) (if (pair? V3261) (let ((V3262 (kl:shen.lazyderef (car V3261) V3598))) (if (pair? V3262) (let ((Y (car V3262))) (let ((V3263 (kl:shen.lazyderef (cdr V3262) V3598))) (if (pair? V3263) (let ((V3264 (kl:shen.lazyderef (car V3263) V3598))) (if (eq? (quote :) V3264) (let ((V3265 (kl:shen.lazyderef (cdr V3263) V3598))) (if (pair? V3265) (let ((B (car V3265))) (let ((V3266 (kl:shen.lazyderef (cdr V3265) V3598))) (if (null? V3266) (begin (kl:shen.incinfs) (kl:identical V3595 Y V3598 (lambda () (kl:unify! V3596 B V3598 V3599)))) #f))) #f)) #f)) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((V3267 (kl:shen.lazyderef V3597 V3598))) (if (pair? V3267) (let ((Hyp (cdr V3267))) (begin (kl:shen.incinfs) (kl:shen.by_hypothesis V3595 V3596 Hyp V3598 V3599))) #f)) Case))) (quote shen.by_hypothesis))
(begin (register-function-arity (quote shen.t*-def) 5) (define (kl:shen.t*-def V3605 V3606 V3607 V3608 V3609) (let ((V3255 (kl:shen.lazyderef V3605 V3608))) (if (pair? V3255) (let ((V3256 (kl:shen.lazyderef (car V3255) V3608))) (if (eq? (quote define) V3256) (let ((V3257 (kl:shen.lazyderef (cdr V3255) V3608))) (if (pair? V3257) (let ((F (car V3257))) (let ((X (cdr V3257))) (let ((Y (kl:shen.newpv V3608))) (let ((E (kl:shen.newpv V3608))) (begin (kl:shen.incinfs) (kl:shen.t*-defh (kl:compile (lambda (Y) (kl:shen.<sig+rules> Y)) X (lambda (E) (if (pair? E) (simple-error (string-append "parse error here: " (kl:shen.app E "\n" (quote shen.s)))) (simple-error "parse error\n")))) F V3606 V3607 V3608 V3609)))))) #f)) #f)) #f))) (quote shen.t*-def))
(begin (register-function-arity (quote shen.t*-defh) 6) (define (kl:shen.t*-defh V3616 V3617 V3618 V3619 V3620 V3621) (let ((V3251 (kl:shen.lazyderef V3616 V3620))) (if (pair? V3251) (let ((Sig (car V3251))) (let ((Rules (cdr V3251))) (begin (kl:shen.incinfs) (kl:shen.t*-defhh Sig (kl:shen.ue-sig Sig) V3617 V3618 V3619 Rules V3620 V3621)))) #f))) (quote shen.t*-defh))
(begin (register-function-arity (quote shen.t*-defhh) 8) (define (kl:shen.t*-defhh V3630 V3631 V3632 V3633 V3634 V3635 V3636 V3637) (begin (kl:shen.incinfs) (kl:shen.t*-rules V3635 V3631 1 V3632 (cons (cons V3632 (cons (quote :) (cons V3631 (quote ())))) V3634) V3636 (lambda () (kl:shen.memo V3632 V3630 V3633 V3636 V3637))))) (quote shen.t*-defhh))
(begin (register-function-arity (quote shen.memo) 5) (define (kl:shen.memo V3643 V3644 V3645 V3646 V3647) (let ((Jnk (kl:shen.newpv V3646))) (begin (kl:shen.incinfs) (kl:unify! V3645 V3644 V3646 (lambda () (kl:bind Jnk (kl:declare (kl:shen.lazyderef V3643 V3646) (kl:shen.lazyderef V3645 V3646)) V3646 V3647)))))) (quote shen.memo))
(begin (register-function-arity (quote shen.<sig+rules>) 1) (define (kl:shen.<sig+rules> V3649) (let ((Parse_shen.<signature> (kl:shen.<signature> V3649))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature>)) (let ((Parse_shen.<non-ll-rules> (kl:shen.<non-ll-rules> Parse_shen.<signature>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<non-ll-rules>)) (kl:shen.pair (car Parse_shen.<non-ll-rules>) (cons (kl:shen.hdtl Parse_shen.<signature>) (kl:shen.hdtl Parse_shen.<non-ll-rules>))) (kl:fail))) (kl:fail)))) (quote shen.<sig+rules>))
(begin (register-function-arity (quote shen.<non-ll-rules>) 1) (define (kl:shen.<non-ll-rules> V3651) (let ((YaccParse (let ((Parse_shen.<rule> (kl:shen.<rule> V3651))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (let ((Parse_shen.<non-ll-rules> (kl:shen.<non-ll-rules> Parse_shen.<rule>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<non-ll-rules>)) (kl:shen.pair (car Parse_shen.<non-ll-rules>) (cons (kl:shen.hdtl Parse_shen.<rule>) (kl:shen.hdtl Parse_shen.<non-ll-rules>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<rule> (kl:shen.<rule> V3651))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (kl:shen.pair (car Parse_shen.<rule>) (cons (kl:shen.hdtl Parse_shen.<rule>) (quote ()))) (kl:fail))) YaccParse))) (quote shen.<non-ll-rules>))
(begin (register-function-arity (quote shen.ue) 1) (define (kl:shen.ue V3653) (cond ((and (pair? V3653) (and (pair? (cdr V3653)) (and (null? (cdr (cdr V3653))) (eq? (car V3653) (quote protect))))) V3653) ((pair? V3653) (kl:map (lambda (Z) (kl:shen.ue Z)) V3653)) ((kl:variable? V3653) (kl:concat (quote &&) V3653)) (#t V3653))) (quote shen.ue))
(begin (register-function-arity (quote shen.ue-sig) 1) (define (kl:shen.ue-sig V3655) (cond ((pair? V3655) (kl:map (lambda (Z) (kl:shen.ue-sig Z)) V3655)) ((kl:variable? V3655) (kl:concat (quote &&&) V3655)) (#t V3655))) (quote shen.ue-sig))
(begin (register-function-arity (quote shen.ues) 1) (define (kl:shen.ues V3661) (cond ((assert-boolean (kl:shen.ue? V3661)) (cons V3661 (quote ()))) ((pair? V3661) (kl:union (kl:shen.ues (car V3661)) (kl:shen.ues (cdr V3661)))) (#t (quote ())))) (quote shen.ues))
(begin (register-function-arity (quote shen.ue?) 1) (define (kl:shen.ue? V3663) (and (kl:symbol? V3663) (assert-boolean (kl:shen.ue-h? (kl:str V3663))))) (quote shen.ue?))
(begin (register-function-arity (quote shen.ue-h?) 1) (define (kl:shen.ue-h? V3671) (cond ((and (assert-boolean (kl:shen.+string? V3671)) (and (equal? "&" (make-string 1 (string-ref V3671 0))) (and (assert-boolean (kl:shen.+string? (string-tail V3671 1))) (equal? "&" (make-string 1 (string-ref (string-tail V3671 1) 0)))))) #t) (#t #f))) (quote shen.ue-h?))
(begin (register-function-arity (quote shen.t*-rules) 7) (define (kl:shen.t*-rules V3679 V3680 V3681 V3682 V3683 V3684 V3685) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (let ((V3235 (kl:shen.lazyderef V3679 V3684))) (if (null? V3235) (begin (kl:shen.incinfs) (kl:thaw V3685)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3236 (kl:shen.lazyderef V3679 V3684))) (if (pair? V3236) (let ((Rule (car V3236))) (let ((Rules (cdr V3236))) (begin (kl:shen.incinfs) (kl:shen.t*-rule (kl:shen.ue Rule) V3680 V3683 V3684 (lambda () (kl:cut Throwcontrol V3684 (lambda () (kl:shen.t*-rules Rules V3680 (+ V3681 1) V3682 V3683 V3684 V3685)))))))) #f)))) (if (kl:= Case #f) (let ((Err (kl:shen.newpv V3684))) (begin (kl:shen.incinfs) (kl:bind Err (simple-error (string-append "type error in rule " (kl:shen.app (kl:shen.lazyderef V3681 V3684) (string-append " of " (kl:shen.app (kl:shen.lazyderef V3682 V3684) "" (quote shen.a))) (quote shen.a)))) V3684 V3685))) Case)) Case))))) (quote shen.t*-rules))
(begin (register-function-arity (quote shen.t*-rule) 5) (define (kl:shen.t*-rule V3691 V3692 V3693 V3694 V3695) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((V3227 (kl:shen.lazyderef V3691 V3694))) (if (pair? V3227) (let ((Patterns (car V3227))) (let ((V3228 (kl:shen.lazyderef (cdr V3227) V3694))) (if (pair? V3228) (let ((Action (car V3228))) (let ((V3229 (kl:shen.lazyderef (cdr V3228) V3694))) (if (null? V3229) (let ((NewHyps (kl:shen.newpv V3694))) (begin (kl:shen.incinfs) (kl:shen.newhyps (kl:shen.placeholders Patterns) V3693 NewHyps V3694 (lambda () (kl:shen.t*-patterns Patterns V3692 NewHyps V3694 (lambda () (kl:cut Throwcontrol V3694 (lambda () (kl:shen.t*-action (kl:shen.curry (kl:shen.ue Action)) (kl:shen.result-type Patterns V3692) (kl:shen.patthyps Patterns V3692 V3693) V3694 V3695))))))))) #f))) #f))) #f))))) (quote shen.t*-rule))
(begin (register-function-arity (quote shen.placeholders) 1) (define (kl:shen.placeholders V3701) (cond ((assert-boolean (kl:shen.ue? V3701)) (cons V3701 (quote ()))) ((pair? V3701) (kl:union (kl:shen.placeholders (car V3701)) (kl:shen.placeholders (cdr V3701)))) (#t (quote ())))) (quote shen.placeholders))
(begin (register-function-arity (quote shen.newhyps) 5) (define (kl:shen.newhyps V3707 V3708 V3709 V3710 V3711) (let ((Case (let ((V3214 (kl:shen.lazyderef V3707 V3710))) (if (null? V3214) (begin (kl:shen.incinfs) (kl:unify! V3709 V3708 V3710 V3711)) #f)))) (if (kl:= Case #f) (let ((V3215 (kl:shen.lazyderef V3707 V3710))) (if (pair? V3215) (let ((V3210 (car V3215))) (let ((Vs (cdr V3215))) (let ((V3216 (kl:shen.lazyderef V3709 V3710))) (if (pair? V3216) (let ((V3217 (kl:shen.lazyderef (car V3216) V3710))) (if (pair? V3217) (let ((V (car V3217))) (let ((V3218 (kl:shen.lazyderef (cdr V3217) V3710))) (if (pair? V3218) (let ((V3219 (kl:shen.lazyderef (car V3218) V3710))) (if (eq? (quote :) V3219) (let ((V3220 (kl:shen.lazyderef (cdr V3218) V3710))) (if (pair? V3220) (let ((A (car V3220))) (let ((V3221 (kl:shen.lazyderef (cdr V3220) V3710))) (if (null? V3221) (let ((NewHyp (cdr V3216))) (begin (kl:shen.incinfs) (kl:unify! V V3210 V3710 (lambda () (kl:shen.newhyps Vs V3708 NewHyp V3710 V3711))))) (if (kl:shen.pvar? V3221) (begin (kl:shen.bindv V3221 (quote ()) V3710) (let ((Result (let ((NewHyp (cdr V3216))) (begin (kl:shen.incinfs) (kl:unify! V V3210 V3710 (lambda () (kl:shen.newhyps Vs V3708 NewHyp V3710 V3711))))))) (begin (kl:shen.unbindv V3221 V3710) Result))) #f)))) (if (kl:shen.pvar? V3220) (let ((A (kl:shen.newpv V3710))) (begin (kl:shen.bindv V3220 (cons A (quote ())) V3710) (let ((Result (let ((NewHyp (cdr V3216))) (begin (kl:shen.incinfs) (kl:unify! V V3210 V3710 (lambda () (kl:shen.newhyps Vs V3708 NewHyp V3710 V3711))))))) (begin (kl:shen.unbindv V3220 V3710) Result)))) #f))) (if (kl:shen.pvar? V3219) (begin (kl:shen.bindv V3219 (quote :) V3710) (let ((Result (let ((V3222 (kl:shen.lazyderef (cdr V3218) V3710))) (if (pair? V3222) (let ((A (car V3222))) (let ((V3223 (kl:shen.lazyderef (cdr V3222) V3710))) (if (null? V3223) (let ((NewHyp (cdr V3216))) (begin (kl:shen.incinfs) (kl:unify! V V3210 V3710 (lambda () (kl:shen.newhyps Vs V3708 NewHyp V3710 V3711))))) (if (kl:shen.pvar? V3223) (begin (kl:shen.bindv V3223 (quote ()) V3710) (let ((Result (let ((NewHyp (cdr V3216))) (begin (kl:shen.incinfs) (kl:unify! V V3210 V3710 (lambda () (kl:shen.newhyps Vs V3708 NewHyp V3710 V3711))))))) (begin (kl:shen.unbindv V3223 V3710) Result))) #f)))) (if (kl:shen.pvar? V3222) (let ((A (kl:shen.newpv V3710))) (begin (kl:shen.bindv V3222 (cons A (quote ())) V3710) (let ((Result (let ((NewHyp (cdr V3216))) (begin (kl:shen.incinfs) (kl:unify! V V3210 V3710 (lambda () (kl:shen.newhyps Vs V3708 NewHyp V3710 V3711))))))) (begin (kl:shen.unbindv V3222 V3710) Result)))) #f))))) (begin (kl:shen.unbindv V3219 V3710) Result))) #f))) (if (kl:shen.pvar? V3218) (let ((A (kl:shen.newpv V3710))) (begin (kl:shen.bindv V3218 (cons (quote :) (cons A (quote ()))) V3710) (let ((Result (let ((NewHyp (cdr V3216))) (begin (kl:shen.incinfs) (kl:unify! V V3210 V3710 (lambda () (kl:shen.newhyps Vs V3708 NewHyp V3710 V3711))))))) (begin (kl:shen.unbindv V3218 V3710) Result)))) #f)))) (if (kl:shen.pvar? V3217) (let ((V (kl:shen.newpv V3710))) (let ((A (kl:shen.newpv V3710))) (begin (kl:shen.bindv V3217 (cons V (cons (quote :) (cons A (quote ())))) V3710) (let ((Result (let ((NewHyp (cdr V3216))) (begin (kl:shen.incinfs) (kl:unify! V V3210 V3710 (lambda () (kl:shen.newhyps Vs V3708 NewHyp V3710 V3711))))))) (begin (kl:shen.unbindv V3217 V3710) Result))))) #f))) (if (kl:shen.pvar? V3216) (let ((V (kl:shen.newpv V3710))) (let ((A (kl:shen.newpv V3710))) (let ((NewHyp (kl:shen.newpv V3710))) (begin (kl:shen.bindv V3216 (cons (cons V (cons (quote :) (cons A (quote ())))) NewHyp) V3710) (let ((Result (begin (kl:shen.incinfs) (kl:unify! V V3210 V3710 (lambda () (kl:shen.newhyps Vs V3708 NewHyp V3710 V3711)))))) (begin (kl:shen.unbindv V3216 V3710) Result)))))) #f))))) #f)) Case))) (quote shen.newhyps))
(begin (register-function-arity (quote shen.patthyps) 3) (define (kl:shen.patthyps V3717 V3718 V3719) (cond ((null? V3717) V3719) ((and (pair? V3717) (and (pair? V3718) (and (pair? (cdr V3718)) (and (eq? (quote -->) (car (cdr V3718))) (and (pair? (cdr (cdr V3718))) (null? (cdr (cdr (cdr V3718))))))))) (kl:adjoin (cons (car V3717) (cons (quote :) (cons (car V3718) (quote ())))) (kl:shen.patthyps (cdr V3717) (car (cdr (cdr V3718))) V3719))) (#t (kl:shen.f_error (quote shen.patthyps))))) (quote shen.patthyps))
(begin (register-function-arity (quote shen.result-type) 2) (define (kl:shen.result-type V3726 V3727) (cond ((and (null? V3726) (and (pair? V3727) (and (eq? (quote -->) (car V3727)) (and (pair? (cdr V3727)) (null? (cdr (cdr V3727))))))) (car (cdr V3727))) ((null? V3726) V3727) ((and (pair? V3726) (and (pair? V3727) (and (pair? (cdr V3727)) (and (eq? (quote -->) (car (cdr V3727))) (and (pair? (cdr (cdr V3727))) (null? (cdr (cdr (cdr V3727))))))))) (kl:shen.result-type (cdr V3726) (car (cdr (cdr V3727))))) (#t (kl:shen.f_error (quote shen.result-type))))) (quote shen.result-type))
(begin (register-function-arity (quote shen.t*-patterns) 5) (define (kl:shen.t*-patterns V3733 V3734 V3735 V3736 V3737) (let ((Case (let ((V3202 (kl:shen.lazyderef V3733 V3736))) (if (null? V3202) (begin (kl:shen.incinfs) (kl:thaw V3737)) #f)))) (if (kl:= Case #f) (let ((V3203 (kl:shen.lazyderef V3733 V3736))) (if (pair? V3203) (let ((Pattern (car V3203))) (let ((Patterns (cdr V3203))) (let ((V3204 (kl:shen.lazyderef V3734 V3736))) (if (pair? V3204) (let ((A (car V3204))) (let ((V3205 (kl:shen.lazyderef (cdr V3204) V3736))) (if (pair? V3205) (let ((V3206 (kl:shen.lazyderef (car V3205) V3736))) (if (eq? (quote -->) V3206) (let ((V3207 (kl:shen.lazyderef (cdr V3205) V3736))) (if (pair? V3207) (let ((B (car V3207))) (let ((V3208 (kl:shen.lazyderef (cdr V3207) V3736))) (if (null? V3208) (begin (kl:shen.incinfs) (kl:shen.t* (cons Pattern (cons (quote :) (cons A (quote ())))) V3735 V3736 (lambda () (kl:shen.t*-patterns Patterns B V3735 V3736 V3737)))) #f))) #f)) #f)) #f))) #f)))) #f)) Case))) (quote shen.t*-patterns))
(begin (register-function-arity (quote shen.t*-action) 5) (define (kl:shen.t*-action V3743 V3744 V3745 V3746 V3747) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (let ((V3179 (kl:shen.lazyderef V3743 V3746))) (if (pair? V3179) (let ((V3180 (kl:shen.lazyderef (car V3179) V3746))) (if (eq? (quote where) V3180) (let ((V3181 (kl:shen.lazyderef (cdr V3179) V3746))) (if (pair? V3181) (let ((P (car V3181))) (let ((V3182 (kl:shen.lazyderef (cdr V3181) V3746))) (if (pair? V3182) (let ((Action (car V3182))) (let ((V3183 (kl:shen.lazyderef (cdr V3182) V3746))) (if (null? V3183) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3746 (lambda () (kl:shen.t* (cons P (cons (quote :) (cons (quote boolean) (quote ())))) V3745 V3746 (lambda () (kl:cut Throwcontrol V3746 (lambda () (kl:shen.t*-action Action V3744 (cons (cons P (cons (quote :) (cons (quote verified) (quote ())))) V3745) V3746 V3747)))))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3184 (kl:shen.lazyderef V3743 V3746))) (if (pair? V3184) (let ((V3185 (kl:shen.lazyderef (car V3184) V3746))) (if (eq? (quote shen.choicepoint!) V3185) (let ((V3186 (kl:shen.lazyderef (cdr V3184) V3746))) (if (pair? V3186) (let ((V3187 (kl:shen.lazyderef (car V3186) V3746))) (if (pair? V3187) (let ((V3188 (kl:shen.lazyderef (car V3187) V3746))) (if (pair? V3188) (let ((V3189 (kl:shen.lazyderef (car V3188) V3746))) (if (eq? (quote fail-if) V3189) (let ((V3190 (kl:shen.lazyderef (cdr V3188) V3746))) (if (pair? V3190) (let ((F (car V3190))) (let ((V3191 (kl:shen.lazyderef (cdr V3190) V3746))) (if (null? V3191) (let ((V3192 (kl:shen.lazyderef (cdr V3187) V3746))) (if (pair? V3192) (let ((Action (car V3192))) (let ((V3193 (kl:shen.lazyderef (cdr V3192) V3746))) (if (null? V3193) (let ((V3194 (kl:shen.lazyderef (cdr V3186) V3746))) (if (null? V3194) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3746 (lambda () (kl:shen.t*-action (cons (quote where) (cons (cons (quote not) (cons (cons F (cons Action (quote ()))) (quote ()))) (cons Action (quote ())))) V3744 V3745 V3746 V3747)))) #f)) #f))) #f)) #f))) #f)) #f)) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3195 (kl:shen.lazyderef V3743 V3746))) (if (pair? V3195) (let ((V3196 (kl:shen.lazyderef (car V3195) V3746))) (if (eq? (quote shen.choicepoint!) V3196) (let ((V3197 (kl:shen.lazyderef (cdr V3195) V3746))) (if (pair? V3197) (let ((Action (car V3197))) (let ((V3198 (kl:shen.lazyderef (cdr V3197) V3746))) (if (null? V3198) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3746 (lambda () (kl:shen.t*-action (cons (quote where) (cons (cons (quote not) (cons (cons (cons (quote =) (cons Action (quote ()))) (cons (cons (quote fail) (quote ())) (quote ()))) (quote ()))) (cons Action (quote ())))) V3744 V3745 V3746 V3747)))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (begin (kl:shen.incinfs) (kl:shen.t* (cons V3743 (cons (quote :) (cons V3744 (quote ())))) V3745 V3746 V3747)) Case)) Case)) Case))))) (quote shen.t*-action))
(begin (register-function-arity (quote findall) 5) (define (kl:findall V3753 V3754 V3755 V3756 V3757) (let ((B (kl:shen.newpv V3756))) (let ((A (kl:shen.newpv V3756))) (begin (kl:shen.incinfs) (kl:bind A (kl:gensym (quote shen.a)) V3756 (lambda () (kl:bind B (kl:set (kl:shen.lazyderef A V3756) (quote ())) V3756 (lambda () (kl:shen.findallhelp V3753 V3754 V3755 A V3756 V3757))))))))) (quote findall))
(begin (register-function-arity (quote shen.findallhelp) 6) (define (kl:shen.findallhelp V3764 V3765 V3766 V3767 V3768 V3769) (let ((Case (begin (kl:shen.incinfs) (kl:call V3765 V3768 (lambda () (kl:shen.remember V3767 V3764 V3768 (lambda () (kl:fwhen #f V3768 V3769)))))))) (if (kl:= Case #f) (begin (kl:shen.incinfs) (kl:bind V3766 (kl:value (kl:shen.lazyderef V3767 V3768)) V3768 V3769)) Case))) (quote shen.findallhelp))
(begin (register-function-arity (quote shen.remember) 4) (define (kl:shen.remember V3774 V3775 V3776 V3777) (let ((B (kl:shen.newpv V3776))) (begin (kl:shen.incinfs) (kl:bind B (kl:set (kl:shen.deref V3774 V3776) (cons (kl:shen.deref V3775 V3776) (kl:value (kl:shen.deref V3774 V3776)))) V3776 V3777)))) (quote shen.remember))
