(module "compiled/t-star.kl")
"Copyright (c) 2010-2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
(begin (register-function-arity (quote shen.typecheck) 2) (define (kl:shen.typecheck V3834 V3835) (let ((Curry (kl:shen.curry V3834))) (let ((ProcessN (kl:shen.start-new-prolog-process))) (let ((Type (kl:shen.insert-prolog-variables (kl:shen.demodulate (kl:shen.curry-type V3835)) ProcessN))) (let ((Continuation (lambda () (kl:return Type ProcessN (quote shen.void))))) (kl:shen.t* (cons Curry (cons (quote :) (cons Type (quote ())))) (quote ()) ProcessN Continuation)))))) (export shen.typecheck) (quote shen.typecheck))
(begin (register-function-arity (quote shen.curry) 1) (define (kl:shen.curry V3837) (cond ((and (pair? V3837) (assert-boolean (kl:shen.special? (car V3837)))) (cons (car V3837) (kl:map (lambda (Y) (kl:shen.curry Y)) (cdr V3837)))) ((and (pair? V3837) (and (pair? (cdr V3837)) (assert-boolean (kl:shen.extraspecial? (car V3837))))) V3837) ((and (pair? V3837) (and (eq? (quote type) (car V3837)) (and (pair? (cdr V3837)) (and (pair? (cdr (cdr V3837))) (null? (cdr (cdr (cdr V3837)))))))) (cons (quote type) (cons (kl:shen.curry (car (cdr V3837))) (cdr (cdr V3837))))) ((and (pair? V3837) (and (pair? (cdr V3837)) (pair? (cdr (cdr V3837))))) (kl:shen.curry (cons (cons (car V3837) (cons (car (cdr V3837)) (quote ()))) (cdr (cdr V3837))))) ((and (pair? V3837) (and (pair? (cdr V3837)) (null? (cdr (cdr V3837))))) (cons (kl:shen.curry (car V3837)) (cons (kl:shen.curry (car (cdr V3837))) (quote ())))) (#t V3837))) (export shen.curry) (quote shen.curry))
(begin (register-function-arity (quote shen.special?) 1) (define (kl:shen.special? V3839) (kl:element? V3839 (kl:value (quote shen.*special*)))) (export shen.special?) (quote shen.special?))
(begin (register-function-arity (quote shen.extraspecial?) 1) (define (kl:shen.extraspecial? V3841) (kl:element? V3841 (kl:value (quote shen.*extraspecial*)))) (export shen.extraspecial?) (quote shen.extraspecial?))
(begin (register-function-arity (quote shen.t*) 4) (define (kl:shen.t* V3846 V3847 V3848 V3849) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (let ((Error (kl:shen.newpv V3848))) (begin (kl:shen.incinfs) (kl:fwhen (kl:shen.maxinfexceeded?) V3848 (lambda () (kl:bind Error (kl:shen.errormaxinfs) V3848 V3849))))))) (if (kl:= Case #f) (let ((Case (let ((V3826 (kl:shen.lazyderef V3846 V3848))) (if (eq? (quote fail) V3826) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3848 (lambda () (kl:shen.prolog-failure V3848 V3849)))) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3827 (kl:shen.lazyderef V3846 V3848))) (if (pair? V3827) (let ((X (car V3827))) (let ((V3828 (kl:shen.lazyderef (cdr V3827) V3848))) (if (pair? V3828) (let ((V3829 (kl:shen.lazyderef (car V3828) V3848))) (if (eq? (quote :) V3829) (let ((V3830 (kl:shen.lazyderef (cdr V3828) V3848))) (if (pair? V3830) (let ((A (car V3830))) (let ((V3831 (kl:shen.lazyderef (cdr V3830) V3848))) (if (null? V3831) (begin (kl:shen.incinfs) (kl:fwhen (kl:shen.type-theory-enabled?) V3848 (lambda () (kl:cut Throwcontrol V3848 (lambda () (kl:shen.th* X A V3847 V3848 V3849)))))) #f))) #f)) #f)) #f))) #f)))) (if (kl:= Case #f) (let ((Datatypes (kl:shen.newpv V3848))) (begin (kl:shen.incinfs) (kl:shen.show V3846 V3847 V3848 (lambda () (kl:bind Datatypes (kl:value (quote shen.*datatypes*)) V3848 (lambda () (kl:shen.udefs* V3846 V3847 Datatypes V3848 V3849))))))) Case)) Case)) Case))))) (export shen.t*) (quote shen.t*))
(begin (register-function-arity (quote shen.type-theory-enabled?) 0) (define (kl:shen.type-theory-enabled?) (kl:value (quote shen.*shen-type-theory-enabled?*))) (export shen.type-theory-enabled?) (quote shen.type-theory-enabled?))
(begin (register-function-arity (quote enable-type-theory) 1) (define (kl:enable-type-theory V3855) (cond ((eq? (quote +) V3855) (kl:set (quote shen.*shen-type-theory-enabled?*) #t)) ((eq? (quote -) V3855) (kl:set (quote shen.*shen-type-theory-enabled?*) #f)) (#t (simple-error "enable-type-theory expects a + or a -\n")))) (export enable-type-theory) (quote enable-type-theory))
(begin (register-function-arity (quote shen.prolog-failure) 2) (define (kl:shen.prolog-failure V3866 V3867) #f) (export shen.prolog-failure) (quote shen.prolog-failure))
(begin (register-function-arity (quote shen.maxinfexceeded?) 0) (define (kl:shen.maxinfexceeded?) (> (kl:inferences) (kl:value (quote shen.*maxinferences*)))) (export shen.maxinfexceeded?) (quote shen.maxinfexceeded?))
(begin (register-function-arity (quote shen.errormaxinfs) 0) (define (kl:shen.errormaxinfs) (simple-error "maximum inferences exceeded~%")) (export shen.errormaxinfs) (quote shen.errormaxinfs))
(begin (register-function-arity (quote shen.udefs*) 5) (define (kl:shen.udefs* V3873 V3874 V3875 V3876 V3877) (let ((Case (let ((V3822 (kl:shen.lazyderef V3875 V3876))) (if (pair? V3822) (let ((D (car V3822))) (begin (kl:shen.incinfs) (kl:call (cons D (cons V3873 (cons V3874 (quote ())))) V3876 V3877))) #f)))) (if (kl:= Case #f) (let ((V3823 (kl:shen.lazyderef V3875 V3876))) (if (pair? V3823) (let ((Ds (cdr V3823))) (begin (kl:shen.incinfs) (kl:shen.udefs* V3873 V3874 Ds V3876 V3877))) #f)) Case))) (export shen.udefs*) (quote shen.udefs*))
(begin (register-function-arity (quote shen.th*) 5) (define (kl:shen.th* V3883 V3884 V3885 V3886 V3887) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (begin (kl:shen.incinfs) (kl:shen.show (cons V3883 (cons (quote :) (cons V3884 (quote ())))) V3885 V3886 (lambda () (kl:fwhen #f V3886 V3887)))))) (if (kl:= Case #f) (let ((Case (let ((F (kl:shen.newpv V3886))) (begin (kl:shen.incinfs) (kl:fwhen (kl:shen.typedf? (kl:shen.lazyderef V3883 V3886)) V3886 (lambda () (kl:bind F (kl:shen.sigf (kl:shen.lazyderef V3883 V3886)) V3886 (lambda () (kl:call (cons F (cons V3884 (quote ()))) V3886 V3887))))))))) (if (kl:= Case #f) (let ((Case (begin (kl:shen.incinfs) (kl:shen.base V3883 V3884 V3886 V3887)))) (if (kl:= Case #f) (let ((Case (begin (kl:shen.incinfs) (kl:shen.by_hypothesis V3883 V3884 V3885 V3886 V3887)))) (if (kl:= Case #f) (let ((Case (let ((V3718 (kl:shen.lazyderef V3883 V3886))) (if (pair? V3718) (let ((F (car V3718))) (let ((V3719 (kl:shen.lazyderef (cdr V3718) V3886))) (if (null? V3719) (begin (kl:shen.incinfs) (kl:shen.th* F (cons (quote -->) (cons V3884 (quote ()))) V3885 V3886 V3887)) #f))) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3720 (kl:shen.lazyderef V3883 V3886))) (if (pair? V3720) (let ((F (car V3720))) (let ((V3721 (kl:shen.lazyderef (cdr V3720) V3886))) (if (pair? V3721) (let ((X (car V3721))) (let ((V3722 (kl:shen.lazyderef (cdr V3721) V3886))) (if (null? V3722) (let ((B (kl:shen.newpv V3886))) (begin (kl:shen.incinfs) (kl:shen.th* F (cons B (cons (quote -->) (cons V3884 (quote ())))) V3885 V3886 (lambda () (kl:shen.th* X B V3885 V3886 V3887))))) #f))) #f))) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3723 (kl:shen.lazyderef V3883 V3886))) (if (pair? V3723) (let ((V3724 (kl:shen.lazyderef (car V3723) V3886))) (if (eq? (quote cons) V3724) (let ((V3725 (kl:shen.lazyderef (cdr V3723) V3886))) (if (pair? V3725) (let ((X (car V3725))) (let ((V3726 (kl:shen.lazyderef (cdr V3725) V3886))) (if (pair? V3726) (let ((Y (car V3726))) (let ((V3727 (kl:shen.lazyderef (cdr V3726) V3886))) (if (null? V3727) (let ((V3728 (kl:shen.lazyderef V3884 V3886))) (if (pair? V3728) (let ((V3729 (kl:shen.lazyderef (car V3728) V3886))) (if (eq? (quote list) V3729) (let ((V3730 (kl:shen.lazyderef (cdr V3728) V3886))) (if (pair? V3730) (let ((A (car V3730))) (let ((V3731 (kl:shen.lazyderef (cdr V3730) V3886))) (if (null? V3731) (begin (kl:shen.incinfs) (kl:shen.th* X A V3885 V3886 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3885 V3886 V3887)))) (if (kl:shen.pvar? V3731) (begin (kl:shen.bindv V3731 (quote ()) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3885 V3886 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3885 V3886 V3887)))))) (begin (kl:shen.unbindv V3731 V3886) Result))) #f)))) (if (kl:shen.pvar? V3730) (let ((A (kl:shen.newpv V3886))) (begin (kl:shen.bindv V3730 (cons A (quote ())) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3885 V3886 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3885 V3886 V3887)))))) (begin (kl:shen.unbindv V3730 V3886) Result)))) #f))) (if (kl:shen.pvar? V3729) (begin (kl:shen.bindv V3729 (quote list) V3886) (let ((Result (let ((V3732 (kl:shen.lazyderef (cdr V3728) V3886))) (if (pair? V3732) (let ((A (car V3732))) (let ((V3733 (kl:shen.lazyderef (cdr V3732) V3886))) (if (null? V3733) (begin (kl:shen.incinfs) (kl:shen.th* X A V3885 V3886 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3885 V3886 V3887)))) (if (kl:shen.pvar? V3733) (begin (kl:shen.bindv V3733 (quote ()) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3885 V3886 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3885 V3886 V3887)))))) (begin (kl:shen.unbindv V3733 V3886) Result))) #f)))) (if (kl:shen.pvar? V3732) (let ((A (kl:shen.newpv V3886))) (begin (kl:shen.bindv V3732 (cons A (quote ())) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3885 V3886 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3885 V3886 V3887)))))) (begin (kl:shen.unbindv V3732 V3886) Result)))) #f))))) (begin (kl:shen.unbindv V3729 V3886) Result))) #f))) (if (kl:shen.pvar? V3728) (let ((A (kl:shen.newpv V3886))) (begin (kl:shen.bindv V3728 (cons (quote list) (cons A (quote ()))) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3885 V3886 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3885 V3886 V3887)))))) (begin (kl:shen.unbindv V3728 V3886) Result)))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3734 (kl:shen.lazyderef V3883 V3886))) (if (pair? V3734) (let ((V3735 (kl:shen.lazyderef (car V3734) V3886))) (if (eq? (quote _waspvm_at_p) V3735) (let ((V3736 (kl:shen.lazyderef (cdr V3734) V3886))) (if (pair? V3736) (let ((X (car V3736))) (let ((V3737 (kl:shen.lazyderef (cdr V3736) V3886))) (if (pair? V3737) (let ((Y (car V3737))) (let ((V3738 (kl:shen.lazyderef (cdr V3737) V3886))) (if (null? V3738) (let ((V3739 (kl:shen.lazyderef V3884 V3886))) (if (pair? V3739) (let ((A (car V3739))) (let ((V3740 (kl:shen.lazyderef (cdr V3739) V3886))) (if (pair? V3740) (let ((V3741 (kl:shen.lazyderef (car V3740) V3886))) (if (eq? (quote *) V3741) (let ((V3742 (kl:shen.lazyderef (cdr V3740) V3886))) (if (pair? V3742) (let ((B (car V3742))) (let ((V3743 (kl:shen.lazyderef (cdr V3742) V3886))) (if (null? V3743) (begin (kl:shen.incinfs) (kl:shen.th* X A V3885 V3886 (lambda () (kl:shen.th* Y B V3885 V3886 V3887)))) (if (kl:shen.pvar? V3743) (begin (kl:shen.bindv V3743 (quote ()) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3885 V3886 (lambda () (kl:shen.th* Y B V3885 V3886 V3887)))))) (begin (kl:shen.unbindv V3743 V3886) Result))) #f)))) (if (kl:shen.pvar? V3742) (let ((B (kl:shen.newpv V3886))) (begin (kl:shen.bindv V3742 (cons B (quote ())) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3885 V3886 (lambda () (kl:shen.th* Y B V3885 V3886 V3887)))))) (begin (kl:shen.unbindv V3742 V3886) Result)))) #f))) (if (kl:shen.pvar? V3741) (begin (kl:shen.bindv V3741 (quote *) V3886) (let ((Result (let ((V3744 (kl:shen.lazyderef (cdr V3740) V3886))) (if (pair? V3744) (let ((B (car V3744))) (let ((V3745 (kl:shen.lazyderef (cdr V3744) V3886))) (if (null? V3745) (begin (kl:shen.incinfs) (kl:shen.th* X A V3885 V3886 (lambda () (kl:shen.th* Y B V3885 V3886 V3887)))) (if (kl:shen.pvar? V3745) (begin (kl:shen.bindv V3745 (quote ()) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3885 V3886 (lambda () (kl:shen.th* Y B V3885 V3886 V3887)))))) (begin (kl:shen.unbindv V3745 V3886) Result))) #f)))) (if (kl:shen.pvar? V3744) (let ((B (kl:shen.newpv V3886))) (begin (kl:shen.bindv V3744 (cons B (quote ())) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3885 V3886 (lambda () (kl:shen.th* Y B V3885 V3886 V3887)))))) (begin (kl:shen.unbindv V3744 V3886) Result)))) #f))))) (begin (kl:shen.unbindv V3741 V3886) Result))) #f))) (if (kl:shen.pvar? V3740) (let ((B (kl:shen.newpv V3886))) (begin (kl:shen.bindv V3740 (cons (quote *) (cons B (quote ()))) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3885 V3886 (lambda () (kl:shen.th* Y B V3885 V3886 V3887)))))) (begin (kl:shen.unbindv V3740 V3886) Result)))) #f)))) (if (kl:shen.pvar? V3739) (let ((A (kl:shen.newpv V3886))) (let ((B (kl:shen.newpv V3886))) (begin (kl:shen.bindv V3739 (cons A (cons (quote *) (cons B (quote ())))) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3885 V3886 (lambda () (kl:shen.th* Y B V3885 V3886 V3887)))))) (begin (kl:shen.unbindv V3739 V3886) Result))))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3746 (kl:shen.lazyderef V3883 V3886))) (if (pair? V3746) (let ((V3747 (kl:shen.lazyderef (car V3746) V3886))) (if (eq? (quote _waspvm_at_v) V3747) (let ((V3748 (kl:shen.lazyderef (cdr V3746) V3886))) (if (pair? V3748) (let ((X (car V3748))) (let ((V3749 (kl:shen.lazyderef (cdr V3748) V3886))) (if (pair? V3749) (let ((Y (car V3749))) (let ((V3750 (kl:shen.lazyderef (cdr V3749) V3886))) (if (null? V3750) (let ((V3751 (kl:shen.lazyderef V3884 V3886))) (if (pair? V3751) (let ((V3752 (kl:shen.lazyderef (car V3751) V3886))) (if (eq? (quote vector) V3752) (let ((V3753 (kl:shen.lazyderef (cdr V3751) V3886))) (if (pair? V3753) (let ((A (car V3753))) (let ((V3754 (kl:shen.lazyderef (cdr V3753) V3886))) (if (null? V3754) (begin (kl:shen.incinfs) (kl:shen.th* X A V3885 V3886 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3885 V3886 V3887)))) (if (kl:shen.pvar? V3754) (begin (kl:shen.bindv V3754 (quote ()) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3885 V3886 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3885 V3886 V3887)))))) (begin (kl:shen.unbindv V3754 V3886) Result))) #f)))) (if (kl:shen.pvar? V3753) (let ((A (kl:shen.newpv V3886))) (begin (kl:shen.bindv V3753 (cons A (quote ())) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3885 V3886 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3885 V3886 V3887)))))) (begin (kl:shen.unbindv V3753 V3886) Result)))) #f))) (if (kl:shen.pvar? V3752) (begin (kl:shen.bindv V3752 (quote vector) V3886) (let ((Result (let ((V3755 (kl:shen.lazyderef (cdr V3751) V3886))) (if (pair? V3755) (let ((A (car V3755))) (let ((V3756 (kl:shen.lazyderef (cdr V3755) V3886))) (if (null? V3756) (begin (kl:shen.incinfs) (kl:shen.th* X A V3885 V3886 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3885 V3886 V3887)))) (if (kl:shen.pvar? V3756) (begin (kl:shen.bindv V3756 (quote ()) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3885 V3886 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3885 V3886 V3887)))))) (begin (kl:shen.unbindv V3756 V3886) Result))) #f)))) (if (kl:shen.pvar? V3755) (let ((A (kl:shen.newpv V3886))) (begin (kl:shen.bindv V3755 (cons A (quote ())) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3885 V3886 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3885 V3886 V3887)))))) (begin (kl:shen.unbindv V3755 V3886) Result)))) #f))))) (begin (kl:shen.unbindv V3752 V3886) Result))) #f))) (if (kl:shen.pvar? V3751) (let ((A (kl:shen.newpv V3886))) (begin (kl:shen.bindv V3751 (cons (quote vector) (cons A (quote ()))) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3885 V3886 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3885 V3886 V3887)))))) (begin (kl:shen.unbindv V3751 V3886) Result)))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3757 (kl:shen.lazyderef V3883 V3886))) (if (pair? V3757) (let ((V3758 (kl:shen.lazyderef (car V3757) V3886))) (if (eq? (quote _waspvm_at_s) V3758) (let ((V3759 (kl:shen.lazyderef (cdr V3757) V3886))) (if (pair? V3759) (let ((X (car V3759))) (let ((V3760 (kl:shen.lazyderef (cdr V3759) V3886))) (if (pair? V3760) (let ((Y (car V3760))) (let ((V3761 (kl:shen.lazyderef (cdr V3760) V3886))) (if (null? V3761) (let ((V3762 (kl:shen.lazyderef V3884 V3886))) (if (eq? (quote string) V3762) (begin (kl:shen.incinfs) (kl:shen.th* X (quote string) V3885 V3886 (lambda () (kl:shen.th* Y (quote string) V3885 V3886 V3887)))) (if (kl:shen.pvar? V3762) (begin (kl:shen.bindv V3762 (quote string) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X (quote string) V3885 V3886 (lambda () (kl:shen.th* Y (quote string) V3885 V3886 V3887)))))) (begin (kl:shen.unbindv V3762 V3886) Result))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3763 (kl:shen.lazyderef V3883 V3886))) (if (pair? V3763) (let ((V3764 (kl:shen.lazyderef (car V3763) V3886))) (if (eq? (quote lambda) V3764) (let ((V3765 (kl:shen.lazyderef (cdr V3763) V3886))) (if (pair? V3765) (let ((X (car V3765))) (let ((V3766 (kl:shen.lazyderef (cdr V3765) V3886))) (if (pair? V3766) (let ((Y (car V3766))) (let ((V3767 (kl:shen.lazyderef (cdr V3766) V3886))) (if (null? V3767) (let ((V3768 (kl:shen.lazyderef V3884 V3886))) (if (pair? V3768) (let ((A (car V3768))) (let ((V3769 (kl:shen.lazyderef (cdr V3768) V3886))) (if (pair? V3769) (let ((V3770 (kl:shen.lazyderef (car V3769) V3886))) (if (eq? (quote -->) V3770) (let ((V3771 (kl:shen.lazyderef (cdr V3769) V3886))) (if (pair? V3771) (let ((B (car V3771))) (let ((V3772 (kl:shen.lazyderef (cdr V3771) V3886))) (if (null? V3772) (let ((Z (kl:shen.newpv V3886))) (let ((X&& (kl:shen.newpv V3886))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3886 (lambda () (kl:bind X&& (kl:shen.placeholder) V3886 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3886) (kl:shen.lazyderef X V3886) (kl:shen.lazyderef Y V3886)) V3886 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3885) V3886 V3887)))))))))) (if (kl:shen.pvar? V3772) (begin (kl:shen.bindv V3772 (quote ()) V3886) (let ((Result (let ((Z (kl:shen.newpv V3886))) (let ((X&& (kl:shen.newpv V3886))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3886 (lambda () (kl:bind X&& (kl:shen.placeholder) V3886 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3886) (kl:shen.lazyderef X V3886) (kl:shen.lazyderef Y V3886)) V3886 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3885) V3886 V3887)))))))))))) (begin (kl:shen.unbindv V3772 V3886) Result))) #f)))) (if (kl:shen.pvar? V3771) (let ((B (kl:shen.newpv V3886))) (begin (kl:shen.bindv V3771 (cons B (quote ())) V3886) (let ((Result (let ((Z (kl:shen.newpv V3886))) (let ((X&& (kl:shen.newpv V3886))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3886 (lambda () (kl:bind X&& (kl:shen.placeholder) V3886 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3886) (kl:shen.lazyderef X V3886) (kl:shen.lazyderef Y V3886)) V3886 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3885) V3886 V3887)))))))))))) (begin (kl:shen.unbindv V3771 V3886) Result)))) #f))) (if (kl:shen.pvar? V3770) (begin (kl:shen.bindv V3770 (quote -->) V3886) (let ((Result (let ((V3773 (kl:shen.lazyderef (cdr V3769) V3886))) (if (pair? V3773) (let ((B (car V3773))) (let ((V3774 (kl:shen.lazyderef (cdr V3773) V3886))) (if (null? V3774) (let ((Z (kl:shen.newpv V3886))) (let ((X&& (kl:shen.newpv V3886))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3886 (lambda () (kl:bind X&& (kl:shen.placeholder) V3886 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3886) (kl:shen.lazyderef X V3886) (kl:shen.lazyderef Y V3886)) V3886 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3885) V3886 V3887)))))))))) (if (kl:shen.pvar? V3774) (begin (kl:shen.bindv V3774 (quote ()) V3886) (let ((Result (let ((Z (kl:shen.newpv V3886))) (let ((X&& (kl:shen.newpv V3886))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3886 (lambda () (kl:bind X&& (kl:shen.placeholder) V3886 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3886) (kl:shen.lazyderef X V3886) (kl:shen.lazyderef Y V3886)) V3886 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3885) V3886 V3887)))))))))))) (begin (kl:shen.unbindv V3774 V3886) Result))) #f)))) (if (kl:shen.pvar? V3773) (let ((B (kl:shen.newpv V3886))) (begin (kl:shen.bindv V3773 (cons B (quote ())) V3886) (let ((Result (let ((Z (kl:shen.newpv V3886))) (let ((X&& (kl:shen.newpv V3886))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3886 (lambda () (kl:bind X&& (kl:shen.placeholder) V3886 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3886) (kl:shen.lazyderef X V3886) (kl:shen.lazyderef Y V3886)) V3886 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3885) V3886 V3887)))))))))))) (begin (kl:shen.unbindv V3773 V3886) Result)))) #f))))) (begin (kl:shen.unbindv V3770 V3886) Result))) #f))) (if (kl:shen.pvar? V3769) (let ((B (kl:shen.newpv V3886))) (begin (kl:shen.bindv V3769 (cons (quote -->) (cons B (quote ()))) V3886) (let ((Result (let ((Z (kl:shen.newpv V3886))) (let ((X&& (kl:shen.newpv V3886))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3886 (lambda () (kl:bind X&& (kl:shen.placeholder) V3886 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3886) (kl:shen.lazyderef X V3886) (kl:shen.lazyderef Y V3886)) V3886 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3885) V3886 V3887)))))))))))) (begin (kl:shen.unbindv V3769 V3886) Result)))) #f)))) (if (kl:shen.pvar? V3768) (let ((A (kl:shen.newpv V3886))) (let ((B (kl:shen.newpv V3886))) (begin (kl:shen.bindv V3768 (cons A (cons (quote -->) (cons B (quote ())))) V3886) (let ((Result (let ((Z (kl:shen.newpv V3886))) (let ((X&& (kl:shen.newpv V3886))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3886 (lambda () (kl:bind X&& (kl:shen.placeholder) V3886 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3886) (kl:shen.lazyderef X V3886) (kl:shen.lazyderef Y V3886)) V3886 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3885) V3886 V3887)))))))))))) (begin (kl:shen.unbindv V3768 V3886) Result))))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3775 (kl:shen.lazyderef V3883 V3886))) (if (pair? V3775) (let ((V3776 (kl:shen.lazyderef (car V3775) V3886))) (if (eq? (quote let) V3776) (let ((V3777 (kl:shen.lazyderef (cdr V3775) V3886))) (if (pair? V3777) (let ((X (car V3777))) (let ((V3778 (kl:shen.lazyderef (cdr V3777) V3886))) (if (pair? V3778) (let ((Y (car V3778))) (let ((V3779 (kl:shen.lazyderef (cdr V3778) V3886))) (if (pair? V3779) (let ((Z (car V3779))) (let ((V3780 (kl:shen.lazyderef (cdr V3779) V3886))) (if (null? V3780) (let ((W (kl:shen.newpv V3886))) (let ((X&& (kl:shen.newpv V3886))) (let ((B (kl:shen.newpv V3886))) (begin (kl:shen.incinfs) (kl:shen.th* Y B V3885 V3886 (lambda () (kl:bind X&& (kl:shen.placeholder) V3886 (lambda () (kl:bind W (kl:shen.ebr (kl:shen.lazyderef X&& V3886) (kl:shen.lazyderef X V3886) (kl:shen.lazyderef Z V3886)) V3886 (lambda () (kl:shen.th* W V3884 (cons (cons X&& (cons (quote :) (cons B (quote ())))) V3885) V3886 V3887))))))))))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3781 (kl:shen.lazyderef V3883 V3886))) (if (pair? V3781) (let ((V3782 (kl:shen.lazyderef (car V3781) V3886))) (if (eq? (quote open) V3782) (let ((V3783 (kl:shen.lazyderef (cdr V3781) V3886))) (if (pair? V3783) (let ((FileName (car V3783))) (let ((V3784 (kl:shen.lazyderef (cdr V3783) V3886))) (if (pair? V3784) (let ((Direction3714 (car V3784))) (let ((V3785 (kl:shen.lazyderef (cdr V3784) V3886))) (if (null? V3785) (let ((V3786 (kl:shen.lazyderef V3884 V3886))) (if (pair? V3786) (let ((V3787 (kl:shen.lazyderef (car V3786) V3886))) (if (eq? (quote stream) V3787) (let ((V3788 (kl:shen.lazyderef (cdr V3786) V3886))) (if (pair? V3788) (let ((Direction (car V3788))) (let ((V3789 (kl:shen.lazyderef (cdr V3788) V3886))) (if (null? V3789) (begin (kl:shen.incinfs) (kl:unify! Direction Direction3714 V3886 (lambda () (kl:cut Throwcontrol V3886 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3886) (cons (quote in) (cons (quote out) (quote ())))) V3886 (lambda () (kl:shen.th* FileName (quote string) V3885 V3886 V3887)))))))) (if (kl:shen.pvar? V3789) (begin (kl:shen.bindv V3789 (quote ()) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3714 V3886 (lambda () (kl:cut Throwcontrol V3886 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3886) (cons (quote in) (cons (quote out) (quote ())))) V3886 (lambda () (kl:shen.th* FileName (quote string) V3885 V3886 V3887)))))))))) (begin (kl:shen.unbindv V3789 V3886) Result))) #f)))) (if (kl:shen.pvar? V3788) (let ((Direction (kl:shen.newpv V3886))) (begin (kl:shen.bindv V3788 (cons Direction (quote ())) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3714 V3886 (lambda () (kl:cut Throwcontrol V3886 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3886) (cons (quote in) (cons (quote out) (quote ())))) V3886 (lambda () (kl:shen.th* FileName (quote string) V3885 V3886 V3887)))))))))) (begin (kl:shen.unbindv V3788 V3886) Result)))) #f))) (if (kl:shen.pvar? V3787) (begin (kl:shen.bindv V3787 (quote stream) V3886) (let ((Result (let ((V3790 (kl:shen.lazyderef (cdr V3786) V3886))) (if (pair? V3790) (let ((Direction (car V3790))) (let ((V3791 (kl:shen.lazyderef (cdr V3790) V3886))) (if (null? V3791) (begin (kl:shen.incinfs) (kl:unify! Direction Direction3714 V3886 (lambda () (kl:cut Throwcontrol V3886 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3886) (cons (quote in) (cons (quote out) (quote ())))) V3886 (lambda () (kl:shen.th* FileName (quote string) V3885 V3886 V3887)))))))) (if (kl:shen.pvar? V3791) (begin (kl:shen.bindv V3791 (quote ()) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3714 V3886 (lambda () (kl:cut Throwcontrol V3886 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3886) (cons (quote in) (cons (quote out) (quote ())))) V3886 (lambda () (kl:shen.th* FileName (quote string) V3885 V3886 V3887)))))))))) (begin (kl:shen.unbindv V3791 V3886) Result))) #f)))) (if (kl:shen.pvar? V3790) (let ((Direction (kl:shen.newpv V3886))) (begin (kl:shen.bindv V3790 (cons Direction (quote ())) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3714 V3886 (lambda () (kl:cut Throwcontrol V3886 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3886) (cons (quote in) (cons (quote out) (quote ())))) V3886 (lambda () (kl:shen.th* FileName (quote string) V3885 V3886 V3887)))))))))) (begin (kl:shen.unbindv V3790 V3886) Result)))) #f))))) (begin (kl:shen.unbindv V3787 V3886) Result))) #f))) (if (kl:shen.pvar? V3786) (let ((Direction (kl:shen.newpv V3886))) (begin (kl:shen.bindv V3786 (cons (quote stream) (cons Direction (quote ()))) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3714 V3886 (lambda () (kl:cut Throwcontrol V3886 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3886) (cons (quote in) (cons (quote out) (quote ())))) V3886 (lambda () (kl:shen.th* FileName (quote string) V3885 V3886 V3887)))))))))) (begin (kl:shen.unbindv V3786 V3886) Result)))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3792 (kl:shen.lazyderef V3883 V3886))) (if (pair? V3792) (let ((V3793 (kl:shen.lazyderef (car V3792) V3886))) (if (eq? (quote type) V3793) (let ((V3794 (kl:shen.lazyderef (cdr V3792) V3886))) (if (pair? V3794) (let ((X (car V3794))) (let ((V3795 (kl:shen.lazyderef (cdr V3794) V3886))) (if (pair? V3795) (let ((A (car V3795))) (let ((V3796 (kl:shen.lazyderef (cdr V3795) V3886))) (if (null? V3796) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3886 (lambda () (kl:unify A V3884 V3886 (lambda () (kl:shen.th* X A V3885 V3886 V3887)))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3797 (kl:shen.lazyderef V3883 V3886))) (if (pair? V3797) (let ((V3798 (kl:shen.lazyderef (car V3797) V3886))) (if (eq? (quote input+) V3798) (let ((V3799 (kl:shen.lazyderef (cdr V3797) V3886))) (if (pair? V3799) (let ((A (car V3799))) (let ((V3800 (kl:shen.lazyderef (cdr V3799) V3886))) (if (pair? V3800) (let ((Stream (car V3800))) (let ((V3801 (kl:shen.lazyderef (cdr V3800) V3886))) (if (null? V3801) (let ((C (kl:shen.newpv V3886))) (begin (kl:shen.incinfs) (kl:bind C (kl:shen.demodulate (kl:shen.lazyderef A V3886)) V3886 (lambda () (kl:unify V3884 C V3886 (lambda () (kl:shen.th* Stream (cons (quote stream) (cons (quote in) (quote ()))) V3885 V3886 V3887))))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3802 (kl:shen.lazyderef V3883 V3886))) (if (pair? V3802) (let ((V3803 (kl:shen.lazyderef (car V3802) V3886))) (if (eq? (quote set) V3803) (let ((V3804 (kl:shen.lazyderef (cdr V3802) V3886))) (if (pair? V3804) (let ((Var (car V3804))) (let ((V3805 (kl:shen.lazyderef (cdr V3804) V3886))) (if (pair? V3805) (let ((Val (car V3805))) (let ((V3806 (kl:shen.lazyderef (cdr V3805) V3886))) (if (null? V3806) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3886 (lambda () (kl:shen.th* Var (quote symbol) V3885 V3886 (lambda () (kl:cut Throwcontrol V3886 (lambda () (kl:shen.th* (cons (quote value) (cons Var (quote ()))) V3884 V3885 V3886 (lambda () (kl:shen.th* Val V3884 V3885 V3886 V3887)))))))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((NewHyp (kl:shen.newpv V3886))) (begin (kl:shen.incinfs) (kl:shen.t*-hyps V3885 NewHyp V3886 (lambda () (kl:shen.th* V3883 V3884 NewHyp V3886 V3887))))))) (if (kl:= Case #f) (let ((Case (let ((V3807 (kl:shen.lazyderef V3883 V3886))) (if (pair? V3807) (let ((V3808 (kl:shen.lazyderef (car V3807) V3886))) (if (eq? (quote define) V3808) (let ((V3809 (kl:shen.lazyderef (cdr V3807) V3886))) (if (pair? V3809) (let ((F (car V3809))) (let ((X (cdr V3809))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3886 (lambda () (kl:shen.t*-def (cons (quote define) (cons F X)) V3884 V3885 V3886 V3887)))))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3810 (kl:shen.lazyderef V3883 V3886))) (if (pair? V3810) (let ((V3811 (kl:shen.lazyderef (car V3810) V3886))) (if (eq? (quote defmacro) V3811) (let ((V3812 (kl:shen.lazyderef V3884 V3886))) (if (eq? (quote unit) V3812) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3886 V3887)) (if (kl:shen.pvar? V3812) (begin (kl:shen.bindv V3812 (quote unit) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3886 V3887)))) (begin (kl:shen.unbindv V3812 V3886) Result))) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3813 (kl:shen.lazyderef V3883 V3886))) (if (pair? V3813) (let ((V3814 (kl:shen.lazyderef (car V3813) V3886))) (if (eq? (quote shen.process-datatype) V3814) (let ((V3815 (kl:shen.lazyderef V3884 V3886))) (if (eq? (quote symbol) V3815) (begin (kl:shen.incinfs) (kl:thaw V3887)) (if (kl:shen.pvar? V3815) (begin (kl:shen.bindv V3815 (quote symbol) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3887)))) (begin (kl:shen.unbindv V3815 V3886) Result))) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3816 (kl:shen.lazyderef V3883 V3886))) (if (pair? V3816) (let ((V3817 (kl:shen.lazyderef (car V3816) V3886))) (if (eq? (quote shen.synonyms-help) V3817) (let ((V3818 (kl:shen.lazyderef V3884 V3886))) (if (eq? (quote symbol) V3818) (begin (kl:shen.incinfs) (kl:thaw V3887)) (if (kl:shen.pvar? V3818) (begin (kl:shen.bindv V3818 (quote symbol) V3886) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3887)))) (begin (kl:shen.unbindv V3818 V3886) Result))) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((Datatypes (kl:shen.newpv V3886))) (begin (kl:shen.incinfs) (kl:bind Datatypes (kl:value (quote shen.*datatypes*)) V3886 (lambda () (kl:shen.udefs* (cons V3883 (cons (quote :) (cons V3884 (quote ())))) V3885 Datatypes V3886 V3887))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case))))) (export shen.th*) (quote shen.th*))
(begin (register-function-arity (quote shen.t*-hyps) 4) (define (kl:shen.t*-hyps V3892 V3893 V3894 V3895) (let ((Case (let ((V3629 (kl:shen.lazyderef V3892 V3894))) (if (pair? V3629) (let ((V3630 (kl:shen.lazyderef (car V3629) V3894))) (if (pair? V3630) (let ((V3631 (kl:shen.lazyderef (car V3630) V3894))) (if (pair? V3631) (let ((V3632 (kl:shen.lazyderef (car V3631) V3894))) (if (eq? (quote cons) V3632) (let ((V3633 (kl:shen.lazyderef (cdr V3631) V3894))) (if (pair? V3633) (let ((X (car V3633))) (let ((V3634 (kl:shen.lazyderef (cdr V3633) V3894))) (if (pair? V3634) (let ((Y (car V3634))) (let ((V3635 (kl:shen.lazyderef (cdr V3634) V3894))) (if (null? V3635) (let ((V3636 (kl:shen.lazyderef (cdr V3630) V3894))) (if (pair? V3636) (let ((V3637 (kl:shen.lazyderef (car V3636) V3894))) (if (eq? (quote :) V3637) (let ((V3638 (kl:shen.lazyderef (cdr V3636) V3894))) (if (pair? V3638) (let ((V3639 (kl:shen.lazyderef (car V3638) V3894))) (if (pair? V3639) (let ((V3640 (kl:shen.lazyderef (car V3639) V3894))) (if (eq? (quote list) V3640) (let ((V3641 (kl:shen.lazyderef (cdr V3639) V3894))) (if (pair? V3641) (let ((A (car V3641))) (let ((V3642 (kl:shen.lazyderef (cdr V3641) V3894))) (if (null? V3642) (let ((V3643 (kl:shen.lazyderef (cdr V3638) V3894))) (if (null? V3643) (let ((Hyp (cdr V3629))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3643) (begin (kl:shen.bindv V3643 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3629))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3643 V3894) Result))) #f))) (if (kl:shen.pvar? V3642) (begin (kl:shen.bindv V3642 (quote ()) V3894) (let ((Result (let ((V3644 (kl:shen.lazyderef (cdr V3638) V3894))) (if (null? V3644) (let ((Hyp (cdr V3629))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3644) (begin (kl:shen.bindv V3644 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3629))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3644 V3894) Result))) #f))))) (begin (kl:shen.unbindv V3642 V3894) Result))) #f)))) (if (kl:shen.pvar? V3641) (let ((A (kl:shen.newpv V3894))) (begin (kl:shen.bindv V3641 (cons A (quote ())) V3894) (let ((Result (let ((V3645 (kl:shen.lazyderef (cdr V3638) V3894))) (if (null? V3645) (let ((Hyp (cdr V3629))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3645) (begin (kl:shen.bindv V3645 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3629))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3645 V3894) Result))) #f))))) (begin (kl:shen.unbindv V3641 V3894) Result)))) #f))) (if (kl:shen.pvar? V3640) (begin (kl:shen.bindv V3640 (quote list) V3894) (let ((Result (let ((V3646 (kl:shen.lazyderef (cdr V3639) V3894))) (if (pair? V3646) (let ((A (car V3646))) (let ((V3647 (kl:shen.lazyderef (cdr V3646) V3894))) (if (null? V3647) (let ((V3648 (kl:shen.lazyderef (cdr V3638) V3894))) (if (null? V3648) (let ((Hyp (cdr V3629))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3648) (begin (kl:shen.bindv V3648 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3629))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3648 V3894) Result))) #f))) (if (kl:shen.pvar? V3647) (begin (kl:shen.bindv V3647 (quote ()) V3894) (let ((Result (let ((V3649 (kl:shen.lazyderef (cdr V3638) V3894))) (if (null? V3649) (let ((Hyp (cdr V3629))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3649) (begin (kl:shen.bindv V3649 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3629))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3649 V3894) Result))) #f))))) (begin (kl:shen.unbindv V3647 V3894) Result))) #f)))) (if (kl:shen.pvar? V3646) (let ((A (kl:shen.newpv V3894))) (begin (kl:shen.bindv V3646 (cons A (quote ())) V3894) (let ((Result (let ((V3650 (kl:shen.lazyderef (cdr V3638) V3894))) (if (null? V3650) (let ((Hyp (cdr V3629))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3650) (begin (kl:shen.bindv V3650 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3629))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3650 V3894) Result))) #f))))) (begin (kl:shen.unbindv V3646 V3894) Result)))) #f))))) (begin (kl:shen.unbindv V3640 V3894) Result))) #f))) (if (kl:shen.pvar? V3639) (let ((A (kl:shen.newpv V3894))) (begin (kl:shen.bindv V3639 (cons (quote list) (cons A (quote ()))) V3894) (let ((Result (let ((V3651 (kl:shen.lazyderef (cdr V3638) V3894))) (if (null? V3651) (let ((Hyp (cdr V3629))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3651) (begin (kl:shen.bindv V3651 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3629))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3651 V3894) Result))) #f))))) (begin (kl:shen.unbindv V3639 V3894) Result)))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3652 (kl:shen.lazyderef V3892 V3894))) (if (pair? V3652) (let ((V3653 (kl:shen.lazyderef (car V3652) V3894))) (if (pair? V3653) (let ((V3654 (kl:shen.lazyderef (car V3653) V3894))) (if (pair? V3654) (let ((V3655 (kl:shen.lazyderef (car V3654) V3894))) (if (eq? (quote _waspvm_at_p) V3655) (let ((V3656 (kl:shen.lazyderef (cdr V3654) V3894))) (if (pair? V3656) (let ((X (car V3656))) (let ((V3657 (kl:shen.lazyderef (cdr V3656) V3894))) (if (pair? V3657) (let ((Y (car V3657))) (let ((V3658 (kl:shen.lazyderef (cdr V3657) V3894))) (if (null? V3658) (let ((V3659 (kl:shen.lazyderef (cdr V3653) V3894))) (if (pair? V3659) (let ((V3660 (kl:shen.lazyderef (car V3659) V3894))) (if (eq? (quote :) V3660) (let ((V3661 (kl:shen.lazyderef (cdr V3659) V3894))) (if (pair? V3661) (let ((V3662 (kl:shen.lazyderef (car V3661) V3894))) (if (pair? V3662) (let ((A (car V3662))) (let ((V3663 (kl:shen.lazyderef (cdr V3662) V3894))) (if (pair? V3663) (let ((V3664 (kl:shen.lazyderef (car V3663) V3894))) (if (eq? (quote *) V3664) (let ((V3665 (kl:shen.lazyderef (cdr V3663) V3894))) (if (pair? V3665) (let ((B (car V3665))) (let ((V3666 (kl:shen.lazyderef (cdr V3665) V3894))) (if (null? V3666) (let ((V3667 (kl:shen.lazyderef (cdr V3661) V3894))) (if (null? V3667) (let ((Hyp (cdr V3652))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (kl:shen.lazyderef B V3894) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3667) (begin (kl:shen.bindv V3667 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3652))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (kl:shen.lazyderef B V3894) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3667 V3894) Result))) #f))) (if (kl:shen.pvar? V3666) (begin (kl:shen.bindv V3666 (quote ()) V3894) (let ((Result (let ((V3668 (kl:shen.lazyderef (cdr V3661) V3894))) (if (null? V3668) (let ((Hyp (cdr V3652))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (kl:shen.lazyderef B V3894) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3668) (begin (kl:shen.bindv V3668 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3652))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (kl:shen.lazyderef B V3894) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3668 V3894) Result))) #f))))) (begin (kl:shen.unbindv V3666 V3894) Result))) #f)))) (if (kl:shen.pvar? V3665) (let ((B (kl:shen.newpv V3894))) (begin (kl:shen.bindv V3665 (cons B (quote ())) V3894) (let ((Result (let ((V3669 (kl:shen.lazyderef (cdr V3661) V3894))) (if (null? V3669) (let ((Hyp (cdr V3652))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (kl:shen.lazyderef B V3894) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3669) (begin (kl:shen.bindv V3669 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3652))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (kl:shen.lazyderef B V3894) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3669 V3894) Result))) #f))))) (begin (kl:shen.unbindv V3665 V3894) Result)))) #f))) (if (kl:shen.pvar? V3664) (begin (kl:shen.bindv V3664 (quote *) V3894) (let ((Result (let ((V3670 (kl:shen.lazyderef (cdr V3663) V3894))) (if (pair? V3670) (let ((B (car V3670))) (let ((V3671 (kl:shen.lazyderef (cdr V3670) V3894))) (if (null? V3671) (let ((V3672 (kl:shen.lazyderef (cdr V3661) V3894))) (if (null? V3672) (let ((Hyp (cdr V3652))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (kl:shen.lazyderef B V3894) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3672) (begin (kl:shen.bindv V3672 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3652))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (kl:shen.lazyderef B V3894) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3672 V3894) Result))) #f))) (if (kl:shen.pvar? V3671) (begin (kl:shen.bindv V3671 (quote ()) V3894) (let ((Result (let ((V3673 (kl:shen.lazyderef (cdr V3661) V3894))) (if (null? V3673) (let ((Hyp (cdr V3652))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (kl:shen.lazyderef B V3894) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3673) (begin (kl:shen.bindv V3673 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3652))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (kl:shen.lazyderef B V3894) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3673 V3894) Result))) #f))))) (begin (kl:shen.unbindv V3671 V3894) Result))) #f)))) (if (kl:shen.pvar? V3670) (let ((B (kl:shen.newpv V3894))) (begin (kl:shen.bindv V3670 (cons B (quote ())) V3894) (let ((Result (let ((V3674 (kl:shen.lazyderef (cdr V3661) V3894))) (if (null? V3674) (let ((Hyp (cdr V3652))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (kl:shen.lazyderef B V3894) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3674) (begin (kl:shen.bindv V3674 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3652))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (kl:shen.lazyderef B V3894) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3674 V3894) Result))) #f))))) (begin (kl:shen.unbindv V3670 V3894) Result)))) #f))))) (begin (kl:shen.unbindv V3664 V3894) Result))) #f))) (if (kl:shen.pvar? V3663) (let ((B (kl:shen.newpv V3894))) (begin (kl:shen.bindv V3663 (cons (quote *) (cons B (quote ()))) V3894) (let ((Result (let ((V3675 (kl:shen.lazyderef (cdr V3661) V3894))) (if (null? V3675) (let ((Hyp (cdr V3652))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (kl:shen.lazyderef B V3894) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3675) (begin (kl:shen.bindv V3675 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3652))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (kl:shen.lazyderef B V3894) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3675 V3894) Result))) #f))))) (begin (kl:shen.unbindv V3663 V3894) Result)))) #f)))) (if (kl:shen.pvar? V3662) (let ((A (kl:shen.newpv V3894))) (let ((B (kl:shen.newpv V3894))) (begin (kl:shen.bindv V3662 (cons A (cons (quote *) (cons B (quote ())))) V3894) (let ((Result (let ((V3676 (kl:shen.lazyderef (cdr V3661) V3894))) (if (null? V3676) (let ((Hyp (cdr V3652))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (kl:shen.lazyderef B V3894) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3676) (begin (kl:shen.bindv V3676 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3652))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (kl:shen.lazyderef B V3894) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3676 V3894) Result))) #f))))) (begin (kl:shen.unbindv V3662 V3894) Result))))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3677 (kl:shen.lazyderef V3892 V3894))) (if (pair? V3677) (let ((V3678 (kl:shen.lazyderef (car V3677) V3894))) (if (pair? V3678) (let ((V3679 (kl:shen.lazyderef (car V3678) V3894))) (if (pair? V3679) (let ((V3680 (kl:shen.lazyderef (car V3679) V3894))) (if (eq? (quote _waspvm_at_v) V3680) (let ((V3681 (kl:shen.lazyderef (cdr V3679) V3894))) (if (pair? V3681) (let ((X (car V3681))) (let ((V3682 (kl:shen.lazyderef (cdr V3681) V3894))) (if (pair? V3682) (let ((Y (car V3682))) (let ((V3683 (kl:shen.lazyderef (cdr V3682) V3894))) (if (null? V3683) (let ((V3684 (kl:shen.lazyderef (cdr V3678) V3894))) (if (pair? V3684) (let ((V3685 (kl:shen.lazyderef (car V3684) V3894))) (if (eq? (quote :) V3685) (let ((V3686 (kl:shen.lazyderef (cdr V3684) V3894))) (if (pair? V3686) (let ((V3687 (kl:shen.lazyderef (car V3686) V3894))) (if (pair? V3687) (let ((V3688 (kl:shen.lazyderef (car V3687) V3894))) (if (eq? (quote vector) V3688) (let ((V3689 (kl:shen.lazyderef (cdr V3687) V3894))) (if (pair? V3689) (let ((A (car V3689))) (let ((V3690 (kl:shen.lazyderef (cdr V3689) V3894))) (if (null? V3690) (let ((V3691 (kl:shen.lazyderef (cdr V3686) V3894))) (if (null? V3691) (let ((Hyp (cdr V3677))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3691) (begin (kl:shen.bindv V3691 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3677))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3691 V3894) Result))) #f))) (if (kl:shen.pvar? V3690) (begin (kl:shen.bindv V3690 (quote ()) V3894) (let ((Result (let ((V3692 (kl:shen.lazyderef (cdr V3686) V3894))) (if (null? V3692) (let ((Hyp (cdr V3677))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3692) (begin (kl:shen.bindv V3692 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3677))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3692 V3894) Result))) #f))))) (begin (kl:shen.unbindv V3690 V3894) Result))) #f)))) (if (kl:shen.pvar? V3689) (let ((A (kl:shen.newpv V3894))) (begin (kl:shen.bindv V3689 (cons A (quote ())) V3894) (let ((Result (let ((V3693 (kl:shen.lazyderef (cdr V3686) V3894))) (if (null? V3693) (let ((Hyp (cdr V3677))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3693) (begin (kl:shen.bindv V3693 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3677))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3693 V3894) Result))) #f))))) (begin (kl:shen.unbindv V3689 V3894) Result)))) #f))) (if (kl:shen.pvar? V3688) (begin (kl:shen.bindv V3688 (quote vector) V3894) (let ((Result (let ((V3694 (kl:shen.lazyderef (cdr V3687) V3894))) (if (pair? V3694) (let ((A (car V3694))) (let ((V3695 (kl:shen.lazyderef (cdr V3694) V3894))) (if (null? V3695) (let ((V3696 (kl:shen.lazyderef (cdr V3686) V3894))) (if (null? V3696) (let ((Hyp (cdr V3677))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3696) (begin (kl:shen.bindv V3696 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3677))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3696 V3894) Result))) #f))) (if (kl:shen.pvar? V3695) (begin (kl:shen.bindv V3695 (quote ()) V3894) (let ((Result (let ((V3697 (kl:shen.lazyderef (cdr V3686) V3894))) (if (null? V3697) (let ((Hyp (cdr V3677))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3697) (begin (kl:shen.bindv V3697 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3677))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3697 V3894) Result))) #f))))) (begin (kl:shen.unbindv V3695 V3894) Result))) #f)))) (if (kl:shen.pvar? V3694) (let ((A (kl:shen.newpv V3894))) (begin (kl:shen.bindv V3694 (cons A (quote ())) V3894) (let ((Result (let ((V3698 (kl:shen.lazyderef (cdr V3686) V3894))) (if (null? V3698) (let ((Hyp (cdr V3677))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3698) (begin (kl:shen.bindv V3698 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3677))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3698 V3894) Result))) #f))))) (begin (kl:shen.unbindv V3694 V3894) Result)))) #f))))) (begin (kl:shen.unbindv V3688 V3894) Result))) #f))) (if (kl:shen.pvar? V3687) (let ((A (kl:shen.newpv V3894))) (begin (kl:shen.bindv V3687 (cons (quote vector) (cons A (quote ()))) V3894) (let ((Result (let ((V3699 (kl:shen.lazyderef (cdr V3686) V3894))) (if (null? V3699) (let ((Hyp (cdr V3677))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3699) (begin (kl:shen.bindv V3699 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3677))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (kl:shen.lazyderef A V3894) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3894) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3699 V3894) Result))) #f))))) (begin (kl:shen.unbindv V3687 V3894) Result)))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3700 (kl:shen.lazyderef V3892 V3894))) (if (pair? V3700) (let ((V3701 (kl:shen.lazyderef (car V3700) V3894))) (if (pair? V3701) (let ((V3702 (kl:shen.lazyderef (car V3701) V3894))) (if (pair? V3702) (let ((V3703 (kl:shen.lazyderef (car V3702) V3894))) (if (eq? (quote _waspvm_at_s) V3703) (let ((V3704 (kl:shen.lazyderef (cdr V3702) V3894))) (if (pair? V3704) (let ((X (car V3704))) (let ((V3705 (kl:shen.lazyderef (cdr V3704) V3894))) (if (pair? V3705) (let ((Y (car V3705))) (let ((V3706 (kl:shen.lazyderef (cdr V3705) V3894))) (if (null? V3706) (let ((V3707 (kl:shen.lazyderef (cdr V3701) V3894))) (if (pair? V3707) (let ((V3708 (kl:shen.lazyderef (car V3707) V3894))) (if (eq? (quote :) V3708) (let ((V3709 (kl:shen.lazyderef (cdr V3707) V3894))) (if (pair? V3709) (let ((V3710 (kl:shen.lazyderef (car V3709) V3894))) (if (eq? (quote string) V3710) (let ((V3711 (kl:shen.lazyderef (cdr V3709) V3894))) (if (null? V3711) (let ((Hyp (cdr V3700))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3711) (begin (kl:shen.bindv V3711 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3700))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3711 V3894) Result))) #f))) (if (kl:shen.pvar? V3710) (begin (kl:shen.bindv V3710 (quote string) V3894) (let ((Result (let ((V3712 (kl:shen.lazyderef (cdr V3709) V3894))) (if (null? V3712) (let ((Hyp (cdr V3700))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))) (if (kl:shen.pvar? V3712) (begin (kl:shen.bindv V3712 (quote ()) V3894) (let ((Result (let ((Hyp (cdr V3700))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (cons (kl:shen.lazyderef X V3894) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3894) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V3894))) V3894 V3895))))) (begin (kl:shen.unbindv V3712 V3894) Result))) #f))))) (begin (kl:shen.unbindv V3710 V3894) Result))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((V3713 (kl:shen.lazyderef V3892 V3894))) (if (pair? V3713) (let ((X (car V3713))) (let ((Hyp (cdr V3713))) (let ((NewHyps (kl:shen.newpv V3894))) (begin (kl:shen.incinfs) (kl:bind V3893 (cons (kl:shen.lazyderef X V3894) (kl:shen.lazyderef NewHyps V3894)) V3894 (lambda () (kl:shen.t*-hyps Hyp NewHyps V3894 V3895))))))) #f)) Case)) Case)) Case)) Case))) (export shen.t*-hyps) (quote shen.t*-hyps))
(begin (register-function-arity (quote shen.show) 4) (define (kl:shen.show V3912 V3913 V3914 V3915) (cond ((assert-boolean (kl:value (quote shen.*spy*))) (begin (kl:shen.line) (begin (kl:shen.show-p (kl:shen.deref V3912 V3914)) (begin (kl:nl 1) (begin (kl:nl 1) (begin (kl:shen.show-assumptions (kl:shen.deref V3913 V3914) 1) (begin (kl:shen.prhush "\n> " (kl:stoutput)) (begin (kl:shen.pause-for-user) (kl:thaw V3915))))))))) (#t (kl:thaw V3915)))) (export shen.show) (quote shen.show))
(begin (register-function-arity (quote shen.line) 0) (define (kl:shen.line) (let ((Infs (kl:inferences))) (kl:shen.prhush (string-append "____________________________________________________________ " (kl:shen.app Infs (string-append " inference" (kl:shen.app (if (kl:= 1 Infs) "" "s") " \n?- " (quote shen.a))) (quote shen.a))) (kl:stoutput)))) (export shen.line) (quote shen.line))
(begin (register-function-arity (quote shen.show-p) 1) (define (kl:shen.show-p V3917) (cond ((and (pair? V3917) (and (pair? (cdr V3917)) (and (eq? (quote :) (car (cdr V3917))) (and (pair? (cdr (cdr V3917))) (null? (cdr (cdr (cdr V3917)))))))) (kl:shen.prhush (kl:shen.app (car V3917) (string-append " : " (kl:shen.app (car (cdr (cdr V3917))) "" (quote shen.r))) (quote shen.r)) (kl:stoutput))) (#t (kl:shen.prhush (kl:shen.app V3917 "" (quote shen.r)) (kl:stoutput))))) (export shen.show-p) (quote shen.show-p))
(begin (register-function-arity (quote shen.show-assumptions) 2) (define (kl:shen.show-assumptions V3922 V3923) (cond ((null? V3922) (quote shen.skip)) ((pair? V3922) (begin (kl:shen.prhush (kl:shen.app V3923 ". " (quote shen.a)) (kl:stoutput)) (begin (kl:shen.show-p (car V3922)) (begin (kl:nl 1) (kl:shen.show-assumptions (cdr V3922) (+ V3923 1)))))) (#t (kl:shen.f_error (quote shen.show-assumptions))))) (export shen.show-assumptions) (quote shen.show-assumptions))
(begin (register-function-arity (quote shen.pause-for-user) 0) (define (kl:shen.pause-for-user) (let ((Byte (read-u8 (kl:stinput)))) (if (kl:= Byte 94) (simple-error "input aborted\n") (kl:nl 1)))) (export shen.pause-for-user) (quote shen.pause-for-user))
(begin (register-function-arity (quote shen.typedf?) 1) (define (kl:shen.typedf? V3925) (pair? (kl:assoc V3925 (kl:value (quote shen.*signedfuncs*))))) (export shen.typedf?) (quote shen.typedf?))
(begin (register-function-arity (quote shen.sigf) 1) (define (kl:shen.sigf V3927) (kl:concat (quote shen.type-signature-of-) V3927)) (export shen.sigf) (quote shen.sigf))
(begin (register-function-arity (quote shen.placeholder) 0) (define (kl:shen.placeholder) (kl:gensym (quote &&))) (export shen.placeholder) (quote shen.placeholder))
(begin (register-function-arity (quote shen.base) 4) (define (kl:shen.base V3932 V3933 V3934 V3935) (let ((Case (let ((V3616 (kl:shen.lazyderef V3933 V3934))) (if (eq? (quote number) V3616) (begin (kl:shen.incinfs) (kl:fwhen (number? (kl:shen.lazyderef V3932 V3934)) V3934 V3935)) (if (kl:shen.pvar? V3616) (begin (kl:shen.bindv V3616 (quote number) V3934) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (number? (kl:shen.lazyderef V3932 V3934)) V3934 V3935)))) (begin (kl:shen.unbindv V3616 V3934) Result))) #f))))) (if (kl:= Case #f) (let ((Case (let ((V3617 (kl:shen.lazyderef V3933 V3934))) (if (eq? (quote boolean) V3617) (begin (kl:shen.incinfs) (kl:fwhen (kl:boolean? (kl:shen.lazyderef V3932 V3934)) V3934 V3935)) (if (kl:shen.pvar? V3617) (begin (kl:shen.bindv V3617 (quote boolean) V3934) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (kl:boolean? (kl:shen.lazyderef V3932 V3934)) V3934 V3935)))) (begin (kl:shen.unbindv V3617 V3934) Result))) #f))))) (if (kl:= Case #f) (let ((Case (let ((V3618 (kl:shen.lazyderef V3933 V3934))) (if (eq? (quote string) V3618) (begin (kl:shen.incinfs) (kl:fwhen (string? (kl:shen.lazyderef V3932 V3934)) V3934 V3935)) (if (kl:shen.pvar? V3618) (begin (kl:shen.bindv V3618 (quote string) V3934) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (string? (kl:shen.lazyderef V3932 V3934)) V3934 V3935)))) (begin (kl:shen.unbindv V3618 V3934) Result))) #f))))) (if (kl:= Case #f) (let ((Case (let ((V3619 (kl:shen.lazyderef V3933 V3934))) (if (eq? (quote symbol) V3619) (begin (kl:shen.incinfs) (kl:fwhen (kl:symbol? (kl:shen.lazyderef V3932 V3934)) V3934 (lambda () (kl:fwhen (kl:not (kl:shen.ue? (kl:shen.lazyderef V3932 V3934))) V3934 V3935)))) (if (kl:shen.pvar? V3619) (begin (kl:shen.bindv V3619 (quote symbol) V3934) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (kl:symbol? (kl:shen.lazyderef V3932 V3934)) V3934 (lambda () (kl:fwhen (kl:not (kl:shen.ue? (kl:shen.lazyderef V3932 V3934))) V3934 V3935)))))) (begin (kl:shen.unbindv V3619 V3934) Result))) #f))))) (if (kl:= Case #f) (let ((V3620 (kl:shen.lazyderef V3932 V3934))) (if (null? V3620) (let ((V3621 (kl:shen.lazyderef V3933 V3934))) (if (pair? V3621) (let ((V3622 (kl:shen.lazyderef (car V3621) V3934))) (if (eq? (quote list) V3622) (let ((V3623 (kl:shen.lazyderef (cdr V3621) V3934))) (if (pair? V3623) (let ((A (car V3623))) (let ((V3624 (kl:shen.lazyderef (cdr V3623) V3934))) (if (null? V3624) (begin (kl:shen.incinfs) (kl:thaw V3935)) (if (kl:shen.pvar? V3624) (begin (kl:shen.bindv V3624 (quote ()) V3934) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3935)))) (begin (kl:shen.unbindv V3624 V3934) Result))) #f)))) (if (kl:shen.pvar? V3623) (let ((A (kl:shen.newpv V3934))) (begin (kl:shen.bindv V3623 (cons A (quote ())) V3934) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3935)))) (begin (kl:shen.unbindv V3623 V3934) Result)))) #f))) (if (kl:shen.pvar? V3622) (begin (kl:shen.bindv V3622 (quote list) V3934) (let ((Result (let ((V3625 (kl:shen.lazyderef (cdr V3621) V3934))) (if (pair? V3625) (let ((A (car V3625))) (let ((V3626 (kl:shen.lazyderef (cdr V3625) V3934))) (if (null? V3626) (begin (kl:shen.incinfs) (kl:thaw V3935)) (if (kl:shen.pvar? V3626) (begin (kl:shen.bindv V3626 (quote ()) V3934) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3935)))) (begin (kl:shen.unbindv V3626 V3934) Result))) #f)))) (if (kl:shen.pvar? V3625) (let ((A (kl:shen.newpv V3934))) (begin (kl:shen.bindv V3625 (cons A (quote ())) V3934) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3935)))) (begin (kl:shen.unbindv V3625 V3934) Result)))) #f))))) (begin (kl:shen.unbindv V3622 V3934) Result))) #f))) (if (kl:shen.pvar? V3621) (let ((A (kl:shen.newpv V3934))) (begin (kl:shen.bindv V3621 (cons (quote list) (cons A (quote ()))) V3934) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3935)))) (begin (kl:shen.unbindv V3621 V3934) Result)))) #f))) #f)) Case)) Case)) Case)) Case))) (export shen.base) (quote shen.base))
(begin (register-function-arity (quote shen.by_hypothesis) 5) (define (kl:shen.by_hypothesis V3941 V3942 V3943 V3944 V3945) (let ((Case (let ((V3607 (kl:shen.lazyderef V3943 V3944))) (if (pair? V3607) (let ((V3608 (kl:shen.lazyderef (car V3607) V3944))) (if (pair? V3608) (let ((Y (car V3608))) (let ((V3609 (kl:shen.lazyderef (cdr V3608) V3944))) (if (pair? V3609) (let ((V3610 (kl:shen.lazyderef (car V3609) V3944))) (if (eq? (quote :) V3610) (let ((V3611 (kl:shen.lazyderef (cdr V3609) V3944))) (if (pair? V3611) (let ((B (car V3611))) (let ((V3612 (kl:shen.lazyderef (cdr V3611) V3944))) (if (null? V3612) (begin (kl:shen.incinfs) (kl:identical V3941 Y V3944 (lambda () (kl:unify! V3942 B V3944 V3945)))) #f))) #f)) #f)) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((V3613 (kl:shen.lazyderef V3943 V3944))) (if (pair? V3613) (let ((Hyp (cdr V3613))) (begin (kl:shen.incinfs) (kl:shen.by_hypothesis V3941 V3942 Hyp V3944 V3945))) #f)) Case))) (export shen.by_hypothesis) (quote shen.by_hypothesis))
(begin (register-function-arity (quote shen.t*-def) 5) (define (kl:shen.t*-def V3951 V3952 V3953 V3954 V3955) (let ((V3601 (kl:shen.lazyderef V3951 V3954))) (if (pair? V3601) (let ((V3602 (kl:shen.lazyderef (car V3601) V3954))) (if (eq? (quote define) V3602) (let ((V3603 (kl:shen.lazyderef (cdr V3601) V3954))) (if (pair? V3603) (let ((F (car V3603))) (let ((X (cdr V3603))) (let ((Y (kl:shen.newpv V3954))) (let ((E (kl:shen.newpv V3954))) (begin (kl:shen.incinfs) (kl:shen.t*-defh (kl:compile (lambda (Y) (kl:shen.<sig+rules> Y)) X (lambda (E) (if (pair? E) (simple-error (string-append "parse error here: " (kl:shen.app E "\n" (quote shen.s)))) (simple-error "parse error\n")))) F V3952 V3953 V3954 V3955)))))) #f)) #f)) #f))) (export shen.t*-def) (quote shen.t*-def))
(begin (register-function-arity (quote shen.t*-defh) 6) (define (kl:shen.t*-defh V3962 V3963 V3964 V3965 V3966 V3967) (let ((V3597 (kl:shen.lazyderef V3962 V3966))) (if (pair? V3597) (let ((Sig (car V3597))) (let ((Rules (cdr V3597))) (begin (kl:shen.incinfs) (kl:shen.t*-defhh Sig (kl:shen.ue-sig Sig) V3963 V3964 V3965 Rules V3966 V3967)))) #f))) (export shen.t*-defh) (quote shen.t*-defh))
(begin (register-function-arity (quote shen.t*-defhh) 8) (define (kl:shen.t*-defhh V3976 V3977 V3978 V3979 V3980 V3981 V3982 V3983) (begin (kl:shen.incinfs) (kl:shen.t*-rules V3981 V3977 1 V3978 (cons (cons V3978 (cons (quote :) (cons V3977 (quote ())))) V3980) V3982 (lambda () (kl:shen.memo V3978 V3976 V3979 V3982 V3983))))) (export shen.t*-defhh) (quote shen.t*-defhh))
(begin (register-function-arity (quote shen.memo) 5) (define (kl:shen.memo V3989 V3990 V3991 V3992 V3993) (let ((Jnk (kl:shen.newpv V3992))) (begin (kl:shen.incinfs) (kl:unify! V3991 V3990 V3992 (lambda () (kl:bind Jnk (kl:declare (kl:shen.lazyderef V3989 V3992) (kl:shen.lazyderef V3991 V3992)) V3992 V3993)))))) (export shen.memo) (quote shen.memo))
(begin (register-function-arity (quote shen.<sig+rules>) 1) (define (kl:shen.<sig+rules> V3995) (let ((Parse_shen.<signature> (kl:shen.<signature> V3995))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature>)) (let ((Parse_shen.<non-ll-rules> (kl:shen.<non-ll-rules> Parse_shen.<signature>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<non-ll-rules>)) (kl:shen.pair (car Parse_shen.<non-ll-rules>) (cons (kl:shen.hdtl Parse_shen.<signature>) (kl:shen.hdtl Parse_shen.<non-ll-rules>))) (kl:fail))) (kl:fail)))) (export shen.<sig+rules>) (quote shen.<sig+rules>))
(begin (register-function-arity (quote shen.<non-ll-rules>) 1) (define (kl:shen.<non-ll-rules> V3997) (let ((YaccParse (let ((Parse_shen.<rule> (kl:shen.<rule> V3997))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (let ((Parse_shen.<non-ll-rules> (kl:shen.<non-ll-rules> Parse_shen.<rule>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<non-ll-rules>)) (kl:shen.pair (car Parse_shen.<non-ll-rules>) (cons (kl:shen.hdtl Parse_shen.<rule>) (kl:shen.hdtl Parse_shen.<non-ll-rules>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<rule> (kl:shen.<rule> V3997))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (kl:shen.pair (car Parse_shen.<rule>) (cons (kl:shen.hdtl Parse_shen.<rule>) (quote ()))) (kl:fail))) YaccParse))) (export shen.<non-ll-rules>) (quote shen.<non-ll-rules>))
(begin (register-function-arity (quote shen.ue) 1) (define (kl:shen.ue V3999) (cond ((and (pair? V3999) (and (pair? (cdr V3999)) (and (null? (cdr (cdr V3999))) (eq? (car V3999) (quote protect))))) V3999) ((pair? V3999) (kl:map (lambda (Z) (kl:shen.ue Z)) V3999)) ((kl:variable? V3999) (kl:concat (quote &&) V3999)) (#t V3999))) (export shen.ue) (quote shen.ue))
(begin (register-function-arity (quote shen.ue-sig) 1) (define (kl:shen.ue-sig V4001) (cond ((pair? V4001) (kl:map (lambda (Z) (kl:shen.ue-sig Z)) V4001)) ((kl:variable? V4001) (kl:concat (quote &&&) V4001)) (#t V4001))) (export shen.ue-sig) (quote shen.ue-sig))
(begin (register-function-arity (quote shen.ues) 1) (define (kl:shen.ues V4007) (cond ((assert-boolean (kl:shen.ue? V4007)) (cons V4007 (quote ()))) ((pair? V4007) (kl:union (kl:shen.ues (car V4007)) (kl:shen.ues (cdr V4007)))) (#t (quote ())))) (export shen.ues) (quote shen.ues))
(begin (register-function-arity (quote shen.ue?) 1) (define (kl:shen.ue? V4009) (and (kl:symbol? V4009) (assert-boolean (kl:shen.ue-h? (kl:str V4009))))) (export shen.ue?) (quote shen.ue?))
(begin (register-function-arity (quote shen.ue-h?) 1) (define (kl:shen.ue-h? V4017) (cond ((and (assert-boolean (kl:shen.+string? V4017)) (and (equal? "&" (make-string 1 (string-ref V4017 0))) (and (assert-boolean (kl:shen.+string? (string-tail V4017 1))) (equal? "&" (make-string 1 (string-ref (string-tail V4017 1) 0)))))) #t) (#t #f))) (export shen.ue-h?) (quote shen.ue-h?))
(begin (register-function-arity (quote shen.t*-rules) 7) (define (kl:shen.t*-rules V4025 V4026 V4027 V4028 V4029 V4030 V4031) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (let ((V3581 (kl:shen.lazyderef V4025 V4030))) (if (null? V3581) (begin (kl:shen.incinfs) (kl:thaw V4031)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3582 (kl:shen.lazyderef V4025 V4030))) (if (pair? V3582) (let ((Rule (car V3582))) (let ((Rules (cdr V3582))) (begin (kl:shen.incinfs) (kl:shen.t*-rule (kl:shen.ue Rule) V4026 V4029 V4030 (lambda () (kl:cut Throwcontrol V4030 (lambda () (kl:shen.t*-rules Rules V4026 (+ V4027 1) V4028 V4029 V4030 V4031)))))))) #f)))) (if (kl:= Case #f) (let ((Err (kl:shen.newpv V4030))) (begin (kl:shen.incinfs) (kl:bind Err (simple-error (string-append "type error in rule " (kl:shen.app (kl:shen.lazyderef V4027 V4030) (string-append " of " (kl:shen.app (kl:shen.lazyderef V4028 V4030) "" (quote shen.a))) (quote shen.a)))) V4030 V4031))) Case)) Case))))) (export shen.t*-rules) (quote shen.t*-rules))
(begin (register-function-arity (quote shen.t*-rule) 5) (define (kl:shen.t*-rule V4037 V4038 V4039 V4040 V4041) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((V3573 (kl:shen.lazyderef V4037 V4040))) (if (pair? V3573) (let ((Patterns (car V3573))) (let ((V3574 (kl:shen.lazyderef (cdr V3573) V4040))) (if (pair? V3574) (let ((Action (car V3574))) (let ((V3575 (kl:shen.lazyderef (cdr V3574) V4040))) (if (null? V3575) (let ((NewHyps (kl:shen.newpv V4040))) (begin (kl:shen.incinfs) (kl:shen.newhyps (kl:shen.placeholders Patterns) V4039 NewHyps V4040 (lambda () (kl:shen.t*-patterns Patterns V4038 NewHyps V4040 (lambda () (kl:cut Throwcontrol V4040 (lambda () (kl:shen.t*-action (kl:shen.curry (kl:shen.ue Action)) (kl:shen.result-type Patterns V4038) (kl:shen.patthyps Patterns V4038 V4039) V4040 V4041))))))))) #f))) #f))) #f))))) (export shen.t*-rule) (quote shen.t*-rule))
(begin (register-function-arity (quote shen.placeholders) 1) (define (kl:shen.placeholders V4047) (cond ((assert-boolean (kl:shen.ue? V4047)) (cons V4047 (quote ()))) ((pair? V4047) (kl:union (kl:shen.placeholders (car V4047)) (kl:shen.placeholders (cdr V4047)))) (#t (quote ())))) (export shen.placeholders) (quote shen.placeholders))
(begin (register-function-arity (quote shen.newhyps) 5) (define (kl:shen.newhyps V4053 V4054 V4055 V4056 V4057) (let ((Case (let ((V3560 (kl:shen.lazyderef V4053 V4056))) (if (null? V3560) (begin (kl:shen.incinfs) (kl:unify! V4055 V4054 V4056 V4057)) #f)))) (if (kl:= Case #f) (let ((V3561 (kl:shen.lazyderef V4053 V4056))) (if (pair? V3561) (let ((V3556 (car V3561))) (let ((Vs (cdr V3561))) (let ((V3562 (kl:shen.lazyderef V4055 V4056))) (if (pair? V3562) (let ((V3563 (kl:shen.lazyderef (car V3562) V4056))) (if (pair? V3563) (let ((V (car V3563))) (let ((V3564 (kl:shen.lazyderef (cdr V3563) V4056))) (if (pair? V3564) (let ((V3565 (kl:shen.lazyderef (car V3564) V4056))) (if (eq? (quote :) V3565) (let ((V3566 (kl:shen.lazyderef (cdr V3564) V4056))) (if (pair? V3566) (let ((A (car V3566))) (let ((V3567 (kl:shen.lazyderef (cdr V3566) V4056))) (if (null? V3567) (let ((NewHyp (cdr V3562))) (begin (kl:shen.incinfs) (kl:unify! V V3556 V4056 (lambda () (kl:shen.newhyps Vs V4054 NewHyp V4056 V4057))))) (if (kl:shen.pvar? V3567) (begin (kl:shen.bindv V3567 (quote ()) V4056) (let ((Result (let ((NewHyp (cdr V3562))) (begin (kl:shen.incinfs) (kl:unify! V V3556 V4056 (lambda () (kl:shen.newhyps Vs V4054 NewHyp V4056 V4057))))))) (begin (kl:shen.unbindv V3567 V4056) Result))) #f)))) (if (kl:shen.pvar? V3566) (let ((A (kl:shen.newpv V4056))) (begin (kl:shen.bindv V3566 (cons A (quote ())) V4056) (let ((Result (let ((NewHyp (cdr V3562))) (begin (kl:shen.incinfs) (kl:unify! V V3556 V4056 (lambda () (kl:shen.newhyps Vs V4054 NewHyp V4056 V4057))))))) (begin (kl:shen.unbindv V3566 V4056) Result)))) #f))) (if (kl:shen.pvar? V3565) (begin (kl:shen.bindv V3565 (quote :) V4056) (let ((Result (let ((V3568 (kl:shen.lazyderef (cdr V3564) V4056))) (if (pair? V3568) (let ((A (car V3568))) (let ((V3569 (kl:shen.lazyderef (cdr V3568) V4056))) (if (null? V3569) (let ((NewHyp (cdr V3562))) (begin (kl:shen.incinfs) (kl:unify! V V3556 V4056 (lambda () (kl:shen.newhyps Vs V4054 NewHyp V4056 V4057))))) (if (kl:shen.pvar? V3569) (begin (kl:shen.bindv V3569 (quote ()) V4056) (let ((Result (let ((NewHyp (cdr V3562))) (begin (kl:shen.incinfs) (kl:unify! V V3556 V4056 (lambda () (kl:shen.newhyps Vs V4054 NewHyp V4056 V4057))))))) (begin (kl:shen.unbindv V3569 V4056) Result))) #f)))) (if (kl:shen.pvar? V3568) (let ((A (kl:shen.newpv V4056))) (begin (kl:shen.bindv V3568 (cons A (quote ())) V4056) (let ((Result (let ((NewHyp (cdr V3562))) (begin (kl:shen.incinfs) (kl:unify! V V3556 V4056 (lambda () (kl:shen.newhyps Vs V4054 NewHyp V4056 V4057))))))) (begin (kl:shen.unbindv V3568 V4056) Result)))) #f))))) (begin (kl:shen.unbindv V3565 V4056) Result))) #f))) (if (kl:shen.pvar? V3564) (let ((A (kl:shen.newpv V4056))) (begin (kl:shen.bindv V3564 (cons (quote :) (cons A (quote ()))) V4056) (let ((Result (let ((NewHyp (cdr V3562))) (begin (kl:shen.incinfs) (kl:unify! V V3556 V4056 (lambda () (kl:shen.newhyps Vs V4054 NewHyp V4056 V4057))))))) (begin (kl:shen.unbindv V3564 V4056) Result)))) #f)))) (if (kl:shen.pvar? V3563) (let ((V (kl:shen.newpv V4056))) (let ((A (kl:shen.newpv V4056))) (begin (kl:shen.bindv V3563 (cons V (cons (quote :) (cons A (quote ())))) V4056) (let ((Result (let ((NewHyp (cdr V3562))) (begin (kl:shen.incinfs) (kl:unify! V V3556 V4056 (lambda () (kl:shen.newhyps Vs V4054 NewHyp V4056 V4057))))))) (begin (kl:shen.unbindv V3563 V4056) Result))))) #f))) (if (kl:shen.pvar? V3562) (let ((V (kl:shen.newpv V4056))) (let ((A (kl:shen.newpv V4056))) (let ((NewHyp (kl:shen.newpv V4056))) (begin (kl:shen.bindv V3562 (cons (cons V (cons (quote :) (cons A (quote ())))) NewHyp) V4056) (let ((Result (begin (kl:shen.incinfs) (kl:unify! V V3556 V4056 (lambda () (kl:shen.newhyps Vs V4054 NewHyp V4056 V4057)))))) (begin (kl:shen.unbindv V3562 V4056) Result)))))) #f))))) #f)) Case))) (export shen.newhyps) (quote shen.newhyps))
(begin (register-function-arity (quote shen.patthyps) 3) (define (kl:shen.patthyps V4063 V4064 V4065) (cond ((null? V4063) V4065) ((and (pair? V4063) (and (pair? V4064) (and (pair? (cdr V4064)) (and (eq? (quote -->) (car (cdr V4064))) (and (pair? (cdr (cdr V4064))) (null? (cdr (cdr (cdr V4064))))))))) (kl:adjoin (cons (car V4063) (cons (quote :) (cons (car V4064) (quote ())))) (kl:shen.patthyps (cdr V4063) (car (cdr (cdr V4064))) V4065))) (#t (kl:shen.f_error (quote shen.patthyps))))) (export shen.patthyps) (quote shen.patthyps))
(begin (register-function-arity (quote shen.result-type) 2) (define (kl:shen.result-type V4072 V4073) (cond ((and (null? V4072) (and (pair? V4073) (and (eq? (quote -->) (car V4073)) (and (pair? (cdr V4073)) (null? (cdr (cdr V4073))))))) (car (cdr V4073))) ((null? V4072) V4073) ((and (pair? V4072) (and (pair? V4073) (and (pair? (cdr V4073)) (and (eq? (quote -->) (car (cdr V4073))) (and (pair? (cdr (cdr V4073))) (null? (cdr (cdr (cdr V4073))))))))) (kl:shen.result-type (cdr V4072) (car (cdr (cdr V4073))))) (#t (kl:shen.f_error (quote shen.result-type))))) (export shen.result-type) (quote shen.result-type))
(begin (register-function-arity (quote shen.t*-patterns) 5) (define (kl:shen.t*-patterns V4079 V4080 V4081 V4082 V4083) (let ((Case (let ((V3548 (kl:shen.lazyderef V4079 V4082))) (if (null? V3548) (begin (kl:shen.incinfs) (kl:thaw V4083)) #f)))) (if (kl:= Case #f) (let ((V3549 (kl:shen.lazyderef V4079 V4082))) (if (pair? V3549) (let ((Pattern (car V3549))) (let ((Patterns (cdr V3549))) (let ((V3550 (kl:shen.lazyderef V4080 V4082))) (if (pair? V3550) (let ((A (car V3550))) (let ((V3551 (kl:shen.lazyderef (cdr V3550) V4082))) (if (pair? V3551) (let ((V3552 (kl:shen.lazyderef (car V3551) V4082))) (if (eq? (quote -->) V3552) (let ((V3553 (kl:shen.lazyderef (cdr V3551) V4082))) (if (pair? V3553) (let ((B (car V3553))) (let ((V3554 (kl:shen.lazyderef (cdr V3553) V4082))) (if (null? V3554) (begin (kl:shen.incinfs) (kl:shen.t* (cons Pattern (cons (quote :) (cons A (quote ())))) V4081 V4082 (lambda () (kl:shen.t*-patterns Patterns B V4081 V4082 V4083)))) #f))) #f)) #f)) #f))) #f)))) #f)) Case))) (export shen.t*-patterns) (quote shen.t*-patterns))
(begin (register-function-arity (quote shen.t*-action) 5) (define (kl:shen.t*-action V4089 V4090 V4091 V4092 V4093) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (let ((V3525 (kl:shen.lazyderef V4089 V4092))) (if (pair? V3525) (let ((V3526 (kl:shen.lazyderef (car V3525) V4092))) (if (eq? (quote where) V3526) (let ((V3527 (kl:shen.lazyderef (cdr V3525) V4092))) (if (pair? V3527) (let ((P (car V3527))) (let ((V3528 (kl:shen.lazyderef (cdr V3527) V4092))) (if (pair? V3528) (let ((Action (car V3528))) (let ((V3529 (kl:shen.lazyderef (cdr V3528) V4092))) (if (null? V3529) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V4092 (lambda () (kl:shen.t* (cons P (cons (quote :) (cons (quote boolean) (quote ())))) V4091 V4092 (lambda () (kl:cut Throwcontrol V4092 (lambda () (kl:shen.t*-action Action V4090 (cons (cons P (cons (quote :) (cons (quote verified) (quote ())))) V4091) V4092 V4093)))))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3530 (kl:shen.lazyderef V4089 V4092))) (if (pair? V3530) (let ((V3531 (kl:shen.lazyderef (car V3530) V4092))) (if (eq? (quote shen.choicepoint!) V3531) (let ((V3532 (kl:shen.lazyderef (cdr V3530) V4092))) (if (pair? V3532) (let ((V3533 (kl:shen.lazyderef (car V3532) V4092))) (if (pair? V3533) (let ((V3534 (kl:shen.lazyderef (car V3533) V4092))) (if (pair? V3534) (let ((V3535 (kl:shen.lazyderef (car V3534) V4092))) (if (eq? (quote fail-if) V3535) (let ((V3536 (kl:shen.lazyderef (cdr V3534) V4092))) (if (pair? V3536) (let ((F (car V3536))) (let ((V3537 (kl:shen.lazyderef (cdr V3536) V4092))) (if (null? V3537) (let ((V3538 (kl:shen.lazyderef (cdr V3533) V4092))) (if (pair? V3538) (let ((Action (car V3538))) (let ((V3539 (kl:shen.lazyderef (cdr V3538) V4092))) (if (null? V3539) (let ((V3540 (kl:shen.lazyderef (cdr V3532) V4092))) (if (null? V3540) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V4092 (lambda () (kl:shen.t*-action (cons (quote where) (cons (cons (quote not) (cons (cons F (cons Action (quote ()))) (quote ()))) (cons Action (quote ())))) V4090 V4091 V4092 V4093)))) #f)) #f))) #f)) #f))) #f)) #f)) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3541 (kl:shen.lazyderef V4089 V4092))) (if (pair? V3541) (let ((V3542 (kl:shen.lazyderef (car V3541) V4092))) (if (eq? (quote shen.choicepoint!) V3542) (let ((V3543 (kl:shen.lazyderef (cdr V3541) V4092))) (if (pair? V3543) (let ((Action (car V3543))) (let ((V3544 (kl:shen.lazyderef (cdr V3543) V4092))) (if (null? V3544) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V4092 (lambda () (kl:shen.t*-action (cons (quote where) (cons (cons (quote not) (cons (cons (cons (quote =) (cons Action (quote ()))) (cons (cons (quote fail) (quote ())) (quote ()))) (quote ()))) (cons Action (quote ())))) V4090 V4091 V4092 V4093)))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (begin (kl:shen.incinfs) (kl:shen.t* (cons V4089 (cons (quote :) (cons V4090 (quote ())))) V4091 V4092 V4093)) Case)) Case)) Case))))) (export shen.t*-action) (quote shen.t*-action))
(begin (register-function-arity (quote findall) 5) (define (kl:findall V4099 V4100 V4101 V4102 V4103) (let ((B (kl:shen.newpv V4102))) (let ((A (kl:shen.newpv V4102))) (begin (kl:shen.incinfs) (kl:bind A (kl:gensym (quote shen.a)) V4102 (lambda () (kl:bind B (kl:set (kl:shen.lazyderef A V4102) (quote ())) V4102 (lambda () (kl:shen.findallhelp V4099 V4100 V4101 A V4102 V4103))))))))) (export findall) (quote findall))
(begin (register-function-arity (quote shen.findallhelp) 6) (define (kl:shen.findallhelp V4110 V4111 V4112 V4113 V4114 V4115) (let ((Case (begin (kl:shen.incinfs) (kl:call V4111 V4114 (lambda () (kl:shen.remember V4113 V4110 V4114 (lambda () (kl:fwhen #f V4114 V4115)))))))) (if (kl:= Case #f) (begin (kl:shen.incinfs) (kl:bind V4112 (kl:value (kl:shen.lazyderef V4113 V4114)) V4114 V4115)) Case))) (export shen.findallhelp) (quote shen.findallhelp))
(begin (register-function-arity (quote shen.remember) 4) (define (kl:shen.remember V4120 V4121 V4122 V4123) (let ((B (kl:shen.newpv V4122))) (begin (kl:shen.incinfs) (kl:bind B (kl:set (kl:shen.deref V4120 V4122) (cons (kl:shen.deref V4121 V4122) (kl:value (kl:shen.deref V4120 V4122)))) V4122 V4123)))) (export shen.remember) (quote shen.remember))
