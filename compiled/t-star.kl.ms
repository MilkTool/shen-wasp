"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.typecheck) 2) (define (kl:shen.typecheck V3386 V3387) (let ((Curry (kl:shen.curry V3386))) (let ((ProcessN (kl:shen.start-new-prolog-process))) (let ((Type (kl:shen.insert-prolog-variables (kl:shen.demodulate (kl:shen.curry-type V3387)) ProcessN))) (let ((Continuation (lambda () (kl:return Type ProcessN (quote shen.void))))) (kl:shen.t* (cons Curry (cons (quote :) (cons Type (quote ())))) (quote ()) ProcessN Continuation)))))) (quote shen.typecheck))
(begin (register-function-arity (quote shen.curry) 1) (define (kl:shen.curry V3389) (cond ((and (pair? V3389) (assert-boolean (kl:shen.special? (car V3389)))) (cons (car V3389) (kl:map (lambda (Y) (kl:shen.curry Y)) (cdr V3389)))) ((and (pair? V3389) (and (pair? (cdr V3389)) (assert-boolean (kl:shen.extraspecial? (car V3389))))) V3389) ((and (pair? V3389) (and (eq? (quote type) (car V3389)) (and (pair? (cdr V3389)) (and (pair? (cdr (cdr V3389))) (null? (cdr (cdr (cdr V3389)))))))) (cons (quote type) (cons (kl:shen.curry (car (cdr V3389))) (cdr (cdr V3389))))) ((and (pair? V3389) (and (pair? (cdr V3389)) (pair? (cdr (cdr V3389))))) (kl:shen.curry (cons (cons (car V3389) (cons (car (cdr V3389)) (quote ()))) (cdr (cdr V3389))))) ((and (pair? V3389) (and (pair? (cdr V3389)) (null? (cdr (cdr V3389))))) (cons (kl:shen.curry (car V3389)) (cons (kl:shen.curry (car (cdr V3389))) (quote ())))) (#t V3389))) (quote shen.curry))
(begin (register-function-arity (quote shen.special?) 1) (define (kl:shen.special? V3391) (kl:element? V3391 (kl:value (quote shen.*special*)))) (quote shen.special?))
(begin (register-function-arity (quote shen.extraspecial?) 1) (define (kl:shen.extraspecial? V3393) (kl:element? V3393 (kl:value (quote shen.*extraspecial*)))) (quote shen.extraspecial?))
(begin (register-function-arity (quote shen.t*) 4) (define (kl:shen.t* V3398 V3399 V3400 V3401) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (let ((Error (kl:shen.newpv V3400))) (begin (kl:shen.incinfs) (kl:fwhen (kl:shen.maxinfexceeded?) V3400 (lambda () (kl:bind Error (kl:shen.errormaxinfs) V3400 V3401))))))) (if (kl:= Case #f) (let ((Case (let ((V3378 (kl:shen.lazyderef V3398 V3400))) (if (eq? (quote fail) V3378) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3400 (lambda () (kl:shen.prolog-failure V3400 V3401)))) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3379 (kl:shen.lazyderef V3398 V3400))) (if (pair? V3379) (let ((X (car V3379))) (let ((V3380 (kl:shen.lazyderef (cdr V3379) V3400))) (if (pair? V3380) (let ((V3381 (kl:shen.lazyderef (car V3380) V3400))) (if (eq? (quote :) V3381) (let ((V3382 (kl:shen.lazyderef (cdr V3380) V3400))) (if (pair? V3382) (let ((A (car V3382))) (let ((V3383 (kl:shen.lazyderef (cdr V3382) V3400))) (if (null? V3383) (begin (kl:shen.incinfs) (kl:fwhen (kl:shen.type-theory-enabled?) V3400 (lambda () (kl:cut Throwcontrol V3400 (lambda () (kl:shen.th* X A V3399 V3400 V3401)))))) #f))) #f)) #f)) #f))) #f)))) (if (kl:= Case #f) (let ((Datatypes (kl:shen.newpv V3400))) (begin (kl:shen.incinfs) (kl:shen.show V3398 V3399 V3400 (lambda () (kl:bind Datatypes (kl:value (quote shen.*datatypes*)) V3400 (lambda () (kl:shen.udefs* V3398 V3399 Datatypes V3400 V3401))))))) Case)) Case)) Case))))) (quote shen.t*))
(begin (register-function-arity (quote shen.type-theory-enabled?) 0) (define (kl:shen.type-theory-enabled?) (kl:value (quote shen.*shen-type-theory-enabled?*))) (quote shen.type-theory-enabled?))
(begin (register-function-arity (quote enable-type-theory) 1) (define (kl:enable-type-theory V3407) (cond ((eq? (quote +) V3407) (kl:set (quote shen.*shen-type-theory-enabled?*) #t)) ((eq? (quote -) V3407) (kl:set (quote shen.*shen-type-theory-enabled?*) #f)) (#t (simple-error "enable-type-theory expects a + or a -\n")))) (quote enable-type-theory))
(begin (register-function-arity (quote shen.prolog-failure) 2) (define (kl:shen.prolog-failure V3418 V3419) #f) (quote shen.prolog-failure))
(begin (register-function-arity (quote shen.maxinfexceeded?) 0) (define (kl:shen.maxinfexceeded?) (> (kl:inferences) (kl:value (quote shen.*maxinferences*)))) (quote shen.maxinfexceeded?))
(begin (register-function-arity (quote shen.errormaxinfs) 0) (define (kl:shen.errormaxinfs) (simple-error "maximum inferences exceeded~%")) (quote shen.errormaxinfs))
(begin (register-function-arity (quote shen.udefs*) 5) (define (kl:shen.udefs* V3425 V3426 V3427 V3428 V3429) (let ((Case (let ((V3374 (kl:shen.lazyderef V3427 V3428))) (if (pair? V3374) (let ((D (car V3374))) (begin (kl:shen.incinfs) (kl:call (cons D (cons V3425 (cons V3426 (quote ())))) V3428 V3429))) #f)))) (if (kl:= Case #f) (let ((V3375 (kl:shen.lazyderef V3427 V3428))) (if (pair? V3375) (let ((Ds (cdr V3375))) (begin (kl:shen.incinfs) (kl:shen.udefs* V3425 V3426 Ds V3428 V3429))) #f)) Case))) (quote shen.udefs*))
(begin (register-function-arity (quote shen.th*) 5) (define (kl:shen.th* V3435 V3436 V3437 V3438 V3439) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (begin (kl:shen.incinfs) (kl:shen.show (cons V3435 (cons (quote :) (cons V3436 (quote ())))) V3437 V3438 (lambda () (kl:fwhen #f V3438 V3439)))))) (if (kl:= Case #f) (let ((Case (let ((F (kl:shen.newpv V3438))) (begin (kl:shen.incinfs) (kl:fwhen (kl:shen.typedf? (kl:shen.lazyderef V3435 V3438)) V3438 (lambda () (kl:bind F (kl:shen.sigf (kl:shen.lazyderef V3435 V3438)) V3438 (lambda () (kl:call (cons F (cons V3436 (quote ()))) V3438 V3439))))))))) (if (kl:= Case #f) (let ((Case (begin (kl:shen.incinfs) (kl:shen.base V3435 V3436 V3438 V3439)))) (if (kl:= Case #f) (let ((Case (begin (kl:shen.incinfs) (kl:shen.by_hypothesis V3435 V3436 V3437 V3438 V3439)))) (if (kl:= Case #f) (let ((Case (let ((V3270 (kl:shen.lazyderef V3435 V3438))) (if (pair? V3270) (let ((F (car V3270))) (let ((V3271 (kl:shen.lazyderef (cdr V3270) V3438))) (if (null? V3271) (begin (kl:shen.incinfs) (kl:shen.th* F (cons (quote -->) (cons V3436 (quote ()))) V3437 V3438 V3439)) #f))) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3272 (kl:shen.lazyderef V3435 V3438))) (if (pair? V3272) (let ((F (car V3272))) (let ((V3273 (kl:shen.lazyderef (cdr V3272) V3438))) (if (pair? V3273) (let ((X (car V3273))) (let ((V3274 (kl:shen.lazyderef (cdr V3273) V3438))) (if (null? V3274) (let ((B (kl:shen.newpv V3438))) (begin (kl:shen.incinfs) (kl:shen.th* F (cons B (cons (quote -->) (cons V3436 (quote ())))) V3437 V3438 (lambda () (kl:shen.th* X B V3437 V3438 V3439))))) #f))) #f))) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3275 (kl:shen.lazyderef V3435 V3438))) (if (pair? V3275) (let ((V3276 (kl:shen.lazyderef (car V3275) V3438))) (if (eq? (quote cons) V3276) (let ((V3277 (kl:shen.lazyderef (cdr V3275) V3438))) (if (pair? V3277) (let ((X (car V3277))) (let ((V3278 (kl:shen.lazyderef (cdr V3277) V3438))) (if (pair? V3278) (let ((Y (car V3278))) (let ((V3279 (kl:shen.lazyderef (cdr V3278) V3438))) (if (null? V3279) (let ((V3280 (kl:shen.lazyderef V3436 V3438))) (if (pair? V3280) (let ((V3281 (kl:shen.lazyderef (car V3280) V3438))) (if (eq? (quote list) V3281) (let ((V3282 (kl:shen.lazyderef (cdr V3280) V3438))) (if (pair? V3282) (let ((A (car V3282))) (let ((V3283 (kl:shen.lazyderef (cdr V3282) V3438))) (if (null? V3283) (begin (kl:shen.incinfs) (kl:shen.th* X A V3437 V3438 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3437 V3438 V3439)))) (if (assert-boolean (kl:shen.pvar? V3283)) (begin (kl:shen.bindv V3283 (quote ()) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3437 V3438 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3437 V3438 V3439)))))) (begin (kl:shen.unbindv V3283 V3438) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3282)) (let ((A (kl:shen.newpv V3438))) (begin (kl:shen.bindv V3282 (cons A (quote ())) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3437 V3438 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3437 V3438 V3439)))))) (begin (kl:shen.unbindv V3282 V3438) Result)))) #f))) (if (assert-boolean (kl:shen.pvar? V3281)) (begin (kl:shen.bindv V3281 (quote list) V3438) (let ((Result (let ((V3284 (kl:shen.lazyderef (cdr V3280) V3438))) (if (pair? V3284) (let ((A (car V3284))) (let ((V3285 (kl:shen.lazyderef (cdr V3284) V3438))) (if (null? V3285) (begin (kl:shen.incinfs) (kl:shen.th* X A V3437 V3438 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3437 V3438 V3439)))) (if (assert-boolean (kl:shen.pvar? V3285)) (begin (kl:shen.bindv V3285 (quote ()) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3437 V3438 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3437 V3438 V3439)))))) (begin (kl:shen.unbindv V3285 V3438) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3284)) (let ((A (kl:shen.newpv V3438))) (begin (kl:shen.bindv V3284 (cons A (quote ())) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3437 V3438 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3437 V3438 V3439)))))) (begin (kl:shen.unbindv V3284 V3438) Result)))) #f))))) (begin (kl:shen.unbindv V3281 V3438) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3280)) (let ((A (kl:shen.newpv V3438))) (begin (kl:shen.bindv V3280 (cons (quote list) (cons A (quote ()))) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3437 V3438 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V3437 V3438 V3439)))))) (begin (kl:shen.unbindv V3280 V3438) Result)))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3286 (kl:shen.lazyderef V3435 V3438))) (if (pair? V3286) (let ((V3287 (kl:shen.lazyderef (car V3286) V3438))) (if (eq? (quote _waspvm_at_p) V3287) (let ((V3288 (kl:shen.lazyderef (cdr V3286) V3438))) (if (pair? V3288) (let ((X (car V3288))) (let ((V3289 (kl:shen.lazyderef (cdr V3288) V3438))) (if (pair? V3289) (let ((Y (car V3289))) (let ((V3290 (kl:shen.lazyderef (cdr V3289) V3438))) (if (null? V3290) (let ((V3291 (kl:shen.lazyderef V3436 V3438))) (if (pair? V3291) (let ((A (car V3291))) (let ((V3292 (kl:shen.lazyderef (cdr V3291) V3438))) (if (pair? V3292) (let ((V3293 (kl:shen.lazyderef (car V3292) V3438))) (if (eq? (quote *) V3293) (let ((V3294 (kl:shen.lazyderef (cdr V3292) V3438))) (if (pair? V3294) (let ((B (car V3294))) (let ((V3295 (kl:shen.lazyderef (cdr V3294) V3438))) (if (null? V3295) (begin (kl:shen.incinfs) (kl:shen.th* X A V3437 V3438 (lambda () (kl:shen.th* Y B V3437 V3438 V3439)))) (if (assert-boolean (kl:shen.pvar? V3295)) (begin (kl:shen.bindv V3295 (quote ()) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3437 V3438 (lambda () (kl:shen.th* Y B V3437 V3438 V3439)))))) (begin (kl:shen.unbindv V3295 V3438) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3294)) (let ((B (kl:shen.newpv V3438))) (begin (kl:shen.bindv V3294 (cons B (quote ())) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3437 V3438 (lambda () (kl:shen.th* Y B V3437 V3438 V3439)))))) (begin (kl:shen.unbindv V3294 V3438) Result)))) #f))) (if (assert-boolean (kl:shen.pvar? V3293)) (begin (kl:shen.bindv V3293 (quote *) V3438) (let ((Result (let ((V3296 (kl:shen.lazyderef (cdr V3292) V3438))) (if (pair? V3296) (let ((B (car V3296))) (let ((V3297 (kl:shen.lazyderef (cdr V3296) V3438))) (if (null? V3297) (begin (kl:shen.incinfs) (kl:shen.th* X A V3437 V3438 (lambda () (kl:shen.th* Y B V3437 V3438 V3439)))) (if (assert-boolean (kl:shen.pvar? V3297)) (begin (kl:shen.bindv V3297 (quote ()) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3437 V3438 (lambda () (kl:shen.th* Y B V3437 V3438 V3439)))))) (begin (kl:shen.unbindv V3297 V3438) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3296)) (let ((B (kl:shen.newpv V3438))) (begin (kl:shen.bindv V3296 (cons B (quote ())) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3437 V3438 (lambda () (kl:shen.th* Y B V3437 V3438 V3439)))))) (begin (kl:shen.unbindv V3296 V3438) Result)))) #f))))) (begin (kl:shen.unbindv V3293 V3438) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3292)) (let ((B (kl:shen.newpv V3438))) (begin (kl:shen.bindv V3292 (cons (quote *) (cons B (quote ()))) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3437 V3438 (lambda () (kl:shen.th* Y B V3437 V3438 V3439)))))) (begin (kl:shen.unbindv V3292 V3438) Result)))) #f)))) (if (assert-boolean (kl:shen.pvar? V3291)) (let ((A (kl:shen.newpv V3438))) (let ((B (kl:shen.newpv V3438))) (begin (kl:shen.bindv V3291 (cons A (cons (quote *) (cons B (quote ())))) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3437 V3438 (lambda () (kl:shen.th* Y B V3437 V3438 V3439)))))) (begin (kl:shen.unbindv V3291 V3438) Result))))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3298 (kl:shen.lazyderef V3435 V3438))) (if (pair? V3298) (let ((V3299 (kl:shen.lazyderef (car V3298) V3438))) (if (eq? (quote _waspvm_at_v) V3299) (let ((V3300 (kl:shen.lazyderef (cdr V3298) V3438))) (if (pair? V3300) (let ((X (car V3300))) (let ((V3301 (kl:shen.lazyderef (cdr V3300) V3438))) (if (pair? V3301) (let ((Y (car V3301))) (let ((V3302 (kl:shen.lazyderef (cdr V3301) V3438))) (if (null? V3302) (let ((V3303 (kl:shen.lazyderef V3436 V3438))) (if (pair? V3303) (let ((V3304 (kl:shen.lazyderef (car V3303) V3438))) (if (eq? (quote vector) V3304) (let ((V3305 (kl:shen.lazyderef (cdr V3303) V3438))) (if (pair? V3305) (let ((A (car V3305))) (let ((V3306 (kl:shen.lazyderef (cdr V3305) V3438))) (if (null? V3306) (begin (kl:shen.incinfs) (kl:shen.th* X A V3437 V3438 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3437 V3438 V3439)))) (if (assert-boolean (kl:shen.pvar? V3306)) (begin (kl:shen.bindv V3306 (quote ()) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3437 V3438 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3437 V3438 V3439)))))) (begin (kl:shen.unbindv V3306 V3438) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3305)) (let ((A (kl:shen.newpv V3438))) (begin (kl:shen.bindv V3305 (cons A (quote ())) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3437 V3438 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3437 V3438 V3439)))))) (begin (kl:shen.unbindv V3305 V3438) Result)))) #f))) (if (assert-boolean (kl:shen.pvar? V3304)) (begin (kl:shen.bindv V3304 (quote vector) V3438) (let ((Result (let ((V3307 (kl:shen.lazyderef (cdr V3303) V3438))) (if (pair? V3307) (let ((A (car V3307))) (let ((V3308 (kl:shen.lazyderef (cdr V3307) V3438))) (if (null? V3308) (begin (kl:shen.incinfs) (kl:shen.th* X A V3437 V3438 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3437 V3438 V3439)))) (if (assert-boolean (kl:shen.pvar? V3308)) (begin (kl:shen.bindv V3308 (quote ()) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3437 V3438 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3437 V3438 V3439)))))) (begin (kl:shen.unbindv V3308 V3438) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3307)) (let ((A (kl:shen.newpv V3438))) (begin (kl:shen.bindv V3307 (cons A (quote ())) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3437 V3438 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3437 V3438 V3439)))))) (begin (kl:shen.unbindv V3307 V3438) Result)))) #f))))) (begin (kl:shen.unbindv V3304 V3438) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3303)) (let ((A (kl:shen.newpv V3438))) (begin (kl:shen.bindv V3303 (cons (quote vector) (cons A (quote ()))) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V3437 V3438 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V3437 V3438 V3439)))))) (begin (kl:shen.unbindv V3303 V3438) Result)))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3309 (kl:shen.lazyderef V3435 V3438))) (if (pair? V3309) (let ((V3310 (kl:shen.lazyderef (car V3309) V3438))) (if (eq? (quote _waspvm_at_s) V3310) (let ((V3311 (kl:shen.lazyderef (cdr V3309) V3438))) (if (pair? V3311) (let ((X (car V3311))) (let ((V3312 (kl:shen.lazyderef (cdr V3311) V3438))) (if (pair? V3312) (let ((Y (car V3312))) (let ((V3313 (kl:shen.lazyderef (cdr V3312) V3438))) (if (null? V3313) (let ((V3314 (kl:shen.lazyderef V3436 V3438))) (if (eq? (quote string) V3314) (begin (kl:shen.incinfs) (kl:shen.th* X (quote string) V3437 V3438 (lambda () (kl:shen.th* Y (quote string) V3437 V3438 V3439)))) (if (assert-boolean (kl:shen.pvar? V3314)) (begin (kl:shen.bindv V3314 (quote string) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X (quote string) V3437 V3438 (lambda () (kl:shen.th* Y (quote string) V3437 V3438 V3439)))))) (begin (kl:shen.unbindv V3314 V3438) Result))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3315 (kl:shen.lazyderef V3435 V3438))) (if (pair? V3315) (let ((V3316 (kl:shen.lazyderef (car V3315) V3438))) (if (eq? (quote lambda) V3316) (let ((V3317 (kl:shen.lazyderef (cdr V3315) V3438))) (if (pair? V3317) (let ((X (car V3317))) (let ((V3318 (kl:shen.lazyderef (cdr V3317) V3438))) (if (pair? V3318) (let ((Y (car V3318))) (let ((V3319 (kl:shen.lazyderef (cdr V3318) V3438))) (if (null? V3319) (let ((V3320 (kl:shen.lazyderef V3436 V3438))) (if (pair? V3320) (let ((A (car V3320))) (let ((V3321 (kl:shen.lazyderef (cdr V3320) V3438))) (if (pair? V3321) (let ((V3322 (kl:shen.lazyderef (car V3321) V3438))) (if (eq? (quote -->) V3322) (let ((V3323 (kl:shen.lazyderef (cdr V3321) V3438))) (if (pair? V3323) (let ((B (car V3323))) (let ((V3324 (kl:shen.lazyderef (cdr V3323) V3438))) (if (null? V3324) (let ((Z (kl:shen.newpv V3438))) (let ((X&& (kl:shen.newpv V3438))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3438 (lambda () (kl:bind X&& (kl:shen.placeholder) V3438 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3438) (kl:shen.lazyderef X V3438) (kl:shen.lazyderef Y V3438)) V3438 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3437) V3438 V3439)))))))))) (if (assert-boolean (kl:shen.pvar? V3324)) (begin (kl:shen.bindv V3324 (quote ()) V3438) (let ((Result (let ((Z (kl:shen.newpv V3438))) (let ((X&& (kl:shen.newpv V3438))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3438 (lambda () (kl:bind X&& (kl:shen.placeholder) V3438 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3438) (kl:shen.lazyderef X V3438) (kl:shen.lazyderef Y V3438)) V3438 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3437) V3438 V3439)))))))))))) (begin (kl:shen.unbindv V3324 V3438) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3323)) (let ((B (kl:shen.newpv V3438))) (begin (kl:shen.bindv V3323 (cons B (quote ())) V3438) (let ((Result (let ((Z (kl:shen.newpv V3438))) (let ((X&& (kl:shen.newpv V3438))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3438 (lambda () (kl:bind X&& (kl:shen.placeholder) V3438 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3438) (kl:shen.lazyderef X V3438) (kl:shen.lazyderef Y V3438)) V3438 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3437) V3438 V3439)))))))))))) (begin (kl:shen.unbindv V3323 V3438) Result)))) #f))) (if (assert-boolean (kl:shen.pvar? V3322)) (begin (kl:shen.bindv V3322 (quote -->) V3438) (let ((Result (let ((V3325 (kl:shen.lazyderef (cdr V3321) V3438))) (if (pair? V3325) (let ((B (car V3325))) (let ((V3326 (kl:shen.lazyderef (cdr V3325) V3438))) (if (null? V3326) (let ((Z (kl:shen.newpv V3438))) (let ((X&& (kl:shen.newpv V3438))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3438 (lambda () (kl:bind X&& (kl:shen.placeholder) V3438 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3438) (kl:shen.lazyderef X V3438) (kl:shen.lazyderef Y V3438)) V3438 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3437) V3438 V3439)))))))))) (if (assert-boolean (kl:shen.pvar? V3326)) (begin (kl:shen.bindv V3326 (quote ()) V3438) (let ((Result (let ((Z (kl:shen.newpv V3438))) (let ((X&& (kl:shen.newpv V3438))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3438 (lambda () (kl:bind X&& (kl:shen.placeholder) V3438 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3438) (kl:shen.lazyderef X V3438) (kl:shen.lazyderef Y V3438)) V3438 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3437) V3438 V3439)))))))))))) (begin (kl:shen.unbindv V3326 V3438) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3325)) (let ((B (kl:shen.newpv V3438))) (begin (kl:shen.bindv V3325 (cons B (quote ())) V3438) (let ((Result (let ((Z (kl:shen.newpv V3438))) (let ((X&& (kl:shen.newpv V3438))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3438 (lambda () (kl:bind X&& (kl:shen.placeholder) V3438 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3438) (kl:shen.lazyderef X V3438) (kl:shen.lazyderef Y V3438)) V3438 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3437) V3438 V3439)))))))))))) (begin (kl:shen.unbindv V3325 V3438) Result)))) #f))))) (begin (kl:shen.unbindv V3322 V3438) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3321)) (let ((B (kl:shen.newpv V3438))) (begin (kl:shen.bindv V3321 (cons (quote -->) (cons B (quote ()))) V3438) (let ((Result (let ((Z (kl:shen.newpv V3438))) (let ((X&& (kl:shen.newpv V3438))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3438 (lambda () (kl:bind X&& (kl:shen.placeholder) V3438 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3438) (kl:shen.lazyderef X V3438) (kl:shen.lazyderef Y V3438)) V3438 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3437) V3438 V3439)))))))))))) (begin (kl:shen.unbindv V3321 V3438) Result)))) #f)))) (if (assert-boolean (kl:shen.pvar? V3320)) (let ((A (kl:shen.newpv V3438))) (let ((B (kl:shen.newpv V3438))) (begin (kl:shen.bindv V3320 (cons A (cons (quote -->) (cons B (quote ())))) V3438) (let ((Result (let ((Z (kl:shen.newpv V3438))) (let ((X&& (kl:shen.newpv V3438))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3438 (lambda () (kl:bind X&& (kl:shen.placeholder) V3438 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V3438) (kl:shen.lazyderef X V3438) (kl:shen.lazyderef Y V3438)) V3438 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V3437) V3438 V3439)))))))))))) (begin (kl:shen.unbindv V3320 V3438) Result))))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3327 (kl:shen.lazyderef V3435 V3438))) (if (pair? V3327) (let ((V3328 (kl:shen.lazyderef (car V3327) V3438))) (if (eq? (quote let) V3328) (let ((V3329 (kl:shen.lazyderef (cdr V3327) V3438))) (if (pair? V3329) (let ((X (car V3329))) (let ((V3330 (kl:shen.lazyderef (cdr V3329) V3438))) (if (pair? V3330) (let ((Y (car V3330))) (let ((V3331 (kl:shen.lazyderef (cdr V3330) V3438))) (if (pair? V3331) (let ((Z (car V3331))) (let ((V3332 (kl:shen.lazyderef (cdr V3331) V3438))) (if (null? V3332) (let ((W (kl:shen.newpv V3438))) (let ((X&& (kl:shen.newpv V3438))) (let ((B (kl:shen.newpv V3438))) (begin (kl:shen.incinfs) (kl:shen.th* Y B V3437 V3438 (lambda () (kl:bind X&& (kl:shen.placeholder) V3438 (lambda () (kl:bind W (kl:shen.ebr (kl:shen.lazyderef X&& V3438) (kl:shen.lazyderef X V3438) (kl:shen.lazyderef Z V3438)) V3438 (lambda () (kl:shen.th* W V3436 (cons (cons X&& (cons (quote :) (cons B (quote ())))) V3437) V3438 V3439))))))))))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3333 (kl:shen.lazyderef V3435 V3438))) (if (pair? V3333) (let ((V3334 (kl:shen.lazyderef (car V3333) V3438))) (if (eq? (quote open) V3334) (let ((V3335 (kl:shen.lazyderef (cdr V3333) V3438))) (if (pair? V3335) (let ((FileName (car V3335))) (let ((V3336 (kl:shen.lazyderef (cdr V3335) V3438))) (if (pair? V3336) (let ((Direction3266 (car V3336))) (let ((V3337 (kl:shen.lazyderef (cdr V3336) V3438))) (if (null? V3337) (let ((V3338 (kl:shen.lazyderef V3436 V3438))) (if (pair? V3338) (let ((V3339 (kl:shen.lazyderef (car V3338) V3438))) (if (eq? (quote stream) V3339) (let ((V3340 (kl:shen.lazyderef (cdr V3338) V3438))) (if (pair? V3340) (let ((Direction (car V3340))) (let ((V3341 (kl:shen.lazyderef (cdr V3340) V3438))) (if (null? V3341) (begin (kl:shen.incinfs) (kl:unify! Direction Direction3266 V3438 (lambda () (kl:cut Throwcontrol V3438 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3438) (cons (quote in) (cons (quote out) (quote ())))) V3438 (lambda () (kl:shen.th* FileName (quote string) V3437 V3438 V3439)))))))) (if (assert-boolean (kl:shen.pvar? V3341)) (begin (kl:shen.bindv V3341 (quote ()) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3266 V3438 (lambda () (kl:cut Throwcontrol V3438 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3438) (cons (quote in) (cons (quote out) (quote ())))) V3438 (lambda () (kl:shen.th* FileName (quote string) V3437 V3438 V3439)))))))))) (begin (kl:shen.unbindv V3341 V3438) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3340)) (let ((Direction (kl:shen.newpv V3438))) (begin (kl:shen.bindv V3340 (cons Direction (quote ())) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3266 V3438 (lambda () (kl:cut Throwcontrol V3438 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3438) (cons (quote in) (cons (quote out) (quote ())))) V3438 (lambda () (kl:shen.th* FileName (quote string) V3437 V3438 V3439)))))))))) (begin (kl:shen.unbindv V3340 V3438) Result)))) #f))) (if (assert-boolean (kl:shen.pvar? V3339)) (begin (kl:shen.bindv V3339 (quote stream) V3438) (let ((Result (let ((V3342 (kl:shen.lazyderef (cdr V3338) V3438))) (if (pair? V3342) (let ((Direction (car V3342))) (let ((V3343 (kl:shen.lazyderef (cdr V3342) V3438))) (if (null? V3343) (begin (kl:shen.incinfs) (kl:unify! Direction Direction3266 V3438 (lambda () (kl:cut Throwcontrol V3438 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3438) (cons (quote in) (cons (quote out) (quote ())))) V3438 (lambda () (kl:shen.th* FileName (quote string) V3437 V3438 V3439)))))))) (if (assert-boolean (kl:shen.pvar? V3343)) (begin (kl:shen.bindv V3343 (quote ()) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3266 V3438 (lambda () (kl:cut Throwcontrol V3438 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3438) (cons (quote in) (cons (quote out) (quote ())))) V3438 (lambda () (kl:shen.th* FileName (quote string) V3437 V3438 V3439)))))))))) (begin (kl:shen.unbindv V3343 V3438) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3342)) (let ((Direction (kl:shen.newpv V3438))) (begin (kl:shen.bindv V3342 (cons Direction (quote ())) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3266 V3438 (lambda () (kl:cut Throwcontrol V3438 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3438) (cons (quote in) (cons (quote out) (quote ())))) V3438 (lambda () (kl:shen.th* FileName (quote string) V3437 V3438 V3439)))))))))) (begin (kl:shen.unbindv V3342 V3438) Result)))) #f))))) (begin (kl:shen.unbindv V3339 V3438) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3338)) (let ((Direction (kl:shen.newpv V3438))) (begin (kl:shen.bindv V3338 (cons (quote stream) (cons Direction (quote ()))) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction3266 V3438 (lambda () (kl:cut Throwcontrol V3438 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V3438) (cons (quote in) (cons (quote out) (quote ())))) V3438 (lambda () (kl:shen.th* FileName (quote string) V3437 V3438 V3439)))))))))) (begin (kl:shen.unbindv V3338 V3438) Result)))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3344 (kl:shen.lazyderef V3435 V3438))) (if (pair? V3344) (let ((V3345 (kl:shen.lazyderef (car V3344) V3438))) (if (eq? (quote type) V3345) (let ((V3346 (kl:shen.lazyderef (cdr V3344) V3438))) (if (pair? V3346) (let ((X (car V3346))) (let ((V3347 (kl:shen.lazyderef (cdr V3346) V3438))) (if (pair? V3347) (let ((A (car V3347))) (let ((V3348 (kl:shen.lazyderef (cdr V3347) V3438))) (if (null? V3348) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3438 (lambda () (kl:unify A V3436 V3438 (lambda () (kl:shen.th* X A V3437 V3438 V3439)))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3349 (kl:shen.lazyderef V3435 V3438))) (if (pair? V3349) (let ((V3350 (kl:shen.lazyderef (car V3349) V3438))) (if (eq? (quote input+) V3350) (let ((V3351 (kl:shen.lazyderef (cdr V3349) V3438))) (if (pair? V3351) (let ((A (car V3351))) (let ((V3352 (kl:shen.lazyderef (cdr V3351) V3438))) (if (pair? V3352) (let ((Stream (car V3352))) (let ((V3353 (kl:shen.lazyderef (cdr V3352) V3438))) (if (null? V3353) (let ((C (kl:shen.newpv V3438))) (begin (kl:shen.incinfs) (kl:bind C (kl:shen.demodulate (kl:shen.lazyderef A V3438)) V3438 (lambda () (kl:unify V3436 C V3438 (lambda () (kl:shen.th* Stream (cons (quote stream) (cons (quote in) (quote ()))) V3437 V3438 V3439))))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3354 (kl:shen.lazyderef V3435 V3438))) (if (pair? V3354) (let ((V3355 (kl:shen.lazyderef (car V3354) V3438))) (if (eq? (quote set) V3355) (let ((V3356 (kl:shen.lazyderef (cdr V3354) V3438))) (if (pair? V3356) (let ((Var (car V3356))) (let ((V3357 (kl:shen.lazyderef (cdr V3356) V3438))) (if (pair? V3357) (let ((Val (car V3357))) (let ((V3358 (kl:shen.lazyderef (cdr V3357) V3438))) (if (null? V3358) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3438 (lambda () (kl:shen.th* Var (quote symbol) V3437 V3438 (lambda () (kl:cut Throwcontrol V3438 (lambda () (kl:shen.th* (cons (quote value) (cons Var (quote ()))) V3436 V3437 V3438 (lambda () (kl:shen.th* Val V3436 V3437 V3438 V3439)))))))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((NewHyp (kl:shen.newpv V3438))) (begin (kl:shen.incinfs) (kl:shen.t*-hyps V3437 NewHyp V3438 (lambda () (kl:shen.th* V3435 V3436 NewHyp V3438 V3439))))))) (if (kl:= Case #f) (let ((Case (let ((V3359 (kl:shen.lazyderef V3435 V3438))) (if (pair? V3359) (let ((V3360 (kl:shen.lazyderef (car V3359) V3438))) (if (eq? (quote define) V3360) (let ((V3361 (kl:shen.lazyderef (cdr V3359) V3438))) (if (pair? V3361) (let ((F (car V3361))) (let ((X (cdr V3361))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3438 (lambda () (kl:shen.t*-def (cons (quote define) (cons F X)) V3436 V3437 V3438 V3439)))))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3362 (kl:shen.lazyderef V3435 V3438))) (if (pair? V3362) (let ((V3363 (kl:shen.lazyderef (car V3362) V3438))) (if (eq? (quote defmacro) V3363) (let ((V3364 (kl:shen.lazyderef V3436 V3438))) (if (eq? (quote unit) V3364) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3438 V3439)) (if (assert-boolean (kl:shen.pvar? V3364)) (begin (kl:shen.bindv V3364 (quote unit) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3438 V3439)))) (begin (kl:shen.unbindv V3364 V3438) Result))) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3365 (kl:shen.lazyderef V3435 V3438))) (if (pair? V3365) (let ((V3366 (kl:shen.lazyderef (car V3365) V3438))) (if (eq? (quote shen.process-datatype) V3366) (let ((V3367 (kl:shen.lazyderef V3436 V3438))) (if (eq? (quote symbol) V3367) (begin (kl:shen.incinfs) (kl:thaw V3439)) (if (assert-boolean (kl:shen.pvar? V3367)) (begin (kl:shen.bindv V3367 (quote symbol) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3439)))) (begin (kl:shen.unbindv V3367 V3438) Result))) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3368 (kl:shen.lazyderef V3435 V3438))) (if (pair? V3368) (let ((V3369 (kl:shen.lazyderef (car V3368) V3438))) (if (eq? (quote shen.synonyms-help) V3369) (let ((V3370 (kl:shen.lazyderef V3436 V3438))) (if (eq? (quote symbol) V3370) (begin (kl:shen.incinfs) (kl:thaw V3439)) (if (assert-boolean (kl:shen.pvar? V3370)) (begin (kl:shen.bindv V3370 (quote symbol) V3438) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3439)))) (begin (kl:shen.unbindv V3370 V3438) Result))) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((Datatypes (kl:shen.newpv V3438))) (begin (kl:shen.incinfs) (kl:bind Datatypes (kl:value (quote shen.*datatypes*)) V3438 (lambda () (kl:shen.udefs* (cons V3435 (cons (quote :) (cons V3436 (quote ())))) V3437 Datatypes V3438 V3439))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case))))) (quote shen.th*))
(begin (register-function-arity (quote shen.t*-hyps) 4) (define (kl:shen.t*-hyps V3444 V3445 V3446 V3447) (let ((Case (let ((V3181 (kl:shen.lazyderef V3444 V3446))) (if (pair? V3181) (let ((V3182 (kl:shen.lazyderef (car V3181) V3446))) (if (pair? V3182) (let ((V3183 (kl:shen.lazyderef (car V3182) V3446))) (if (pair? V3183) (let ((V3184 (kl:shen.lazyderef (car V3183) V3446))) (if (eq? (quote cons) V3184) (let ((V3185 (kl:shen.lazyderef (cdr V3183) V3446))) (if (pair? V3185) (let ((X (car V3185))) (let ((V3186 (kl:shen.lazyderef (cdr V3185) V3446))) (if (pair? V3186) (let ((Y (car V3186))) (let ((V3187 (kl:shen.lazyderef (cdr V3186) V3446))) (if (null? V3187) (let ((V3188 (kl:shen.lazyderef (cdr V3182) V3446))) (if (pair? V3188) (let ((V3189 (kl:shen.lazyderef (car V3188) V3446))) (if (eq? (quote :) V3189) (let ((V3190 (kl:shen.lazyderef (cdr V3188) V3446))) (if (pair? V3190) (let ((V3191 (kl:shen.lazyderef (car V3190) V3446))) (if (pair? V3191) (let ((V3192 (kl:shen.lazyderef (car V3191) V3446))) (if (eq? (quote list) V3192) (let ((V3193 (kl:shen.lazyderef (cdr V3191) V3446))) (if (pair? V3193) (let ((A (car V3193))) (let ((V3194 (kl:shen.lazyderef (cdr V3193) V3446))) (if (null? V3194) (let ((V3195 (kl:shen.lazyderef (cdr V3190) V3446))) (if (null? V3195) (let ((Hyp (cdr V3181))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3195)) (begin (kl:shen.bindv V3195 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3181))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3195 V3446) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3194)) (begin (kl:shen.bindv V3194 (quote ()) V3446) (let ((Result (let ((V3196 (kl:shen.lazyderef (cdr V3190) V3446))) (if (null? V3196) (let ((Hyp (cdr V3181))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3196)) (begin (kl:shen.bindv V3196 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3181))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3196 V3446) Result))) #f))))) (begin (kl:shen.unbindv V3194 V3446) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3193)) (let ((A (kl:shen.newpv V3446))) (begin (kl:shen.bindv V3193 (cons A (quote ())) V3446) (let ((Result (let ((V3197 (kl:shen.lazyderef (cdr V3190) V3446))) (if (null? V3197) (let ((Hyp (cdr V3181))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3197)) (begin (kl:shen.bindv V3197 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3181))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3197 V3446) Result))) #f))))) (begin (kl:shen.unbindv V3193 V3446) Result)))) #f))) (if (assert-boolean (kl:shen.pvar? V3192)) (begin (kl:shen.bindv V3192 (quote list) V3446) (let ((Result (let ((V3198 (kl:shen.lazyderef (cdr V3191) V3446))) (if (pair? V3198) (let ((A (car V3198))) (let ((V3199 (kl:shen.lazyderef (cdr V3198) V3446))) (if (null? V3199) (let ((V3200 (kl:shen.lazyderef (cdr V3190) V3446))) (if (null? V3200) (let ((Hyp (cdr V3181))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3200)) (begin (kl:shen.bindv V3200 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3181))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3200 V3446) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3199)) (begin (kl:shen.bindv V3199 (quote ()) V3446) (let ((Result (let ((V3201 (kl:shen.lazyderef (cdr V3190) V3446))) (if (null? V3201) (let ((Hyp (cdr V3181))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3201)) (begin (kl:shen.bindv V3201 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3181))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3201 V3446) Result))) #f))))) (begin (kl:shen.unbindv V3199 V3446) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3198)) (let ((A (kl:shen.newpv V3446))) (begin (kl:shen.bindv V3198 (cons A (quote ())) V3446) (let ((Result (let ((V3202 (kl:shen.lazyderef (cdr V3190) V3446))) (if (null? V3202) (let ((Hyp (cdr V3181))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3202)) (begin (kl:shen.bindv V3202 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3181))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3202 V3446) Result))) #f))))) (begin (kl:shen.unbindv V3198 V3446) Result)))) #f))))) (begin (kl:shen.unbindv V3192 V3446) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3191)) (let ((A (kl:shen.newpv V3446))) (begin (kl:shen.bindv V3191 (cons (quote list) (cons A (quote ()))) V3446) (let ((Result (let ((V3203 (kl:shen.lazyderef (cdr V3190) V3446))) (if (null? V3203) (let ((Hyp (cdr V3181))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3203)) (begin (kl:shen.bindv V3203 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3181))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3203 V3446) Result))) #f))))) (begin (kl:shen.unbindv V3191 V3446) Result)))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3204 (kl:shen.lazyderef V3444 V3446))) (if (pair? V3204) (let ((V3205 (kl:shen.lazyderef (car V3204) V3446))) (if (pair? V3205) (let ((V3206 (kl:shen.lazyderef (car V3205) V3446))) (if (pair? V3206) (let ((V3207 (kl:shen.lazyderef (car V3206) V3446))) (if (eq? (quote _waspvm_at_p) V3207) (let ((V3208 (kl:shen.lazyderef (cdr V3206) V3446))) (if (pair? V3208) (let ((X (car V3208))) (let ((V3209 (kl:shen.lazyderef (cdr V3208) V3446))) (if (pair? V3209) (let ((Y (car V3209))) (let ((V3210 (kl:shen.lazyderef (cdr V3209) V3446))) (if (null? V3210) (let ((V3211 (kl:shen.lazyderef (cdr V3205) V3446))) (if (pair? V3211) (let ((V3212 (kl:shen.lazyderef (car V3211) V3446))) (if (eq? (quote :) V3212) (let ((V3213 (kl:shen.lazyderef (cdr V3211) V3446))) (if (pair? V3213) (let ((V3214 (kl:shen.lazyderef (car V3213) V3446))) (if (pair? V3214) (let ((A (car V3214))) (let ((V3215 (kl:shen.lazyderef (cdr V3214) V3446))) (if (pair? V3215) (let ((V3216 (kl:shen.lazyderef (car V3215) V3446))) (if (eq? (quote *) V3216) (let ((V3217 (kl:shen.lazyderef (cdr V3215) V3446))) (if (pair? V3217) (let ((B (car V3217))) (let ((V3218 (kl:shen.lazyderef (cdr V3217) V3446))) (if (null? V3218) (let ((V3219 (kl:shen.lazyderef (cdr V3213) V3446))) (if (null? V3219) (let ((Hyp (cdr V3204))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (kl:shen.lazyderef B V3446) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3219)) (begin (kl:shen.bindv V3219 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3204))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (kl:shen.lazyderef B V3446) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3219 V3446) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3218)) (begin (kl:shen.bindv V3218 (quote ()) V3446) (let ((Result (let ((V3220 (kl:shen.lazyderef (cdr V3213) V3446))) (if (null? V3220) (let ((Hyp (cdr V3204))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (kl:shen.lazyderef B V3446) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3220)) (begin (kl:shen.bindv V3220 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3204))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (kl:shen.lazyderef B V3446) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3220 V3446) Result))) #f))))) (begin (kl:shen.unbindv V3218 V3446) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3217)) (let ((B (kl:shen.newpv V3446))) (begin (kl:shen.bindv V3217 (cons B (quote ())) V3446) (let ((Result (let ((V3221 (kl:shen.lazyderef (cdr V3213) V3446))) (if (null? V3221) (let ((Hyp (cdr V3204))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (kl:shen.lazyderef B V3446) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3221)) (begin (kl:shen.bindv V3221 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3204))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (kl:shen.lazyderef B V3446) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3221 V3446) Result))) #f))))) (begin (kl:shen.unbindv V3217 V3446) Result)))) #f))) (if (assert-boolean (kl:shen.pvar? V3216)) (begin (kl:shen.bindv V3216 (quote *) V3446) (let ((Result (let ((V3222 (kl:shen.lazyderef (cdr V3215) V3446))) (if (pair? V3222) (let ((B (car V3222))) (let ((V3223 (kl:shen.lazyderef (cdr V3222) V3446))) (if (null? V3223) (let ((V3224 (kl:shen.lazyderef (cdr V3213) V3446))) (if (null? V3224) (let ((Hyp (cdr V3204))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (kl:shen.lazyderef B V3446) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3224)) (begin (kl:shen.bindv V3224 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3204))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (kl:shen.lazyderef B V3446) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3224 V3446) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3223)) (begin (kl:shen.bindv V3223 (quote ()) V3446) (let ((Result (let ((V3225 (kl:shen.lazyderef (cdr V3213) V3446))) (if (null? V3225) (let ((Hyp (cdr V3204))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (kl:shen.lazyderef B V3446) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3225)) (begin (kl:shen.bindv V3225 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3204))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (kl:shen.lazyderef B V3446) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3225 V3446) Result))) #f))))) (begin (kl:shen.unbindv V3223 V3446) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3222)) (let ((B (kl:shen.newpv V3446))) (begin (kl:shen.bindv V3222 (cons B (quote ())) V3446) (let ((Result (let ((V3226 (kl:shen.lazyderef (cdr V3213) V3446))) (if (null? V3226) (let ((Hyp (cdr V3204))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (kl:shen.lazyderef B V3446) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3226)) (begin (kl:shen.bindv V3226 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3204))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (kl:shen.lazyderef B V3446) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3226 V3446) Result))) #f))))) (begin (kl:shen.unbindv V3222 V3446) Result)))) #f))))) (begin (kl:shen.unbindv V3216 V3446) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3215)) (let ((B (kl:shen.newpv V3446))) (begin (kl:shen.bindv V3215 (cons (quote *) (cons B (quote ()))) V3446) (let ((Result (let ((V3227 (kl:shen.lazyderef (cdr V3213) V3446))) (if (null? V3227) (let ((Hyp (cdr V3204))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (kl:shen.lazyderef B V3446) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3227)) (begin (kl:shen.bindv V3227 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3204))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (kl:shen.lazyderef B V3446) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3227 V3446) Result))) #f))))) (begin (kl:shen.unbindv V3215 V3446) Result)))) #f)))) (if (assert-boolean (kl:shen.pvar? V3214)) (let ((A (kl:shen.newpv V3446))) (let ((B (kl:shen.newpv V3446))) (begin (kl:shen.bindv V3214 (cons A (cons (quote *) (cons B (quote ())))) V3446) (let ((Result (let ((V3228 (kl:shen.lazyderef (cdr V3213) V3446))) (if (null? V3228) (let ((Hyp (cdr V3204))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (kl:shen.lazyderef B V3446) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3228)) (begin (kl:shen.bindv V3228 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3204))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (kl:shen.lazyderef B V3446) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3228 V3446) Result))) #f))))) (begin (kl:shen.unbindv V3214 V3446) Result))))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3229 (kl:shen.lazyderef V3444 V3446))) (if (pair? V3229) (let ((V3230 (kl:shen.lazyderef (car V3229) V3446))) (if (pair? V3230) (let ((V3231 (kl:shen.lazyderef (car V3230) V3446))) (if (pair? V3231) (let ((V3232 (kl:shen.lazyderef (car V3231) V3446))) (if (eq? (quote _waspvm_at_v) V3232) (let ((V3233 (kl:shen.lazyderef (cdr V3231) V3446))) (if (pair? V3233) (let ((X (car V3233))) (let ((V3234 (kl:shen.lazyderef (cdr V3233) V3446))) (if (pair? V3234) (let ((Y (car V3234))) (let ((V3235 (kl:shen.lazyderef (cdr V3234) V3446))) (if (null? V3235) (let ((V3236 (kl:shen.lazyderef (cdr V3230) V3446))) (if (pair? V3236) (let ((V3237 (kl:shen.lazyderef (car V3236) V3446))) (if (eq? (quote :) V3237) (let ((V3238 (kl:shen.lazyderef (cdr V3236) V3446))) (if (pair? V3238) (let ((V3239 (kl:shen.lazyderef (car V3238) V3446))) (if (pair? V3239) (let ((V3240 (kl:shen.lazyderef (car V3239) V3446))) (if (eq? (quote vector) V3240) (let ((V3241 (kl:shen.lazyderef (cdr V3239) V3446))) (if (pair? V3241) (let ((A (car V3241))) (let ((V3242 (kl:shen.lazyderef (cdr V3241) V3446))) (if (null? V3242) (let ((V3243 (kl:shen.lazyderef (cdr V3238) V3446))) (if (null? V3243) (let ((Hyp (cdr V3229))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3243)) (begin (kl:shen.bindv V3243 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3229))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3243 V3446) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3242)) (begin (kl:shen.bindv V3242 (quote ()) V3446) (let ((Result (let ((V3244 (kl:shen.lazyderef (cdr V3238) V3446))) (if (null? V3244) (let ((Hyp (cdr V3229))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3244)) (begin (kl:shen.bindv V3244 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3229))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3244 V3446) Result))) #f))))) (begin (kl:shen.unbindv V3242 V3446) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3241)) (let ((A (kl:shen.newpv V3446))) (begin (kl:shen.bindv V3241 (cons A (quote ())) V3446) (let ((Result (let ((V3245 (kl:shen.lazyderef (cdr V3238) V3446))) (if (null? V3245) (let ((Hyp (cdr V3229))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3245)) (begin (kl:shen.bindv V3245 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3229))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3245 V3446) Result))) #f))))) (begin (kl:shen.unbindv V3241 V3446) Result)))) #f))) (if (assert-boolean (kl:shen.pvar? V3240)) (begin (kl:shen.bindv V3240 (quote vector) V3446) (let ((Result (let ((V3246 (kl:shen.lazyderef (cdr V3239) V3446))) (if (pair? V3246) (let ((A (car V3246))) (let ((V3247 (kl:shen.lazyderef (cdr V3246) V3446))) (if (null? V3247) (let ((V3248 (kl:shen.lazyderef (cdr V3238) V3446))) (if (null? V3248) (let ((Hyp (cdr V3229))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3248)) (begin (kl:shen.bindv V3248 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3229))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3248 V3446) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3247)) (begin (kl:shen.bindv V3247 (quote ()) V3446) (let ((Result (let ((V3249 (kl:shen.lazyderef (cdr V3238) V3446))) (if (null? V3249) (let ((Hyp (cdr V3229))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3249)) (begin (kl:shen.bindv V3249 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3229))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3249 V3446) Result))) #f))))) (begin (kl:shen.unbindv V3247 V3446) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3246)) (let ((A (kl:shen.newpv V3446))) (begin (kl:shen.bindv V3246 (cons A (quote ())) V3446) (let ((Result (let ((V3250 (kl:shen.lazyderef (cdr V3238) V3446))) (if (null? V3250) (let ((Hyp (cdr V3229))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3250)) (begin (kl:shen.bindv V3250 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3229))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3250 V3446) Result))) #f))))) (begin (kl:shen.unbindv V3246 V3446) Result)))) #f))))) (begin (kl:shen.unbindv V3240 V3446) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3239)) (let ((A (kl:shen.newpv V3446))) (begin (kl:shen.bindv V3239 (cons (quote vector) (cons A (quote ()))) V3446) (let ((Result (let ((V3251 (kl:shen.lazyderef (cdr V3238) V3446))) (if (null? V3251) (let ((Hyp (cdr V3229))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3251)) (begin (kl:shen.bindv V3251 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3229))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (kl:shen.lazyderef A V3446) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V3446) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3251 V3446) Result))) #f))))) (begin (kl:shen.unbindv V3239 V3446) Result)))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3252 (kl:shen.lazyderef V3444 V3446))) (if (pair? V3252) (let ((V3253 (kl:shen.lazyderef (car V3252) V3446))) (if (pair? V3253) (let ((V3254 (kl:shen.lazyderef (car V3253) V3446))) (if (pair? V3254) (let ((V3255 (kl:shen.lazyderef (car V3254) V3446))) (if (eq? (quote _waspvm_at_s) V3255) (let ((V3256 (kl:shen.lazyderef (cdr V3254) V3446))) (if (pair? V3256) (let ((X (car V3256))) (let ((V3257 (kl:shen.lazyderef (cdr V3256) V3446))) (if (pair? V3257) (let ((Y (car V3257))) (let ((V3258 (kl:shen.lazyderef (cdr V3257) V3446))) (if (null? V3258) (let ((V3259 (kl:shen.lazyderef (cdr V3253) V3446))) (if (pair? V3259) (let ((V3260 (kl:shen.lazyderef (car V3259) V3446))) (if (eq? (quote :) V3260) (let ((V3261 (kl:shen.lazyderef (cdr V3259) V3446))) (if (pair? V3261) (let ((V3262 (kl:shen.lazyderef (car V3261) V3446))) (if (eq? (quote string) V3262) (let ((V3263 (kl:shen.lazyderef (cdr V3261) V3446))) (if (null? V3263) (let ((Hyp (cdr V3252))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3263)) (begin (kl:shen.bindv V3263 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3252))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3263 V3446) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3262)) (begin (kl:shen.bindv V3262 (quote string) V3446) (let ((Result (let ((V3264 (kl:shen.lazyderef (cdr V3261) V3446))) (if (null? V3264) (let ((Hyp (cdr V3252))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))) (if (assert-boolean (kl:shen.pvar? V3264)) (begin (kl:shen.bindv V3264 (quote ()) V3446) (let ((Result (let ((Hyp (cdr V3252))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (cons (kl:shen.lazyderef X V3446) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V3446) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V3446))) V3446 V3447))))) (begin (kl:shen.unbindv V3264 V3446) Result))) #f))))) (begin (kl:shen.unbindv V3262 V3446) Result))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((V3265 (kl:shen.lazyderef V3444 V3446))) (if (pair? V3265) (let ((X (car V3265))) (let ((Hyp (cdr V3265))) (let ((NewHyps (kl:shen.newpv V3446))) (begin (kl:shen.incinfs) (kl:bind V3445 (cons (kl:shen.lazyderef X V3446) (kl:shen.lazyderef NewHyps V3446)) V3446 (lambda () (kl:shen.t*-hyps Hyp NewHyps V3446 V3447))))))) #f)) Case)) Case)) Case)) Case))) (quote shen.t*-hyps))
(begin (register-function-arity (quote shen.show) 4) (define (kl:shen.show V3464 V3465 V3466 V3467) (cond ((assert-boolean (kl:value (quote shen.*spy*))) (begin (kl:shen.line) (begin (kl:shen.show-p (kl:shen.deref V3464 V3466)) (begin (kl:nl 1) (begin (kl:nl 1) (begin (kl:shen.show-assumptions (kl:shen.deref V3465 V3466) 1) (begin (kl:shen.prhush "\n> " (kl:stoutput)) (begin (kl:shen.pause-for-user) (kl:thaw V3467))))))))) (#t (kl:thaw V3467)))) (quote shen.show))
(begin (register-function-arity (quote shen.line) 0) (define (kl:shen.line) (let ((Infs (kl:inferences))) (kl:shen.prhush (string-append "____________________________________________________________ " (kl:shen.app Infs (string-append " inference" (kl:shen.app (if (kl:= 1 Infs) "" "s") " \n?- " (quote shen.a))) (quote shen.a))) (kl:stoutput)))) (quote shen.line))
(begin (register-function-arity (quote shen.show-p) 1) (define (kl:shen.show-p V3469) (cond ((and (pair? V3469) (and (pair? (cdr V3469)) (and (eq? (quote :) (car (cdr V3469))) (and (pair? (cdr (cdr V3469))) (null? (cdr (cdr (cdr V3469)))))))) (kl:shen.prhush (kl:shen.app (car V3469) (string-append " : " (kl:shen.app (car (cdr (cdr V3469))) "" (quote shen.r))) (quote shen.r)) (kl:stoutput))) (#t (kl:shen.prhush (kl:shen.app V3469 "" (quote shen.r)) (kl:stoutput))))) (quote shen.show-p))
(begin (register-function-arity (quote shen.show-assumptions) 2) (define (kl:shen.show-assumptions V3474 V3475) (cond ((null? V3474) (quote shen.skip)) ((pair? V3474) (begin (kl:shen.prhush (kl:shen.app V3475 ". " (quote shen.a)) (kl:stoutput)) (begin (kl:shen.show-p (car V3474)) (begin (kl:nl 1) (kl:shen.show-assumptions (cdr V3474) (+ V3475 1)))))) (#t (kl:shen.f_error (quote shen.show-assumptions))))) (quote shen.show-assumptions))
(begin (register-function-arity (quote shen.pause-for-user) 0) (define (kl:shen.pause-for-user) (let ((Byte (read-u8 (kl:stinput)))) (if (kl:= Byte 94) (simple-error "input aborted\n") (kl:nl 1)))) (quote shen.pause-for-user))
(begin (register-function-arity (quote shen.typedf?) 1) (define (kl:shen.typedf? V3477) (pair? (kl:assoc V3477 (kl:value (quote shen.*signedfuncs*))))) (quote shen.typedf?))
(begin (register-function-arity (quote shen.sigf) 1) (define (kl:shen.sigf V3479) (kl:concat (quote shen.type-signature-of-) V3479)) (quote shen.sigf))
(begin (register-function-arity (quote shen.placeholder) 0) (define (kl:shen.placeholder) (kl:gensym (quote &&))) (quote shen.placeholder))
(begin (register-function-arity (quote shen.base) 4) (define (kl:shen.base V3484 V3485 V3486 V3487) (let ((Case (let ((V3168 (kl:shen.lazyderef V3485 V3486))) (if (eq? (quote number) V3168) (begin (kl:shen.incinfs) (kl:fwhen (number? (kl:shen.lazyderef V3484 V3486)) V3486 V3487)) (if (assert-boolean (kl:shen.pvar? V3168)) (begin (kl:shen.bindv V3168 (quote number) V3486) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (number? (kl:shen.lazyderef V3484 V3486)) V3486 V3487)))) (begin (kl:shen.unbindv V3168 V3486) Result))) #f))))) (if (kl:= Case #f) (let ((Case (let ((V3169 (kl:shen.lazyderef V3485 V3486))) (if (eq? (quote boolean) V3169) (begin (kl:shen.incinfs) (kl:fwhen (kl:boolean? (kl:shen.lazyderef V3484 V3486)) V3486 V3487)) (if (assert-boolean (kl:shen.pvar? V3169)) (begin (kl:shen.bindv V3169 (quote boolean) V3486) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (kl:boolean? (kl:shen.lazyderef V3484 V3486)) V3486 V3487)))) (begin (kl:shen.unbindv V3169 V3486) Result))) #f))))) (if (kl:= Case #f) (let ((Case (let ((V3170 (kl:shen.lazyderef V3485 V3486))) (if (eq? (quote string) V3170) (begin (kl:shen.incinfs) (kl:fwhen (string? (kl:shen.lazyderef V3484 V3486)) V3486 V3487)) (if (assert-boolean (kl:shen.pvar? V3170)) (begin (kl:shen.bindv V3170 (quote string) V3486) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (string? (kl:shen.lazyderef V3484 V3486)) V3486 V3487)))) (begin (kl:shen.unbindv V3170 V3486) Result))) #f))))) (if (kl:= Case #f) (let ((Case (let ((V3171 (kl:shen.lazyderef V3485 V3486))) (if (eq? (quote symbol) V3171) (begin (kl:shen.incinfs) (kl:fwhen (kl:symbol? (kl:shen.lazyderef V3484 V3486)) V3486 (lambda () (kl:fwhen (kl:not (kl:shen.ue? (kl:shen.lazyderef V3484 V3486))) V3486 V3487)))) (if (assert-boolean (kl:shen.pvar? V3171)) (begin (kl:shen.bindv V3171 (quote symbol) V3486) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (kl:symbol? (kl:shen.lazyderef V3484 V3486)) V3486 (lambda () (kl:fwhen (kl:not (kl:shen.ue? (kl:shen.lazyderef V3484 V3486))) V3486 V3487)))))) (begin (kl:shen.unbindv V3171 V3486) Result))) #f))))) (if (kl:= Case #f) (let ((V3172 (kl:shen.lazyderef V3484 V3486))) (if (null? V3172) (let ((V3173 (kl:shen.lazyderef V3485 V3486))) (if (pair? V3173) (let ((V3174 (kl:shen.lazyderef (car V3173) V3486))) (if (eq? (quote list) V3174) (let ((V3175 (kl:shen.lazyderef (cdr V3173) V3486))) (if (pair? V3175) (let ((A (car V3175))) (let ((V3176 (kl:shen.lazyderef (cdr V3175) V3486))) (if (null? V3176) (begin (kl:shen.incinfs) (kl:thaw V3487)) (if (assert-boolean (kl:shen.pvar? V3176)) (begin (kl:shen.bindv V3176 (quote ()) V3486) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3487)))) (begin (kl:shen.unbindv V3176 V3486) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3175)) (let ((A (kl:shen.newpv V3486))) (begin (kl:shen.bindv V3175 (cons A (quote ())) V3486) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3487)))) (begin (kl:shen.unbindv V3175 V3486) Result)))) #f))) (if (assert-boolean (kl:shen.pvar? V3174)) (begin (kl:shen.bindv V3174 (quote list) V3486) (let ((Result (let ((V3177 (kl:shen.lazyderef (cdr V3173) V3486))) (if (pair? V3177) (let ((A (car V3177))) (let ((V3178 (kl:shen.lazyderef (cdr V3177) V3486))) (if (null? V3178) (begin (kl:shen.incinfs) (kl:thaw V3487)) (if (assert-boolean (kl:shen.pvar? V3178)) (begin (kl:shen.bindv V3178 (quote ()) V3486) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3487)))) (begin (kl:shen.unbindv V3178 V3486) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3177)) (let ((A (kl:shen.newpv V3486))) (begin (kl:shen.bindv V3177 (cons A (quote ())) V3486) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3487)))) (begin (kl:shen.unbindv V3177 V3486) Result)))) #f))))) (begin (kl:shen.unbindv V3174 V3486) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3173)) (let ((A (kl:shen.newpv V3486))) (begin (kl:shen.bindv V3173 (cons (quote list) (cons A (quote ()))) V3486) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V3487)))) (begin (kl:shen.unbindv V3173 V3486) Result)))) #f))) #f)) Case)) Case)) Case)) Case))) (quote shen.base))
(begin (register-function-arity (quote shen.by_hypothesis) 5) (define (kl:shen.by_hypothesis V3493 V3494 V3495 V3496 V3497) (let ((Case (let ((V3159 (kl:shen.lazyderef V3495 V3496))) (if (pair? V3159) (let ((V3160 (kl:shen.lazyderef (car V3159) V3496))) (if (pair? V3160) (let ((Y (car V3160))) (let ((V3161 (kl:shen.lazyderef (cdr V3160) V3496))) (if (pair? V3161) (let ((V3162 (kl:shen.lazyderef (car V3161) V3496))) (if (eq? (quote :) V3162) (let ((V3163 (kl:shen.lazyderef (cdr V3161) V3496))) (if (pair? V3163) (let ((B (car V3163))) (let ((V3164 (kl:shen.lazyderef (cdr V3163) V3496))) (if (null? V3164) (begin (kl:shen.incinfs) (kl:identical V3493 Y V3496 (lambda () (kl:unify! V3494 B V3496 V3497)))) #f))) #f)) #f)) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((V3165 (kl:shen.lazyderef V3495 V3496))) (if (pair? V3165) (let ((Hyp (cdr V3165))) (begin (kl:shen.incinfs) (kl:shen.by_hypothesis V3493 V3494 Hyp V3496 V3497))) #f)) Case))) (quote shen.by_hypothesis))
(begin (register-function-arity (quote shen.t*-def) 5) (define (kl:shen.t*-def V3503 V3504 V3505 V3506 V3507) (let ((V3153 (kl:shen.lazyderef V3503 V3506))) (if (pair? V3153) (let ((V3154 (kl:shen.lazyderef (car V3153) V3506))) (if (eq? (quote define) V3154) (let ((V3155 (kl:shen.lazyderef (cdr V3153) V3506))) (if (pair? V3155) (let ((F (car V3155))) (let ((X (cdr V3155))) (let ((Y (kl:shen.newpv V3506))) (let ((E (kl:shen.newpv V3506))) (begin (kl:shen.incinfs) (kl:shen.t*-defh (kl:compile (lambda (Y) (kl:shen.<sig+rules> Y)) X (lambda (E) (if (pair? E) (simple-error (string-append "parse error here: " (kl:shen.app E "\n" (quote shen.s)))) (simple-error "parse error\n")))) F V3504 V3505 V3506 V3507)))))) #f)) #f)) #f))) (quote shen.t*-def))
(begin (register-function-arity (quote shen.t*-defh) 6) (define (kl:shen.t*-defh V3514 V3515 V3516 V3517 V3518 V3519) (let ((V3149 (kl:shen.lazyderef V3514 V3518))) (if (pair? V3149) (let ((Sig (car V3149))) (let ((Rules (cdr V3149))) (begin (kl:shen.incinfs) (kl:shen.t*-defhh Sig (kl:shen.ue-sig Sig) V3515 V3516 V3517 Rules V3518 V3519)))) #f))) (quote shen.t*-defh))
(begin (register-function-arity (quote shen.t*-defhh) 8) (define (kl:shen.t*-defhh V3528 V3529 V3530 V3531 V3532 V3533 V3534 V3535) (begin (kl:shen.incinfs) (kl:shen.t*-rules V3533 V3529 1 V3530 (cons (cons V3530 (cons (quote :) (cons V3529 (quote ())))) V3532) V3534 (lambda () (kl:shen.memo V3530 V3528 V3531 V3534 V3535))))) (quote shen.t*-defhh))
(begin (register-function-arity (quote shen.memo) 5) (define (kl:shen.memo V3541 V3542 V3543 V3544 V3545) (let ((Jnk (kl:shen.newpv V3544))) (begin (kl:shen.incinfs) (kl:unify! V3543 V3542 V3544 (lambda () (kl:bind Jnk (kl:declare (kl:shen.lazyderef V3541 V3544) (kl:shen.lazyderef V3543 V3544)) V3544 V3545)))))) (quote shen.memo))
(begin (register-function-arity (quote shen.<sig+rules>) 1) (define (kl:shen.<sig+rules> V3547) (let ((Parse_shen.<signature> (kl:shen.<signature> V3547))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature>)) (let ((Parse_shen.<non-ll-rules> (kl:shen.<non-ll-rules> Parse_shen.<signature>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<non-ll-rules>)) (kl:shen.pair (car Parse_shen.<non-ll-rules>) (cons (kl:shen.hdtl Parse_shen.<signature>) (kl:shen.hdtl Parse_shen.<non-ll-rules>))) (kl:fail))) (kl:fail)))) (quote shen.<sig+rules>))
(begin (register-function-arity (quote shen.<non-ll-rules>) 1) (define (kl:shen.<non-ll-rules> V3549) (let ((YaccParse (let ((Parse_shen.<rule> (kl:shen.<rule> V3549))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (let ((Parse_shen.<non-ll-rules> (kl:shen.<non-ll-rules> Parse_shen.<rule>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<non-ll-rules>)) (kl:shen.pair (car Parse_shen.<non-ll-rules>) (cons (kl:shen.hdtl Parse_shen.<rule>) (kl:shen.hdtl Parse_shen.<non-ll-rules>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<rule> (kl:shen.<rule> V3549))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (kl:shen.pair (car Parse_shen.<rule>) (cons (kl:shen.hdtl Parse_shen.<rule>) (quote ()))) (kl:fail))) YaccParse))) (quote shen.<non-ll-rules>))
(begin (register-function-arity (quote shen.ue) 1) (define (kl:shen.ue V3551) (cond ((and (pair? V3551) (and (pair? (cdr V3551)) (and (null? (cdr (cdr V3551))) (eq? (car V3551) (quote protect))))) V3551) ((pair? V3551) (kl:map (lambda (Z) (kl:shen.ue Z)) V3551)) ((kl:variable? V3551) (kl:concat (quote &&) V3551)) (#t V3551))) (quote shen.ue))
(begin (register-function-arity (quote shen.ue-sig) 1) (define (kl:shen.ue-sig V3553) (cond ((pair? V3553) (kl:map (lambda (Z) (kl:shen.ue-sig Z)) V3553)) ((kl:variable? V3553) (kl:concat (quote &&&) V3553)) (#t V3553))) (quote shen.ue-sig))
(begin (register-function-arity (quote shen.ues) 1) (define (kl:shen.ues V3559) (cond ((assert-boolean (kl:shen.ue? V3559)) (cons V3559 (quote ()))) ((pair? V3559) (kl:union (kl:shen.ues (car V3559)) (kl:shen.ues (cdr V3559)))) (#t (quote ())))) (quote shen.ues))
(begin (register-function-arity (quote shen.ue?) 1) (define (kl:shen.ue? V3561) (and (kl:symbol? V3561) (assert-boolean (kl:shen.ue-h? (kl:str V3561))))) (quote shen.ue?))
(begin (register-function-arity (quote shen.ue-h?) 1) (define (kl:shen.ue-h? V3569) (cond ((and (assert-boolean (kl:shen.+string? V3569)) (and (equal? "&" (make-string 1 (string-ref V3569 0))) (and (assert-boolean (kl:shen.+string? (string-tail V3569 1))) (equal? "&" (make-string 1 (string-ref (string-tail V3569 1) 0)))))) #t) (#t #f))) (quote shen.ue-h?))
(begin (register-function-arity (quote shen.t*-rules) 7) (define (kl:shen.t*-rules V3577 V3578 V3579 V3580 V3581 V3582 V3583) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (let ((V3133 (kl:shen.lazyderef V3577 V3582))) (if (null? V3133) (begin (kl:shen.incinfs) (kl:thaw V3583)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3134 (kl:shen.lazyderef V3577 V3582))) (if (pair? V3134) (let ((Rule (car V3134))) (let ((Rules (cdr V3134))) (begin (kl:shen.incinfs) (kl:shen.t*-rule (kl:shen.ue Rule) V3578 V3581 V3582 (lambda () (kl:cut Throwcontrol V3582 (lambda () (kl:shen.t*-rules Rules V3578 (+ V3579 1) V3580 V3581 V3582 V3583)))))))) #f)))) (if (kl:= Case #f) (let ((Err (kl:shen.newpv V3582))) (begin (kl:shen.incinfs) (kl:bind Err (simple-error (string-append "type error in rule " (kl:shen.app (kl:shen.lazyderef V3579 V3582) (string-append " of " (kl:shen.app (kl:shen.lazyderef V3580 V3582) "" (quote shen.a))) (quote shen.a)))) V3582 V3583))) Case)) Case))))) (quote shen.t*-rules))
(begin (register-function-arity (quote shen.t*-rule) 5) (define (kl:shen.t*-rule V3589 V3590 V3591 V3592 V3593) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((V3125 (kl:shen.lazyderef V3589 V3592))) (if (pair? V3125) (let ((Patterns (car V3125))) (let ((V3126 (kl:shen.lazyderef (cdr V3125) V3592))) (if (pair? V3126) (let ((Action (car V3126))) (let ((V3127 (kl:shen.lazyderef (cdr V3126) V3592))) (if (null? V3127) (let ((NewHyps (kl:shen.newpv V3592))) (begin (kl:shen.incinfs) (kl:shen.newhyps (kl:shen.placeholders Patterns) V3591 NewHyps V3592 (lambda () (kl:shen.t*-patterns Patterns V3590 NewHyps V3592 (lambda () (kl:cut Throwcontrol V3592 (lambda () (kl:shen.t*-action (kl:shen.curry (kl:shen.ue Action)) (kl:shen.result-type Patterns V3590) (kl:shen.patthyps Patterns V3590 V3591) V3592 V3593))))))))) #f))) #f))) #f))))) (quote shen.t*-rule))
(begin (register-function-arity (quote shen.placeholders) 1) (define (kl:shen.placeholders V3599) (cond ((assert-boolean (kl:shen.ue? V3599)) (cons V3599 (quote ()))) ((pair? V3599) (kl:union (kl:shen.placeholders (car V3599)) (kl:shen.placeholders (cdr V3599)))) (#t (quote ())))) (quote shen.placeholders))
(begin (register-function-arity (quote shen.newhyps) 5) (define (kl:shen.newhyps V3605 V3606 V3607 V3608 V3609) (let ((Case (let ((V3112 (kl:shen.lazyderef V3605 V3608))) (if (null? V3112) (begin (kl:shen.incinfs) (kl:unify! V3607 V3606 V3608 V3609)) #f)))) (if (kl:= Case #f) (let ((V3113 (kl:shen.lazyderef V3605 V3608))) (if (pair? V3113) (let ((V3108 (car V3113))) (let ((Vs (cdr V3113))) (let ((V3114 (kl:shen.lazyderef V3607 V3608))) (if (pair? V3114) (let ((V3115 (kl:shen.lazyderef (car V3114) V3608))) (if (pair? V3115) (let ((V (car V3115))) (let ((V3116 (kl:shen.lazyderef (cdr V3115) V3608))) (if (pair? V3116) (let ((V3117 (kl:shen.lazyderef (car V3116) V3608))) (if (eq? (quote :) V3117) (let ((V3118 (kl:shen.lazyderef (cdr V3116) V3608))) (if (pair? V3118) (let ((A (car V3118))) (let ((V3119 (kl:shen.lazyderef (cdr V3118) V3608))) (if (null? V3119) (let ((NewHyp (cdr V3114))) (begin (kl:shen.incinfs) (kl:unify! V V3108 V3608 (lambda () (kl:shen.newhyps Vs V3606 NewHyp V3608 V3609))))) (if (assert-boolean (kl:shen.pvar? V3119)) (begin (kl:shen.bindv V3119 (quote ()) V3608) (let ((Result (let ((NewHyp (cdr V3114))) (begin (kl:shen.incinfs) (kl:unify! V V3108 V3608 (lambda () (kl:shen.newhyps Vs V3606 NewHyp V3608 V3609))))))) (begin (kl:shen.unbindv V3119 V3608) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3118)) (let ((A (kl:shen.newpv V3608))) (begin (kl:shen.bindv V3118 (cons A (quote ())) V3608) (let ((Result (let ((NewHyp (cdr V3114))) (begin (kl:shen.incinfs) (kl:unify! V V3108 V3608 (lambda () (kl:shen.newhyps Vs V3606 NewHyp V3608 V3609))))))) (begin (kl:shen.unbindv V3118 V3608) Result)))) #f))) (if (assert-boolean (kl:shen.pvar? V3117)) (begin (kl:shen.bindv V3117 (quote :) V3608) (let ((Result (let ((V3120 (kl:shen.lazyderef (cdr V3116) V3608))) (if (pair? V3120) (let ((A (car V3120))) (let ((V3121 (kl:shen.lazyderef (cdr V3120) V3608))) (if (null? V3121) (let ((NewHyp (cdr V3114))) (begin (kl:shen.incinfs) (kl:unify! V V3108 V3608 (lambda () (kl:shen.newhyps Vs V3606 NewHyp V3608 V3609))))) (if (assert-boolean (kl:shen.pvar? V3121)) (begin (kl:shen.bindv V3121 (quote ()) V3608) (let ((Result (let ((NewHyp (cdr V3114))) (begin (kl:shen.incinfs) (kl:unify! V V3108 V3608 (lambda () (kl:shen.newhyps Vs V3606 NewHyp V3608 V3609))))))) (begin (kl:shen.unbindv V3121 V3608) Result))) #f)))) (if (assert-boolean (kl:shen.pvar? V3120)) (let ((A (kl:shen.newpv V3608))) (begin (kl:shen.bindv V3120 (cons A (quote ())) V3608) (let ((Result (let ((NewHyp (cdr V3114))) (begin (kl:shen.incinfs) (kl:unify! V V3108 V3608 (lambda () (kl:shen.newhyps Vs V3606 NewHyp V3608 V3609))))))) (begin (kl:shen.unbindv V3120 V3608) Result)))) #f))))) (begin (kl:shen.unbindv V3117 V3608) Result))) #f))) (if (assert-boolean (kl:shen.pvar? V3116)) (let ((A (kl:shen.newpv V3608))) (begin (kl:shen.bindv V3116 (cons (quote :) (cons A (quote ()))) V3608) (let ((Result (let ((NewHyp (cdr V3114))) (begin (kl:shen.incinfs) (kl:unify! V V3108 V3608 (lambda () (kl:shen.newhyps Vs V3606 NewHyp V3608 V3609))))))) (begin (kl:shen.unbindv V3116 V3608) Result)))) #f)))) (if (assert-boolean (kl:shen.pvar? V3115)) (let ((V (kl:shen.newpv V3608))) (let ((A (kl:shen.newpv V3608))) (begin (kl:shen.bindv V3115 (cons V (cons (quote :) (cons A (quote ())))) V3608) (let ((Result (let ((NewHyp (cdr V3114))) (begin (kl:shen.incinfs) (kl:unify! V V3108 V3608 (lambda () (kl:shen.newhyps Vs V3606 NewHyp V3608 V3609))))))) (begin (kl:shen.unbindv V3115 V3608) Result))))) #f))) (if (assert-boolean (kl:shen.pvar? V3114)) (let ((V (kl:shen.newpv V3608))) (let ((A (kl:shen.newpv V3608))) (let ((NewHyp (kl:shen.newpv V3608))) (begin (kl:shen.bindv V3114 (cons (cons V (cons (quote :) (cons A (quote ())))) NewHyp) V3608) (let ((Result (begin (kl:shen.incinfs) (kl:unify! V V3108 V3608 (lambda () (kl:shen.newhyps Vs V3606 NewHyp V3608 V3609)))))) (begin (kl:shen.unbindv V3114 V3608) Result)))))) #f))))) #f)) Case))) (quote shen.newhyps))
(begin (register-function-arity (quote shen.patthyps) 3) (define (kl:shen.patthyps V3615 V3616 V3617) (cond ((null? V3615) V3617) ((and (pair? V3615) (and (pair? V3616) (and (pair? (cdr V3616)) (and (eq? (quote -->) (car (cdr V3616))) (and (pair? (cdr (cdr V3616))) (null? (cdr (cdr (cdr V3616))))))))) (kl:adjoin (cons (car V3615) (cons (quote :) (cons (car V3616) (quote ())))) (kl:shen.patthyps (cdr V3615) (car (cdr (cdr V3616))) V3617))) (#t (kl:shen.f_error (quote shen.patthyps))))) (quote shen.patthyps))
(begin (register-function-arity (quote shen.result-type) 2) (define (kl:shen.result-type V3624 V3625) (cond ((and (null? V3624) (and (pair? V3625) (and (eq? (quote -->) (car V3625)) (and (pair? (cdr V3625)) (null? (cdr (cdr V3625))))))) (car (cdr V3625))) ((null? V3624) V3625) ((and (pair? V3624) (and (pair? V3625) (and (pair? (cdr V3625)) (and (eq? (quote -->) (car (cdr V3625))) (and (pair? (cdr (cdr V3625))) (null? (cdr (cdr (cdr V3625))))))))) (kl:shen.result-type (cdr V3624) (car (cdr (cdr V3625))))) (#t (kl:shen.f_error (quote shen.result-type))))) (quote shen.result-type))
(begin (register-function-arity (quote shen.t*-patterns) 5) (define (kl:shen.t*-patterns V3631 V3632 V3633 V3634 V3635) (let ((Case (let ((V3100 (kl:shen.lazyderef V3631 V3634))) (if (null? V3100) (begin (kl:shen.incinfs) (kl:thaw V3635)) #f)))) (if (kl:= Case #f) (let ((V3101 (kl:shen.lazyderef V3631 V3634))) (if (pair? V3101) (let ((Pattern (car V3101))) (let ((Patterns (cdr V3101))) (let ((V3102 (kl:shen.lazyderef V3632 V3634))) (if (pair? V3102) (let ((A (car V3102))) (let ((V3103 (kl:shen.lazyderef (cdr V3102) V3634))) (if (pair? V3103) (let ((V3104 (kl:shen.lazyderef (car V3103) V3634))) (if (eq? (quote -->) V3104) (let ((V3105 (kl:shen.lazyderef (cdr V3103) V3634))) (if (pair? V3105) (let ((B (car V3105))) (let ((V3106 (kl:shen.lazyderef (cdr V3105) V3634))) (if (null? V3106) (begin (kl:shen.incinfs) (kl:shen.t* (cons Pattern (cons (quote :) (cons A (quote ())))) V3633 V3634 (lambda () (kl:shen.t*-patterns Patterns B V3633 V3634 V3635)))) #f))) #f)) #f)) #f))) #f)))) #f)) Case))) (quote shen.t*-patterns))
(begin (register-function-arity (quote shen.t*-action) 5) (define (kl:shen.t*-action V3641 V3642 V3643 V3644 V3645) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (let ((V3077 (kl:shen.lazyderef V3641 V3644))) (if (pair? V3077) (let ((V3078 (kl:shen.lazyderef (car V3077) V3644))) (if (eq? (quote where) V3078) (let ((V3079 (kl:shen.lazyderef (cdr V3077) V3644))) (if (pair? V3079) (let ((P (car V3079))) (let ((V3080 (kl:shen.lazyderef (cdr V3079) V3644))) (if (pair? V3080) (let ((Action (car V3080))) (let ((V3081 (kl:shen.lazyderef (cdr V3080) V3644))) (if (null? V3081) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3644 (lambda () (kl:shen.t* (cons P (cons (quote :) (cons (quote boolean) (quote ())))) V3643 V3644 (lambda () (kl:cut Throwcontrol V3644 (lambda () (kl:shen.t*-action Action V3642 (cons (cons P (cons (quote :) (cons (quote verified) (quote ())))) V3643) V3644 V3645)))))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3082 (kl:shen.lazyderef V3641 V3644))) (if (pair? V3082) (let ((V3083 (kl:shen.lazyderef (car V3082) V3644))) (if (eq? (quote shen.choicepoint!) V3083) (let ((V3084 (kl:shen.lazyderef (cdr V3082) V3644))) (if (pair? V3084) (let ((V3085 (kl:shen.lazyderef (car V3084) V3644))) (if (pair? V3085) (let ((V3086 (kl:shen.lazyderef (car V3085) V3644))) (if (pair? V3086) (let ((V3087 (kl:shen.lazyderef (car V3086) V3644))) (if (eq? (quote fail-if) V3087) (let ((V3088 (kl:shen.lazyderef (cdr V3086) V3644))) (if (pair? V3088) (let ((F (car V3088))) (let ((V3089 (kl:shen.lazyderef (cdr V3088) V3644))) (if (null? V3089) (let ((V3090 (kl:shen.lazyderef (cdr V3085) V3644))) (if (pair? V3090) (let ((Action (car V3090))) (let ((V3091 (kl:shen.lazyderef (cdr V3090) V3644))) (if (null? V3091) (let ((V3092 (kl:shen.lazyderef (cdr V3084) V3644))) (if (null? V3092) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3644 (lambda () (kl:shen.t*-action (cons (quote where) (cons (cons (quote not) (cons (cons F (cons Action (quote ()))) (quote ()))) (cons Action (quote ())))) V3642 V3643 V3644 V3645)))) #f)) #f))) #f)) #f))) #f)) #f)) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V3093 (kl:shen.lazyderef V3641 V3644))) (if (pair? V3093) (let ((V3094 (kl:shen.lazyderef (car V3093) V3644))) (if (eq? (quote shen.choicepoint!) V3094) (let ((V3095 (kl:shen.lazyderef (cdr V3093) V3644))) (if (pair? V3095) (let ((Action (car V3095))) (let ((V3096 (kl:shen.lazyderef (cdr V3095) V3644))) (if (null? V3096) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V3644 (lambda () (kl:shen.t*-action (cons (quote where) (cons (cons (quote not) (cons (cons (cons (quote =) (cons Action (quote ()))) (cons (cons (quote fail) (quote ())) (quote ()))) (quote ()))) (cons Action (quote ())))) V3642 V3643 V3644 V3645)))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (begin (kl:shen.incinfs) (kl:shen.t* (cons V3641 (cons (quote :) (cons V3642 (quote ())))) V3643 V3644 V3645)) Case)) Case)) Case))))) (quote shen.t*-action))
(begin (register-function-arity (quote findall) 5) (define (kl:findall V3651 V3652 V3653 V3654 V3655) (let ((B (kl:shen.newpv V3654))) (let ((A (kl:shen.newpv V3654))) (begin (kl:shen.incinfs) (kl:bind A (kl:gensym (quote shen.a)) V3654 (lambda () (kl:bind B (kl:set (kl:shen.lazyderef A V3654) (quote ())) V3654 (lambda () (kl:shen.findallhelp V3651 V3652 V3653 A V3654 V3655))))))))) (quote findall))
(begin (register-function-arity (quote shen.findallhelp) 6) (define (kl:shen.findallhelp V3662 V3663 V3664 V3665 V3666 V3667) (let ((Case (begin (kl:shen.incinfs) (kl:call V3663 V3666 (lambda () (kl:shen.remember V3665 V3662 V3666 (lambda () (kl:fwhen #f V3666 V3667)))))))) (if (kl:= Case #f) (begin (kl:shen.incinfs) (kl:bind V3664 (kl:value (kl:shen.lazyderef V3665 V3666)) V3666 V3667)) Case))) (quote shen.findallhelp))
(begin (register-function-arity (quote shen.remember) 4) (define (kl:shen.remember V3672 V3673 V3674 V3675) (let ((B (kl:shen.newpv V3674))) (begin (kl:shen.incinfs) (kl:bind B (kl:set (kl:shen.deref V3672 V3674) (cons (kl:shen.deref V3673 V3674) (kl:value (kl:shen.deref V3672 V3674)))) V3674 V3675)))) (quote shen.remember))
