"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote pr) 2) (define (kl:pr V3887 V3888) (guard (lambda (E) V3887) (kl:shen.prh V3887 V3888 0))) (quote pr))
(begin (register-function-arity (quote shen.prh) 3) (define (kl:shen.prh V3892 V3893 V3894) (kl:shen.prh V3892 V3893 (kl:shen.write-char-and-inc V3892 V3893 V3894))) (quote shen.prh))
(begin (register-function-arity (quote shen.write-char-and-inc) 3) (define (kl:shen.write-char-and-inc V3898 V3899 V3900) (begin (write-u8 (string-ref (make-string 1 (string-ref V3898 V3900)) 0) V3899) (+ V3900 1))) (quote shen.write-char-and-inc))
(begin (register-function-arity (quote print) 1) (define (kl:print V3902) (let ((String (kl:shen.insert V3902 "~S"))) (let ((Print (kl:shen.prhush String (kl:stoutput)))) V3902))) (quote print))
(begin (register-function-arity (quote shen.prhush) 2) (define (kl:shen.prhush V3905 V3906) (if (assert-boolean (kl:value (quote *hush*))) V3905 (kl:pr V3905 V3906))) (quote shen.prhush))
(begin (register-function-arity (quote shen.mkstr) 2) (define (kl:shen.mkstr V3909 V3910) (cond ((string? V3909) (kl:shen.mkstr-l (kl:shen.proc-nl V3909) V3910)) (#t (kl:shen.mkstr-r (cons (quote shen.proc-nl) (cons V3909 (quote ()))) V3910)))) (quote shen.mkstr))
(begin (register-function-arity (quote shen.mkstr-l) 2) (define (kl:shen.mkstr-l V3913 V3914) (cond ((null? V3914) V3913) ((pair? V3914) (kl:shen.mkstr-l (kl:shen.insert-l (car V3914) V3913) (cdr V3914))) (#t (kl:shen.f_error (quote shen.mkstr-l))))) (quote shen.mkstr-l))
(begin (register-function-arity (quote shen.insert-l) 2) (define (kl:shen.insert-l V3919 V3920) (cond ((equal? "" V3920) "") ((and (assert-boolean (kl:shen.+string? V3920)) (and (equal? "~" (make-string 1 (string-ref V3920 0))) (and (assert-boolean (kl:shen.+string? (string-tail V3920 1))) (equal? "A" (make-string 1 (string-ref (string-tail V3920 1) 0)))))) (cons (quote shen.app) (cons V3919 (cons (string-tail (string-tail V3920 1) 1) (cons (quote shen.a) (quote ())))))) ((and (assert-boolean (kl:shen.+string? V3920)) (and (equal? "~" (make-string 1 (string-ref V3920 0))) (and (assert-boolean (kl:shen.+string? (string-tail V3920 1))) (equal? "R" (make-string 1 (string-ref (string-tail V3920 1) 0)))))) (cons (quote shen.app) (cons V3919 (cons (string-tail (string-tail V3920 1) 1) (cons (quote shen.r) (quote ())))))) ((and (assert-boolean (kl:shen.+string? V3920)) (and (equal? "~" (make-string 1 (string-ref V3920 0))) (and (assert-boolean (kl:shen.+string? (string-tail V3920 1))) (equal? "S" (make-string 1 (string-ref (string-tail V3920 1) 0)))))) (cons (quote shen.app) (cons V3919 (cons (string-tail (string-tail V3920 1) 1) (cons (quote shen.s) (quote ())))))) ((assert-boolean (kl:shen.+string? V3920)) (kl:shen.factor-cn (cons (quote cn) (cons (make-string 1 (string-ref V3920 0)) (cons (kl:shen.insert-l V3919 (string-tail V3920 1)) (quote ())))))) ((and (pair? V3920) (and (eq? (quote cn) (car V3920)) (and (pair? (cdr V3920)) (and (pair? (cdr (cdr V3920))) (null? (cdr (cdr (cdr V3920)))))))) (cons (quote cn) (cons (car (cdr V3920)) (cons (kl:shen.insert-l V3919 (car (cdr (cdr V3920)))) (quote ()))))) ((and (pair? V3920) (and (eq? (quote shen.app) (car V3920)) (and (pair? (cdr V3920)) (and (pair? (cdr (cdr V3920))) (and (pair? (cdr (cdr (cdr V3920)))) (null? (cdr (cdr (cdr (cdr V3920)))))))))) (cons (quote shen.app) (cons (car (cdr V3920)) (cons (kl:shen.insert-l V3919 (car (cdr (cdr V3920)))) (cdr (cdr (cdr V3920))))))) (#t (kl:shen.f_error (quote shen.insert-l))))) (quote shen.insert-l))
(begin (register-function-arity (quote shen.factor-cn) 1) (define (kl:shen.factor-cn V3922) (cond ((and (pair? V3922) (and (eq? (quote cn) (car V3922)) (and (pair? (cdr V3922)) (and (pair? (cdr (cdr V3922))) (and (pair? (car (cdr (cdr V3922)))) (and (eq? (quote cn) (car (car (cdr (cdr V3922))))) (and (pair? (cdr (car (cdr (cdr V3922))))) (and (pair? (cdr (cdr (car (cdr (cdr V3922)))))) (and (null? (cdr (cdr (cdr (car (cdr (cdr V3922))))))) (and (null? (cdr (cdr (cdr V3922)))) (and (string? (car (cdr V3922))) (string? (car (cdr (car (cdr (cdr V3922))))))))))))))))) (cons (quote cn) (cons (string-append (car (cdr V3922)) (car (cdr (car (cdr (cdr V3922)))))) (cdr (cdr (car (cdr (cdr V3922)))))))) (#t V3922))) (quote shen.factor-cn))
(begin (register-function-arity (quote shen.proc-nl) 1) (define (kl:shen.proc-nl V3924) (cond ((equal? "" V3924) "") ((and (assert-boolean (kl:shen.+string? V3924)) (and (equal? "~" (make-string 1 (string-ref V3924 0))) (and (assert-boolean (kl:shen.+string? (string-tail V3924 1))) (equal? "%" (make-string 1 (string-ref (string-tail V3924 1) 0)))))) (string-append (make-string 1 10) (kl:shen.proc-nl (string-tail (string-tail V3924 1) 1)))) ((assert-boolean (kl:shen.+string? V3924)) (string-append (make-string 1 (string-ref V3924 0)) (kl:shen.proc-nl (string-tail V3924 1)))) (#t (kl:shen.f_error (quote shen.proc-nl))))) (quote shen.proc-nl))
(begin (register-function-arity (quote shen.mkstr-r) 2) (define (kl:shen.mkstr-r V3927 V3928) (cond ((null? V3928) V3927) ((pair? V3928) (kl:shen.mkstr-r (cons (quote shen.insert) (cons (car V3928) (cons V3927 (quote ())))) (cdr V3928))) (#t (kl:shen.f_error (quote shen.mkstr-r))))) (quote shen.mkstr-r))
(begin (register-function-arity (quote shen.insert) 2) (define (kl:shen.insert V3931 V3932) (kl:shen.insert-h V3931 V3932 "")) (quote shen.insert))
(begin (register-function-arity (quote shen.insert-h) 3) (define (kl:shen.insert-h V3938 V3939 V3940) (cond ((equal? "" V3939) V3940) ((and (assert-boolean (kl:shen.+string? V3939)) (and (equal? "~" (make-string 1 (string-ref V3939 0))) (and (assert-boolean (kl:shen.+string? (string-tail V3939 1))) (equal? "A" (make-string 1 (string-ref (string-tail V3939 1) 0)))))) (string-append V3940 (kl:shen.app V3938 (string-tail (string-tail V3939 1) 1) (quote shen.a)))) ((and (assert-boolean (kl:shen.+string? V3939)) (and (equal? "~" (make-string 1 (string-ref V3939 0))) (and (assert-boolean (kl:shen.+string? (string-tail V3939 1))) (equal? "R" (make-string 1 (string-ref (string-tail V3939 1) 0)))))) (string-append V3940 (kl:shen.app V3938 (string-tail (string-tail V3939 1) 1) (quote shen.r)))) ((and (assert-boolean (kl:shen.+string? V3939)) (and (equal? "~" (make-string 1 (string-ref V3939 0))) (and (assert-boolean (kl:shen.+string? (string-tail V3939 1))) (equal? "S" (make-string 1 (string-ref (string-tail V3939 1) 0)))))) (string-append V3940 (kl:shen.app V3938 (string-tail (string-tail V3939 1) 1) (quote shen.s)))) ((assert-boolean (kl:shen.+string? V3939)) (kl:shen.insert-h V3938 (string-tail V3939 1) (string-append V3940 (make-string 1 (string-ref V3939 0))))) (#t (kl:shen.f_error (quote shen.insert-h))))) (quote shen.insert-h))
(begin (register-function-arity (quote shen.app) 3) (define (kl:shen.app V3944 V3945 V3946) (string-append (kl:shen.arg->str V3944 V3946) V3945)) (quote shen.app))
(begin (register-function-arity (quote shen.arg->str) 2) (define (kl:shen.arg->str V3954 V3955) (cond ((kl:= V3954 (kl:fail)) "...") ((assert-boolean (kl:shen.list? V3954)) (kl:shen.list->str V3954 V3955)) ((string? V3954) (kl:shen.str->str V3954 V3955)) ((vector? V3954) (kl:shen.vector->str V3954 V3955)) (#t (kl:shen.atom->str V3954)))) (quote shen.arg->str))
(begin (register-function-arity (quote shen.list->str) 2) (define (kl:shen.list->str V3958 V3959) (cond ((eq? (quote shen.r) V3959) (kl:_waspvm_at_s "(" (kl:_waspvm_at_s (kl:shen.iter-list V3958 (quote shen.r) (kl:shen.maxseq)) ")"))) (#t (kl:_waspvm_at_s "[" (kl:_waspvm_at_s (kl:shen.iter-list V3958 V3959 (kl:shen.maxseq)) "]"))))) (quote shen.list->str))
(begin (register-function-arity (quote shen.maxseq) 0) (define (kl:shen.maxseq) (kl:value (quote *maximum-print-sequence-size*))) (quote shen.maxseq))
(begin (register-function-arity (quote shen.iter-list) 3) (define (kl:shen.iter-list V3973 V3974 V3975) (cond ((null? V3973) "") ((kl:= 0 V3975) "... etc") ((and (pair? V3973) (null? (cdr V3973))) (kl:shen.arg->str (car V3973) V3974)) ((pair? V3973) (kl:_waspvm_at_s (kl:shen.arg->str (car V3973) V3974) (kl:_waspvm_at_s " " (kl:shen.iter-list (cdr V3973) V3974 (- V3975 1))))) (#t (kl:_waspvm_at_s "|" (kl:_waspvm_at_s " " (kl:shen.arg->str V3973 V3974)))))) (quote shen.iter-list))
(begin (register-function-arity (quote shen.str->str) 2) (define (kl:shen.str->str V3982 V3983) (cond ((eq? (quote shen.a) V3983) V3982) (#t (kl:_waspvm_at_s (make-string 1 34) (kl:_waspvm_at_s V3982 (make-string 1 34)))))) (quote shen.str->str))
(begin (register-function-arity (quote shen.vector->str) 2) (define (kl:shen.vector->str V3986 V3987) (if (assert-boolean (kl:shen.print-vector? V3986)) ((kl:function (vector-ref V3986 0)) V3986) (if (assert-boolean (kl:vector? V3986)) (kl:_waspvm_at_s "<" (kl:_waspvm_at_s (kl:shen.iter-vector V3986 1 V3987 (kl:shen.maxseq)) ">")) (kl:_waspvm_at_s "<" (kl:_waspvm_at_s "<" (kl:_waspvm_at_s (kl:shen.iter-vector V3986 0 V3987 (kl:shen.maxseq)) ">>")))))) (quote shen.vector->str))
(begin (register-function-arity (quote shen.print-vector?) 1) (define (kl:shen.print-vector? V3989) (let ((Zero (vector-ref V3989 0))) (if (eq? Zero (quote shen.tuple)) #t (if (eq? Zero (quote shen.pvar)) #t (if (kl:not (number? Zero)) (kl:shen.fbound? Zero) #f))))) (quote shen.print-vector?))
(begin (register-function-arity (quote shen.fbound?) 1) (define (kl:shen.fbound? V3991) (guard (lambda (E) #f) (begin (kl:shen.lookup-func V3991 (kl:value (quote shen.*symbol-table*))) #t))) (quote shen.fbound?))
(begin (register-function-arity (quote shen.tuple) 1) (define (kl:shen.tuple V3993) (string-append "(@p " (kl:shen.app (vector-ref V3993 1) (string-append " " (kl:shen.app (vector-ref V3993 2) ")" (quote shen.s))) (quote shen.s)))) (quote shen.tuple))
(begin (register-function-arity (quote shen.iter-vector) 4) (define (kl:shen.iter-vector V4004 V4005 V4006 V4007) (cond ((kl:= 0 V4007) "... etc") (#t (let ((Item (guard (lambda (E) (quote shen.out-of-bounds)) (vector-ref V4004 V4005)))) (let ((Next (guard (lambda (E) (quote shen.out-of-bounds)) (vector-ref V4004 (+ V4005 1))))) (if (eq? Item (quote shen.out-of-bounds)) "" (if (eq? Next (quote shen.out-of-bounds)) (kl:shen.arg->str Item V4006) (kl:_waspvm_at_s (kl:shen.arg->str Item V4006) (kl:_waspvm_at_s " " (kl:shen.iter-vector V4004 (+ V4005 1) V4006 (- V4007 1))))))))))) (quote shen.iter-vector))
(begin (register-function-arity (quote shen.atom->str) 1) (define (kl:shen.atom->str V4009) (guard (lambda (E) (kl:shen.funexstring)) (kl:str V4009))) (quote shen.atom->str))
(begin (register-function-arity (quote shen.funexstring) 0) (define (kl:shen.funexstring) (kl:_waspvm_at_s "\016" (kl:_waspvm_at_s "f" (kl:_waspvm_at_s "u" (kl:_waspvm_at_s "n" (kl:_waspvm_at_s "e" (kl:_waspvm_at_s (kl:shen.arg->str (kl:gensym (kl:intern "x")) (quote shen.a)) "\017"))))))) (quote shen.funexstring))
(begin (register-function-arity (quote shen.list?) 1) (define (kl:shen.list? V4011) (or (kl:empty? V4011) (pair? V4011))) (quote shen.list?))
