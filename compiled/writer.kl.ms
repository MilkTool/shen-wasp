(module "compiled/writer.kl")
"Copyright (c) 2010-2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
(begin (register-function-arity (quote pr) 2) (define (kl:pr V5697 V5698) (guard (lambda (E) V5697) (kl:shen.prh V5697 V5698 0))) (export pr) (quote pr))
(begin (register-function-arity (quote shen.prh) 3) (define (kl:shen.prh V5702 V5703 V5704) (kl:shen.prh V5702 V5703 (kl:shen.write-char-and-inc V5702 V5703 V5704))) (export shen.prh) (quote shen.prh))
(begin (register-function-arity (quote shen.write-char-and-inc) 3) (define (kl:shen.write-char-and-inc V5708 V5709 V5710) (begin (write-u8 (string-ref (make-string 1 (string-ref V5708 V5710)) 0) V5709) (+ V5710 1))) (export shen.write-char-and-inc) (quote shen.write-char-and-inc))
(begin (register-function-arity (quote print) 1) (define (kl:print V5712) (let ((String (kl:shen.insert V5712 "~S"))) (let ((Print (kl:shen.prhush String (kl:stoutput)))) V5712))) (export print) (quote print))
(begin (register-function-arity (quote shen.prhush) 2) (define (kl:shen.prhush V5715 V5716) (if (assert-boolean (kl:value (quote *hush*))) V5715 (kl:pr V5715 V5716))) (export shen.prhush) (quote shen.prhush))
(begin (register-function-arity (quote shen.mkstr) 2) (define (kl:shen.mkstr V5719 V5720) (cond ((string? V5719) (kl:shen.mkstr-l (kl:shen.proc-nl V5719) V5720)) (#t (kl:shen.mkstr-r (cons (quote shen.proc-nl) (cons V5719 (quote ()))) V5720)))) (export shen.mkstr) (quote shen.mkstr))
(begin (register-function-arity (quote shen.mkstr-l) 2) (define (kl:shen.mkstr-l V5723 V5724) (cond ((null? V5724) V5723) ((pair? V5724) (kl:shen.mkstr-l (kl:shen.insert-l (car V5724) V5723) (cdr V5724))) (#t (kl:shen.f_error (quote shen.mkstr-l))))) (export shen.mkstr-l) (quote shen.mkstr-l))
(begin (register-function-arity (quote shen.insert-l) 2) (define (kl:shen.insert-l V5729 V5730) (cond ((equal? "" V5730) "") ((and (assert-boolean (kl:shen.+string? V5730)) (and (equal? "~" (make-string 1 (string-ref V5730 0))) (and (assert-boolean (kl:shen.+string? (string-tail V5730 1))) (equal? "A" (make-string 1 (string-ref (string-tail V5730 1) 0)))))) (cons (quote shen.app) (cons V5729 (cons (string-tail (string-tail V5730 1) 1) (cons (quote shen.a) (quote ())))))) ((and (assert-boolean (kl:shen.+string? V5730)) (and (equal? "~" (make-string 1 (string-ref V5730 0))) (and (assert-boolean (kl:shen.+string? (string-tail V5730 1))) (equal? "R" (make-string 1 (string-ref (string-tail V5730 1) 0)))))) (cons (quote shen.app) (cons V5729 (cons (string-tail (string-tail V5730 1) 1) (cons (quote shen.r) (quote ())))))) ((and (assert-boolean (kl:shen.+string? V5730)) (and (equal? "~" (make-string 1 (string-ref V5730 0))) (and (assert-boolean (kl:shen.+string? (string-tail V5730 1))) (equal? "S" (make-string 1 (string-ref (string-tail V5730 1) 0)))))) (cons (quote shen.app) (cons V5729 (cons (string-tail (string-tail V5730 1) 1) (cons (quote shen.s) (quote ())))))) ((assert-boolean (kl:shen.+string? V5730)) (kl:shen.factor-cn (cons (quote cn) (cons (make-string 1 (string-ref V5730 0)) (cons (kl:shen.insert-l V5729 (string-tail V5730 1)) (quote ())))))) ((and (pair? V5730) (and (eq? (quote cn) (car V5730)) (and (pair? (cdr V5730)) (and (pair? (cdr (cdr V5730))) (null? (cdr (cdr (cdr V5730)))))))) (cons (quote cn) (cons (car (cdr V5730)) (cons (kl:shen.insert-l V5729 (car (cdr (cdr V5730)))) (quote ()))))) ((and (pair? V5730) (and (eq? (quote shen.app) (car V5730)) (and (pair? (cdr V5730)) (and (pair? (cdr (cdr V5730))) (and (pair? (cdr (cdr (cdr V5730)))) (null? (cdr (cdr (cdr (cdr V5730)))))))))) (cons (quote shen.app) (cons (car (cdr V5730)) (cons (kl:shen.insert-l V5729 (car (cdr (cdr V5730)))) (cdr (cdr (cdr V5730))))))) (#t (kl:shen.f_error (quote shen.insert-l))))) (export shen.insert-l) (quote shen.insert-l))
(begin (register-function-arity (quote shen.factor-cn) 1) (define (kl:shen.factor-cn V5732) (cond ((and (pair? V5732) (and (eq? (quote cn) (car V5732)) (and (pair? (cdr V5732)) (and (pair? (cdr (cdr V5732))) (and (pair? (car (cdr (cdr V5732)))) (and (eq? (quote cn) (car (car (cdr (cdr V5732))))) (and (pair? (cdr (car (cdr (cdr V5732))))) (and (pair? (cdr (cdr (car (cdr (cdr V5732)))))) (and (null? (cdr (cdr (cdr (car (cdr (cdr V5732))))))) (and (null? (cdr (cdr (cdr V5732)))) (and (string? (car (cdr V5732))) (string? (car (cdr (car (cdr (cdr V5732))))))))))))))))) (cons (quote cn) (cons (string-append (car (cdr V5732)) (car (cdr (car (cdr (cdr V5732)))))) (cdr (cdr (car (cdr (cdr V5732)))))))) (#t V5732))) (export shen.factor-cn) (quote shen.factor-cn))
(begin (register-function-arity (quote shen.proc-nl) 1) (define (kl:shen.proc-nl V5734) (cond ((equal? "" V5734) "") ((and (assert-boolean (kl:shen.+string? V5734)) (and (equal? "~" (make-string 1 (string-ref V5734 0))) (and (assert-boolean (kl:shen.+string? (string-tail V5734 1))) (equal? "%" (make-string 1 (string-ref (string-tail V5734 1) 0)))))) (string-append (make-string 1 10) (kl:shen.proc-nl (string-tail (string-tail V5734 1) 1)))) ((assert-boolean (kl:shen.+string? V5734)) (string-append (make-string 1 (string-ref V5734 0)) (kl:shen.proc-nl (string-tail V5734 1)))) (#t (kl:shen.f_error (quote shen.proc-nl))))) (export shen.proc-nl) (quote shen.proc-nl))
(begin (register-function-arity (quote shen.mkstr-r) 2) (define (kl:shen.mkstr-r V5737 V5738) (cond ((null? V5738) V5737) ((pair? V5738) (kl:shen.mkstr-r (cons (quote shen.insert) (cons (car V5738) (cons V5737 (quote ())))) (cdr V5738))) (#t (kl:shen.f_error (quote shen.mkstr-r))))) (export shen.mkstr-r) (quote shen.mkstr-r))
(begin (register-function-arity (quote shen.insert) 2) (define (kl:shen.insert V5741 V5742) (kl:shen.insert-h V5741 V5742 "")) (export shen.insert) (quote shen.insert))
(begin (register-function-arity (quote shen.insert-h) 3) (define (kl:shen.insert-h V5748 V5749 V5750) (cond ((equal? "" V5749) V5750) ((and (assert-boolean (kl:shen.+string? V5749)) (and (equal? "~" (make-string 1 (string-ref V5749 0))) (and (assert-boolean (kl:shen.+string? (string-tail V5749 1))) (equal? "A" (make-string 1 (string-ref (string-tail V5749 1) 0)))))) (string-append V5750 (kl:shen.app V5748 (string-tail (string-tail V5749 1) 1) (quote shen.a)))) ((and (assert-boolean (kl:shen.+string? V5749)) (and (equal? "~" (make-string 1 (string-ref V5749 0))) (and (assert-boolean (kl:shen.+string? (string-tail V5749 1))) (equal? "R" (make-string 1 (string-ref (string-tail V5749 1) 0)))))) (string-append V5750 (kl:shen.app V5748 (string-tail (string-tail V5749 1) 1) (quote shen.r)))) ((and (assert-boolean (kl:shen.+string? V5749)) (and (equal? "~" (make-string 1 (string-ref V5749 0))) (and (assert-boolean (kl:shen.+string? (string-tail V5749 1))) (equal? "S" (make-string 1 (string-ref (string-tail V5749 1) 0)))))) (string-append V5750 (kl:shen.app V5748 (string-tail (string-tail V5749 1) 1) (quote shen.s)))) ((assert-boolean (kl:shen.+string? V5749)) (kl:shen.insert-h V5748 (string-tail V5749 1) (string-append V5750 (make-string 1 (string-ref V5749 0))))) (#t (kl:shen.f_error (quote shen.insert-h))))) (export shen.insert-h) (quote shen.insert-h))
(begin (register-function-arity (quote shen.app) 3) (define (kl:shen.app V5754 V5755 V5756) (string-append (kl:shen.arg->str V5754 V5756) V5755)) (export shen.app) (quote shen.app))
(begin (register-function-arity (quote shen.arg->str) 2) (define (kl:shen.arg->str V5764 V5765) (cond ((kl:= V5764 (kl:fail)) "...") ((assert-boolean (kl:shen.list? V5764)) (kl:shen.list->str V5764 V5765)) ((string? V5764) (kl:shen.str->str V5764 V5765)) ((vector? V5764) (kl:shen.vector->str V5764 V5765)) (#t (kl:shen.atom->str V5764)))) (export shen.arg->str) (quote shen.arg->str))
(begin (register-function-arity (quote shen.list->str) 2) (define (kl:shen.list->str V5768 V5769) (cond ((eq? (quote shen.r) V5769) (kl:_waspvm_at_s "(" (kl:_waspvm_at_s (kl:shen.iter-list V5768 (quote shen.r) (kl:shen.maxseq)) ")"))) (#t (kl:_waspvm_at_s "[" (kl:_waspvm_at_s (kl:shen.iter-list V5768 V5769 (kl:shen.maxseq)) "]"))))) (export shen.list->str) (quote shen.list->str))
(begin (register-function-arity (quote shen.maxseq) 0) (define (kl:shen.maxseq) (kl:value (quote *maximum-print-sequence-size*))) (export shen.maxseq) (quote shen.maxseq))
(begin (register-function-arity (quote shen.iter-list) 3) (define (kl:shen.iter-list V5783 V5784 V5785) (cond ((null? V5783) "") ((kl:= 0 V5785) "... etc") ((and (pair? V5783) (null? (cdr V5783))) (kl:shen.arg->str (car V5783) V5784)) ((pair? V5783) (kl:_waspvm_at_s (kl:shen.arg->str (car V5783) V5784) (kl:_waspvm_at_s " " (kl:shen.iter-list (cdr V5783) V5784 (- V5785 1))))) (#t (kl:_waspvm_at_s "|" (kl:_waspvm_at_s " " (kl:shen.arg->str V5783 V5784)))))) (export shen.iter-list) (quote shen.iter-list))
(begin (register-function-arity (quote shen.str->str) 2) (define (kl:shen.str->str V5792 V5793) (cond ((eq? (quote shen.a) V5793) V5792) (#t (kl:_waspvm_at_s (make-string 1 34) (kl:_waspvm_at_s V5792 (make-string 1 34)))))) (export shen.str->str) (quote shen.str->str))
(begin (register-function-arity (quote shen.vector->str) 2) (define (kl:shen.vector->str V5796 V5797) (if (assert-boolean (kl:shen.print-vector? V5796)) ((kl:function (vector-ref V5796 0)) V5796) (if (assert-boolean (kl:vector? V5796)) (kl:_waspvm_at_s "<" (kl:_waspvm_at_s (kl:shen.iter-vector V5796 1 V5797 (kl:shen.maxseq)) ">")) (kl:_waspvm_at_s "<" (kl:_waspvm_at_s "<" (kl:_waspvm_at_s (kl:shen.iter-vector V5796 0 V5797 (kl:shen.maxseq)) ">>")))))) (export shen.vector->str) (quote shen.vector->str))
(begin (register-function-arity (quote shen.empty-absvector?) 1) (define (kl:shen.empty-absvector? V5799) (kl:= V5799 (kl:value (quote shen.*empty-absvector*)))) (export shen.empty-absvector?) (quote shen.empty-absvector?))
(begin (register-function-arity (quote shen.print-vector?) 1) (define (kl:shen.print-vector? V5801) (and (kl:not (kl:shen.empty-absvector? V5801)) (assert-boolean (let ((First (vector-ref V5801 0))) (or (eq? First (quote shen.tuple)) (or (eq? First (quote shen.pvar)) (or (eq? First (quote shen.dictionary)) (and (kl:not (number? First)) (assert-boolean (kl:shen.fbound? First)))))))))) (export shen.print-vector?) (quote shen.print-vector?))
(begin (register-function-arity (quote shen.fbound?) 1) (define (kl:shen.fbound? V5803) (guard (lambda (E) #f) (begin (kl:shen.lookup-func V5803) #t))) (export shen.fbound?) (quote shen.fbound?))
(begin (register-function-arity (quote shen.tuple) 1) (define (kl:shen.tuple V5805) (string-append "(@p " (kl:shen.app (vector-ref V5805 1) (string-append " " (kl:shen.app (vector-ref V5805 2) ")" (quote shen.s))) (quote shen.s)))) (export shen.tuple) (quote shen.tuple))
(begin (register-function-arity (quote shen.dictionary) 1) (define (kl:shen.dictionary V5807) "(dict ...)") (export shen.dictionary) (quote shen.dictionary))
(begin (register-function-arity (quote shen.iter-vector) 4) (define (kl:shen.iter-vector V5818 V5819 V5820 V5821) (cond ((kl:= 0 V5821) "... etc") (#t (let ((Item (guard (lambda (E) (quote shen.out-of-bounds)) (vector-ref V5818 V5819)))) (let ((Next (guard (lambda (E) (quote shen.out-of-bounds)) (vector-ref V5818 (+ V5819 1))))) (if (eq? Item (quote shen.out-of-bounds)) "" (if (eq? Next (quote shen.out-of-bounds)) (kl:shen.arg->str Item V5820) (kl:_waspvm_at_s (kl:shen.arg->str Item V5820) (kl:_waspvm_at_s " " (kl:shen.iter-vector V5818 (+ V5819 1) V5820 (- V5821 1))))))))))) (export shen.iter-vector) (quote shen.iter-vector))
(begin (register-function-arity (quote shen.atom->str) 1) (define (kl:shen.atom->str V5823) (guard (lambda (E) (kl:shen.funexstring)) (kl:str V5823))) (export shen.atom->str) (quote shen.atom->str))
(begin (register-function-arity (quote shen.funexstring) 0) (define (kl:shen.funexstring) (kl:_waspvm_at_s "\016" (kl:_waspvm_at_s "f" (kl:_waspvm_at_s "u" (kl:_waspvm_at_s "n" (kl:_waspvm_at_s "e" (kl:_waspvm_at_s (kl:shen.arg->str (kl:gensym (kl:intern "x")) (quote shen.a)) "\017"))))))) (export shen.funexstring) (quote shen.funexstring))
(begin (register-function-arity (quote shen.list?) 1) (define (kl:shen.list? V5825) (or (kl:empty? V5825) (pair? V5825))) (export shen.list?) (quote shen.list?))
