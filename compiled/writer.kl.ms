"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote pr) 2) (define (kl:pr V4185 V4186) (guard (lambda (E) V4185) (kl:shen.prh V4185 V4186 0))) (quote pr))
(begin (register-function-arity (quote shen.prh) 3) (define (kl:shen.prh V4190 V4191 V4192) (kl:shen.prh V4190 V4191 (kl:shen.write-char-and-inc V4190 V4191 V4192))) (quote shen.prh))
(begin (register-function-arity (quote shen.write-char-and-inc) 3) (define (kl:shen.write-char-and-inc V4196 V4197 V4198) (begin (write-u8 (string-ref (make-string 1 (string-ref V4196 V4198)) 0) V4197) (+ V4198 1))) (quote shen.write-char-and-inc))
(begin (register-function-arity (quote print) 1) (define (kl:print V4200) (let ((String (kl:shen.insert V4200 "~S"))) (let ((Print (kl:shen.prhush String (kl:stoutput)))) V4200))) (quote print))
(begin (register-function-arity (quote shen.prhush) 2) (define (kl:shen.prhush V4203 V4204) (if (assert-boolean (kl:value (quote *hush*))) V4203 (kl:pr V4203 V4204))) (quote shen.prhush))
(begin (register-function-arity (quote shen.mkstr) 2) (define (kl:shen.mkstr V4207 V4208) (cond ((string? V4207) (kl:shen.mkstr-l (kl:shen.proc-nl V4207) V4208)) (#t (kl:shen.mkstr-r (cons (quote shen.proc-nl) (cons V4207 (quote ()))) V4208)))) (quote shen.mkstr))
(begin (register-function-arity (quote shen.mkstr-l) 2) (define (kl:shen.mkstr-l V4211 V4212) (cond ((null? V4212) V4211) ((pair? V4212) (kl:shen.mkstr-l (kl:shen.insert-l (car V4212) V4211) (cdr V4212))) (#t (kl:shen.f_error (quote shen.mkstr-l))))) (quote shen.mkstr-l))
(begin (register-function-arity (quote shen.insert-l) 2) (define (kl:shen.insert-l V4217 V4218) (cond ((equal? "" V4218) "") ((and (assert-boolean (kl:shen.+string? V4218)) (and (equal? "~" (make-string 1 (string-ref V4218 0))) (and (assert-boolean (kl:shen.+string? (string-tail V4218 1))) (equal? "A" (make-string 1 (string-ref (string-tail V4218 1) 0)))))) (cons (quote shen.app) (cons V4217 (cons (string-tail (string-tail V4218 1) 1) (cons (quote shen.a) (quote ())))))) ((and (assert-boolean (kl:shen.+string? V4218)) (and (equal? "~" (make-string 1 (string-ref V4218 0))) (and (assert-boolean (kl:shen.+string? (string-tail V4218 1))) (equal? "R" (make-string 1 (string-ref (string-tail V4218 1) 0)))))) (cons (quote shen.app) (cons V4217 (cons (string-tail (string-tail V4218 1) 1) (cons (quote shen.r) (quote ())))))) ((and (assert-boolean (kl:shen.+string? V4218)) (and (equal? "~" (make-string 1 (string-ref V4218 0))) (and (assert-boolean (kl:shen.+string? (string-tail V4218 1))) (equal? "S" (make-string 1 (string-ref (string-tail V4218 1) 0)))))) (cons (quote shen.app) (cons V4217 (cons (string-tail (string-tail V4218 1) 1) (cons (quote shen.s) (quote ())))))) ((assert-boolean (kl:shen.+string? V4218)) (kl:shen.factor-cn (cons (quote cn) (cons (make-string 1 (string-ref V4218 0)) (cons (kl:shen.insert-l V4217 (string-tail V4218 1)) (quote ())))))) ((and (pair? V4218) (and (eq? (quote cn) (car V4218)) (and (pair? (cdr V4218)) (and (pair? (cdr (cdr V4218))) (null? (cdr (cdr (cdr V4218)))))))) (cons (quote cn) (cons (car (cdr V4218)) (cons (kl:shen.insert-l V4217 (car (cdr (cdr V4218)))) (quote ()))))) ((and (pair? V4218) (and (eq? (quote shen.app) (car V4218)) (and (pair? (cdr V4218)) (and (pair? (cdr (cdr V4218))) (and (pair? (cdr (cdr (cdr V4218)))) (null? (cdr (cdr (cdr (cdr V4218)))))))))) (cons (quote shen.app) (cons (car (cdr V4218)) (cons (kl:shen.insert-l V4217 (car (cdr (cdr V4218)))) (cdr (cdr (cdr V4218))))))) (#t (kl:shen.f_error (quote shen.insert-l))))) (quote shen.insert-l))
(begin (register-function-arity (quote shen.factor-cn) 1) (define (kl:shen.factor-cn V4220) (cond ((and (pair? V4220) (and (eq? (quote cn) (car V4220)) (and (pair? (cdr V4220)) (and (pair? (cdr (cdr V4220))) (and (pair? (car (cdr (cdr V4220)))) (and (eq? (quote cn) (car (car (cdr (cdr V4220))))) (and (pair? (cdr (car (cdr (cdr V4220))))) (and (pair? (cdr (cdr (car (cdr (cdr V4220)))))) (and (null? (cdr (cdr (cdr (car (cdr (cdr V4220))))))) (and (null? (cdr (cdr (cdr V4220)))) (and (string? (car (cdr V4220))) (string? (car (cdr (car (cdr (cdr V4220))))))))))))))))) (cons (quote cn) (cons (string-append (car (cdr V4220)) (car (cdr (car (cdr (cdr V4220)))))) (cdr (cdr (car (cdr (cdr V4220)))))))) (#t V4220))) (quote shen.factor-cn))
(begin (register-function-arity (quote shen.proc-nl) 1) (define (kl:shen.proc-nl V4222) (cond ((equal? "" V4222) "") ((and (assert-boolean (kl:shen.+string? V4222)) (and (equal? "~" (make-string 1 (string-ref V4222 0))) (and (assert-boolean (kl:shen.+string? (string-tail V4222 1))) (equal? "%" (make-string 1 (string-ref (string-tail V4222 1) 0)))))) (string-append (make-string 1 10) (kl:shen.proc-nl (string-tail (string-tail V4222 1) 1)))) ((assert-boolean (kl:shen.+string? V4222)) (string-append (make-string 1 (string-ref V4222 0)) (kl:shen.proc-nl (string-tail V4222 1)))) (#t (kl:shen.f_error (quote shen.proc-nl))))) (quote shen.proc-nl))
(begin (register-function-arity (quote shen.mkstr-r) 2) (define (kl:shen.mkstr-r V4225 V4226) (cond ((null? V4226) V4225) ((pair? V4226) (kl:shen.mkstr-r (cons (quote shen.insert) (cons (car V4226) (cons V4225 (quote ())))) (cdr V4226))) (#t (kl:shen.f_error (quote shen.mkstr-r))))) (quote shen.mkstr-r))
(begin (register-function-arity (quote shen.insert) 2) (define (kl:shen.insert V4229 V4230) (kl:shen.insert-h V4229 V4230 "")) (quote shen.insert))
(begin (register-function-arity (quote shen.insert-h) 3) (define (kl:shen.insert-h V4236 V4237 V4238) (cond ((equal? "" V4237) V4238) ((and (assert-boolean (kl:shen.+string? V4237)) (and (equal? "~" (make-string 1 (string-ref V4237 0))) (and (assert-boolean (kl:shen.+string? (string-tail V4237 1))) (equal? "A" (make-string 1 (string-ref (string-tail V4237 1) 0)))))) (string-append V4238 (kl:shen.app V4236 (string-tail (string-tail V4237 1) 1) (quote shen.a)))) ((and (assert-boolean (kl:shen.+string? V4237)) (and (equal? "~" (make-string 1 (string-ref V4237 0))) (and (assert-boolean (kl:shen.+string? (string-tail V4237 1))) (equal? "R" (make-string 1 (string-ref (string-tail V4237 1) 0)))))) (string-append V4238 (kl:shen.app V4236 (string-tail (string-tail V4237 1) 1) (quote shen.r)))) ((and (assert-boolean (kl:shen.+string? V4237)) (and (equal? "~" (make-string 1 (string-ref V4237 0))) (and (assert-boolean (kl:shen.+string? (string-tail V4237 1))) (equal? "S" (make-string 1 (string-ref (string-tail V4237 1) 0)))))) (string-append V4238 (kl:shen.app V4236 (string-tail (string-tail V4237 1) 1) (quote shen.s)))) ((assert-boolean (kl:shen.+string? V4237)) (kl:shen.insert-h V4236 (string-tail V4237 1) (string-append V4238 (make-string 1 (string-ref V4237 0))))) (#t (kl:shen.f_error (quote shen.insert-h))))) (quote shen.insert-h))
(begin (register-function-arity (quote shen.app) 3) (define (kl:shen.app V4242 V4243 V4244) (string-append (kl:shen.arg->str V4242 V4244) V4243)) (quote shen.app))
(begin (register-function-arity (quote shen.arg->str) 2) (define (kl:shen.arg->str V4252 V4253) (cond ((kl:= V4252 (kl:fail)) "...") ((assert-boolean (kl:shen.list? V4252)) (kl:shen.list->str V4252 V4253)) ((string? V4252) (kl:shen.str->str V4252 V4253)) ((vector? V4252) (kl:shen.vector->str V4252 V4253)) (#t (kl:shen.atom->str V4252)))) (quote shen.arg->str))
(begin (register-function-arity (quote shen.list->str) 2) (define (kl:shen.list->str V4256 V4257) (cond ((eq? (quote shen.r) V4257) (kl:_waspvm_at_s "(" (kl:_waspvm_at_s (kl:shen.iter-list V4256 (quote shen.r) (kl:shen.maxseq)) ")"))) (#t (kl:_waspvm_at_s "[" (kl:_waspvm_at_s (kl:shen.iter-list V4256 V4257 (kl:shen.maxseq)) "]"))))) (quote shen.list->str))
(begin (register-function-arity (quote shen.maxseq) 0) (define (kl:shen.maxseq) (kl:value (quote *maximum-print-sequence-size*))) (quote shen.maxseq))
(begin (register-function-arity (quote shen.iter-list) 3) (define (kl:shen.iter-list V4271 V4272 V4273) (cond ((null? V4271) "") ((kl:= 0 V4273) "... etc") ((and (pair? V4271) (null? (cdr V4271))) (kl:shen.arg->str (car V4271) V4272)) ((pair? V4271) (kl:_waspvm_at_s (kl:shen.arg->str (car V4271) V4272) (kl:_waspvm_at_s " " (kl:shen.iter-list (cdr V4271) V4272 (- V4273 1))))) (#t (kl:_waspvm_at_s "|" (kl:_waspvm_at_s " " (kl:shen.arg->str V4271 V4272)))))) (quote shen.iter-list))
(begin (register-function-arity (quote shen.str->str) 2) (define (kl:shen.str->str V4280 V4281) (cond ((eq? (quote shen.a) V4281) V4280) (#t (kl:_waspvm_at_s (make-string 1 34) (kl:_waspvm_at_s V4280 (make-string 1 34)))))) (quote shen.str->str))
(begin (register-function-arity (quote shen.vector->str) 2) (define (kl:shen.vector->str V4284 V4285) (if (assert-boolean (kl:shen.print-vector? V4284)) ((kl:function (vector-ref V4284 0)) V4284) (if (assert-boolean (kl:vector? V4284)) (kl:_waspvm_at_s "<" (kl:_waspvm_at_s (kl:shen.iter-vector V4284 1 V4285 (kl:shen.maxseq)) ">")) (kl:_waspvm_at_s "<" (kl:_waspvm_at_s "<" (kl:_waspvm_at_s (kl:shen.iter-vector V4284 0 V4285 (kl:shen.maxseq)) ">>")))))) (quote shen.vector->str))
(begin (register-function-arity (quote shen.print-vector?) 1) (define (kl:shen.print-vector? V4287) (let ((Zero (vector-ref V4287 0))) (if (eq? Zero (quote shen.tuple)) #t (if (eq? Zero (quote shen.pvar)) #t (if (eq? Zero (quote shen.dictionary)) #t (if (kl:not (number? Zero)) (kl:shen.fbound? Zero) #f)))))) (quote shen.print-vector?))
(begin (register-function-arity (quote shen.fbound?) 1) (define (kl:shen.fbound? V4289) (guard (lambda (E) #f) (begin (kl:shen.lookup-func V4289) #t))) (quote shen.fbound?))
(begin (register-function-arity (quote shen.tuple) 1) (define (kl:shen.tuple V4291) (string-append "(@p " (kl:shen.app (vector-ref V4291 1) (string-append " " (kl:shen.app (vector-ref V4291 2) ")" (quote shen.s))) (quote shen.s)))) (quote shen.tuple))
(begin (register-function-arity (quote shen.dictionary) 1) (define (kl:shen.dictionary V4293) "(dict ...)") (quote shen.dictionary))
(begin (register-function-arity (quote shen.iter-vector) 4) (define (kl:shen.iter-vector V4304 V4305 V4306 V4307) (cond ((kl:= 0 V4307) "... etc") (#t (let ((Item (kl:<-address/or V4304 V4305 (lambda () (quote shen.out-of-bounds))))) (let ((Next (kl:<-address/or V4304 (+ V4305 1) (lambda () (quote shen.out-of-bounds))))) (if (eq? Item (quote shen.out-of-bounds)) "" (if (eq? Next (quote shen.out-of-bounds)) (kl:shen.arg->str Item V4306) (kl:_waspvm_at_s (kl:shen.arg->str Item V4306) (kl:_waspvm_at_s " " (kl:shen.iter-vector V4304 (+ V4305 1) V4306 (- V4307 1))))))))))) (quote shen.iter-vector))
(begin (register-function-arity (quote shen.atom->str) 1) (define (kl:shen.atom->str V4309) (guard (lambda (E) (kl:shen.funexstring)) (kl:str V4309))) (quote shen.atom->str))
(begin (register-function-arity (quote shen.funexstring) 0) (define (kl:shen.funexstring) (kl:_waspvm_at_s "\016" (kl:_waspvm_at_s "f" (kl:_waspvm_at_s "u" (kl:_waspvm_at_s "n" (kl:_waspvm_at_s "e" (kl:_waspvm_at_s (kl:shen.arg->str (kl:gensym (kl:intern "x")) (quote shen.a)) "\017"))))))) (quote shen.funexstring))
(begin (register-function-arity (quote shen.list?) 1) (define (kl:shen.list? V4311) (or (kl:empty? V4311) (pair? V4311))) (quote shen.list?))
