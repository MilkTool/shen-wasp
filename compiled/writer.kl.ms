"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote pr) 2) (define (kl:pr V3991 V3992) (guard (lambda (E) V3991) (kl:shen.prh V3991 V3992 0))) (quote pr))
(begin (register-function-arity (quote shen.prh) 3) (define (kl:shen.prh V3996 V3997 V3998) (kl:shen.prh V3996 V3997 (kl:shen.write-char-and-inc V3996 V3997 V3998))) (quote shen.prh))
(begin (register-function-arity (quote shen.write-char-and-inc) 3) (define (kl:shen.write-char-and-inc V4002 V4003 V4004) (begin (write-u8 (string-ref (make-string 1 (string-ref V4002 V4004)) 0) V4003) (+ V4004 1))) (quote shen.write-char-and-inc))
(begin (register-function-arity (quote print) 1) (define (kl:print V4006) (let ((String (kl:shen.insert V4006 "~S"))) (let ((Print (kl:shen.prhush String (kl:stoutput)))) V4006))) (quote print))
(begin (register-function-arity (quote shen.prhush) 2) (define (kl:shen.prhush V4009 V4010) (if (assert-boolean (kl:value (quote *hush*))) V4009 (kl:pr V4009 V4010))) (quote shen.prhush))
(begin (register-function-arity (quote shen.mkstr) 2) (define (kl:shen.mkstr V4013 V4014) (cond ((string? V4013) (kl:shen.mkstr-l (kl:shen.proc-nl V4013) V4014)) (#t (kl:shen.mkstr-r (cons (quote shen.proc-nl) (cons V4013 (quote ()))) V4014)))) (quote shen.mkstr))
(begin (register-function-arity (quote shen.mkstr-l) 2) (define (kl:shen.mkstr-l V4017 V4018) (cond ((null? V4018) V4017) ((pair? V4018) (kl:shen.mkstr-l (kl:shen.insert-l (car V4018) V4017) (cdr V4018))) (#t (kl:shen.f_error (quote shen.mkstr-l))))) (quote shen.mkstr-l))
(begin (register-function-arity (quote shen.insert-l) 2) (define (kl:shen.insert-l V4023 V4024) (cond ((equal? "" V4024) "") ((and (assert-boolean (kl:shen.+string? V4024)) (and (equal? "~" (make-string 1 (string-ref V4024 0))) (and (assert-boolean (kl:shen.+string? (string-tail V4024 1))) (equal? "A" (make-string 1 (string-ref (string-tail V4024 1) 0)))))) (cons (quote shen.app) (cons V4023 (cons (string-tail (string-tail V4024 1) 1) (cons (quote shen.a) (quote ())))))) ((and (assert-boolean (kl:shen.+string? V4024)) (and (equal? "~" (make-string 1 (string-ref V4024 0))) (and (assert-boolean (kl:shen.+string? (string-tail V4024 1))) (equal? "R" (make-string 1 (string-ref (string-tail V4024 1) 0)))))) (cons (quote shen.app) (cons V4023 (cons (string-tail (string-tail V4024 1) 1) (cons (quote shen.r) (quote ())))))) ((and (assert-boolean (kl:shen.+string? V4024)) (and (equal? "~" (make-string 1 (string-ref V4024 0))) (and (assert-boolean (kl:shen.+string? (string-tail V4024 1))) (equal? "S" (make-string 1 (string-ref (string-tail V4024 1) 0)))))) (cons (quote shen.app) (cons V4023 (cons (string-tail (string-tail V4024 1) 1) (cons (quote shen.s) (quote ())))))) ((assert-boolean (kl:shen.+string? V4024)) (kl:shen.factor-cn (cons (quote cn) (cons (make-string 1 (string-ref V4024 0)) (cons (kl:shen.insert-l V4023 (string-tail V4024 1)) (quote ())))))) ((and (pair? V4024) (and (eq? (quote cn) (car V4024)) (and (pair? (cdr V4024)) (and (pair? (cdr (cdr V4024))) (null? (cdr (cdr (cdr V4024)))))))) (cons (quote cn) (cons (car (cdr V4024)) (cons (kl:shen.insert-l V4023 (car (cdr (cdr V4024)))) (quote ()))))) ((and (pair? V4024) (and (eq? (quote shen.app) (car V4024)) (and (pair? (cdr V4024)) (and (pair? (cdr (cdr V4024))) (and (pair? (cdr (cdr (cdr V4024)))) (null? (cdr (cdr (cdr (cdr V4024)))))))))) (cons (quote shen.app) (cons (car (cdr V4024)) (cons (kl:shen.insert-l V4023 (car (cdr (cdr V4024)))) (cdr (cdr (cdr V4024))))))) (#t (kl:shen.f_error (quote shen.insert-l))))) (quote shen.insert-l))
(begin (register-function-arity (quote shen.factor-cn) 1) (define (kl:shen.factor-cn V4026) (cond ((and (pair? V4026) (and (eq? (quote cn) (car V4026)) (and (pair? (cdr V4026)) (and (pair? (cdr (cdr V4026))) (and (pair? (car (cdr (cdr V4026)))) (and (eq? (quote cn) (car (car (cdr (cdr V4026))))) (and (pair? (cdr (car (cdr (cdr V4026))))) (and (pair? (cdr (cdr (car (cdr (cdr V4026)))))) (and (null? (cdr (cdr (cdr (car (cdr (cdr V4026))))))) (and (null? (cdr (cdr (cdr V4026)))) (and (string? (car (cdr V4026))) (string? (car (cdr (car (cdr (cdr V4026))))))))))))))))) (cons (quote cn) (cons (string-append (car (cdr V4026)) (car (cdr (car (cdr (cdr V4026)))))) (cdr (cdr (car (cdr (cdr V4026)))))))) (#t V4026))) (quote shen.factor-cn))
(begin (register-function-arity (quote shen.proc-nl) 1) (define (kl:shen.proc-nl V4028) (cond ((equal? "" V4028) "") ((and (assert-boolean (kl:shen.+string? V4028)) (and (equal? "~" (make-string 1 (string-ref V4028 0))) (and (assert-boolean (kl:shen.+string? (string-tail V4028 1))) (equal? "%" (make-string 1 (string-ref (string-tail V4028 1) 0)))))) (string-append (make-string 1 10) (kl:shen.proc-nl (string-tail (string-tail V4028 1) 1)))) ((assert-boolean (kl:shen.+string? V4028)) (string-append (make-string 1 (string-ref V4028 0)) (kl:shen.proc-nl (string-tail V4028 1)))) (#t (kl:shen.f_error (quote shen.proc-nl))))) (quote shen.proc-nl))
(begin (register-function-arity (quote shen.mkstr-r) 2) (define (kl:shen.mkstr-r V4031 V4032) (cond ((null? V4032) V4031) ((pair? V4032) (kl:shen.mkstr-r (cons (quote shen.insert) (cons (car V4032) (cons V4031 (quote ())))) (cdr V4032))) (#t (kl:shen.f_error (quote shen.mkstr-r))))) (quote shen.mkstr-r))
(begin (register-function-arity (quote shen.insert) 2) (define (kl:shen.insert V4035 V4036) (kl:shen.insert-h V4035 V4036 "")) (quote shen.insert))
(begin (register-function-arity (quote shen.insert-h) 3) (define (kl:shen.insert-h V4042 V4043 V4044) (cond ((equal? "" V4043) V4044) ((and (assert-boolean (kl:shen.+string? V4043)) (and (equal? "~" (make-string 1 (string-ref V4043 0))) (and (assert-boolean (kl:shen.+string? (string-tail V4043 1))) (equal? "A" (make-string 1 (string-ref (string-tail V4043 1) 0)))))) (string-append V4044 (kl:shen.app V4042 (string-tail (string-tail V4043 1) 1) (quote shen.a)))) ((and (assert-boolean (kl:shen.+string? V4043)) (and (equal? "~" (make-string 1 (string-ref V4043 0))) (and (assert-boolean (kl:shen.+string? (string-tail V4043 1))) (equal? "R" (make-string 1 (string-ref (string-tail V4043 1) 0)))))) (string-append V4044 (kl:shen.app V4042 (string-tail (string-tail V4043 1) 1) (quote shen.r)))) ((and (assert-boolean (kl:shen.+string? V4043)) (and (equal? "~" (make-string 1 (string-ref V4043 0))) (and (assert-boolean (kl:shen.+string? (string-tail V4043 1))) (equal? "S" (make-string 1 (string-ref (string-tail V4043 1) 0)))))) (string-append V4044 (kl:shen.app V4042 (string-tail (string-tail V4043 1) 1) (quote shen.s)))) ((assert-boolean (kl:shen.+string? V4043)) (kl:shen.insert-h V4042 (string-tail V4043 1) (string-append V4044 (make-string 1 (string-ref V4043 0))))) (#t (kl:shen.f_error (quote shen.insert-h))))) (quote shen.insert-h))
(begin (register-function-arity (quote shen.app) 3) (define (kl:shen.app V4048 V4049 V4050) (string-append (kl:shen.arg->str V4048 V4050) V4049)) (quote shen.app))
(begin (register-function-arity (quote shen.arg->str) 2) (define (kl:shen.arg->str V4058 V4059) (cond ((kl:= V4058 (kl:fail)) "...") ((assert-boolean (kl:shen.list? V4058)) (kl:shen.list->str V4058 V4059)) ((string? V4058) (kl:shen.str->str V4058 V4059)) ((vector? V4058) (kl:shen.vector->str V4058 V4059)) (#t (kl:shen.atom->str V4058)))) (quote shen.arg->str))
(begin (register-function-arity (quote shen.list->str) 2) (define (kl:shen.list->str V4062 V4063) (cond ((eq? (quote shen.r) V4063) (kl:_waspvm_at_s "(" (kl:_waspvm_at_s (kl:shen.iter-list V4062 (quote shen.r) (kl:shen.maxseq)) ")"))) (#t (kl:_waspvm_at_s "[" (kl:_waspvm_at_s (kl:shen.iter-list V4062 V4063 (kl:shen.maxseq)) "]"))))) (quote shen.list->str))
(begin (register-function-arity (quote shen.maxseq) 0) (define (kl:shen.maxseq) (kl:value (quote *maximum-print-sequence-size*))) (quote shen.maxseq))
(begin (register-function-arity (quote shen.iter-list) 3) (define (kl:shen.iter-list V4077 V4078 V4079) (cond ((null? V4077) "") ((kl:= 0 V4079) "... etc") ((and (pair? V4077) (null? (cdr V4077))) (kl:shen.arg->str (car V4077) V4078)) ((pair? V4077) (kl:_waspvm_at_s (kl:shen.arg->str (car V4077) V4078) (kl:_waspvm_at_s " " (kl:shen.iter-list (cdr V4077) V4078 (- V4079 1))))) (#t (kl:_waspvm_at_s "|" (kl:_waspvm_at_s " " (kl:shen.arg->str V4077 V4078)))))) (quote shen.iter-list))
(begin (register-function-arity (quote shen.str->str) 2) (define (kl:shen.str->str V4086 V4087) (cond ((eq? (quote shen.a) V4087) V4086) (#t (kl:_waspvm_at_s (make-string 1 34) (kl:_waspvm_at_s V4086 (make-string 1 34)))))) (quote shen.str->str))
(begin (register-function-arity (quote shen.vector->str) 2) (define (kl:shen.vector->str V4090 V4091) (if (assert-boolean (kl:shen.print-vector? V4090)) ((kl:function (vector-ref V4090 0)) V4090) (if (assert-boolean (kl:vector? V4090)) (kl:_waspvm_at_s "<" (kl:_waspvm_at_s (kl:shen.iter-vector V4090 1 V4091 (kl:shen.maxseq)) ">")) (kl:_waspvm_at_s "<" (kl:_waspvm_at_s "<" (kl:_waspvm_at_s (kl:shen.iter-vector V4090 0 V4091 (kl:shen.maxseq)) ">>")))))) (quote shen.vector->str))
(begin (register-function-arity (quote shen.print-vector?) 1) (define (kl:shen.print-vector? V4093) (let ((Zero (vector-ref V4093 0))) (if (eq? Zero (quote shen.tuple)) #t (if (eq? Zero (quote shen.pvar)) #t (if (eq? Zero (quote shen.dictionary)) #t (if (kl:not (number? Zero)) (kl:shen.fbound? Zero) #f)))))) (quote shen.print-vector?))
(begin (register-function-arity (quote shen.fbound?) 1) (define (kl:shen.fbound? V4095) (guard (lambda (E) #f) (begin (kl:shen.lookup-func V4095) #t))) (quote shen.fbound?))
(begin (register-function-arity (quote shen.tuple) 1) (define (kl:shen.tuple V4097) (string-append "(@p " (kl:shen.app (vector-ref V4097 1) (string-append " " (kl:shen.app (vector-ref V4097 2) ")" (quote shen.s))) (quote shen.s)))) (quote shen.tuple))
(begin (register-function-arity (quote shen.dictionary) 1) (define (kl:shen.dictionary V4099) "(dict ...)") (quote shen.dictionary))
(begin (register-function-arity (quote shen.iter-vector) 4) (define (kl:shen.iter-vector V4110 V4111 V4112 V4113) (cond ((kl:= 0 V4113) "... etc") (#t (let ((Item (guard (lambda (E) (quote shen.out-of-bounds)) (vector-ref V4110 V4111)))) (let ((Next (guard (lambda (E) (quote shen.out-of-bounds)) (vector-ref V4110 (+ V4111 1))))) (if (eq? Item (quote shen.out-of-bounds)) "" (if (eq? Next (quote shen.out-of-bounds)) (kl:shen.arg->str Item V4112) (kl:_waspvm_at_s (kl:shen.arg->str Item V4112) (kl:_waspvm_at_s " " (kl:shen.iter-vector V4110 (+ V4111 1) V4112 (- V4113 1))))))))))) (quote shen.iter-vector))
(begin (register-function-arity (quote shen.atom->str) 1) (define (kl:shen.atom->str V4115) (guard (lambda (E) (kl:shen.funexstring)) (kl:str V4115))) (quote shen.atom->str))
(begin (register-function-arity (quote shen.funexstring) 0) (define (kl:shen.funexstring) (kl:_waspvm_at_s "\016" (kl:_waspvm_at_s "f" (kl:_waspvm_at_s "u" (kl:_waspvm_at_s "n" (kl:_waspvm_at_s "e" (kl:_waspvm_at_s (kl:shen.arg->str (kl:gensym (kl:intern "x")) (quote shen.a)) "\017"))))))) (quote shen.funexstring))
(begin (register-function-arity (quote shen.list?) 1) (define (kl:shen.list? V4117) (or (kl:empty? V4117) (pair? V4117))) (quote shen.list?))
