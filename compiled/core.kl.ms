"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.shen->kl) 2) (define (kl:shen.shen->kl V1191 V1192) (kl:compile (lambda (X) (kl:shen.<define> X)) (cons V1191 V1192) (lambda (X) (kl:shen.shen-syntax-error V1191 X)))) (quote shen.shen->kl))
(begin (register-function-arity (quote shen.shen-syntax-error) 2) (define (kl:shen.shen-syntax-error V1199 V1200) (cond ((pair? V1200) (simple-error (string-append "syntax error in " (kl:shen.app V1199 (string-append " here:\n\n " (kl:shen.app (kl:shen.next-50 50 (car V1200)) "\n" (quote shen.a))) (quote shen.a))))) (#t (simple-error (string-append "syntax error in " (kl:shen.app V1199 "\n" (quote shen.a))))))) (quote shen.shen-syntax-error))
(begin (register-function-arity (quote shen.<define>) 1) (define (kl:shen.<define> V1202) (let ((YaccParse (let ((Parse_shen.<name> (kl:shen.<name> V1202))) (if (kl:not (kl:= (kl:fail) Parse_shen.<name>)) (let ((Parse_shen.<signature> (kl:shen.<signature> Parse_shen.<name>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature>)) (let ((Parse_shen.<rules> (kl:shen.<rules> Parse_shen.<signature>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rules>)) (kl:shen.pair (car Parse_shen.<rules>) (kl:shen.compile_to_machine_code (kl:shen.hdtl Parse_shen.<name>) (kl:shen.hdtl Parse_shen.<rules>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<name> (kl:shen.<name> V1202))) (if (kl:not (kl:= (kl:fail) Parse_shen.<name>)) (let ((Parse_shen.<rules> (kl:shen.<rules> Parse_shen.<name>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rules>)) (kl:shen.pair (car Parse_shen.<rules>) (kl:shen.compile_to_machine_code (kl:shen.hdtl Parse_shen.<name>) (kl:shen.hdtl Parse_shen.<rules>))) (kl:fail))) (kl:fail))) YaccParse))) (quote shen.<define>))
(begin (register-function-arity (quote shen.<name>) 1) (define (kl:shen.<name> V1204) (if (pair? (car V1204)) (let ((Parse_X (kl:shen.hdhd V1204))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1204) (kl:shen.hdtl V1204))) (if (and (kl:symbol? Parse_X) (kl:not (kl:shen.sysfunc? Parse_X))) Parse_X (simple-error (kl:shen.app Parse_X " is not a legitimate function name.\n" (quote shen.a)))))) (kl:fail))) (quote shen.<name>))
(begin (register-function-arity (quote shen.sysfunc?) 1) (define (kl:shen.sysfunc? V1206) (kl:element? V1206 (kl:get (kl:intern "shen") (quote shen.external-symbols) (kl:value (quote *property-vector*))))) (quote shen.sysfunc?))
(begin (register-function-arity (quote shen.<signature>) 1) (define (kl:shen.<signature> V1210) (if (and (pair? (car V1210)) (eq? (quote {) (kl:shen.hdhd V1210))) (let ((NewStream1207 (kl:shen.pair (kl:shen.tlhd V1210) (kl:shen.hdtl V1210)))) (let ((Parse_shen.<signature-help> (kl:shen.<signature-help> NewStream1207))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature-help>)) (if (and (pair? (car Parse_shen.<signature-help>)) (eq? (quote }) (kl:shen.hdhd Parse_shen.<signature-help>))) (let ((NewStream1208 (kl:shen.pair (kl:shen.tlhd Parse_shen.<signature-help>) (kl:shen.hdtl Parse_shen.<signature-help>)))) (kl:shen.pair (car NewStream1208) (kl:shen.demodulate (kl:shen.curry-type (kl:shen.hdtl Parse_shen.<signature-help>))))) (kl:fail)) (kl:fail)))) (kl:fail))) (quote shen.<signature>))
(begin (register-function-arity (quote shen.curry-type) 1) (define (kl:shen.curry-type V1212) (cond ((and (pair? V1212) (and (pair? (cdr V1212)) (and (eq? (quote -->) (car (cdr V1212))) (and (pair? (cdr (cdr V1212))) (and (pair? (cdr (cdr (cdr V1212)))) (eq? (quote -->) (car (cdr (cdr (cdr V1212)))))))))) (kl:shen.curry-type (cons (car V1212) (cons (quote -->) (cons (cdr (cdr V1212)) (quote ())))))) ((and (pair? V1212) (and (pair? (cdr V1212)) (and (eq? (quote *) (car (cdr V1212))) (and (pair? (cdr (cdr V1212))) (and (pair? (cdr (cdr (cdr V1212)))) (eq? (quote *) (car (cdr (cdr (cdr V1212)))))))))) (kl:shen.curry-type (cons (car V1212) (cons (quote *) (cons (cdr (cdr V1212)) (quote ())))))) ((pair? V1212) (kl:map (lambda (Z) (kl:shen.curry-type Z)) V1212)) (#t V1212))) (quote shen.curry-type))
(begin (register-function-arity (quote shen.<signature-help>) 1) (define (kl:shen.<signature-help> V1214) (let ((YaccParse (if (pair? (car V1214)) (let ((Parse_X (kl:shen.hdhd V1214))) (let ((Parse_shen.<signature-help> (kl:shen.<signature-help> (kl:shen.pair (kl:shen.tlhd V1214) (kl:shen.hdtl V1214))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature-help>)) (if (kl:not (kl:element? Parse_X (cons (quote {) (cons (quote }) (quote ()))))) (kl:shen.pair (car Parse_shen.<signature-help>) (cons Parse_X (kl:shen.hdtl Parse_shen.<signature-help>))) (kl:fail)) (kl:fail)))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1214))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<signature-help>))
(begin (register-function-arity (quote shen.<rules>) 1) (define (kl:shen.<rules> V1216) (let ((YaccParse (let ((Parse_shen.<rule> (kl:shen.<rule> V1216))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (let ((Parse_shen.<rules> (kl:shen.<rules> Parse_shen.<rule>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rules>)) (kl:shen.pair (car Parse_shen.<rules>) (cons (kl:shen.linearise (kl:shen.hdtl Parse_shen.<rule>)) (kl:shen.hdtl Parse_shen.<rules>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<rule> (kl:shen.<rule> V1216))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (kl:shen.pair (car Parse_shen.<rule>) (cons (kl:shen.linearise (kl:shen.hdtl Parse_shen.<rule>)) (quote ()))) (kl:fail))) YaccParse))) (quote shen.<rules>))
(begin (register-function-arity (quote shen.<rule>) 1) (define (kl:shen.<rule> V1224) (let ((YaccParse (let ((Parse_shen.<patterns> (kl:shen.<patterns> V1224))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote ->) (kl:shen.hdhd Parse_shen.<patterns>))) (let ((NewStream1217 (kl:shen.pair (kl:shen.tlhd Parse_shen.<patterns>) (kl:shen.hdtl Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> NewStream1217))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (if (and (pair? (car Parse_shen.<action>)) (eq? (quote where) (kl:shen.hdhd Parse_shen.<action>))) (let ((NewStream1218 (kl:shen.pair (kl:shen.tlhd Parse_shen.<action>) (kl:shen.hdtl Parse_shen.<action>)))) (let ((Parse_shen.<guard> (kl:shen.<guard> NewStream1218))) (if (kl:not (kl:= (kl:fail) Parse_shen.<guard>)) (kl:shen.pair (car Parse_shen.<guard>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (cons (quote where) (cons (kl:shen.hdtl Parse_shen.<guard>) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ())))) (quote ())))) (kl:fail)))) (kl:fail)) (kl:fail)))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<patterns> (kl:shen.<patterns> V1224))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote ->) (kl:shen.hdhd Parse_shen.<patterns>))) (let ((NewStream1219 (kl:shen.pair (kl:shen.tlhd Parse_shen.<patterns>) (kl:shen.hdtl Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> NewStream1219))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (kl:shen.pair (car Parse_shen.<action>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ())))) (kl:fail)))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<patterns> (kl:shen.<patterns> V1224))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote <-) (kl:shen.hdhd Parse_shen.<patterns>))) (let ((NewStream1220 (kl:shen.pair (kl:shen.tlhd Parse_shen.<patterns>) (kl:shen.hdtl Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> NewStream1220))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (if (and (pair? (car Parse_shen.<action>)) (eq? (quote where) (kl:shen.hdhd Parse_shen.<action>))) (let ((NewStream1221 (kl:shen.pair (kl:shen.tlhd Parse_shen.<action>) (kl:shen.hdtl Parse_shen.<action>)))) (let ((Parse_shen.<guard> (kl:shen.<guard> NewStream1221))) (if (kl:not (kl:= (kl:fail) Parse_shen.<guard>)) (kl:shen.pair (car Parse_shen.<guard>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (cons (quote where) (cons (kl:shen.hdtl Parse_shen.<guard>) (cons (cons (quote shen.choicepoint!) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ()))) (quote ())))) (quote ())))) (kl:fail)))) (kl:fail)) (kl:fail)))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<patterns> (kl:shen.<patterns> V1224))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote <-) (kl:shen.hdhd Parse_shen.<patterns>))) (let ((NewStream1222 (kl:shen.pair (kl:shen.tlhd Parse_shen.<patterns>) (kl:shen.hdtl Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> NewStream1222))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (kl:shen.pair (car Parse_shen.<action>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (cons (quote shen.choicepoint!) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ()))) (quote ())))) (kl:fail)))) (kl:fail)) (kl:fail))) YaccParse)) YaccParse)) YaccParse))) (quote shen.<rule>))
(begin (register-function-arity (quote shen.fail_if) 2) (define (kl:shen.fail_if V1227 V1228) (if (assert-boolean (V1227 V1228)) (kl:fail) V1228)) (quote shen.fail_if))
(begin (register-function-arity (quote shen.succeeds?) 1) (define (kl:shen.succeeds? V1234) (cond ((kl:= V1234 (kl:fail)) #f) (#t #t))) (quote shen.succeeds?))
(begin (register-function-arity (quote shen.<patterns>) 1) (define (kl:shen.<patterns> V1236) (let ((YaccParse (let ((Parse_shen.<pattern> (kl:shen.<pattern> V1236))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern>)) (let ((Parse_shen.<patterns> (kl:shen.<patterns> Parse_shen.<pattern>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (kl:shen.pair (car Parse_shen.<patterns>) (cons (kl:shen.hdtl Parse_shen.<pattern>) (kl:shen.hdtl Parse_shen.<patterns>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1236))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<patterns>))
(begin (register-function-arity (quote shen.<pattern>) 1) (define (kl:shen.<pattern> V1249) (let ((YaccParse (if (and (pair? (car V1249)) (pair? (kl:shen.hdhd V1249))) (if (and (pair? (car (kl:shen.pair (kl:shen.hdhd V1249) (kl:shen.hdtl V1249)))) (eq? (quote _waspvm_at_p) (kl:shen.hdhd (kl:shen.pair (kl:shen.hdhd V1249) (kl:shen.hdtl V1249))))) (let ((NewStream1238 (kl:shen.pair (kl:shen.tlhd (kl:shen.pair (kl:shen.hdhd V1249) (kl:shen.hdtl V1249))) (kl:shen.hdtl (kl:shen.pair (kl:shen.hdhd V1249) (kl:shen.hdtl V1249)))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> NewStream1238))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1249) (kl:shen.hdtl V1249))) (cons (quote _waspvm_at_p) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail)))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V1249)) (pair? (kl:shen.hdhd V1249))) (if (and (pair? (car (kl:shen.pair (kl:shen.hdhd V1249) (kl:shen.hdtl V1249)))) (eq? (quote cons) (kl:shen.hdhd (kl:shen.pair (kl:shen.hdhd V1249) (kl:shen.hdtl V1249))))) (let ((NewStream1240 (kl:shen.pair (kl:shen.tlhd (kl:shen.pair (kl:shen.hdhd V1249) (kl:shen.hdtl V1249))) (kl:shen.hdtl (kl:shen.pair (kl:shen.hdhd V1249) (kl:shen.hdtl V1249)))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> NewStream1240))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1249) (kl:shen.hdtl V1249))) (cons (quote cons) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail)))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V1249)) (pair? (kl:shen.hdhd V1249))) (if (and (pair? (car (kl:shen.pair (kl:shen.hdhd V1249) (kl:shen.hdtl V1249)))) (eq? (quote _waspvm_at_v) (kl:shen.hdhd (kl:shen.pair (kl:shen.hdhd V1249) (kl:shen.hdtl V1249))))) (let ((NewStream1242 (kl:shen.pair (kl:shen.tlhd (kl:shen.pair (kl:shen.hdhd V1249) (kl:shen.hdtl V1249))) (kl:shen.hdtl (kl:shen.pair (kl:shen.hdhd V1249) (kl:shen.hdtl V1249)))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> NewStream1242))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1249) (kl:shen.hdtl V1249))) (cons (quote _waspvm_at_v) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail)))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V1249)) (pair? (kl:shen.hdhd V1249))) (if (and (pair? (car (kl:shen.pair (kl:shen.hdhd V1249) (kl:shen.hdtl V1249)))) (eq? (quote _waspvm_at_s) (kl:shen.hdhd (kl:shen.pair (kl:shen.hdhd V1249) (kl:shen.hdtl V1249))))) (let ((NewStream1244 (kl:shen.pair (kl:shen.tlhd (kl:shen.pair (kl:shen.hdhd V1249) (kl:shen.hdtl V1249))) (kl:shen.hdtl (kl:shen.pair (kl:shen.hdhd V1249) (kl:shen.hdtl V1249)))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> NewStream1244))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1249) (kl:shen.hdtl V1249))) (cons (quote _waspvm_at_s) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail)))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V1249)) (pair? (kl:shen.hdhd V1249))) (if (and (pair? (car (kl:shen.pair (kl:shen.hdhd V1249) (kl:shen.hdtl V1249)))) (eq? (quote vector) (kl:shen.hdhd (kl:shen.pair (kl:shen.hdhd V1249) (kl:shen.hdtl V1249))))) (let ((NewStream1246 (kl:shen.pair (kl:shen.tlhd (kl:shen.pair (kl:shen.hdhd V1249) (kl:shen.hdtl V1249))) (kl:shen.hdtl (kl:shen.pair (kl:shen.hdhd V1249) (kl:shen.hdtl V1249)))))) (if (and (pair? (car NewStream1246)) (kl:= 0 (kl:shen.hdhd NewStream1246))) (let ((NewStream1247 (kl:shen.pair (kl:shen.tlhd NewStream1246) (kl:shen.hdtl NewStream1246)))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1249) (kl:shen.hdtl V1249))) (cons (quote vector) (cons 0 (quote ()))))) (kl:fail))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (pair? (car V1249)) (let ((Parse_X (kl:shen.hdhd V1249))) (if (pair? Parse_X) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1249) (kl:shen.hdtl V1249))) (kl:shen.constructor-error Parse_X)) (kl:fail))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<simple_pattern> (kl:shen.<simple_pattern> V1249))) (if (kl:not (kl:= (kl:fail) Parse_shen.<simple_pattern>)) (kl:shen.pair (car Parse_shen.<simple_pattern>) (kl:shen.hdtl Parse_shen.<simple_pattern>)) (kl:fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse))) (quote shen.<pattern>))
(begin (register-function-arity (quote shen.constructor-error) 1) (define (kl:shen.constructor-error V1251) (simple-error (kl:shen.app V1251 " is not a legitimate constructor\n" (quote shen.a)))) (quote shen.constructor-error))
(begin (register-function-arity (quote shen.<simple_pattern>) 1) (define (kl:shen.<simple_pattern> V1253) (let ((YaccParse (if (pair? (car V1253)) (let ((Parse_X (kl:shen.hdhd V1253))) (if (eq? Parse_X (quote _)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1253) (kl:shen.hdtl V1253))) (kl:gensym (quote Parse_Y))) (kl:fail))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (if (pair? (car V1253)) (let ((Parse_X (kl:shen.hdhd V1253))) (if (kl:not (kl:element? Parse_X (cons (quote ->) (cons (quote <-) (quote ()))))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1253) (kl:shen.hdtl V1253))) Parse_X) (kl:fail))) (kl:fail)) YaccParse))) (quote shen.<simple_pattern>))
(begin (register-function-arity (quote shen.<pattern1>) 1) (define (kl:shen.<pattern1> V1255) (let ((Parse_shen.<pattern> (kl:shen.<pattern> V1255))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern>)) (kl:shen.pair (car Parse_shen.<pattern>) (kl:shen.hdtl Parse_shen.<pattern>)) (kl:fail)))) (quote shen.<pattern1>))
(begin (register-function-arity (quote shen.<pattern2>) 1) (define (kl:shen.<pattern2> V1257) (let ((Parse_shen.<pattern> (kl:shen.<pattern> V1257))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern>)) (kl:shen.pair (car Parse_shen.<pattern>) (kl:shen.hdtl Parse_shen.<pattern>)) (kl:fail)))) (quote shen.<pattern2>))
(begin (register-function-arity (quote shen.<action>) 1) (define (kl:shen.<action> V1259) (if (pair? (car V1259)) (let ((Parse_X (kl:shen.hdhd V1259))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1259) (kl:shen.hdtl V1259))) Parse_X)) (kl:fail))) (quote shen.<action>))
(begin (register-function-arity (quote shen.<guard>) 1) (define (kl:shen.<guard> V1261) (if (pair? (car V1261)) (let ((Parse_X (kl:shen.hdhd V1261))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1261) (kl:shen.hdtl V1261))) Parse_X)) (kl:fail))) (quote shen.<guard>))
(begin (register-function-arity (quote shen.compile_to_machine_code) 2) (define (kl:shen.compile_to_machine_code V1264 V1265) (let ((Lambda+ (kl:shen.compile_to_lambda+ V1264 V1265))) (let ((KL (kl:shen.compile_to_kl V1264 Lambda+))) (let ((Record (kl:shen.record-source V1264 KL))) KL)))) (quote shen.compile_to_machine_code))
(begin (register-function-arity (quote shen.record-source) 2) (define (kl:shen.record-source V1270 V1271) (cond ((assert-boolean (kl:value (quote shen.*installing-kl*))) (quote shen.skip)) (#t (kl:put V1270 (quote shen.source) V1271 (kl:value (quote *property-vector*)))))) (quote shen.record-source))
(begin (register-function-arity (quote shen.compile_to_lambda+) 2) (define (kl:shen.compile_to_lambda+ V1274 V1275) (let ((Arity (kl:shen.aritycheck V1274 V1275))) (let ((UpDateSymbolTable (kl:shen.update-symbol-table V1274 Arity))) (let ((Free (kl:shen.for-each (lambda (Rule) (kl:shen.free_variable_check V1274 Rule)) V1275))) (let ((Variables (kl:shen.parameters Arity))) (let ((Strip (kl:map (lambda (X) (kl:shen.strip-protect X)) V1275))) (let ((Abstractions (kl:map (lambda (X) (kl:shen.abstract_rule X)) Strip))) (let ((Applications (kl:map (lambda (X) (kl:shen.application_build Variables X)) Abstractions))) (cons Variables (cons Applications (quote ()))))))))))) (quote shen.compile_to_lambda+))
(begin (register-function-arity (quote shen.update-symbol-table) 2) (define (kl:shen.update-symbol-table V1278 V1279) (cond ((kl:= 0 V1279) (quote shen.skip)) (#t (kl:put V1278 (quote shen.lambda-form) (kl:eval-kl (kl:shen.lambda-form V1278 V1279)) (kl:value (quote *property-vector*)))))) (quote shen.update-symbol-table))
(begin (register-function-arity (quote shen.free_variable_check) 2) (define (kl:shen.free_variable_check V1282 V1283) (cond ((and (pair? V1283) (and (pair? (cdr V1283)) (null? (cdr (cdr V1283))))) (let ((Bound (kl:shen.extract_vars (car V1283)))) (let ((Free (kl:shen.extract_free_vars Bound (car (cdr V1283))))) (kl:shen.free_variable_warnings V1282 Free)))) (#t (kl:shen.f_error (quote shen.free_variable_check))))) (quote shen.free_variable_check))
(begin (register-function-arity (quote shen.extract_vars) 1) (define (kl:shen.extract_vars V1285) (cond ((kl:variable? V1285) (cons V1285 (quote ()))) ((pair? V1285) (kl:union (kl:shen.extract_vars (car V1285)) (kl:shen.extract_vars (cdr V1285)))) (#t (quote ())))) (quote shen.extract_vars))
(begin (register-function-arity (quote shen.extract_free_vars) 2) (define (kl:shen.extract_free_vars V1297 V1298) (cond ((and (pair? V1298) (and (pair? (cdr V1298)) (and (null? (cdr (cdr V1298))) (eq? (car V1298) (quote protect))))) (quote ())) ((and (kl:variable? V1298) (kl:not (kl:element? V1298 V1297))) (cons V1298 (quote ()))) ((and (pair? V1298) (and (eq? (quote lambda) (car V1298)) (and (pair? (cdr V1298)) (and (pair? (cdr (cdr V1298))) (null? (cdr (cdr (cdr V1298)))))))) (kl:shen.extract_free_vars (cons (car (cdr V1298)) V1297) (car (cdr (cdr V1298))))) ((and (pair? V1298) (and (eq? (quote let) (car V1298)) (and (pair? (cdr V1298)) (and (pair? (cdr (cdr V1298))) (and (pair? (cdr (cdr (cdr V1298)))) (null? (cdr (cdr (cdr (cdr V1298)))))))))) (kl:union (kl:shen.extract_free_vars V1297 (car (cdr (cdr V1298)))) (kl:shen.extract_free_vars (cons (car (cdr V1298)) V1297) (car (cdr (cdr (cdr V1298))))))) ((pair? V1298) (kl:union (kl:shen.extract_free_vars V1297 (car V1298)) (kl:shen.extract_free_vars V1297 (cdr V1298)))) (#t (quote ())))) (quote shen.extract_free_vars))
(begin (register-function-arity (quote shen.free_variable_warnings) 2) (define (kl:shen.free_variable_warnings V1303 V1304) (cond ((null? V1304) (quote _)) (#t (simple-error (string-append "error: the following variables are free in " (kl:shen.app V1303 (string-append ": " (kl:shen.app (kl:shen.list_variables V1304) "" (quote shen.a))) (quote shen.a))))))) (quote shen.free_variable_warnings))
(begin (register-function-arity (quote shen.list_variables) 1) (define (kl:shen.list_variables V1306) (cond ((and (pair? V1306) (null? (cdr V1306))) (string-append (kl:str (car V1306)) ".")) ((pair? V1306) (string-append (kl:str (car V1306)) (string-append ", " (kl:shen.list_variables (cdr V1306))))) (#t (kl:shen.f_error (quote shen.list_variables))))) (quote shen.list_variables))
(begin (register-function-arity (quote shen.strip-protect) 1) (define (kl:shen.strip-protect V1308) (cond ((and (pair? V1308) (and (pair? (cdr V1308)) (and (null? (cdr (cdr V1308))) (eq? (car V1308) (quote protect))))) (kl:shen.strip-protect (car (cdr V1308)))) ((pair? V1308) (kl:map (lambda (Z) (kl:shen.strip-protect Z)) V1308)) (#t V1308))) (quote shen.strip-protect))
(begin (register-function-arity (quote shen.linearise) 1) (define (kl:shen.linearise V1310) (cond ((and (pair? V1310) (and (pair? (cdr V1310)) (null? (cdr (cdr V1310))))) (kl:shen.linearise_help (kl:shen.flatten (car V1310)) (car V1310) (car (cdr V1310)))) (#t (kl:shen.f_error (quote shen.linearise))))) (quote shen.linearise))
(begin (register-function-arity (quote shen.flatten) 1) (define (kl:shen.flatten V1312) (cond ((null? V1312) (quote ())) ((pair? V1312) (kl:append (kl:shen.flatten (car V1312)) (kl:shen.flatten (cdr V1312)))) (#t (cons V1312 (quote ()))))) (quote shen.flatten))
(begin (register-function-arity (quote shen.linearise_help) 3) (define (kl:shen.linearise_help V1316 V1317 V1318) (cond ((null? V1316) (cons V1317 (cons V1318 (quote ())))) ((pair? V1316) (if (and (kl:variable? (car V1316)) (kl:element? (car V1316) (cdr V1316))) (let ((Var (kl:gensym (car V1316)))) (let ((NewAction (cons (quote where) (cons (cons (quote =) (cons (car V1316) (cons Var (quote ())))) (cons V1318 (quote ())))))) (let ((NewPatts (kl:shen.linearise_X (car V1316) Var V1317))) (kl:shen.linearise_help (cdr V1316) NewPatts NewAction)))) (kl:shen.linearise_help (cdr V1316) V1317 V1318))) (#t (kl:shen.f_error (quote shen.linearise_help))))) (quote shen.linearise_help))
(begin (register-function-arity (quote shen.linearise_X) 3) (define (kl:shen.linearise_X V1331 V1332 V1333) (cond ((kl:= V1333 V1331) V1332) ((pair? V1333) (let ((L (kl:shen.linearise_X V1331 V1332 (car V1333)))) (if (kl:= L (car V1333)) (cons (car V1333) (kl:shen.linearise_X V1331 V1332 (cdr V1333))) (cons L (cdr V1333))))) (#t V1333))) (quote shen.linearise_X))
(begin (register-function-arity (quote shen.aritycheck) 2) (define (kl:shen.aritycheck V1336 V1337) (cond ((and (pair? V1337) (and (pair? (car V1337)) (and (pair? (cdr (car V1337))) (and (null? (cdr (cdr (car V1337)))) (null? (cdr V1337)))))) (begin (kl:shen.aritycheck-action (car (cdr (car V1337)))) (kl:shen.aritycheck-name V1336 (kl:arity V1336) (kl:length (car (car V1337)))))) ((and (pair? V1337) (and (pair? (car V1337)) (and (pair? (cdr (car V1337))) (and (null? (cdr (cdr (car V1337)))) (and (pair? (cdr V1337)) (and (pair? (car (cdr V1337))) (and (pair? (cdr (car (cdr V1337)))) (null? (cdr (cdr (car (cdr V1337)))))))))))) (if (kl:= (kl:length (car (car V1337))) (kl:length (car (car (cdr V1337))))) (begin (kl:shen.aritycheck-action (car (cdr (car V1337)))) (kl:shen.aritycheck V1336 (cdr V1337))) (simple-error (string-append "arity error in " (kl:shen.app V1336 "\n" (quote shen.a)))))) (#t (kl:shen.f_error (quote shen.aritycheck))))) (quote shen.aritycheck))
(begin (register-function-arity (quote shen.aritycheck-name) 3) (define (kl:shen.aritycheck-name V1350 V1351 V1352) (cond ((kl:= -1 V1351) V1352) ((kl:= V1352 V1351) V1352) (#t (begin (kl:shen.prhush (string-append "\nwarning: changing the arity of " (kl:shen.app V1350 " can cause errors.\n" (quote shen.a))) (kl:stoutput)) V1352)))) (quote shen.aritycheck-name))
(begin (register-function-arity (quote shen.aritycheck-action) 1) (define (kl:shen.aritycheck-action V1358) (cond ((pair? V1358) (begin (kl:shen.aah (car V1358) (cdr V1358)) (kl:shen.for-each (lambda (Y) (kl:shen.aritycheck-action Y)) V1358))) (#t (quote shen.skip)))) (quote shen.aritycheck-action))
(begin (register-function-arity (quote shen.aah) 2) (define (kl:shen.aah V1361 V1362) (let ((Arity (kl:arity V1361))) (let ((Len (kl:length V1362))) (if (and (> Arity -1) (> Len Arity)) (kl:shen.prhush (string-append "warning: " (kl:shen.app V1361 (string-append " might not like " (kl:shen.app Len (string-append " argument" (kl:shen.app (if (> Len 1) "s" "") ".\n" (quote shen.a))) (quote shen.a))) (quote shen.a))) (kl:stoutput)) (quote shen.skip))))) (quote shen.aah))
(begin (register-function-arity (quote shen.abstract_rule) 1) (define (kl:shen.abstract_rule V1364) (cond ((and (pair? V1364) (and (pair? (cdr V1364)) (null? (cdr (cdr V1364))))) (kl:shen.abstraction_build (car V1364) (car (cdr V1364)))) (#t (kl:shen.f_error (quote shen.abstract_rule))))) (quote shen.abstract_rule))
(begin (register-function-arity (quote shen.abstraction_build) 2) (define (kl:shen.abstraction_build V1367 V1368) (cond ((null? V1367) V1368) ((pair? V1367) (cons (quote /.) (cons (car V1367) (cons (kl:shen.abstraction_build (cdr V1367) V1368) (quote ()))))) (#t (kl:shen.f_error (quote shen.abstraction_build))))) (quote shen.abstraction_build))
(begin (register-function-arity (quote shen.parameters) 1) (define (kl:shen.parameters V1370) (cond ((kl:= 0 V1370) (quote ())) (#t (cons (kl:gensym (quote V)) (kl:shen.parameters (- V1370 1)))))) (quote shen.parameters))
(begin (register-function-arity (quote shen.application_build) 2) (define (kl:shen.application_build V1373 V1374) (cond ((null? V1373) V1374) ((pair? V1373) (kl:shen.application_build (cdr V1373) (cons V1374 (cons (car V1373) (quote ()))))) (#t (kl:shen.f_error (quote shen.application_build))))) (quote shen.application_build))
(begin (register-function-arity (quote shen.compile_to_kl) 2) (define (kl:shen.compile_to_kl V1377 V1378) (cond ((and (pair? V1378) (and (pair? (cdr V1378)) (null? (cdr (cdr V1378))))) (let ((Arity (kl:shen.store-arity V1377 (kl:length (car V1378))))) (let ((Reduce (kl:map (lambda (X) (kl:shen.reduce X)) (car (cdr V1378))))) (let ((CondExpression (kl:shen.cond-expression V1377 (car V1378) Reduce))) (let ((TypeTable (if (assert-boolean (kl:value (quote shen.*optimise*))) (kl:shen.typextable (kl:shen.get-type V1377) (car V1378)) (quote shen.skip)))) (let ((TypedCondExpression (if (assert-boolean (kl:value (quote shen.*optimise*))) (kl:shen.assign-types (car V1378) TypeTable CondExpression) CondExpression))) (cons (quote defun) (cons V1377 (cons (car V1378) (cons TypedCondExpression (quote ()))))))))))) (#t (kl:shen.f_error (quote shen.compile_to_kl))))) (quote shen.compile_to_kl))
(begin (register-function-arity (quote shen.get-type) 1) (define (kl:shen.get-type V1384) (cond ((pair? V1384) (quote shen.skip)) (#t (let ((FType (kl:assoc V1384 (kl:value (quote shen.*signedfuncs*))))) (if (kl:empty? FType) (quote shen.skip) (cdr FType)))))) (quote shen.get-type))
(begin (register-function-arity (quote shen.typextable) 2) (define (kl:shen.typextable V1395 V1396) (cond ((and (pair? V1395) (and (pair? (cdr V1395)) (and (eq? (quote -->) (car (cdr V1395))) (and (pair? (cdr (cdr V1395))) (and (null? (cdr (cdr (cdr V1395)))) (pair? V1396)))))) (if (kl:variable? (car V1395)) (kl:shen.typextable (car (cdr (cdr V1395))) (cdr V1396)) (cons (cons (car V1396) (car V1395)) (kl:shen.typextable (car (cdr (cdr V1395))) (cdr V1396))))) (#t (quote ())))) (quote shen.typextable))
(begin (register-function-arity (quote shen.assign-types) 3) (define (kl:shen.assign-types V1400 V1401 V1402) (cond ((and (pair? V1402) (and (eq? (quote let) (car V1402)) (and (pair? (cdr V1402)) (and (pair? (cdr (cdr V1402))) (and (pair? (cdr (cdr (cdr V1402)))) (null? (cdr (cdr (cdr (cdr V1402)))))))))) (cons (quote let) (cons (car (cdr V1402)) (cons (kl:shen.assign-types V1400 V1401 (car (cdr (cdr V1402)))) (cons (kl:shen.assign-types (cons (car (cdr V1402)) V1400) V1401 (car (cdr (cdr (cdr V1402))))) (quote ())))))) ((and (pair? V1402) (and (eq? (quote lambda) (car V1402)) (and (pair? (cdr V1402)) (and (pair? (cdr (cdr V1402))) (null? (cdr (cdr (cdr V1402)))))))) (cons (quote lambda) (cons (car (cdr V1402)) (cons (kl:shen.assign-types (cons (car (cdr V1402)) V1400) V1401 (car (cdr (cdr V1402)))) (quote ()))))) ((and (pair? V1402) (eq? (quote cond) (car V1402))) (cons (quote cond) (kl:map (lambda (Y) (cons (kl:shen.assign-types V1400 V1401 (car Y)) (cons (kl:shen.assign-types V1400 V1401 (car (cdr Y))) (quote ())))) (cdr V1402)))) ((pair? V1402) (let ((NewTable (kl:shen.typextable (kl:shen.get-type (car V1402)) (cdr V1402)))) (cons (car V1402) (kl:map (lambda (Y) (kl:shen.assign-types V1400 (kl:append V1401 NewTable) Y)) (cdr V1402))))) (#t (let ((AtomType (kl:assoc V1402 V1401))) (if (pair? AtomType) (cons (quote type) (cons V1402 (cons (cdr AtomType) (quote ())))) (if (kl:element? V1402 V1400) V1402 (kl:shen.atom-type V1402))))))) (quote shen.assign-types))
(begin (register-function-arity (quote shen.atom-type) 1) (define (kl:shen.atom-type V1404) (if (string? V1404) (cons (quote type) (cons V1404 (cons (quote string) (quote ())))) (if (number? V1404) (cons (quote type) (cons V1404 (cons (quote number) (quote ())))) (if (kl:boolean? V1404) (cons (quote type) (cons V1404 (cons (quote boolean) (quote ())))) (if (kl:symbol? V1404) (cons (quote type) (cons V1404 (cons (quote symbol) (quote ())))) V1404))))) (quote shen.atom-type))
(begin (register-function-arity (quote shen.store-arity) 2) (define (kl:shen.store-arity V1409 V1410) (cond ((assert-boolean (kl:value (quote shen.*installing-kl*))) (quote shen.skip)) (#t (kl:put V1409 (quote arity) V1410 (kl:value (quote *property-vector*)))))) (quote shen.store-arity))
(begin (register-function-arity (quote shen.reduce) 1) (define (kl:shen.reduce V1412) (begin (kl:set (quote shen.*teststack*) (quote ())) (let ((Result (kl:shen.reduce_help V1412))) (cons (cons (quote :) (cons (quote shen.tests) (kl:reverse (kl:value (quote shen.*teststack*))))) (cons Result (quote ())))))) (quote shen.reduce))
(begin (register-function-arity (quote shen.reduce_help) 1) (define (kl:shen.reduce_help V1414) (cond ((and (pair? V1414) (and (pair? (car V1414)) (and (eq? (quote /.) (car (car V1414))) (and (pair? (cdr (car V1414))) (and (pair? (car (cdr (car V1414)))) (and (eq? (quote cons) (car (car (cdr (car V1414))))) (and (pair? (cdr (car (cdr (car V1414))))) (and (pair? (cdr (cdr (car (cdr (car V1414)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1414))))))) (and (pair? (cdr (cdr (car V1414)))) (and (null? (cdr (cdr (cdr (car V1414))))) (and (pair? (cdr V1414)) (null? (cdr (cdr V1414))))))))))))))) (begin (kl:shen.add_test (cons (quote cons?) (cdr V1414))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V1414))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V1414)))))) (cons (kl:shen.ebr (car (cdr V1414)) (car (cdr (car V1414))) (car (cdr (cdr (car V1414))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote hd) (cdr V1414)) (quote ()))) (cons (cons (quote tl) (cdr V1414)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V1414) (and (pair? (car V1414)) (and (eq? (quote /.) (car (car V1414))) (and (pair? (cdr (car V1414))) (and (pair? (car (cdr (car V1414)))) (and (eq? (quote _waspvm_at_p) (car (car (cdr (car V1414))))) (and (pair? (cdr (car (cdr (car V1414))))) (and (pair? (cdr (cdr (car (cdr (car V1414)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1414))))))) (and (pair? (cdr (cdr (car V1414)))) (and (null? (cdr (cdr (cdr (car V1414))))) (and (pair? (cdr V1414)) (null? (cdr (cdr V1414))))))))))))))) (begin (kl:shen.add_test (cons (quote tuple?) (cdr V1414))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V1414))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V1414)))))) (cons (kl:shen.ebr (car (cdr V1414)) (car (cdr (car V1414))) (car (cdr (cdr (car V1414))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote fst) (cdr V1414)) (quote ()))) (cons (cons (quote snd) (cdr V1414)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V1414) (and (pair? (car V1414)) (and (eq? (quote /.) (car (car V1414))) (and (pair? (cdr (car V1414))) (and (pair? (car (cdr (car V1414)))) (and (eq? (quote _waspvm_at_v) (car (car (cdr (car V1414))))) (and (pair? (cdr (car (cdr (car V1414))))) (and (pair? (cdr (cdr (car (cdr (car V1414)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1414))))))) (and (pair? (cdr (cdr (car V1414)))) (and (null? (cdr (cdr (cdr (car V1414))))) (and (pair? (cdr V1414)) (null? (cdr (cdr V1414))))))))))))))) (begin (kl:shen.add_test (cons (quote shen.+vector?) (cdr V1414))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V1414))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V1414)))))) (cons (kl:shen.ebr (car (cdr V1414)) (car (cdr (car V1414))) (car (cdr (cdr (car V1414))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote hdv) (cdr V1414)) (quote ()))) (cons (cons (quote tlv) (cdr V1414)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V1414) (and (pair? (car V1414)) (and (eq? (quote /.) (car (car V1414))) (and (pair? (cdr (car V1414))) (and (pair? (car (cdr (car V1414)))) (and (eq? (quote _waspvm_at_s) (car (car (cdr (car V1414))))) (and (pair? (cdr (car (cdr (car V1414))))) (and (pair? (cdr (cdr (car (cdr (car V1414)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1414))))))) (and (pair? (cdr (cdr (car V1414)))) (and (null? (cdr (cdr (cdr (car V1414))))) (and (pair? (cdr V1414)) (null? (cdr (cdr V1414))))))))))))))) (begin (kl:shen.add_test (cons (quote shen.+string?) (cdr V1414))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V1414))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V1414)))))) (cons (kl:shen.ebr (car (cdr V1414)) (car (cdr (car V1414))) (car (cdr (cdr (car V1414))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote pos) (cons (car (cdr V1414)) (cons 0 (quote ())))) (quote ()))) (cons (cons (quote tlstr) (cdr V1414)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V1414) (and (pair? (car V1414)) (and (eq? (quote /.) (car (car V1414))) (and (pair? (cdr (car V1414))) (and (pair? (cdr (cdr (car V1414)))) (and (null? (cdr (cdr (cdr (car V1414))))) (and (pair? (cdr V1414)) (and (null? (cdr (cdr V1414))) (kl:not (kl:variable? (car (cdr (car V1414))))))))))))) (begin (kl:shen.add_test (cons (quote =) (cons (car (cdr (car V1414))) (cdr V1414)))) (kl:shen.reduce_help (car (cdr (cdr (car V1414))))))) ((and (pair? V1414) (and (pair? (car V1414)) (and (eq? (quote /.) (car (car V1414))) (and (pair? (cdr (car V1414))) (and (pair? (cdr (cdr (car V1414)))) (and (null? (cdr (cdr (cdr (car V1414))))) (and (pair? (cdr V1414)) (null? (cdr (cdr V1414)))))))))) (kl:shen.reduce_help (kl:shen.ebr (car (cdr V1414)) (car (cdr (car V1414))) (car (cdr (cdr (car V1414))))))) ((and (pair? V1414) (and (eq? (quote where) (car V1414)) (and (pair? (cdr V1414)) (and (pair? (cdr (cdr V1414))) (null? (cdr (cdr (cdr V1414)))))))) (begin (kl:shen.add_test (car (cdr V1414))) (kl:shen.reduce_help (car (cdr (cdr V1414)))))) ((and (pair? V1414) (and (pair? (cdr V1414)) (null? (cdr (cdr V1414))))) (let ((Z (kl:shen.reduce_help (car V1414)))) (if (kl:= (car V1414) Z) V1414 (kl:shen.reduce_help (cons Z (cdr V1414)))))) (#t V1414))) (quote shen.reduce_help))
(begin (register-function-arity (quote shen.+string?) 1) (define (kl:shen.+string? V1416) (cond ((equal? "" V1416) #f) (#t (string? V1416)))) (quote shen.+string?))
(begin (register-function-arity (quote shen.+vector?) 1) (define (kl:shen.+vector? V1418) (and (vector? V1418) (> (vector-ref V1418 0) 0))) (quote shen.+vector?))
(begin (register-function-arity (quote shen.ebr) 3) (define (kl:shen.ebr V1432 V1433 V1434) (cond ((kl:= V1434 V1433) V1432) ((and (pair? V1434) (and (eq? (quote /.) (car V1434)) (and (pair? (cdr V1434)) (and (pair? (cdr (cdr V1434))) (and (null? (cdr (cdr (cdr V1434)))) (> (kl:occurrences V1433 (car (cdr V1434))) 0)))))) V1434) ((and (pair? V1434) (and (eq? (quote lambda) (car V1434)) (and (pair? (cdr V1434)) (and (pair? (cdr (cdr V1434))) (and (null? (cdr (cdr (cdr V1434)))) (> (kl:occurrences V1433 (car (cdr V1434))) 0)))))) V1434) ((and (pair? V1434) (and (eq? (quote let) (car V1434)) (and (pair? (cdr V1434)) (and (pair? (cdr (cdr V1434))) (and (pair? (cdr (cdr (cdr V1434)))) (and (null? (cdr (cdr (cdr (cdr V1434))))) (kl:= (car (cdr V1434)) V1433))))))) (cons (quote let) (cons (car (cdr V1434)) (cons (kl:shen.ebr V1432 (car (cdr V1434)) (car (cdr (cdr V1434)))) (cdr (cdr (cdr V1434))))))) ((pair? V1434) (cons (kl:shen.ebr V1432 V1433 (car V1434)) (kl:shen.ebr V1432 V1433 (cdr V1434)))) (#t V1434))) (quote shen.ebr))
(begin (register-function-arity (quote shen.add_test) 1) (define (kl:shen.add_test V1436) (kl:set (quote shen.*teststack*) (cons V1436 (kl:value (quote shen.*teststack*))))) (quote shen.add_test))
(begin (register-function-arity (quote shen.cond-expression) 3) (define (kl:shen.cond-expression V1440 V1441 V1442) (let ((Err (kl:shen.err-condition V1440))) (let ((Cases (kl:shen.case-form V1442 Err))) (let ((EncodeChoices (kl:shen.encode-choices Cases V1440))) (kl:shen.cond-form EncodeChoices))))) (quote shen.cond-expression))
(begin (register-function-arity (quote shen.cond-form) 1) (define (kl:shen.cond-form V1446) (cond ((and (pair? V1446) (and (pair? (car V1446)) (and (kl:= #t (car (car V1446))) (and (pair? (cdr (car V1446))) (null? (cdr (cdr (car V1446)))))))) (car (cdr (car V1446)))) (#t (cons (quote cond) V1446)))) (quote shen.cond-form))
(begin (register-function-arity (quote shen.encode-choices) 2) (define (kl:shen.encode-choices V1451 V1452) (cond ((null? V1451) (quote ())) ((and (pair? V1451) (and (pair? (car V1451)) (and (kl:= #t (car (car V1451))) (and (pair? (cdr (car V1451))) (and (pair? (car (cdr (car V1451)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V1451))))) (and (pair? (cdr (car (cdr (car V1451))))) (and (null? (cdr (cdr (car (cdr (car V1451)))))) (and (null? (cdr (cdr (car V1451)))) (null? (cdr V1451))))))))))) (cons (cons #t (cons (cons (quote let) (cons (quote Result) (cons (car (cdr (car (cdr (car V1451))))) (cons (cons (quote if) (cons (cons (quote =) (cons (quote Result) (cons (cons (quote fail) (quote ())) (quote ())))) (cons (if (assert-boolean (kl:value (quote shen.*installing-kl*))) (cons (quote shen.sys-error) (cons V1452 (quote ()))) (cons (quote shen.f_error) (cons V1452 (quote ())))) (cons (quote Result) (quote ()))))) (quote ()))))) (quote ()))) (quote ()))) ((and (pair? V1451) (and (pair? (car V1451)) (and (kl:= #t (car (car V1451))) (and (pair? (cdr (car V1451))) (and (pair? (car (cdr (car V1451)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V1451))))) (and (pair? (cdr (car (cdr (car V1451))))) (and (null? (cdr (cdr (car (cdr (car V1451)))))) (null? (cdr (cdr (car V1451)))))))))))) (cons (cons #t (cons (cons (quote let) (cons (quote Result) (cons (car (cdr (car (cdr (car V1451))))) (cons (cons (quote if) (cons (cons (quote =) (cons (quote Result) (cons (cons (quote fail) (quote ())) (quote ())))) (cons (kl:shen.cond-form (kl:shen.encode-choices (cdr V1451) V1452)) (cons (quote Result) (quote ()))))) (quote ()))))) (quote ()))) (quote ()))) ((and (pair? V1451) (and (pair? (car V1451)) (and (pair? (cdr (car V1451))) (and (pair? (car (cdr (car V1451)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V1451))))) (and (pair? (cdr (car (cdr (car V1451))))) (and (null? (cdr (cdr (car (cdr (car V1451)))))) (null? (cdr (cdr (car V1451))))))))))) (cons (cons #t (cons (cons (quote let) (cons (quote Freeze) (cons (cons (quote freeze) (cons (kl:shen.cond-form (kl:shen.encode-choices (cdr V1451) V1452)) (quote ()))) (cons (cons (quote if) (cons (car (car V1451)) (cons (cons (quote let) (cons (quote Result) (cons (car (cdr (car (cdr (car V1451))))) (cons (cons (quote if) (cons (cons (quote =) (cons (quote Result) (cons (cons (quote fail) (quote ())) (quote ())))) (cons (cons (quote thaw) (cons (quote Freeze) (quote ()))) (cons (quote Result) (quote ()))))) (quote ()))))) (cons (cons (quote thaw) (cons (quote Freeze) (quote ()))) (quote ()))))) (quote ()))))) (quote ()))) (quote ()))) ((and (pair? V1451) (and (pair? (car V1451)) (and (pair? (cdr (car V1451))) (null? (cdr (cdr (car V1451))))))) (cons (car V1451) (kl:shen.encode-choices (cdr V1451) V1452))) (#t (kl:shen.f_error (quote shen.encode-choices))))) (quote shen.encode-choices))
(begin (register-function-arity (quote shen.case-form) 2) (define (kl:shen.case-form V1459 V1460) (cond ((null? V1459) (cons V1460 (quote ()))) ((and (pair? V1459) (and (pair? (car V1459)) (and (pair? (car (car V1459))) (and (eq? (quote :) (car (car (car V1459)))) (and (pair? (cdr (car (car V1459)))) (and (eq? (quote shen.tests) (car (cdr (car (car V1459))))) (and (null? (cdr (cdr (car (car V1459))))) (and (pair? (cdr (car V1459))) (and (pair? (car (cdr (car V1459)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V1459))))) (and (pair? (cdr (car (cdr (car V1459))))) (and (null? (cdr (cdr (car (cdr (car V1459)))))) (null? (cdr (cdr (car V1459)))))))))))))))) (cons (cons #t (cdr (car V1459))) (kl:shen.case-form (cdr V1459) V1460))) ((and (pair? V1459) (and (pair? (car V1459)) (and (pair? (car (car V1459))) (and (eq? (quote :) (car (car (car V1459)))) (and (pair? (cdr (car (car V1459)))) (and (eq? (quote shen.tests) (car (cdr (car (car V1459))))) (and (null? (cdr (cdr (car (car V1459))))) (and (pair? (cdr (car V1459))) (null? (cdr (cdr (car V1459)))))))))))) (cons (cons #t (cdr (car V1459))) (quote ()))) ((and (pair? V1459) (and (pair? (car V1459)) (and (pair? (car (car V1459))) (and (eq? (quote :) (car (car (car V1459)))) (and (pair? (cdr (car (car V1459)))) (and (eq? (quote shen.tests) (car (cdr (car (car V1459))))) (and (pair? (cdr (car V1459))) (null? (cdr (cdr (car V1459))))))))))) (cons (cons (kl:shen.embed-and (cdr (cdr (car (car V1459))))) (cdr (car V1459))) (kl:shen.case-form (cdr V1459) V1460))) (#t (kl:shen.f_error (quote shen.case-form))))) (quote shen.case-form))
(begin (register-function-arity (quote shen.embed-and) 1) (define (kl:shen.embed-and V1462) (cond ((and (pair? V1462) (null? (cdr V1462))) (car V1462)) ((pair? V1462) (cons (quote and) (cons (car V1462) (cons (kl:shen.embed-and (cdr V1462)) (quote ()))))) (#t (kl:shen.f_error (quote shen.embed-and))))) (quote shen.embed-and))
(begin (register-function-arity (quote shen.err-condition) 1) (define (kl:shen.err-condition V1464) (cons #t (cons (cons (quote shen.f_error) (cons V1464 (quote ()))) (quote ())))) (quote shen.err-condition))
(begin (register-function-arity (quote shen.sys-error) 1) (define (kl:shen.sys-error V1466) (simple-error (string-append "system function " (kl:shen.app V1466 ": unexpected argument\n" (quote shen.a))))) (quote shen.sys-error))
