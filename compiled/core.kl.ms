(module "compiled/core.kl")
"Copyright (c) 2010-2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
(begin (register-function-arity (quote shen.shen->kl) 2) (define (kl:shen.shen->kl V1261 V1262) (kl:compile (lambda (X) (kl:shen.<define> X)) (cons V1261 V1262) (lambda (X) (kl:shen.shen-syntax-error V1261 X)))) (export shen.shen->kl) (quote shen.shen->kl))
(begin (register-function-arity (quote shen.shen-syntax-error) 2) (define (kl:shen.shen-syntax-error V1269 V1270) (cond ((pair? V1270) (simple-error (string-append "syntax error in " (kl:shen.app V1269 (string-append " here:\n\n " (kl:shen.app (kl:shen.next-50 50 (car V1270)) "\n" (quote shen.a))) (quote shen.a))))) (#t (simple-error (string-append "syntax error in " (kl:shen.app V1269 "\n" (quote shen.a))))))) (export shen.shen-syntax-error) (quote shen.shen-syntax-error))
(begin (register-function-arity (quote shen.<define>) 1) (define (kl:shen.<define> V1272) (let ((YaccParse (let ((Parse_shen.<name> (kl:shen.<name> V1272))) (if (kl:not (kl:= (kl:fail) Parse_shen.<name>)) (let ((Parse_shen.<signature> (kl:shen.<signature> Parse_shen.<name>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature>)) (let ((Parse_shen.<rules> (kl:shen.<rules> Parse_shen.<signature>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rules>)) (kl:shen.pair (car Parse_shen.<rules>) (kl:shen.compile_to_machine_code (kl:shen.hdtl Parse_shen.<name>) (kl:shen.hdtl Parse_shen.<rules>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<name> (kl:shen.<name> V1272))) (if (kl:not (kl:= (kl:fail) Parse_shen.<name>)) (let ((Parse_shen.<rules> (kl:shen.<rules> Parse_shen.<name>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rules>)) (kl:shen.pair (car Parse_shen.<rules>) (kl:shen.compile_to_machine_code (kl:shen.hdtl Parse_shen.<name>) (kl:shen.hdtl Parse_shen.<rules>))) (kl:fail))) (kl:fail))) YaccParse))) (export shen.<define>) (quote shen.<define>))
(begin (register-function-arity (quote shen.<name>) 1) (define (kl:shen.<name> V1274) (if (pair? (car V1274)) (let ((Parse_X (kl:shen.hdhd V1274))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1274) (kl:shen.hdtl V1274))) (if (and (kl:symbol? Parse_X) (kl:not (kl:shen.sysfunc? Parse_X))) Parse_X (simple-error (kl:shen.app Parse_X " is not a legitimate function name.\n" (quote shen.a)))))) (kl:fail))) (export shen.<name>) (quote shen.<name>))
(begin (register-function-arity (quote shen.sysfunc?) 1) (define (kl:shen.sysfunc? V1276) (kl:element? V1276 (kl:get (kl:intern "shen") (quote shen.external-symbols) (kl:value (quote *property-vector*))))) (export shen.sysfunc?) (quote shen.sysfunc?))
(begin (register-function-arity (quote shen.<signature>) 1) (define (kl:shen.<signature> V1280) (if (and (pair? (car V1280)) (eq? (quote {) (kl:shen.hdhd V1280))) (let ((NewStream1277 (kl:shen.pair (kl:shen.tlhd V1280) (kl:shen.hdtl V1280)))) (let ((Parse_shen.<signature-help> (kl:shen.<signature-help> NewStream1277))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature-help>)) (if (and (pair? (car Parse_shen.<signature-help>)) (eq? (quote }) (kl:shen.hdhd Parse_shen.<signature-help>))) (let ((NewStream1278 (kl:shen.pair (kl:shen.tlhd Parse_shen.<signature-help>) (kl:shen.hdtl Parse_shen.<signature-help>)))) (kl:shen.pair (car NewStream1278) (kl:shen.demodulate (kl:shen.curry-type (kl:shen.hdtl Parse_shen.<signature-help>))))) (kl:fail)) (kl:fail)))) (kl:fail))) (export shen.<signature>) (quote shen.<signature>))
(begin (register-function-arity (quote shen.curry-type) 1) (define (kl:shen.curry-type V1282) (kl:shen.active-cons (kl:shen.curry-type-h V1282))) (export shen.curry-type) (quote shen.curry-type))
(begin (register-function-arity (quote shen.active-cons) 1) (define (kl:shen.active-cons V1284) (cond ((and (pair? V1284) (and (pair? (cdr V1284)) (and (pair? (cdr (cdr V1284))) (and (null? (cdr (cdr (cdr V1284)))) (eq? (car (cdr V1284)) (quote bar!)))))) (cons (kl:shen.active-cons (car V1284)) (kl:shen.active-cons (car (cdr (cdr V1284)))))) ((pair? V1284) (cons (kl:shen.active-cons (car V1284)) (kl:shen.active-cons (cdr V1284)))) (#t V1284))) (export shen.active-cons) (quote shen.active-cons))
(begin (register-function-arity (quote shen.curry-type-h) 1) (define (kl:shen.curry-type-h V1286) (cond ((and (pair? V1286) (and (pair? (cdr V1286)) (and (eq? (quote -->) (car (cdr V1286))) (and (pair? (cdr (cdr V1286))) (and (pair? (cdr (cdr (cdr V1286)))) (eq? (quote -->) (car (cdr (cdr (cdr V1286)))))))))) (kl:shen.curry-type-h (cons (car V1286) (cons (quote -->) (cons (cdr (cdr V1286)) (quote ())))))) ((and (pair? V1286) (and (pair? (cdr V1286)) (and (eq? (quote *) (car (cdr V1286))) (and (pair? (cdr (cdr V1286))) (and (pair? (cdr (cdr (cdr V1286)))) (eq? (quote *) (car (cdr (cdr (cdr V1286)))))))))) (kl:shen.curry-type-h (cons (car V1286) (cons (quote *) (cons (cdr (cdr V1286)) (quote ())))))) ((pair? V1286) (kl:map (lambda (Z) (kl:shen.curry-type-h Z)) V1286)) (#t V1286))) (export shen.curry-type-h) (quote shen.curry-type-h))
(begin (register-function-arity (quote shen.<signature-help>) 1) (define (kl:shen.<signature-help> V1288) (let ((YaccParse (if (pair? (car V1288)) (let ((Parse_X (kl:shen.hdhd V1288))) (let ((Parse_shen.<signature-help> (kl:shen.<signature-help> (kl:shen.pair (kl:shen.tlhd V1288) (kl:shen.hdtl V1288))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature-help>)) (if (kl:not (kl:element? Parse_X (cons (quote {) (cons (quote }) (quote ()))))) (kl:shen.pair (car Parse_shen.<signature-help>) (cons Parse_X (kl:shen.hdtl Parse_shen.<signature-help>))) (kl:fail)) (kl:fail)))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1288))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<signature-help>) (quote shen.<signature-help>))
(begin (register-function-arity (quote shen.<rules>) 1) (define (kl:shen.<rules> V1290) (let ((YaccParse (let ((Parse_shen.<rule> (kl:shen.<rule> V1290))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (let ((Parse_shen.<rules> (kl:shen.<rules> Parse_shen.<rule>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rules>)) (kl:shen.pair (car Parse_shen.<rules>) (cons (kl:shen.linearise (kl:shen.hdtl Parse_shen.<rule>)) (kl:shen.hdtl Parse_shen.<rules>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<rule> (kl:shen.<rule> V1290))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (kl:shen.pair (car Parse_shen.<rule>) (cons (kl:shen.linearise (kl:shen.hdtl Parse_shen.<rule>)) (quote ()))) (kl:fail))) YaccParse))) (export shen.<rules>) (quote shen.<rules>))
(begin (register-function-arity (quote shen.<rule>) 1) (define (kl:shen.<rule> V1298) (let ((YaccParse (let ((Parse_shen.<patterns> (kl:shen.<patterns> V1298))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote ->) (kl:shen.hdhd Parse_shen.<patterns>))) (let ((NewStream1291 (kl:shen.pair (kl:shen.tlhd Parse_shen.<patterns>) (kl:shen.hdtl Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> NewStream1291))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (if (and (pair? (car Parse_shen.<action>)) (eq? (quote where) (kl:shen.hdhd Parse_shen.<action>))) (let ((NewStream1292 (kl:shen.pair (kl:shen.tlhd Parse_shen.<action>) (kl:shen.hdtl Parse_shen.<action>)))) (let ((Parse_shen.<guard> (kl:shen.<guard> NewStream1292))) (if (kl:not (kl:= (kl:fail) Parse_shen.<guard>)) (kl:shen.pair (car Parse_shen.<guard>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (cons (quote where) (cons (kl:shen.hdtl Parse_shen.<guard>) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ())))) (quote ())))) (kl:fail)))) (kl:fail)) (kl:fail)))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<patterns> (kl:shen.<patterns> V1298))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote ->) (kl:shen.hdhd Parse_shen.<patterns>))) (let ((NewStream1293 (kl:shen.pair (kl:shen.tlhd Parse_shen.<patterns>) (kl:shen.hdtl Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> NewStream1293))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (kl:shen.pair (car Parse_shen.<action>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ())))) (kl:fail)))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<patterns> (kl:shen.<patterns> V1298))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote <-) (kl:shen.hdhd Parse_shen.<patterns>))) (let ((NewStream1294 (kl:shen.pair (kl:shen.tlhd Parse_shen.<patterns>) (kl:shen.hdtl Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> NewStream1294))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (if (and (pair? (car Parse_shen.<action>)) (eq? (quote where) (kl:shen.hdhd Parse_shen.<action>))) (let ((NewStream1295 (kl:shen.pair (kl:shen.tlhd Parse_shen.<action>) (kl:shen.hdtl Parse_shen.<action>)))) (let ((Parse_shen.<guard> (kl:shen.<guard> NewStream1295))) (if (kl:not (kl:= (kl:fail) Parse_shen.<guard>)) (kl:shen.pair (car Parse_shen.<guard>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (cons (quote where) (cons (kl:shen.hdtl Parse_shen.<guard>) (cons (cons (quote shen.choicepoint!) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ()))) (quote ())))) (quote ())))) (kl:fail)))) (kl:fail)) (kl:fail)))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<patterns> (kl:shen.<patterns> V1298))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote <-) (kl:shen.hdhd Parse_shen.<patterns>))) (let ((NewStream1296 (kl:shen.pair (kl:shen.tlhd Parse_shen.<patterns>) (kl:shen.hdtl Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> NewStream1296))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (kl:shen.pair (car Parse_shen.<action>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (cons (quote shen.choicepoint!) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ()))) (quote ())))) (kl:fail)))) (kl:fail)) (kl:fail))) YaccParse)) YaccParse)) YaccParse))) (export shen.<rule>) (quote shen.<rule>))
(begin (register-function-arity (quote shen.fail_if) 2) (define (kl:shen.fail_if V1301 V1302) (if (assert-boolean (V1301 V1302)) (kl:fail) V1302)) (export shen.fail_if) (quote shen.fail_if))
(begin (register-function-arity (quote shen.succeeds?) 1) (define (kl:shen.succeeds? V1308) (cond ((kl:= V1308 (kl:fail)) #f) (#t #t))) (export shen.succeeds?) (quote shen.succeeds?))
(begin (register-function-arity (quote shen.<patterns>) 1) (define (kl:shen.<patterns> V1310) (let ((YaccParse (let ((Parse_shen.<pattern> (kl:shen.<pattern> V1310))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern>)) (let ((Parse_shen.<patterns> (kl:shen.<patterns> Parse_shen.<pattern>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (kl:shen.pair (car Parse_shen.<patterns>) (cons (kl:shen.hdtl Parse_shen.<pattern>) (kl:shen.hdtl Parse_shen.<patterns>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1310))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<patterns>) (quote shen.<patterns>))
(begin (register-function-arity (quote shen.<pattern>) 1) (define (kl:shen.<pattern> V1323) (let ((YaccParse (if (and (pair? (car V1323)) (pair? (kl:shen.hdhd V1323))) (if (and (pair? (car (kl:shen.pair (kl:shen.hdhd V1323) (kl:shen.hdtl V1323)))) (eq? (quote _waspvm_at_p) (kl:shen.hdhd (kl:shen.pair (kl:shen.hdhd V1323) (kl:shen.hdtl V1323))))) (let ((NewStream1312 (kl:shen.pair (kl:shen.tlhd (kl:shen.pair (kl:shen.hdhd V1323) (kl:shen.hdtl V1323))) (kl:shen.hdtl (kl:shen.pair (kl:shen.hdhd V1323) (kl:shen.hdtl V1323)))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> NewStream1312))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1323) (kl:shen.hdtl V1323))) (cons (quote _waspvm_at_p) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail)))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V1323)) (pair? (kl:shen.hdhd V1323))) (if (and (pair? (car (kl:shen.pair (kl:shen.hdhd V1323) (kl:shen.hdtl V1323)))) (eq? (quote cons) (kl:shen.hdhd (kl:shen.pair (kl:shen.hdhd V1323) (kl:shen.hdtl V1323))))) (let ((NewStream1314 (kl:shen.pair (kl:shen.tlhd (kl:shen.pair (kl:shen.hdhd V1323) (kl:shen.hdtl V1323))) (kl:shen.hdtl (kl:shen.pair (kl:shen.hdhd V1323) (kl:shen.hdtl V1323)))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> NewStream1314))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1323) (kl:shen.hdtl V1323))) (cons (quote cons) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail)))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V1323)) (pair? (kl:shen.hdhd V1323))) (if (and (pair? (car (kl:shen.pair (kl:shen.hdhd V1323) (kl:shen.hdtl V1323)))) (eq? (quote _waspvm_at_v) (kl:shen.hdhd (kl:shen.pair (kl:shen.hdhd V1323) (kl:shen.hdtl V1323))))) (let ((NewStream1316 (kl:shen.pair (kl:shen.tlhd (kl:shen.pair (kl:shen.hdhd V1323) (kl:shen.hdtl V1323))) (kl:shen.hdtl (kl:shen.pair (kl:shen.hdhd V1323) (kl:shen.hdtl V1323)))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> NewStream1316))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1323) (kl:shen.hdtl V1323))) (cons (quote _waspvm_at_v) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail)))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V1323)) (pair? (kl:shen.hdhd V1323))) (if (and (pair? (car (kl:shen.pair (kl:shen.hdhd V1323) (kl:shen.hdtl V1323)))) (eq? (quote _waspvm_at_s) (kl:shen.hdhd (kl:shen.pair (kl:shen.hdhd V1323) (kl:shen.hdtl V1323))))) (let ((NewStream1318 (kl:shen.pair (kl:shen.tlhd (kl:shen.pair (kl:shen.hdhd V1323) (kl:shen.hdtl V1323))) (kl:shen.hdtl (kl:shen.pair (kl:shen.hdhd V1323) (kl:shen.hdtl V1323)))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> NewStream1318))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1323) (kl:shen.hdtl V1323))) (cons (quote _waspvm_at_s) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail)))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V1323)) (pair? (kl:shen.hdhd V1323))) (if (and (pair? (car (kl:shen.pair (kl:shen.hdhd V1323) (kl:shen.hdtl V1323)))) (eq? (quote vector) (kl:shen.hdhd (kl:shen.pair (kl:shen.hdhd V1323) (kl:shen.hdtl V1323))))) (let ((NewStream1320 (kl:shen.pair (kl:shen.tlhd (kl:shen.pair (kl:shen.hdhd V1323) (kl:shen.hdtl V1323))) (kl:shen.hdtl (kl:shen.pair (kl:shen.hdhd V1323) (kl:shen.hdtl V1323)))))) (if (and (pair? (car NewStream1320)) (kl:= 0 (kl:shen.hdhd NewStream1320))) (let ((NewStream1321 (kl:shen.pair (kl:shen.tlhd NewStream1320) (kl:shen.hdtl NewStream1320)))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1323) (kl:shen.hdtl V1323))) (cons (quote vector) (cons 0 (quote ()))))) (kl:fail))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (pair? (car V1323)) (let ((Parse_X (kl:shen.hdhd V1323))) (if (pair? Parse_X) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1323) (kl:shen.hdtl V1323))) (kl:shen.constructor-error Parse_X)) (kl:fail))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<simple_pattern> (kl:shen.<simple_pattern> V1323))) (if (kl:not (kl:= (kl:fail) Parse_shen.<simple_pattern>)) (kl:shen.pair (car Parse_shen.<simple_pattern>) (kl:shen.hdtl Parse_shen.<simple_pattern>)) (kl:fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse))) (export shen.<pattern>) (quote shen.<pattern>))
(begin (register-function-arity (quote shen.constructor-error) 1) (define (kl:shen.constructor-error V1325) (simple-error (kl:shen.app V1325 " is not a legitimate constructor\n" (quote shen.a)))) (export shen.constructor-error) (quote shen.constructor-error))
(begin (register-function-arity (quote shen.<simple_pattern>) 1) (define (kl:shen.<simple_pattern> V1327) (let ((YaccParse (if (pair? (car V1327)) (let ((Parse_X (kl:shen.hdhd V1327))) (if (eq? Parse_X (quote _)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1327) (kl:shen.hdtl V1327))) (kl:gensym (quote Parse_Y))) (kl:fail))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (if (pair? (car V1327)) (let ((Parse_X (kl:shen.hdhd V1327))) (if (kl:not (kl:element? Parse_X (cons (quote ->) (cons (quote <-) (quote ()))))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1327) (kl:shen.hdtl V1327))) Parse_X) (kl:fail))) (kl:fail)) YaccParse))) (export shen.<simple_pattern>) (quote shen.<simple_pattern>))
(begin (register-function-arity (quote shen.<pattern1>) 1) (define (kl:shen.<pattern1> V1329) (let ((Parse_shen.<pattern> (kl:shen.<pattern> V1329))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern>)) (kl:shen.pair (car Parse_shen.<pattern>) (kl:shen.hdtl Parse_shen.<pattern>)) (kl:fail)))) (export shen.<pattern1>) (quote shen.<pattern1>))
(begin (register-function-arity (quote shen.<pattern2>) 1) (define (kl:shen.<pattern2> V1331) (let ((Parse_shen.<pattern> (kl:shen.<pattern> V1331))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern>)) (kl:shen.pair (car Parse_shen.<pattern>) (kl:shen.hdtl Parse_shen.<pattern>)) (kl:fail)))) (export shen.<pattern2>) (quote shen.<pattern2>))
(begin (register-function-arity (quote shen.<action>) 1) (define (kl:shen.<action> V1333) (if (pair? (car V1333)) (let ((Parse_X (kl:shen.hdhd V1333))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1333) (kl:shen.hdtl V1333))) Parse_X)) (kl:fail))) (export shen.<action>) (quote shen.<action>))
(begin (register-function-arity (quote shen.<guard>) 1) (define (kl:shen.<guard> V1335) (if (pair? (car V1335)) (let ((Parse_X (kl:shen.hdhd V1335))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1335) (kl:shen.hdtl V1335))) Parse_X)) (kl:fail))) (export shen.<guard>) (quote shen.<guard>))
(begin (register-function-arity (quote shen.compile_to_machine_code) 2) (define (kl:shen.compile_to_machine_code V1338 V1339) (let ((Lambda+ (kl:shen.compile_to_lambda+ V1338 V1339))) (let ((KL (kl:shen.compile_to_kl V1338 Lambda+))) (let ((Record (kl:shen.record-source V1338 KL))) KL)))) (export shen.compile_to_machine_code) (quote shen.compile_to_machine_code))
(begin (register-function-arity (quote shen.record-source) 2) (define (kl:shen.record-source V1344 V1345) (cond ((assert-boolean (kl:value (quote shen.*installing-kl*))) (quote shen.skip)) (#t (kl:put V1344 (quote shen.source) V1345 (kl:value (quote *property-vector*)))))) (export shen.record-source) (quote shen.record-source))
(begin (register-function-arity (quote shen.compile_to_lambda+) 2) (define (kl:shen.compile_to_lambda+ V1348 V1349) (let ((Arity (kl:shen.aritycheck V1348 V1349))) (let ((UpDateSymbolTable (kl:shen.update-symbol-table V1348 Arity))) (let ((Free (kl:shen.for-each (lambda (Rule) (kl:shen.free_variable_check V1348 Rule)) V1349))) (let ((Variables (kl:shen.parameters Arity))) (let ((Strip (kl:map (lambda (X) (kl:shen.strip-protect X)) V1349))) (let ((Abstractions (kl:map (lambda (X) (kl:shen.abstract_rule X)) Strip))) (let ((Applications (kl:map (lambda (X) (kl:shen.application_build Variables X)) Abstractions))) (cons Variables (cons Applications (quote ()))))))))))) (export shen.compile_to_lambda+) (quote shen.compile_to_lambda+))
(begin (register-function-arity (quote shen.update-symbol-table) 2) (define (kl:shen.update-symbol-table V1352 V1353) (cond ((kl:= 0 V1353) (quote shen.skip)) (#t (kl:put V1352 (quote shen.lambda-form) (kl:eval-kl (kl:shen.lambda-form V1352 V1353)) (kl:value (quote *property-vector*)))))) (export shen.update-symbol-table) (quote shen.update-symbol-table))
(begin (register-function-arity (quote shen.free_variable_check) 2) (define (kl:shen.free_variable_check V1356 V1357) (cond ((and (pair? V1357) (and (pair? (cdr V1357)) (null? (cdr (cdr V1357))))) (let ((Bound (kl:shen.extract_vars (car V1357)))) (let ((Free (kl:shen.extract_free_vars Bound (car (cdr V1357))))) (kl:shen.free_variable_warnings V1356 Free)))) (#t (kl:shen.f_error (quote shen.free_variable_check))))) (export shen.free_variable_check) (quote shen.free_variable_check))
(begin (register-function-arity (quote shen.extract_vars) 1) (define (kl:shen.extract_vars V1359) (cond ((kl:variable? V1359) (cons V1359 (quote ()))) ((pair? V1359) (kl:union (kl:shen.extract_vars (car V1359)) (kl:shen.extract_vars (cdr V1359)))) (#t (quote ())))) (export shen.extract_vars) (quote shen.extract_vars))
(begin (register-function-arity (quote shen.extract_free_vars) 2) (define (kl:shen.extract_free_vars V1371 V1372) (cond ((and (pair? V1372) (and (pair? (cdr V1372)) (and (null? (cdr (cdr V1372))) (eq? (car V1372) (quote protect))))) (quote ())) ((and (kl:variable? V1372) (kl:not (kl:element? V1372 V1371))) (cons V1372 (quote ()))) ((and (pair? V1372) (and (eq? (quote lambda) (car V1372)) (and (pair? (cdr V1372)) (and (pair? (cdr (cdr V1372))) (null? (cdr (cdr (cdr V1372)))))))) (kl:shen.extract_free_vars (cons (car (cdr V1372)) V1371) (car (cdr (cdr V1372))))) ((and (pair? V1372) (and (eq? (quote let) (car V1372)) (and (pair? (cdr V1372)) (and (pair? (cdr (cdr V1372))) (and (pair? (cdr (cdr (cdr V1372)))) (null? (cdr (cdr (cdr (cdr V1372)))))))))) (kl:union (kl:shen.extract_free_vars V1371 (car (cdr (cdr V1372)))) (kl:shen.extract_free_vars (cons (car (cdr V1372)) V1371) (car (cdr (cdr (cdr V1372))))))) ((pair? V1372) (kl:union (kl:shen.extract_free_vars V1371 (car V1372)) (kl:shen.extract_free_vars V1371 (cdr V1372)))) (#t (quote ())))) (export shen.extract_free_vars) (quote shen.extract_free_vars))
(begin (register-function-arity (quote shen.free_variable_warnings) 2) (define (kl:shen.free_variable_warnings V1377 V1378) (cond ((null? V1378) (quote _)) (#t (simple-error (string-append "error: the following variables are free in " (kl:shen.app V1377 (string-append ": " (kl:shen.app (kl:shen.list_variables V1378) "" (quote shen.a))) (quote shen.a))))))) (export shen.free_variable_warnings) (quote shen.free_variable_warnings))
(begin (register-function-arity (quote shen.list_variables) 1) (define (kl:shen.list_variables V1380) (cond ((and (pair? V1380) (null? (cdr V1380))) (string-append (kl:str (car V1380)) ".")) ((pair? V1380) (string-append (kl:str (car V1380)) (string-append ", " (kl:shen.list_variables (cdr V1380))))) (#t (kl:shen.f_error (quote shen.list_variables))))) (export shen.list_variables) (quote shen.list_variables))
(begin (register-function-arity (quote shen.strip-protect) 1) (define (kl:shen.strip-protect V1382) (cond ((and (pair? V1382) (and (pair? (cdr V1382)) (and (null? (cdr (cdr V1382))) (eq? (car V1382) (quote protect))))) (kl:shen.strip-protect (car (cdr V1382)))) ((pair? V1382) (kl:map (lambda (Z) (kl:shen.strip-protect Z)) V1382)) (#t V1382))) (export shen.strip-protect) (quote shen.strip-protect))
(begin (register-function-arity (quote shen.linearise) 1) (define (kl:shen.linearise V1384) (cond ((and (pair? V1384) (and (pair? (cdr V1384)) (null? (cdr (cdr V1384))))) (kl:shen.linearise_help (kl:shen.flatten (car V1384)) (car V1384) (car (cdr V1384)))) (#t (kl:shen.f_error (quote shen.linearise))))) (export shen.linearise) (quote shen.linearise))
(begin (register-function-arity (quote shen.flatten) 1) (define (kl:shen.flatten V1386) (cond ((null? V1386) (quote ())) ((pair? V1386) (kl:append (kl:shen.flatten (car V1386)) (kl:shen.flatten (cdr V1386)))) (#t (cons V1386 (quote ()))))) (export shen.flatten) (quote shen.flatten))
(begin (register-function-arity (quote shen.linearise_help) 3) (define (kl:shen.linearise_help V1390 V1391 V1392) (cond ((null? V1390) (cons V1391 (cons V1392 (quote ())))) ((pair? V1390) (if (and (kl:variable? (car V1390)) (kl:element? (car V1390) (cdr V1390))) (let ((Var (kl:gensym (car V1390)))) (let ((NewAction (cons (quote where) (cons (cons (quote =) (cons (car V1390) (cons Var (quote ())))) (cons V1392 (quote ())))))) (let ((NewPatts (kl:shen.linearise_X (car V1390) Var V1391))) (kl:shen.linearise_help (cdr V1390) NewPatts NewAction)))) (kl:shen.linearise_help (cdr V1390) V1391 V1392))) (#t (kl:shen.f_error (quote shen.linearise_help))))) (export shen.linearise_help) (quote shen.linearise_help))
(begin (register-function-arity (quote shen.linearise_X) 3) (define (kl:shen.linearise_X V1405 V1406 V1407) (cond ((kl:= V1407 V1405) V1406) ((pair? V1407) (let ((L (kl:shen.linearise_X V1405 V1406 (car V1407)))) (if (kl:= L (car V1407)) (cons (car V1407) (kl:shen.linearise_X V1405 V1406 (cdr V1407))) (cons L (cdr V1407))))) (#t V1407))) (export shen.linearise_X) (quote shen.linearise_X))
(begin (register-function-arity (quote shen.aritycheck) 2) (define (kl:shen.aritycheck V1410 V1411) (cond ((and (pair? V1411) (and (pair? (car V1411)) (and (pair? (cdr (car V1411))) (and (null? (cdr (cdr (car V1411)))) (null? (cdr V1411)))))) (begin (kl:shen.aritycheck-action (car (cdr (car V1411)))) (kl:shen.aritycheck-name V1410 (kl:arity V1410) (kl:length (car (car V1411)))))) ((and (pair? V1411) (and (pair? (car V1411)) (and (pair? (cdr (car V1411))) (and (null? (cdr (cdr (car V1411)))) (and (pair? (cdr V1411)) (and (pair? (car (cdr V1411))) (and (pair? (cdr (car (cdr V1411)))) (null? (cdr (cdr (car (cdr V1411)))))))))))) (if (kl:= (kl:length (car (car V1411))) (kl:length (car (car (cdr V1411))))) (begin (kl:shen.aritycheck-action (car (cdr (car V1411)))) (kl:shen.aritycheck V1410 (cdr V1411))) (simple-error (string-append "arity error in " (kl:shen.app V1410 "\n" (quote shen.a)))))) (#t (kl:shen.f_error (quote shen.aritycheck))))) (export shen.aritycheck) (quote shen.aritycheck))
(begin (register-function-arity (quote shen.aritycheck-name) 3) (define (kl:shen.aritycheck-name V1424 V1425 V1426) (cond ((kl:= -1 V1425) V1426) ((kl:= V1426 V1425) V1426) (#t (begin (kl:shen.prhush (string-append "\nwarning: changing the arity of " (kl:shen.app V1424 " can cause errors.\n" (quote shen.a))) (kl:stoutput)) V1426)))) (export shen.aritycheck-name) (quote shen.aritycheck-name))
(begin (register-function-arity (quote shen.aritycheck-action) 1) (define (kl:shen.aritycheck-action V1432) (cond ((pair? V1432) (begin (kl:shen.aah (car V1432) (cdr V1432)) (kl:shen.for-each (lambda (Y) (kl:shen.aritycheck-action Y)) V1432))) (#t (quote shen.skip)))) (export shen.aritycheck-action) (quote shen.aritycheck-action))
(begin (register-function-arity (quote shen.aah) 2) (define (kl:shen.aah V1435 V1436) (let ((Arity (kl:arity V1435))) (let ((Len (kl:length V1436))) (if (and (> Arity -1) (> Len Arity)) (kl:shen.prhush (string-append "warning: " (kl:shen.app V1435 (string-append " might not like " (kl:shen.app Len (string-append " argument" (kl:shen.app (if (> Len 1) "s" "") ".\n" (quote shen.a))) (quote shen.a))) (quote shen.a))) (kl:stoutput)) (quote shen.skip))))) (export shen.aah) (quote shen.aah))
(begin (register-function-arity (quote shen.abstract_rule) 1) (define (kl:shen.abstract_rule V1438) (cond ((and (pair? V1438) (and (pair? (cdr V1438)) (null? (cdr (cdr V1438))))) (kl:shen.abstraction_build (car V1438) (car (cdr V1438)))) (#t (kl:shen.f_error (quote shen.abstract_rule))))) (export shen.abstract_rule) (quote shen.abstract_rule))
(begin (register-function-arity (quote shen.abstraction_build) 2) (define (kl:shen.abstraction_build V1441 V1442) (cond ((null? V1441) V1442) ((pair? V1441) (cons (quote /.) (cons (car V1441) (cons (kl:shen.abstraction_build (cdr V1441) V1442) (quote ()))))) (#t (kl:shen.f_error (quote shen.abstraction_build))))) (export shen.abstraction_build) (quote shen.abstraction_build))
(begin (register-function-arity (quote shen.parameters) 1) (define (kl:shen.parameters V1444) (cond ((kl:= 0 V1444) (quote ())) (#t (cons (kl:gensym (quote V)) (kl:shen.parameters (- V1444 1)))))) (export shen.parameters) (quote shen.parameters))
(begin (register-function-arity (quote shen.application_build) 2) (define (kl:shen.application_build V1447 V1448) (cond ((null? V1447) V1448) ((pair? V1447) (kl:shen.application_build (cdr V1447) (cons V1448 (cons (car V1447) (quote ()))))) (#t (kl:shen.f_error (quote shen.application_build))))) (export shen.application_build) (quote shen.application_build))
(begin (register-function-arity (quote shen.compile_to_kl) 2) (define (kl:shen.compile_to_kl V1451 V1452) (cond ((and (pair? V1452) (and (pair? (cdr V1452)) (null? (cdr (cdr V1452))))) (let ((Arity (kl:shen.store-arity V1451 (kl:length (car V1452))))) (let ((Reduce (kl:map (lambda (X) (kl:shen.reduce X)) (car (cdr V1452))))) (let ((CondExpression (kl:shen.cond-expression V1451 (car V1452) Reduce))) (let ((TypeTable (if (assert-boolean (kl:value (quote shen.*optimise*))) (kl:shen.typextable (kl:shen.get-type V1451) (car V1452)) (quote shen.skip)))) (let ((TypedCondExpression (if (assert-boolean (kl:value (quote shen.*optimise*))) (kl:shen.assign-types (car V1452) TypeTable CondExpression) CondExpression))) (cons (quote defun) (cons V1451 (cons (car V1452) (cons TypedCondExpression (quote ()))))))))))) (#t (kl:shen.f_error (quote shen.compile_to_kl))))) (export shen.compile_to_kl) (quote shen.compile_to_kl))
(begin (register-function-arity (quote shen.get-type) 1) (define (kl:shen.get-type V1458) (cond ((pair? V1458) (quote shen.skip)) (#t (let ((FType (kl:assoc V1458 (kl:value (quote shen.*signedfuncs*))))) (if (kl:empty? FType) (quote shen.skip) (cdr FType)))))) (export shen.get-type) (quote shen.get-type))
(begin (register-function-arity (quote shen.typextable) 2) (define (kl:shen.typextable V1469 V1470) (cond ((and (pair? V1469) (and (pair? (cdr V1469)) (and (eq? (quote -->) (car (cdr V1469))) (and (pair? (cdr (cdr V1469))) (and (null? (cdr (cdr (cdr V1469)))) (pair? V1470)))))) (if (kl:variable? (car V1469)) (kl:shen.typextable (car (cdr (cdr V1469))) (cdr V1470)) (cons (cons (car V1470) (car V1469)) (kl:shen.typextable (car (cdr (cdr V1469))) (cdr V1470))))) (#t (quote ())))) (export shen.typextable) (quote shen.typextable))
(begin (register-function-arity (quote shen.assign-types) 3) (define (kl:shen.assign-types V1474 V1475 V1476) (cond ((and (pair? V1476) (and (eq? (quote let) (car V1476)) (and (pair? (cdr V1476)) (and (pair? (cdr (cdr V1476))) (and (pair? (cdr (cdr (cdr V1476)))) (null? (cdr (cdr (cdr (cdr V1476)))))))))) (cons (quote let) (cons (car (cdr V1476)) (cons (kl:shen.assign-types V1474 V1475 (car (cdr (cdr V1476)))) (cons (kl:shen.assign-types (cons (car (cdr V1476)) V1474) V1475 (car (cdr (cdr (cdr V1476))))) (quote ())))))) ((and (pair? V1476) (and (eq? (quote lambda) (car V1476)) (and (pair? (cdr V1476)) (and (pair? (cdr (cdr V1476))) (null? (cdr (cdr (cdr V1476)))))))) (cons (quote lambda) (cons (car (cdr V1476)) (cons (kl:shen.assign-types (cons (car (cdr V1476)) V1474) V1475 (car (cdr (cdr V1476)))) (quote ()))))) ((and (pair? V1476) (eq? (quote cond) (car V1476))) (cons (quote cond) (kl:map (lambda (Y) (cons (kl:shen.assign-types V1474 V1475 (car Y)) (cons (kl:shen.assign-types V1474 V1475 (car (cdr Y))) (quote ())))) (cdr V1476)))) ((pair? V1476) (let ((NewTable (kl:shen.typextable (kl:shen.get-type (car V1476)) (cdr V1476)))) (cons (car V1476) (kl:map (lambda (Y) (kl:shen.assign-types V1474 (kl:append V1475 NewTable) Y)) (cdr V1476))))) (#t (let ((AtomType (kl:assoc V1476 V1475))) (if (pair? AtomType) (cons (quote type) (cons V1476 (cons (cdr AtomType) (quote ())))) (if (kl:element? V1476 V1474) V1476 (kl:shen.atom-type V1476))))))) (export shen.assign-types) (quote shen.assign-types))
(begin (register-function-arity (quote shen.atom-type) 1) (define (kl:shen.atom-type V1478) (if (string? V1478) (cons (quote type) (cons V1478 (cons (quote string) (quote ())))) (if (number? V1478) (cons (quote type) (cons V1478 (cons (quote number) (quote ())))) (if (kl:boolean? V1478) (cons (quote type) (cons V1478 (cons (quote boolean) (quote ())))) (if (kl:symbol? V1478) (cons (quote type) (cons V1478 (cons (quote symbol) (quote ())))) V1478))))) (export shen.atom-type) (quote shen.atom-type))
(begin (register-function-arity (quote shen.store-arity) 2) (define (kl:shen.store-arity V1483 V1484) (cond ((assert-boolean (kl:value (quote shen.*installing-kl*))) (quote shen.skip)) (#t (kl:put V1483 (quote arity) V1484 (kl:value (quote *property-vector*)))))) (export shen.store-arity) (quote shen.store-arity))
(begin (register-function-arity (quote shen.reduce) 1) (define (kl:shen.reduce V1486) (begin (kl:set (quote shen.*teststack*) (quote ())) (let ((Result (kl:shen.reduce_help V1486))) (cons (cons (quote :) (cons (quote shen.tests) (kl:reverse (kl:value (quote shen.*teststack*))))) (cons Result (quote ())))))) (export shen.reduce) (quote shen.reduce))
(begin (register-function-arity (quote shen.reduce_help) 1) (define (kl:shen.reduce_help V1488) (cond ((and (pair? V1488) (and (pair? (car V1488)) (and (eq? (quote /.) (car (car V1488))) (and (pair? (cdr (car V1488))) (and (pair? (car (cdr (car V1488)))) (and (eq? (quote cons) (car (car (cdr (car V1488))))) (and (pair? (cdr (car (cdr (car V1488))))) (and (pair? (cdr (cdr (car (cdr (car V1488)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1488))))))) (and (pair? (cdr (cdr (car V1488)))) (and (null? (cdr (cdr (cdr (car V1488))))) (and (pair? (cdr V1488)) (null? (cdr (cdr V1488))))))))))))))) (begin (kl:shen.add_test (cons (quote cons?) (cdr V1488))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V1488))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V1488)))))) (cons (kl:shen.ebr (car (cdr V1488)) (car (cdr (car V1488))) (car (cdr (cdr (car V1488))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote hd) (cdr V1488)) (quote ()))) (cons (cons (quote tl) (cdr V1488)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V1488) (and (pair? (car V1488)) (and (eq? (quote /.) (car (car V1488))) (and (pair? (cdr (car V1488))) (and (pair? (car (cdr (car V1488)))) (and (eq? (quote _waspvm_at_p) (car (car (cdr (car V1488))))) (and (pair? (cdr (car (cdr (car V1488))))) (and (pair? (cdr (cdr (car (cdr (car V1488)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1488))))))) (and (pair? (cdr (cdr (car V1488)))) (and (null? (cdr (cdr (cdr (car V1488))))) (and (pair? (cdr V1488)) (null? (cdr (cdr V1488))))))))))))))) (begin (kl:shen.add_test (cons (quote tuple?) (cdr V1488))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V1488))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V1488)))))) (cons (kl:shen.ebr (car (cdr V1488)) (car (cdr (car V1488))) (car (cdr (cdr (car V1488))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote fst) (cdr V1488)) (quote ()))) (cons (cons (quote snd) (cdr V1488)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V1488) (and (pair? (car V1488)) (and (eq? (quote /.) (car (car V1488))) (and (pair? (cdr (car V1488))) (and (pair? (car (cdr (car V1488)))) (and (eq? (quote _waspvm_at_v) (car (car (cdr (car V1488))))) (and (pair? (cdr (car (cdr (car V1488))))) (and (pair? (cdr (cdr (car (cdr (car V1488)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1488))))))) (and (pair? (cdr (cdr (car V1488)))) (and (null? (cdr (cdr (cdr (car V1488))))) (and (pair? (cdr V1488)) (null? (cdr (cdr V1488))))))))))))))) (begin (kl:shen.add_test (cons (quote shen.+vector?) (cdr V1488))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V1488))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V1488)))))) (cons (kl:shen.ebr (car (cdr V1488)) (car (cdr (car V1488))) (car (cdr (cdr (car V1488))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote hdv) (cdr V1488)) (quote ()))) (cons (cons (quote tlv) (cdr V1488)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V1488) (and (pair? (car V1488)) (and (eq? (quote /.) (car (car V1488))) (and (pair? (cdr (car V1488))) (and (pair? (car (cdr (car V1488)))) (and (eq? (quote _waspvm_at_s) (car (car (cdr (car V1488))))) (and (pair? (cdr (car (cdr (car V1488))))) (and (pair? (cdr (cdr (car (cdr (car V1488)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1488))))))) (and (pair? (cdr (cdr (car V1488)))) (and (null? (cdr (cdr (cdr (car V1488))))) (and (pair? (cdr V1488)) (null? (cdr (cdr V1488))))))))))))))) (begin (kl:shen.add_test (cons (quote shen.+string?) (cdr V1488))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V1488))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V1488)))))) (cons (kl:shen.ebr (car (cdr V1488)) (car (cdr (car V1488))) (car (cdr (cdr (car V1488))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote pos) (cons (car (cdr V1488)) (cons 0 (quote ())))) (quote ()))) (cons (cons (quote tlstr) (cdr V1488)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V1488) (and (pair? (car V1488)) (and (eq? (quote /.) (car (car V1488))) (and (pair? (cdr (car V1488))) (and (pair? (cdr (cdr (car V1488)))) (and (null? (cdr (cdr (cdr (car V1488))))) (and (pair? (cdr V1488)) (and (null? (cdr (cdr V1488))) (kl:not (kl:variable? (car (cdr (car V1488))))))))))))) (begin (kl:shen.add_test (cons (quote =) (cons (car (cdr (car V1488))) (cdr V1488)))) (kl:shen.reduce_help (car (cdr (cdr (car V1488))))))) ((and (pair? V1488) (and (pair? (car V1488)) (and (eq? (quote /.) (car (car V1488))) (and (pair? (cdr (car V1488))) (and (pair? (cdr (cdr (car V1488)))) (and (null? (cdr (cdr (cdr (car V1488))))) (and (pair? (cdr V1488)) (null? (cdr (cdr V1488)))))))))) (kl:shen.reduce_help (kl:shen.ebr (car (cdr V1488)) (car (cdr (car V1488))) (car (cdr (cdr (car V1488))))))) ((and (pair? V1488) (and (eq? (quote where) (car V1488)) (and (pair? (cdr V1488)) (and (pair? (cdr (cdr V1488))) (null? (cdr (cdr (cdr V1488)))))))) (begin (kl:shen.add_test (car (cdr V1488))) (kl:shen.reduce_help (car (cdr (cdr V1488)))))) ((and (pair? V1488) (and (pair? (cdr V1488)) (null? (cdr (cdr V1488))))) (let ((Z (kl:shen.reduce_help (car V1488)))) (if (kl:= (car V1488) Z) V1488 (kl:shen.reduce_help (cons Z (cdr V1488)))))) (#t V1488))) (export shen.reduce_help) (quote shen.reduce_help))
(begin (register-function-arity (quote shen.+string?) 1) (define (kl:shen.+string? V1490) (cond ((equal? "" V1490) #f) (#t (string? V1490)))) (export shen.+string?) (quote shen.+string?))
(begin (register-function-arity (quote shen.+vector?) 1) (define (kl:shen.+vector? V1492) (and (vector? V1492) (> (vector-ref V1492 0) 0))) (export shen.+vector?) (quote shen.+vector?))
(begin (register-function-arity (quote shen.ebr) 3) (define (kl:shen.ebr V1505 V1506 V1507) (cond ((kl:= V1507 V1506) V1505) ((and (pair? V1507) (and (eq? (quote lambda) (car V1507)) (and (pair? (cdr V1507)) (and (pair? (cdr (cdr V1507))) (and (null? (cdr (cdr (cdr V1507)))) (assert-boolean (kl:shen.clash? (car (cdr V1507)) V1506))))))) V1507) ((and (pair? V1507) (and (eq? (quote let) (car V1507)) (and (pair? (cdr V1507)) (and (pair? (cdr (cdr V1507))) (and (pair? (cdr (cdr (cdr V1507)))) (and (null? (cdr (cdr (cdr (cdr V1507))))) (assert-boolean (kl:shen.clash? (car (cdr V1507)) V1506)))))))) (cons (quote let) (cons (car (cdr V1507)) (cons (kl:shen.ebr V1505 V1506 (car (cdr (cdr V1507)))) (cdr (cdr (cdr V1507))))))) ((pair? V1507) (cons (kl:shen.ebr V1505 V1506 (car V1507)) (kl:shen.ebr V1505 V1506 (cdr V1507)))) (#t V1507))) (export shen.ebr) (quote shen.ebr))
(begin (register-function-arity (quote shen.clash?) 2) (define (kl:shen.clash? V1519 V1520) (cond ((kl:= V1520 V1519) #t) ((pair? V1520) (or (assert-boolean (kl:shen.clash? V1519 (car V1520))) (assert-boolean (kl:shen.clash? V1519 (cdr V1520))))) (#t #f))) (export shen.clash?) (quote shen.clash?))
(begin (register-function-arity (quote shen.add_test) 1) (define (kl:shen.add_test V1522) (kl:set (quote shen.*teststack*) (cons V1522 (kl:value (quote shen.*teststack*))))) (export shen.add_test) (quote shen.add_test))
(begin (register-function-arity (quote shen.cond-expression) 3) (define (kl:shen.cond-expression V1526 V1527 V1528) (let ((Err (kl:shen.err-condition V1526))) (let ((Cases (kl:shen.case-form V1528 Err))) (let ((EncodeChoices (kl:shen.encode-choices Cases V1526))) (kl:shen.cond-form EncodeChoices))))) (export shen.cond-expression) (quote shen.cond-expression))
(begin (register-function-arity (quote shen.cond-form) 1) (define (kl:shen.cond-form V1532) (cond ((and (pair? V1532) (and (pair? (car V1532)) (and (kl:= #t (car (car V1532))) (and (pair? (cdr (car V1532))) (null? (cdr (cdr (car V1532)))))))) (car (cdr (car V1532)))) (#t (cons (quote cond) V1532)))) (export shen.cond-form) (quote shen.cond-form))
(begin (register-function-arity (quote shen.encode-choices) 2) (define (kl:shen.encode-choices V1537 V1538) (cond ((null? V1537) (quote ())) ((and (pair? V1537) (and (pair? (car V1537)) (and (kl:= #t (car (car V1537))) (and (pair? (cdr (car V1537))) (and (pair? (car (cdr (car V1537)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V1537))))) (and (pair? (cdr (car (cdr (car V1537))))) (and (null? (cdr (cdr (car (cdr (car V1537)))))) (and (null? (cdr (cdr (car V1537)))) (null? (cdr V1537))))))))))) (cons (cons #t (cons (cons (quote let) (cons (quote Result) (cons (car (cdr (car (cdr (car V1537))))) (cons (cons (quote if) (cons (cons (quote =) (cons (quote Result) (cons (cons (quote fail) (quote ())) (quote ())))) (cons (if (assert-boolean (kl:value (quote shen.*installing-kl*))) (cons (quote shen.sys-error) (cons V1538 (quote ()))) (cons (quote shen.f_error) (cons V1538 (quote ())))) (cons (quote Result) (quote ()))))) (quote ()))))) (quote ()))) (quote ()))) ((and (pair? V1537) (and (pair? (car V1537)) (and (kl:= #t (car (car V1537))) (and (pair? (cdr (car V1537))) (and (pair? (car (cdr (car V1537)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V1537))))) (and (pair? (cdr (car (cdr (car V1537))))) (and (null? (cdr (cdr (car (cdr (car V1537)))))) (null? (cdr (cdr (car V1537)))))))))))) (cons (cons #t (cons (cons (quote let) (cons (quote Result) (cons (car (cdr (car (cdr (car V1537))))) (cons (cons (quote if) (cons (cons (quote =) (cons (quote Result) (cons (cons (quote fail) (quote ())) (quote ())))) (cons (kl:shen.cond-form (kl:shen.encode-choices (cdr V1537) V1538)) (cons (quote Result) (quote ()))))) (quote ()))))) (quote ()))) (quote ()))) ((and (pair? V1537) (and (pair? (car V1537)) (and (pair? (cdr (car V1537))) (and (pair? (car (cdr (car V1537)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V1537))))) (and (pair? (cdr (car (cdr (car V1537))))) (and (null? (cdr (cdr (car (cdr (car V1537)))))) (null? (cdr (cdr (car V1537))))))))))) (cons (cons #t (cons (cons (quote let) (cons (quote Freeze) (cons (cons (quote freeze) (cons (kl:shen.cond-form (kl:shen.encode-choices (cdr V1537) V1538)) (quote ()))) (cons (cons (quote if) (cons (car (car V1537)) (cons (cons (quote let) (cons (quote Result) (cons (car (cdr (car (cdr (car V1537))))) (cons (cons (quote if) (cons (cons (quote =) (cons (quote Result) (cons (cons (quote fail) (quote ())) (quote ())))) (cons (cons (quote thaw) (cons (quote Freeze) (quote ()))) (cons (quote Result) (quote ()))))) (quote ()))))) (cons (cons (quote thaw) (cons (quote Freeze) (quote ()))) (quote ()))))) (quote ()))))) (quote ()))) (quote ()))) ((and (pair? V1537) (and (pair? (car V1537)) (and (pair? (cdr (car V1537))) (null? (cdr (cdr (car V1537))))))) (cons (car V1537) (kl:shen.encode-choices (cdr V1537) V1538))) (#t (kl:shen.f_error (quote shen.encode-choices))))) (export shen.encode-choices) (quote shen.encode-choices))
(begin (register-function-arity (quote shen.case-form) 2) (define (kl:shen.case-form V1545 V1546) (cond ((null? V1545) (cons V1546 (quote ()))) ((and (pair? V1545) (and (pair? (car V1545)) (and (pair? (car (car V1545))) (and (eq? (quote :) (car (car (car V1545)))) (and (pair? (cdr (car (car V1545)))) (and (eq? (quote shen.tests) (car (cdr (car (car V1545))))) (and (null? (cdr (cdr (car (car V1545))))) (and (pair? (cdr (car V1545))) (and (pair? (car (cdr (car V1545)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V1545))))) (and (pair? (cdr (car (cdr (car V1545))))) (and (null? (cdr (cdr (car (cdr (car V1545)))))) (null? (cdr (cdr (car V1545)))))))))))))))) (cons (cons #t (cdr (car V1545))) (kl:shen.case-form (cdr V1545) V1546))) ((and (pair? V1545) (and (pair? (car V1545)) (and (pair? (car (car V1545))) (and (eq? (quote :) (car (car (car V1545)))) (and (pair? (cdr (car (car V1545)))) (and (eq? (quote shen.tests) (car (cdr (car (car V1545))))) (and (null? (cdr (cdr (car (car V1545))))) (and (pair? (cdr (car V1545))) (null? (cdr (cdr (car V1545)))))))))))) (cons (cons #t (cdr (car V1545))) (quote ()))) ((and (pair? V1545) (and (pair? (car V1545)) (and (pair? (car (car V1545))) (and (eq? (quote :) (car (car (car V1545)))) (and (pair? (cdr (car (car V1545)))) (and (eq? (quote shen.tests) (car (cdr (car (car V1545))))) (and (pair? (cdr (car V1545))) (null? (cdr (cdr (car V1545))))))))))) (cons (cons (kl:shen.embed-and (cdr (cdr (car (car V1545))))) (cdr (car V1545))) (kl:shen.case-form (cdr V1545) V1546))) (#t (kl:shen.f_error (quote shen.case-form))))) (export shen.case-form) (quote shen.case-form))
(begin (register-function-arity (quote shen.embed-and) 1) (define (kl:shen.embed-and V1548) (cond ((and (pair? V1548) (null? (cdr V1548))) (car V1548)) ((pair? V1548) (cons (quote and) (cons (car V1548) (cons (kl:shen.embed-and (cdr V1548)) (quote ()))))) (#t (kl:shen.f_error (quote shen.embed-and))))) (export shen.embed-and) (quote shen.embed-and))
(begin (register-function-arity (quote shen.err-condition) 1) (define (kl:shen.err-condition V1550) (cons #t (cons (cons (quote shen.f_error) (cons V1550 (quote ()))) (quote ())))) (export shen.err-condition) (quote shen.err-condition))
(begin (register-function-arity (quote shen.sys-error) 1) (define (kl:shen.sys-error V1552) (simple-error (string-append "system function " (kl:shen.app V1552 ": unexpected argument\n" (quote shen.a))))) (export shen.sys-error) (quote shen.sys-error))
