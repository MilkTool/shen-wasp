"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen->kl) 2) (define (kl:shen->kl V1191 V1192) (kl:compile (lambda (X) (kl:shen.<define> X)) (cons V1191 V1192) (lambda (X) (kl:shen-syntax-error V1191 X)))) (quote shen->kl))
(begin (register-function-arity (quote shen-syntax-error) 2) (define (kl:shen-syntax-error V1199 V1200) (cond ((pair? V1200) (simple-error (string-append "syntax error in " (kl:shen.app V1199 (string-append " here:\n\n " (kl:shen.app (kl:shen.next-50 50 (car V1200)) "\n" (quote shen.a))) (quote shen.a))))) (#t (simple-error (string-append "syntax error in " (kl:shen.app V1199 "\n" (quote shen.a))))))) (quote shen-syntax-error))
(begin (register-function-arity (quote shen.<define>) 1) (define (kl:shen.<define> V1202) (let ((YaccParse (let ((Parse_shen.<name> (kl:shen.<name> V1202))) (if (kl:not (kl:= (kl:fail) Parse_shen.<name>)) (let ((Parse_shen.<signature> (kl:shen.<signature> Parse_shen.<name>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature>)) (let ((Parse_shen.<rules> (kl:shen.<rules> Parse_shen.<signature>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rules>)) (kl:shen.pair (car Parse_shen.<rules>) (kl:shen.compile_to_machine_code (kl:shen.hdtl Parse_shen.<name>) (kl:shen.hdtl Parse_shen.<rules>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<name> (kl:shen.<name> V1202))) (if (kl:not (kl:= (kl:fail) Parse_shen.<name>)) (let ((Parse_shen.<rules> (kl:shen.<rules> Parse_shen.<name>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rules>)) (kl:shen.pair (car Parse_shen.<rules>) (kl:shen.compile_to_machine_code (kl:shen.hdtl Parse_shen.<name>) (kl:shen.hdtl Parse_shen.<rules>))) (kl:fail))) (kl:fail))) YaccParse))) (quote shen.<define>))
(begin (register-function-arity (quote shen.<name>) 1) (define (kl:shen.<name> V1204) (if (pair? (car V1204)) (let ((Parse_X (car (car V1204)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1204)) (kl:shen.hdtl V1204))) (if (and (kl:symbol? Parse_X) (kl:not (kl:shen.sysfunc? Parse_X))) Parse_X (simple-error (kl:shen.app Parse_X " is not a legitimate function name.\n" (quote shen.a)))))) (kl:fail))) (quote shen.<name>))
(begin (register-function-arity (quote shen.sysfunc?) 1) (define (kl:shen.sysfunc? V1206) (kl:element? V1206 (kl:get (kl:intern "shen") (quote shen.external-symbols) (kl:value (quote *property-vector*))))) (quote shen.sysfunc?))
(begin (register-function-arity (quote shen.<signature>) 1) (define (kl:shen.<signature> V1208) (if (and (pair? (car V1208)) (eq? (quote {) (car (car V1208)))) (let ((Parse_shen.<signature-help> (kl:shen.<signature-help> (kl:shen.pair (cdr (car V1208)) (kl:shen.hdtl V1208))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature-help>)) (if (and (pair? (car Parse_shen.<signature-help>)) (eq? (quote }) (car (car Parse_shen.<signature-help>)))) (kl:shen.pair (car (kl:shen.pair (cdr (car Parse_shen.<signature-help>)) (kl:shen.hdtl Parse_shen.<signature-help>))) (kl:shen.demodulate (kl:shen.curry-type (kl:shen.hdtl Parse_shen.<signature-help>)))) (kl:fail)) (kl:fail))) (kl:fail))) (quote shen.<signature>))
(begin (register-function-arity (quote shen.curry-type) 1) (define (kl:shen.curry-type V1210) (cond ((and (pair? V1210) (and (pair? (cdr V1210)) (and (eq? (quote -->) (car (cdr V1210))) (and (pair? (cdr (cdr V1210))) (and (pair? (cdr (cdr (cdr V1210)))) (eq? (quote -->) (car (cdr (cdr (cdr V1210)))))))))) (kl:shen.curry-type (cons (car V1210) (cons (quote -->) (cons (cdr (cdr V1210)) (quote ())))))) ((and (pair? V1210) (and (pair? (cdr V1210)) (and (eq? (quote *) (car (cdr V1210))) (and (pair? (cdr (cdr V1210))) (and (pair? (cdr (cdr (cdr V1210)))) (eq? (quote *) (car (cdr (cdr (cdr V1210)))))))))) (kl:shen.curry-type (cons (car V1210) (cons (quote *) (cons (cdr (cdr V1210)) (quote ())))))) ((pair? V1210) (kl:map (lambda (Z) (kl:shen.curry-type Z)) V1210)) (#t V1210))) (quote shen.curry-type))
(begin (register-function-arity (quote shen.<signature-help>) 1) (define (kl:shen.<signature-help> V1212) (let ((YaccParse (if (pair? (car V1212)) (let ((Parse_X (car (car V1212)))) (let ((Parse_shen.<signature-help> (kl:shen.<signature-help> (kl:shen.pair (cdr (car V1212)) (kl:shen.hdtl V1212))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature-help>)) (if (kl:not (kl:element? Parse_X (cons (quote {) (cons (quote }) (quote ()))))) (kl:shen.pair (car Parse_shen.<signature-help>) (cons Parse_X (kl:shen.hdtl Parse_shen.<signature-help>))) (kl:fail)) (kl:fail)))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1212))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<signature-help>))
(begin (register-function-arity (quote shen.<rules>) 1) (define (kl:shen.<rules> V1214) (let ((YaccParse (let ((Parse_shen.<rule> (kl:shen.<rule> V1214))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (let ((Parse_shen.<rules> (kl:shen.<rules> Parse_shen.<rule>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rules>)) (kl:shen.pair (car Parse_shen.<rules>) (cons (kl:shen.linearise (kl:shen.hdtl Parse_shen.<rule>)) (kl:shen.hdtl Parse_shen.<rules>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<rule> (kl:shen.<rule> V1214))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (kl:shen.pair (car Parse_shen.<rule>) (cons (kl:shen.linearise (kl:shen.hdtl Parse_shen.<rule>)) (quote ()))) (kl:fail))) YaccParse))) (quote shen.<rules>))
(begin (register-function-arity (quote shen.<rule>) 1) (define (kl:shen.<rule> V1216) (let ((YaccParse (let ((Parse_shen.<patterns> (kl:shen.<patterns> V1216))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote ->) (car (car Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> (kl:shen.pair (cdr (car Parse_shen.<patterns>)) (kl:shen.hdtl Parse_shen.<patterns>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (if (and (pair? (car Parse_shen.<action>)) (eq? (quote where) (car (car Parse_shen.<action>)))) (let ((Parse_shen.<guard> (kl:shen.<guard> (kl:shen.pair (cdr (car Parse_shen.<action>)) (kl:shen.hdtl Parse_shen.<action>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<guard>)) (kl:shen.pair (car Parse_shen.<guard>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (cons (quote where) (cons (kl:shen.hdtl Parse_shen.<guard>) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ())))) (quote ())))) (kl:fail))) (kl:fail)) (kl:fail))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<patterns> (kl:shen.<patterns> V1216))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote ->) (car (car Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> (kl:shen.pair (cdr (car Parse_shen.<patterns>)) (kl:shen.hdtl Parse_shen.<patterns>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (kl:shen.pair (car Parse_shen.<action>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ())))) (kl:fail))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<patterns> (kl:shen.<patterns> V1216))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote <-) (car (car Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> (kl:shen.pair (cdr (car Parse_shen.<patterns>)) (kl:shen.hdtl Parse_shen.<patterns>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (if (and (pair? (car Parse_shen.<action>)) (eq? (quote where) (car (car Parse_shen.<action>)))) (let ((Parse_shen.<guard> (kl:shen.<guard> (kl:shen.pair (cdr (car Parse_shen.<action>)) (kl:shen.hdtl Parse_shen.<action>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<guard>)) (kl:shen.pair (car Parse_shen.<guard>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (cons (quote where) (cons (kl:shen.hdtl Parse_shen.<guard>) (cons (cons (quote shen.choicepoint!) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ()))) (quote ())))) (quote ())))) (kl:fail))) (kl:fail)) (kl:fail))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<patterns> (kl:shen.<patterns> V1216))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote <-) (car (car Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> (kl:shen.pair (cdr (car Parse_shen.<patterns>)) (kl:shen.hdtl Parse_shen.<patterns>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (kl:shen.pair (car Parse_shen.<action>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (cons (quote shen.choicepoint!) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ()))) (quote ())))) (kl:fail))) (kl:fail)) (kl:fail))) YaccParse)) YaccParse)) YaccParse))) (quote shen.<rule>))
(begin (register-function-arity (quote shen.fail_if) 2) (define (kl:shen.fail_if V1219 V1220) (if (assert-boolean (V1219 V1220)) (kl:fail) V1220)) (quote shen.fail_if))
(begin (register-function-arity (quote shen.succeeds?) 1) (define (kl:shen.succeeds? V1226) (cond ((kl:= V1226 (kl:fail)) #f) (#t #t))) (quote shen.succeeds?))
(begin (register-function-arity (quote shen.<patterns>) 1) (define (kl:shen.<patterns> V1228) (let ((YaccParse (let ((Parse_shen.<pattern> (kl:shen.<pattern> V1228))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern>)) (let ((Parse_shen.<patterns> (kl:shen.<patterns> Parse_shen.<pattern>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (kl:shen.pair (car Parse_shen.<patterns>) (cons (kl:shen.hdtl Parse_shen.<pattern>) (kl:shen.hdtl Parse_shen.<patterns>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1228))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<patterns>))
(begin (register-function-arity (quote shen.<pattern>) 1) (define (kl:shen.<pattern> V1235) (let ((YaccParse (if (and (pair? (car V1235)) (pair? (car (car V1235)))) (if (and (pair? (car (kl:shen.pair (car (car V1235)) (car (cdr V1235))))) (eq? (quote _waspvm_at_p) (car (car (kl:shen.pair (car (car V1235)) (car (cdr V1235))))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> (kl:shen.pair (cdr (car (kl:shen.pair (car (car V1235)) (car (cdr V1235))))) (kl:shen.hdtl (kl:shen.pair (car (car V1235)) (car (cdr V1235)))))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (cdr (car V1235)) (car (cdr V1235)))) (cons (quote _waspvm_at_p) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V1235)) (pair? (car (car V1235)))) (if (and (pair? (car (kl:shen.pair (car (car V1235)) (car (cdr V1235))))) (eq? (quote cons) (car (car (kl:shen.pair (car (car V1235)) (car (cdr V1235))))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> (kl:shen.pair (cdr (car (kl:shen.pair (car (car V1235)) (car (cdr V1235))))) (kl:shen.hdtl (kl:shen.pair (car (car V1235)) (car (cdr V1235)))))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (cdr (car V1235)) (car (cdr V1235)))) (cons (quote cons) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V1235)) (pair? (car (car V1235)))) (if (and (pair? (car (kl:shen.pair (car (car V1235)) (car (cdr V1235))))) (eq? (quote _waspvm_at_v) (car (car (kl:shen.pair (car (car V1235)) (car (cdr V1235))))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> (kl:shen.pair (cdr (car (kl:shen.pair (car (car V1235)) (car (cdr V1235))))) (kl:shen.hdtl (kl:shen.pair (car (car V1235)) (car (cdr V1235)))))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (cdr (car V1235)) (car (cdr V1235)))) (cons (quote _waspvm_at_v) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V1235)) (pair? (car (car V1235)))) (if (and (pair? (car (kl:shen.pair (car (car V1235)) (car (cdr V1235))))) (eq? (quote _waspvm_at_s) (car (car (kl:shen.pair (car (car V1235)) (car (cdr V1235))))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> (kl:shen.pair (cdr (car (kl:shen.pair (car (car V1235)) (car (cdr V1235))))) (kl:shen.hdtl (kl:shen.pair (car (car V1235)) (car (cdr V1235)))))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (cdr (car V1235)) (car (cdr V1235)))) (cons (quote _waspvm_at_s) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V1235)) (pair? (car (car V1235)))) (if (and (pair? (car (kl:shen.pair (car (car V1235)) (car (cdr V1235))))) (eq? (quote vector) (car (car (kl:shen.pair (car (car V1235)) (car (cdr V1235))))))) (if (and (pair? (car (kl:shen.pair (cdr (car (kl:shen.pair (car (car V1235)) (car (cdr V1235))))) (kl:shen.hdtl (kl:shen.pair (car (car V1235)) (car (cdr V1235))))))) (kl:= 0 (car (car (kl:shen.pair (cdr (car (kl:shen.pair (car (car V1235)) (car (cdr V1235))))) (kl:shen.hdtl (kl:shen.pair (car (car V1235)) (car (cdr V1235))))))))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1235)) (car (cdr V1235)))) (cons (quote vector) (cons 0 (quote ())))) (kl:fail)) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (pair? (car V1235)) (let ((Parse_X (car (car V1235)))) (if (pair? Parse_X) (kl:shen.pair (car (kl:shen.pair (cdr (car V1235)) (kl:shen.hdtl V1235))) (kl:shen.constructor-error Parse_X)) (kl:fail))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<simple_pattern> (kl:shen.<simple_pattern> V1235))) (if (kl:not (kl:= (kl:fail) Parse_shen.<simple_pattern>)) (kl:shen.pair (car Parse_shen.<simple_pattern>) (kl:shen.hdtl Parse_shen.<simple_pattern>)) (kl:fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse))) (quote shen.<pattern>))
(begin (register-function-arity (quote shen.constructor-error) 1) (define (kl:shen.constructor-error V1237) (simple-error (kl:shen.app V1237 " is not a legitimate constructor\n" (quote shen.a)))) (quote shen.constructor-error))
(begin (register-function-arity (quote shen.<simple_pattern>) 1) (define (kl:shen.<simple_pattern> V1239) (let ((YaccParse (if (pair? (car V1239)) (let ((Parse_X (car (car V1239)))) (if (eq? Parse_X (quote _)) (kl:shen.pair (car (kl:shen.pair (cdr (car V1239)) (kl:shen.hdtl V1239))) (kl:gensym (quote Parse_Y))) (kl:fail))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (if (pair? (car V1239)) (let ((Parse_X (car (car V1239)))) (if (kl:not (kl:element? Parse_X (cons (quote ->) (cons (quote <-) (quote ()))))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1239)) (kl:shen.hdtl V1239))) Parse_X) (kl:fail))) (kl:fail)) YaccParse))) (quote shen.<simple_pattern>))
(begin (register-function-arity (quote shen.<pattern1>) 1) (define (kl:shen.<pattern1> V1241) (let ((Parse_shen.<pattern> (kl:shen.<pattern> V1241))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern>)) (kl:shen.pair (car Parse_shen.<pattern>) (kl:shen.hdtl Parse_shen.<pattern>)) (kl:fail)))) (quote shen.<pattern1>))
(begin (register-function-arity (quote shen.<pattern2>) 1) (define (kl:shen.<pattern2> V1243) (let ((Parse_shen.<pattern> (kl:shen.<pattern> V1243))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern>)) (kl:shen.pair (car Parse_shen.<pattern>) (kl:shen.hdtl Parse_shen.<pattern>)) (kl:fail)))) (quote shen.<pattern2>))
(begin (register-function-arity (quote shen.<action>) 1) (define (kl:shen.<action> V1245) (if (pair? (car V1245)) (let ((Parse_X (car (car V1245)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1245)) (kl:shen.hdtl V1245))) Parse_X)) (kl:fail))) (quote shen.<action>))
(begin (register-function-arity (quote shen.<guard>) 1) (define (kl:shen.<guard> V1247) (if (pair? (car V1247)) (let ((Parse_X (car (car V1247)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1247)) (kl:shen.hdtl V1247))) Parse_X)) (kl:fail))) (quote shen.<guard>))
(begin (register-function-arity (quote shen.compile_to_machine_code) 2) (define (kl:shen.compile_to_machine_code V1250 V1251) (let ((Lambda+ (kl:shen.compile_to_lambda+ V1250 V1251))) (let ((KL (kl:shen.compile_to_kl V1250 Lambda+))) (let ((Record (kl:shen.record-source V1250 KL))) KL)))) (quote shen.compile_to_machine_code))
(begin (register-function-arity (quote shen.record-source) 2) (define (kl:shen.record-source V1256 V1257) (cond ((assert-boolean (kl:value (quote shen.*installing-kl*))) (quote shen.skip)) (#t (kl:put V1256 (quote shen.source) V1257 (kl:value (quote *property-vector*)))))) (quote shen.record-source))
(begin (register-function-arity (quote shen.compile_to_lambda+) 2) (define (kl:shen.compile_to_lambda+ V1260 V1261) (let ((Arity (kl:shen.aritycheck V1260 V1261))) (let ((UpDateSymbolTable (kl:shen.update-symbol-table V1260 Arity))) (let ((Free (kl:map (lambda (Rule) (kl:shen.free_variable_check V1260 Rule)) V1261))) (let ((Variables (kl:shen.parameters Arity))) (let ((Strip (kl:map (lambda (X) (kl:shen.strip-protect X)) V1261))) (let ((Abstractions (kl:map (lambda (X) (kl:shen.abstract_rule X)) Strip))) (let ((Applications (kl:map (lambda (X) (kl:shen.application_build Variables X)) Abstractions))) (cons Variables (cons Applications (quote ()))))))))))) (quote shen.compile_to_lambda+))
(begin (register-function-arity (quote shen.update-symbol-table) 2) (define (kl:shen.update-symbol-table V1264 V1265) (kl:set (quote shen.*symbol-table*) (kl:shen.update-symbol-table-h V1264 V1265 (kl:value (quote shen.*symbol-table*)) (quote ())))) (quote shen.update-symbol-table))
(begin (register-function-arity (quote shen.update-symbol-table-h) 4) (define (kl:shen.update-symbol-table-h V1273 V1274 V1275 V1276) (cond ((null? V1275) (let ((NewEntry (cons V1273 (kl:eval-kl (kl:shen.lambda-form V1273 V1274))))) (cons NewEntry V1276))) ((and (pair? V1275) (and (pair? (car V1275)) (kl:= (car (car V1275)) V1273))) (let ((ChangedEntry (cons (car (car V1275)) (kl:eval-kl (kl:shen.lambda-form (car (car V1275)) V1274))))) (kl:append (cdr V1275) (cons ChangedEntry V1276)))) ((pair? V1275) (kl:shen.update-symbol-table-h V1273 V1274 (cdr V1275) (cons (car V1275) V1276))) (#t (kl:shen.f_error (quote shen.update-symbol-table-h))))) (quote shen.update-symbol-table-h))
(begin (register-function-arity (quote shen.free_variable_check) 2) (define (kl:shen.free_variable_check V1279 V1280) (cond ((and (pair? V1280) (and (pair? (cdr V1280)) (null? (cdr (cdr V1280))))) (let ((Bound (kl:shen.extract_vars (car V1280)))) (let ((Free (kl:shen.extract_free_vars Bound (car (cdr V1280))))) (kl:shen.free_variable_warnings V1279 Free)))) (#t (kl:shen.f_error (quote shen.free_variable_check))))) (quote shen.free_variable_check))
(begin (register-function-arity (quote shen.extract_vars) 1) (define (kl:shen.extract_vars V1282) (cond ((kl:variable? V1282) (cons V1282 (quote ()))) ((pair? V1282) (kl:union (kl:shen.extract_vars (car V1282)) (kl:shen.extract_vars (cdr V1282)))) (#t (quote ())))) (quote shen.extract_vars))
(begin (register-function-arity (quote shen.extract_free_vars) 2) (define (kl:shen.extract_free_vars V1294 V1295) (cond ((and (pair? V1295) (and (pair? (cdr V1295)) (and (null? (cdr (cdr V1295))) (eq? (car V1295) (quote protect))))) (quote ())) ((and (kl:variable? V1295) (kl:not (kl:element? V1295 V1294))) (cons V1295 (quote ()))) ((and (pair? V1295) (and (eq? (quote lambda) (car V1295)) (and (pair? (cdr V1295)) (and (pair? (cdr (cdr V1295))) (null? (cdr (cdr (cdr V1295)))))))) (kl:shen.extract_free_vars (cons (car (cdr V1295)) V1294) (car (cdr (cdr V1295))))) ((and (pair? V1295) (and (eq? (quote let) (car V1295)) (and (pair? (cdr V1295)) (and (pair? (cdr (cdr V1295))) (and (pair? (cdr (cdr (cdr V1295)))) (null? (cdr (cdr (cdr (cdr V1295)))))))))) (kl:union (kl:shen.extract_free_vars V1294 (car (cdr (cdr V1295)))) (kl:shen.extract_free_vars (cons (car (cdr V1295)) V1294) (car (cdr (cdr (cdr V1295))))))) ((pair? V1295) (kl:union (kl:shen.extract_free_vars V1294 (car V1295)) (kl:shen.extract_free_vars V1294 (cdr V1295)))) (#t (quote ())))) (quote shen.extract_free_vars))
(begin (register-function-arity (quote shen.free_variable_warnings) 2) (define (kl:shen.free_variable_warnings V1300 V1301) (cond ((null? V1301) (quote _)) (#t (simple-error (string-append "error: the following variables are free in " (kl:shen.app V1300 (string-append ": " (kl:shen.app (kl:shen.list_variables V1301) "" (quote shen.a))) (quote shen.a))))))) (quote shen.free_variable_warnings))
(begin (register-function-arity (quote shen.list_variables) 1) (define (kl:shen.list_variables V1303) (cond ((and (pair? V1303) (null? (cdr V1303))) (string-append (kl:str (car V1303)) ".")) ((pair? V1303) (string-append (kl:str (car V1303)) (string-append ", " (kl:shen.list_variables (cdr V1303))))) (#t (kl:shen.f_error (quote shen.list_variables))))) (quote shen.list_variables))
(begin (register-function-arity (quote shen.strip-protect) 1) (define (kl:shen.strip-protect V1305) (cond ((and (pair? V1305) (and (pair? (cdr V1305)) (and (null? (cdr (cdr V1305))) (eq? (car V1305) (quote protect))))) (kl:shen.strip-protect (car (cdr V1305)))) ((pair? V1305) (kl:map (lambda (Z) (kl:shen.strip-protect Z)) V1305)) (#t V1305))) (quote shen.strip-protect))
(begin (register-function-arity (quote shen.linearise) 1) (define (kl:shen.linearise V1307) (cond ((and (pair? V1307) (and (pair? (cdr V1307)) (null? (cdr (cdr V1307))))) (kl:shen.linearise_help (kl:shen.flatten (car V1307)) (car V1307) (car (cdr V1307)))) (#t (kl:shen.f_error (quote shen.linearise))))) (quote shen.linearise))
(begin (register-function-arity (quote shen.flatten) 1) (define (kl:shen.flatten V1309) (cond ((null? V1309) (quote ())) ((pair? V1309) (kl:append (kl:shen.flatten (car V1309)) (kl:shen.flatten (cdr V1309)))) (#t (cons V1309 (quote ()))))) (quote shen.flatten))
(begin (register-function-arity (quote shen.linearise_help) 3) (define (kl:shen.linearise_help V1313 V1314 V1315) (cond ((null? V1313) (cons V1314 (cons V1315 (quote ())))) ((pair? V1313) (if (and (kl:variable? (car V1313)) (kl:element? (car V1313) (cdr V1313))) (let ((Var (kl:gensym (car V1313)))) (let ((NewAction (cons (quote where) (cons (cons (quote =) (cons (car V1313) (cons Var (quote ())))) (cons V1315 (quote ())))))) (let ((NewPatts (kl:shen.linearise_X (car V1313) Var V1314))) (kl:shen.linearise_help (cdr V1313) NewPatts NewAction)))) (kl:shen.linearise_help (cdr V1313) V1314 V1315))) (#t (kl:shen.f_error (quote shen.linearise_help))))) (quote shen.linearise_help))
(begin (register-function-arity (quote shen.linearise_X) 3) (define (kl:shen.linearise_X V1328 V1329 V1330) (cond ((kl:= V1330 V1328) V1329) ((pair? V1330) (let ((L (kl:shen.linearise_X V1328 V1329 (car V1330)))) (if (kl:= L (car V1330)) (cons (car V1330) (kl:shen.linearise_X V1328 V1329 (cdr V1330))) (cons L (cdr V1330))))) (#t V1330))) (quote shen.linearise_X))
(begin (register-function-arity (quote shen.aritycheck) 2) (define (kl:shen.aritycheck V1333 V1334) (cond ((and (pair? V1334) (and (pair? (car V1334)) (and (pair? (cdr (car V1334))) (and (null? (cdr (cdr (car V1334)))) (null? (cdr V1334)))))) (begin (kl:shen.aritycheck-action (car (cdr (car V1334)))) (kl:shen.aritycheck-name V1333 (kl:arity V1333) (kl:length (car (car V1334)))))) ((and (pair? V1334) (and (pair? (car V1334)) (and (pair? (cdr (car V1334))) (and (null? (cdr (cdr (car V1334)))) (and (pair? (cdr V1334)) (and (pair? (car (cdr V1334))) (and (pair? (cdr (car (cdr V1334)))) (null? (cdr (cdr (car (cdr V1334)))))))))))) (if (kl:= (kl:length (car (car V1334))) (kl:length (car (car (cdr V1334))))) (begin (kl:shen.aritycheck-action (car (cdr (car V1334)))) (kl:shen.aritycheck V1333 (cdr V1334))) (simple-error (string-append "arity error in " (kl:shen.app V1333 "\n" (quote shen.a)))))) (#t (kl:shen.f_error (quote shen.aritycheck))))) (quote shen.aritycheck))
(begin (register-function-arity (quote shen.aritycheck-name) 3) (define (kl:shen.aritycheck-name V1347 V1348 V1349) (cond ((kl:= -1 V1348) V1349) ((kl:= V1349 V1348) V1349) (#t (begin (kl:shen.prhush (string-append "\nwarning: changing the arity of " (kl:shen.app V1347 " can cause errors.\n" (quote shen.a))) (kl:stoutput)) V1349)))) (quote shen.aritycheck-name))
(begin (register-function-arity (quote shen.aritycheck-action) 1) (define (kl:shen.aritycheck-action V1355) (cond ((pair? V1355) (begin (kl:shen.aah (car V1355) (cdr V1355)) (kl:map (lambda (Y) (kl:shen.aritycheck-action Y)) V1355))) (#t (quote shen.skip)))) (quote shen.aritycheck-action))
(begin (register-function-arity (quote shen.aah) 2) (define (kl:shen.aah V1358 V1359) (let ((Arity (kl:arity V1358))) (let ((Len (kl:length V1359))) (if (and (> Arity -1) (> Len Arity)) (kl:shen.prhush (string-append "warning: " (kl:shen.app V1358 (string-append " might not like " (kl:shen.app Len (string-append " argument" (kl:shen.app (if (> Len 1) "s" "") ".\n" (quote shen.a))) (quote shen.a))) (quote shen.a))) (kl:stoutput)) (quote shen.skip))))) (quote shen.aah))
(begin (register-function-arity (quote shen.abstract_rule) 1) (define (kl:shen.abstract_rule V1361) (cond ((and (pair? V1361) (and (pair? (cdr V1361)) (null? (cdr (cdr V1361))))) (kl:shen.abstraction_build (car V1361) (car (cdr V1361)))) (#t (kl:shen.f_error (quote shen.abstract_rule))))) (quote shen.abstract_rule))
(begin (register-function-arity (quote shen.abstraction_build) 2) (define (kl:shen.abstraction_build V1364 V1365) (cond ((null? V1364) V1365) ((pair? V1364) (cons (quote /.) (cons (car V1364) (cons (kl:shen.abstraction_build (cdr V1364) V1365) (quote ()))))) (#t (kl:shen.f_error (quote shen.abstraction_build))))) (quote shen.abstraction_build))
(begin (register-function-arity (quote shen.parameters) 1) (define (kl:shen.parameters V1367) (cond ((kl:= 0 V1367) (quote ())) (#t (cons (kl:gensym (quote V)) (kl:shen.parameters (- V1367 1)))))) (quote shen.parameters))
(begin (register-function-arity (quote shen.application_build) 2) (define (kl:shen.application_build V1370 V1371) (cond ((null? V1370) V1371) ((pair? V1370) (kl:shen.application_build (cdr V1370) (cons V1371 (cons (car V1370) (quote ()))))) (#t (kl:shen.f_error (quote shen.application_build))))) (quote shen.application_build))
(begin (register-function-arity (quote shen.compile_to_kl) 2) (define (kl:shen.compile_to_kl V1374 V1375) (cond ((and (pair? V1375) (and (pair? (cdr V1375)) (null? (cdr (cdr V1375))))) (let ((Arity (kl:shen.store-arity V1374 (kl:length (car V1375))))) (let ((Reduce (kl:map (lambda (X) (kl:shen.reduce X)) (car (cdr V1375))))) (let ((CondExpression (kl:shen.cond-expression V1374 (car V1375) Reduce))) (let ((TypeTable (if (assert-boolean (kl:value (quote shen.*optimise*))) (kl:shen.typextable (kl:shen.get-type V1374) (car V1375)) (quote shen.skip)))) (let ((TypedCondExpression (if (assert-boolean (kl:value (quote shen.*optimise*))) (kl:shen.assign-types (car V1375) TypeTable CondExpression) CondExpression))) (cons (quote defun) (cons V1374 (cons (car V1375) (cons TypedCondExpression (quote ()))))))))))) (#t (kl:shen.f_error (quote shen.compile_to_kl))))) (quote shen.compile_to_kl))
(begin (register-function-arity (quote shen.get-type) 1) (define (kl:shen.get-type V1381) (cond ((pair? V1381) (quote shen.skip)) (#t (let ((FType (kl:assoc V1381 (kl:value (quote shen.*signedfuncs*))))) (if (kl:empty? FType) (quote shen.skip) (cdr FType)))))) (quote shen.get-type))
(begin (register-function-arity (quote shen.typextable) 2) (define (kl:shen.typextable V1392 V1393) (cond ((and (pair? V1392) (and (pair? (cdr V1392)) (and (eq? (quote -->) (car (cdr V1392))) (and (pair? (cdr (cdr V1392))) (and (null? (cdr (cdr (cdr V1392)))) (pair? V1393)))))) (if (kl:variable? (car V1392)) (kl:shen.typextable (car (cdr (cdr V1392))) (cdr V1393)) (cons (cons (car V1393) (car V1392)) (kl:shen.typextable (car (cdr (cdr V1392))) (cdr V1393))))) (#t (quote ())))) (quote shen.typextable))
(begin (register-function-arity (quote shen.assign-types) 3) (define (kl:shen.assign-types V1397 V1398 V1399) (cond ((and (pair? V1399) (and (eq? (quote let) (car V1399)) (and (pair? (cdr V1399)) (and (pair? (cdr (cdr V1399))) (and (pair? (cdr (cdr (cdr V1399)))) (null? (cdr (cdr (cdr (cdr V1399)))))))))) (cons (quote let) (cons (car (cdr V1399)) (cons (kl:shen.assign-types V1397 V1398 (car (cdr (cdr V1399)))) (cons (kl:shen.assign-types (cons (car (cdr V1399)) V1397) V1398 (car (cdr (cdr (cdr V1399))))) (quote ())))))) ((and (pair? V1399) (and (eq? (quote lambda) (car V1399)) (and (pair? (cdr V1399)) (and (pair? (cdr (cdr V1399))) (null? (cdr (cdr (cdr V1399)))))))) (cons (quote lambda) (cons (car (cdr V1399)) (cons (kl:shen.assign-types (cons (car (cdr V1399)) V1397) V1398 (car (cdr (cdr V1399)))) (quote ()))))) ((and (pair? V1399) (eq? (quote cond) (car V1399))) (cons (quote cond) (kl:map (lambda (Y) (cons (kl:shen.assign-types V1397 V1398 (car Y)) (cons (kl:shen.assign-types V1397 V1398 (car (cdr Y))) (quote ())))) (cdr V1399)))) ((pair? V1399) (let ((NewTable (kl:shen.typextable (kl:shen.get-type (car V1399)) (cdr V1399)))) (cons (car V1399) (kl:map (lambda (Y) (kl:shen.assign-types V1397 (kl:append V1398 NewTable) Y)) (cdr V1399))))) (#t (let ((AtomType (kl:assoc V1399 V1398))) (if (pair? AtomType) (cons (quote type) (cons V1399 (cons (cdr AtomType) (quote ())))) (if (kl:element? V1399 V1397) V1399 (kl:shen.atom-type V1399))))))) (quote shen.assign-types))
(begin (register-function-arity (quote shen.atom-type) 1) (define (kl:shen.atom-type V1401) (if (string? V1401) (cons (quote type) (cons V1401 (cons (quote string) (quote ())))) (if (number? V1401) (cons (quote type) (cons V1401 (cons (quote number) (quote ())))) (if (kl:boolean? V1401) (cons (quote type) (cons V1401 (cons (quote boolean) (quote ())))) (if (kl:symbol? V1401) (cons (quote type) (cons V1401 (cons (quote symbol) (quote ())))) V1401))))) (quote shen.atom-type))
(begin (register-function-arity (quote shen.store-arity) 2) (define (kl:shen.store-arity V1406 V1407) (cond ((assert-boolean (kl:value (quote shen.*installing-kl*))) (quote shen.skip)) (#t (kl:put V1406 (quote arity) V1407 (kl:value (quote *property-vector*)))))) (quote shen.store-arity))
(begin (register-function-arity (quote shen.reduce) 1) (define (kl:shen.reduce V1409) (begin (kl:set (quote shen.*teststack*) (quote ())) (let ((Result (kl:shen.reduce_help V1409))) (cons (cons (quote :) (cons (quote shen.tests) (kl:reverse (kl:value (quote shen.*teststack*))))) (cons Result (quote ())))))) (quote shen.reduce))
(begin (register-function-arity (quote shen.reduce_help) 1) (define (kl:shen.reduce_help V1411) (cond ((and (pair? V1411) (and (pair? (car V1411)) (and (eq? (quote /.) (car (car V1411))) (and (pair? (cdr (car V1411))) (and (pair? (car (cdr (car V1411)))) (and (eq? (quote cons) (car (car (cdr (car V1411))))) (and (pair? (cdr (car (cdr (car V1411))))) (and (pair? (cdr (cdr (car (cdr (car V1411)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1411))))))) (and (pair? (cdr (cdr (car V1411)))) (and (null? (cdr (cdr (cdr (car V1411))))) (and (pair? (cdr V1411)) (null? (cdr (cdr V1411))))))))))))))) (begin (kl:shen.add_test (cons (quote cons?) (cdr V1411))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V1411))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V1411)))))) (cons (kl:shen.ebr (car (cdr V1411)) (car (cdr (car V1411))) (car (cdr (cdr (car V1411))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote hd) (cdr V1411)) (quote ()))) (cons (cons (quote tl) (cdr V1411)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V1411) (and (pair? (car V1411)) (and (eq? (quote /.) (car (car V1411))) (and (pair? (cdr (car V1411))) (and (pair? (car (cdr (car V1411)))) (and (eq? (quote _waspvm_at_p) (car (car (cdr (car V1411))))) (and (pair? (cdr (car (cdr (car V1411))))) (and (pair? (cdr (cdr (car (cdr (car V1411)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1411))))))) (and (pair? (cdr (cdr (car V1411)))) (and (null? (cdr (cdr (cdr (car V1411))))) (and (pair? (cdr V1411)) (null? (cdr (cdr V1411))))))))))))))) (begin (kl:shen.add_test (cons (quote tuple?) (cdr V1411))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V1411))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V1411)))))) (cons (kl:shen.ebr (car (cdr V1411)) (car (cdr (car V1411))) (car (cdr (cdr (car V1411))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote fst) (cdr V1411)) (quote ()))) (cons (cons (quote snd) (cdr V1411)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V1411) (and (pair? (car V1411)) (and (eq? (quote /.) (car (car V1411))) (and (pair? (cdr (car V1411))) (and (pair? (car (cdr (car V1411)))) (and (eq? (quote _waspvm_at_v) (car (car (cdr (car V1411))))) (and (pair? (cdr (car (cdr (car V1411))))) (and (pair? (cdr (cdr (car (cdr (car V1411)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1411))))))) (and (pair? (cdr (cdr (car V1411)))) (and (null? (cdr (cdr (cdr (car V1411))))) (and (pair? (cdr V1411)) (null? (cdr (cdr V1411))))))))))))))) (begin (kl:shen.add_test (cons (quote shen.+vector?) (cdr V1411))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V1411))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V1411)))))) (cons (kl:shen.ebr (car (cdr V1411)) (car (cdr (car V1411))) (car (cdr (cdr (car V1411))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote hdv) (cdr V1411)) (quote ()))) (cons (cons (quote tlv) (cdr V1411)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V1411) (and (pair? (car V1411)) (and (eq? (quote /.) (car (car V1411))) (and (pair? (cdr (car V1411))) (and (pair? (car (cdr (car V1411)))) (and (eq? (quote _waspvm_at_s) (car (car (cdr (car V1411))))) (and (pair? (cdr (car (cdr (car V1411))))) (and (pair? (cdr (cdr (car (cdr (car V1411)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1411))))))) (and (pair? (cdr (cdr (car V1411)))) (and (null? (cdr (cdr (cdr (car V1411))))) (and (pair? (cdr V1411)) (null? (cdr (cdr V1411))))))))))))))) (begin (kl:shen.add_test (cons (quote shen.+string?) (cdr V1411))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V1411))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V1411)))))) (cons (kl:shen.ebr (car (cdr V1411)) (car (cdr (car V1411))) (car (cdr (cdr (car V1411))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote pos) (cons (car (cdr V1411)) (cons 0 (quote ())))) (quote ()))) (cons (cons (quote tlstr) (cdr V1411)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V1411) (and (pair? (car V1411)) (and (eq? (quote /.) (car (car V1411))) (and (pair? (cdr (car V1411))) (and (pair? (cdr (cdr (car V1411)))) (and (null? (cdr (cdr (cdr (car V1411))))) (and (pair? (cdr V1411)) (and (null? (cdr (cdr V1411))) (kl:not (kl:variable? (car (cdr (car V1411))))))))))))) (begin (kl:shen.add_test (cons (quote =) (cons (car (cdr (car V1411))) (cdr V1411)))) (kl:shen.reduce_help (car (cdr (cdr (car V1411))))))) ((and (pair? V1411) (and (pair? (car V1411)) (and (eq? (quote /.) (car (car V1411))) (and (pair? (cdr (car V1411))) (and (pair? (cdr (cdr (car V1411)))) (and (null? (cdr (cdr (cdr (car V1411))))) (and (pair? (cdr V1411)) (null? (cdr (cdr V1411)))))))))) (kl:shen.reduce_help (kl:shen.ebr (car (cdr V1411)) (car (cdr (car V1411))) (car (cdr (cdr (car V1411))))))) ((and (pair? V1411) (and (eq? (quote where) (car V1411)) (and (pair? (cdr V1411)) (and (pair? (cdr (cdr V1411))) (null? (cdr (cdr (cdr V1411)))))))) (begin (kl:shen.add_test (car (cdr V1411))) (kl:shen.reduce_help (car (cdr (cdr V1411)))))) ((and (pair? V1411) (and (pair? (cdr V1411)) (null? (cdr (cdr V1411))))) (let ((Z (kl:shen.reduce_help (car V1411)))) (if (kl:= (car V1411) Z) V1411 (kl:shen.reduce_help (cons Z (cdr V1411)))))) (#t V1411))) (quote shen.reduce_help))
(begin (register-function-arity (quote shen.+string?) 1) (define (kl:shen.+string? V1413) (cond ((equal? "" V1413) #f) (#t (string? V1413)))) (quote shen.+string?))
(begin (register-function-arity (quote shen.+vector) 1) (define (kl:shen.+vector V1415) (cond ((kl:= V1415 (kl:vector 0)) #f) (#t (kl:vector? V1415)))) (quote shen.+vector))
(begin (register-function-arity (quote shen.ebr) 3) (define (kl:shen.ebr V1429 V1430 V1431) (cond ((kl:= V1431 V1430) V1429) ((and (pair? V1431) (and (eq? (quote /.) (car V1431)) (and (pair? (cdr V1431)) (and (pair? (cdr (cdr V1431))) (and (null? (cdr (cdr (cdr V1431)))) (> (kl:occurrences V1430 (car (cdr V1431))) 0)))))) V1431) ((and (pair? V1431) (and (eq? (quote lambda) (car V1431)) (and (pair? (cdr V1431)) (and (pair? (cdr (cdr V1431))) (and (null? (cdr (cdr (cdr V1431)))) (> (kl:occurrences V1430 (car (cdr V1431))) 0)))))) V1431) ((and (pair? V1431) (and (eq? (quote let) (car V1431)) (and (pair? (cdr V1431)) (and (pair? (cdr (cdr V1431))) (and (pair? (cdr (cdr (cdr V1431)))) (and (null? (cdr (cdr (cdr (cdr V1431))))) (kl:= (car (cdr V1431)) V1430))))))) (cons (quote let) (cons (car (cdr V1431)) (cons (kl:shen.ebr V1429 (car (cdr V1431)) (car (cdr (cdr V1431)))) (cdr (cdr (cdr V1431))))))) ((pair? V1431) (cons (kl:shen.ebr V1429 V1430 (car V1431)) (kl:shen.ebr V1429 V1430 (cdr V1431)))) (#t V1431))) (quote shen.ebr))
(begin (register-function-arity (quote shen.add_test) 1) (define (kl:shen.add_test V1433) (kl:set (quote shen.*teststack*) (cons V1433 (kl:value (quote shen.*teststack*))))) (quote shen.add_test))
(begin (register-function-arity (quote shen.cond-expression) 3) (define (kl:shen.cond-expression V1437 V1438 V1439) (let ((Err (kl:shen.err-condition V1437))) (let ((Cases (kl:shen.case-form V1439 Err))) (let ((EncodeChoices (kl:shen.encode-choices Cases V1437))) (kl:shen.cond-form EncodeChoices))))) (quote shen.cond-expression))
(begin (register-function-arity (quote shen.cond-form) 1) (define (kl:shen.cond-form V1443) (cond ((and (pair? V1443) (and (pair? (car V1443)) (and (kl:= #t (car (car V1443))) (and (pair? (cdr (car V1443))) (null? (cdr (cdr (car V1443)))))))) (car (cdr (car V1443)))) (#t (cons (quote cond) V1443)))) (quote shen.cond-form))
(begin (register-function-arity (quote shen.encode-choices) 2) (define (kl:shen.encode-choices V1448 V1449) (cond ((null? V1448) (quote ())) ((and (pair? V1448) (and (pair? (car V1448)) (and (kl:= #t (car (car V1448))) (and (pair? (cdr (car V1448))) (and (pair? (car (cdr (car V1448)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V1448))))) (and (pair? (cdr (car (cdr (car V1448))))) (and (null? (cdr (cdr (car (cdr (car V1448)))))) (and (null? (cdr (cdr (car V1448)))) (null? (cdr V1448))))))))))) (cons (cons #t (cons (cons (quote let) (cons (quote Result) (cons (car (cdr (car (cdr (car V1448))))) (cons (cons (quote if) (cons (cons (quote =) (cons (quote Result) (cons (cons (quote fail) (quote ())) (quote ())))) (cons (if (assert-boolean (kl:value (quote shen.*installing-kl*))) (cons (quote shen.sys-error) (cons V1449 (quote ()))) (cons (quote shen.f_error) (cons V1449 (quote ())))) (cons (quote Result) (quote ()))))) (quote ()))))) (quote ()))) (quote ()))) ((and (pair? V1448) (and (pair? (car V1448)) (and (kl:= #t (car (car V1448))) (and (pair? (cdr (car V1448))) (and (pair? (car (cdr (car V1448)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V1448))))) (and (pair? (cdr (car (cdr (car V1448))))) (and (null? (cdr (cdr (car (cdr (car V1448)))))) (null? (cdr (cdr (car V1448)))))))))))) (cons (cons #t (cons (cons (quote let) (cons (quote Result) (cons (car (cdr (car (cdr (car V1448))))) (cons (cons (quote if) (cons (cons (quote =) (cons (quote Result) (cons (cons (quote fail) (quote ())) (quote ())))) (cons (kl:shen.cond-form (kl:shen.encode-choices (cdr V1448) V1449)) (cons (quote Result) (quote ()))))) (quote ()))))) (quote ()))) (quote ()))) ((and (pair? V1448) (and (pair? (car V1448)) (and (pair? (cdr (car V1448))) (and (pair? (car (cdr (car V1448)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V1448))))) (and (pair? (cdr (car (cdr (car V1448))))) (and (null? (cdr (cdr (car (cdr (car V1448)))))) (null? (cdr (cdr (car V1448))))))))))) (cons (cons #t (cons (cons (quote let) (cons (quote Freeze) (cons (cons (quote freeze) (cons (kl:shen.cond-form (kl:shen.encode-choices (cdr V1448) V1449)) (quote ()))) (cons (cons (quote if) (cons (car (car V1448)) (cons (cons (quote let) (cons (quote Result) (cons (car (cdr (car (cdr (car V1448))))) (cons (cons (quote if) (cons (cons (quote =) (cons (quote Result) (cons (cons (quote fail) (quote ())) (quote ())))) (cons (cons (quote thaw) (cons (quote Freeze) (quote ()))) (cons (quote Result) (quote ()))))) (quote ()))))) (cons (cons (quote thaw) (cons (quote Freeze) (quote ()))) (quote ()))))) (quote ()))))) (quote ()))) (quote ()))) ((and (pair? V1448) (and (pair? (car V1448)) (and (pair? (cdr (car V1448))) (null? (cdr (cdr (car V1448))))))) (cons (car V1448) (kl:shen.encode-choices (cdr V1448) V1449))) (#t (kl:shen.f_error (quote shen.encode-choices))))) (quote shen.encode-choices))
(begin (register-function-arity (quote shen.case-form) 2) (define (kl:shen.case-form V1456 V1457) (cond ((null? V1456) (cons V1457 (quote ()))) ((and (pair? V1456) (and (pair? (car V1456)) (and (pair? (car (car V1456))) (and (eq? (quote :) (car (car (car V1456)))) (and (pair? (cdr (car (car V1456)))) (and (eq? (quote shen.tests) (car (cdr (car (car V1456))))) (and (null? (cdr (cdr (car (car V1456))))) (and (pair? (cdr (car V1456))) (and (pair? (car (cdr (car V1456)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V1456))))) (and (pair? (cdr (car (cdr (car V1456))))) (and (null? (cdr (cdr (car (cdr (car V1456)))))) (null? (cdr (cdr (car V1456)))))))))))))))) (cons (cons #t (cdr (car V1456))) (kl:shen.case-form (cdr V1456) V1457))) ((and (pair? V1456) (and (pair? (car V1456)) (and (pair? (car (car V1456))) (and (eq? (quote :) (car (car (car V1456)))) (and (pair? (cdr (car (car V1456)))) (and (eq? (quote shen.tests) (car (cdr (car (car V1456))))) (and (null? (cdr (cdr (car (car V1456))))) (and (pair? (cdr (car V1456))) (null? (cdr (cdr (car V1456)))))))))))) (cons (cons #t (cdr (car V1456))) (quote ()))) ((and (pair? V1456) (and (pair? (car V1456)) (and (pair? (car (car V1456))) (and (eq? (quote :) (car (car (car V1456)))) (and (pair? (cdr (car (car V1456)))) (and (eq? (quote shen.tests) (car (cdr (car (car V1456))))) (and (pair? (cdr (car V1456))) (null? (cdr (cdr (car V1456))))))))))) (cons (cons (kl:shen.embed-and (cdr (cdr (car (car V1456))))) (cdr (car V1456))) (kl:shen.case-form (cdr V1456) V1457))) (#t (kl:shen.f_error (quote shen.case-form))))) (quote shen.case-form))
(begin (register-function-arity (quote shen.embed-and) 1) (define (kl:shen.embed-and V1459) (cond ((and (pair? V1459) (null? (cdr V1459))) (car V1459)) ((pair? V1459) (cons (quote and) (cons (car V1459) (cons (kl:shen.embed-and (cdr V1459)) (quote ()))))) (#t (kl:shen.f_error (quote shen.embed-and))))) (quote shen.embed-and))
(begin (register-function-arity (quote shen.err-condition) 1) (define (kl:shen.err-condition V1461) (cons #t (cons (cons (quote shen.f_error) (cons V1461 (quote ()))) (quote ())))) (quote shen.err-condition))
(begin (register-function-arity (quote shen.sys-error) 1) (define (kl:shen.sys-error V1463) (simple-error (string-append "system function " (kl:shen.app V1463 ": unexpected argument\n" (quote shen.a))))) (quote shen.sys-error))
