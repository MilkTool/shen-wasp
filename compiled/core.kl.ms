"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen.shen->kl) 2) (define (kl:shen.shen->kl V1362 V1363) (kl:compile (lambda (X) (kl:shen.<define> X)) (cons V1362 V1363) (lambda (X) (kl:shen.shen-syntax-error V1362 X)))) (quote shen.shen->kl))
(begin (register-function-arity (quote shen.shen-syntax-error) 2) (define (kl:shen.shen-syntax-error V1370 V1371) (cond ((pair? V1371) (simple-error (string-append "syntax error in " (kl:shen.app V1370 (string-append " here:\n\n " (kl:shen.app (kl:shen.next-50 50 (car V1371)) "\n" (quote shen.a))) (quote shen.a))))) (#t (simple-error (string-append "syntax error in " (kl:shen.app V1370 "\n" (quote shen.a))))))) (quote shen.shen-syntax-error))
(begin (register-function-arity (quote shen.<define>) 1) (define (kl:shen.<define> V1373) (let ((YaccParse (let ((Parse_shen.<name> (kl:shen.<name> V1373))) (if (kl:not (kl:= (kl:fail) Parse_shen.<name>)) (let ((Parse_shen.<signature> (kl:shen.<signature> Parse_shen.<name>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature>)) (let ((Parse_shen.<rules> (kl:shen.<rules> Parse_shen.<signature>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rules>)) (kl:shen.pair (car Parse_shen.<rules>) (kl:shen.compile_to_machine_code (kl:shen.hdtl Parse_shen.<name>) (kl:shen.hdtl Parse_shen.<rules>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<name> (kl:shen.<name> V1373))) (if (kl:not (kl:= (kl:fail) Parse_shen.<name>)) (let ((Parse_shen.<rules> (kl:shen.<rules> Parse_shen.<name>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rules>)) (kl:shen.pair (car Parse_shen.<rules>) (kl:shen.compile_to_machine_code (kl:shen.hdtl Parse_shen.<name>) (kl:shen.hdtl Parse_shen.<rules>))) (kl:fail))) (kl:fail))) YaccParse))) (quote shen.<define>))
(begin (register-function-arity (quote shen.<name>) 1) (define (kl:shen.<name> V1375) (if (pair? (car V1375)) (let ((Parse_X (car (car V1375)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1375)) (kl:shen.hdtl V1375))) (if (and (kl:symbol? Parse_X) (kl:not (kl:shen.sysfunc? Parse_X))) Parse_X (simple-error (kl:shen.app Parse_X " is not a legitimate function name.\n" (quote shen.a)))))) (kl:fail))) (quote shen.<name>))
(begin (register-function-arity (quote shen.sysfunc?) 1) (define (kl:shen.sysfunc? V1377) (kl:element? V1377 (kl:get (kl:intern "shen") (quote shen.external-symbols) (kl:value (quote *property-vector*))))) (quote shen.sysfunc?))
(begin (register-function-arity (quote shen.<signature>) 1) (define (kl:shen.<signature> V1379) (if (and (pair? (car V1379)) (eq? (quote {) (car (car V1379)))) (let ((Parse_shen.<signature-help> (kl:shen.<signature-help> (kl:shen.pair (cdr (car V1379)) (kl:shen.hdtl V1379))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature-help>)) (if (and (pair? (car Parse_shen.<signature-help>)) (eq? (quote }) (car (car Parse_shen.<signature-help>)))) (kl:shen.pair (car (kl:shen.pair (cdr (car Parse_shen.<signature-help>)) (kl:shen.hdtl Parse_shen.<signature-help>))) (kl:shen.demodulate (kl:shen.curry-type (kl:shen.hdtl Parse_shen.<signature-help>)))) (kl:fail)) (kl:fail))) (kl:fail))) (quote shen.<signature>))
(begin (register-function-arity (quote shen.curry-type) 1) (define (kl:shen.curry-type V1381) (cond ((and (pair? V1381) (and (pair? (cdr V1381)) (and (eq? (quote -->) (car (cdr V1381))) (and (pair? (cdr (cdr V1381))) (and (pair? (cdr (cdr (cdr V1381)))) (eq? (quote -->) (car (cdr (cdr (cdr V1381)))))))))) (kl:shen.curry-type (cons (car V1381) (cons (quote -->) (cons (cdr (cdr V1381)) (quote ())))))) ((and (pair? V1381) (and (pair? (cdr V1381)) (and (eq? (quote *) (car (cdr V1381))) (and (pair? (cdr (cdr V1381))) (and (pair? (cdr (cdr (cdr V1381)))) (eq? (quote *) (car (cdr (cdr (cdr V1381)))))))))) (kl:shen.curry-type (cons (car V1381) (cons (quote *) (cons (cdr (cdr V1381)) (quote ())))))) ((pair? V1381) (kl:map (lambda (Z) (kl:shen.curry-type Z)) V1381)) (#t V1381))) (quote shen.curry-type))
(begin (register-function-arity (quote shen.<signature-help>) 1) (define (kl:shen.<signature-help> V1383) (let ((YaccParse (if (pair? (car V1383)) (let ((Parse_X (car (car V1383)))) (let ((Parse_shen.<signature-help> (kl:shen.<signature-help> (kl:shen.pair (cdr (car V1383)) (kl:shen.hdtl V1383))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature-help>)) (if (kl:not (kl:element? Parse_X (cons (quote {) (cons (quote }) (quote ()))))) (kl:shen.pair (car Parse_shen.<signature-help>) (cons Parse_X (kl:shen.hdtl Parse_shen.<signature-help>))) (kl:fail)) (kl:fail)))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1383))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<signature-help>))
(begin (register-function-arity (quote shen.<rules>) 1) (define (kl:shen.<rules> V1385) (let ((YaccParse (let ((Parse_shen.<rule> (kl:shen.<rule> V1385))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (let ((Parse_shen.<rules> (kl:shen.<rules> Parse_shen.<rule>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rules>)) (kl:shen.pair (car Parse_shen.<rules>) (cons (kl:shen.linearise (kl:shen.hdtl Parse_shen.<rule>)) (kl:shen.hdtl Parse_shen.<rules>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<rule> (kl:shen.<rule> V1385))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (kl:shen.pair (car Parse_shen.<rule>) (cons (kl:shen.linearise (kl:shen.hdtl Parse_shen.<rule>)) (quote ()))) (kl:fail))) YaccParse))) (quote shen.<rules>))
(begin (register-function-arity (quote shen.<rule>) 1) (define (kl:shen.<rule> V1387) (let ((YaccParse (let ((Parse_shen.<patterns> (kl:shen.<patterns> V1387))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote ->) (car (car Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> (kl:shen.pair (cdr (car Parse_shen.<patterns>)) (kl:shen.hdtl Parse_shen.<patterns>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (if (and (pair? (car Parse_shen.<action>)) (eq? (quote where) (car (car Parse_shen.<action>)))) (let ((Parse_shen.<guard> (kl:shen.<guard> (kl:shen.pair (cdr (car Parse_shen.<action>)) (kl:shen.hdtl Parse_shen.<action>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<guard>)) (kl:shen.pair (car Parse_shen.<guard>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (cons (quote where) (cons (kl:shen.hdtl Parse_shen.<guard>) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ())))) (quote ())))) (kl:fail))) (kl:fail)) (kl:fail))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<patterns> (kl:shen.<patterns> V1387))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote ->) (car (car Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> (kl:shen.pair (cdr (car Parse_shen.<patterns>)) (kl:shen.hdtl Parse_shen.<patterns>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (kl:shen.pair (car Parse_shen.<action>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ())))) (kl:fail))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<patterns> (kl:shen.<patterns> V1387))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote <-) (car (car Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> (kl:shen.pair (cdr (car Parse_shen.<patterns>)) (kl:shen.hdtl Parse_shen.<patterns>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (if (and (pair? (car Parse_shen.<action>)) (eq? (quote where) (car (car Parse_shen.<action>)))) (let ((Parse_shen.<guard> (kl:shen.<guard> (kl:shen.pair (cdr (car Parse_shen.<action>)) (kl:shen.hdtl Parse_shen.<action>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<guard>)) (kl:shen.pair (car Parse_shen.<guard>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (cons (quote where) (cons (kl:shen.hdtl Parse_shen.<guard>) (cons (cons (quote shen.choicepoint!) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ()))) (quote ())))) (quote ())))) (kl:fail))) (kl:fail)) (kl:fail))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<patterns> (kl:shen.<patterns> V1387))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote <-) (car (car Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> (kl:shen.pair (cdr (car Parse_shen.<patterns>)) (kl:shen.hdtl Parse_shen.<patterns>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (kl:shen.pair (car Parse_shen.<action>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (cons (quote shen.choicepoint!) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ()))) (quote ())))) (kl:fail))) (kl:fail)) (kl:fail))) YaccParse)) YaccParse)) YaccParse))) (quote shen.<rule>))
(begin (register-function-arity (quote shen.fail_if) 2) (define (kl:shen.fail_if V1390 V1391) (if (assert-boolean (V1390 V1391)) (kl:fail) V1391)) (quote shen.fail_if))
(begin (register-function-arity (quote shen.succeeds?) 1) (define (kl:shen.succeeds? V1397) (cond ((kl:= V1397 (kl:fail)) #f) (#t #t))) (quote shen.succeeds?))
(begin (register-function-arity (quote shen.<patterns>) 1) (define (kl:shen.<patterns> V1399) (let ((YaccParse (let ((Parse_shen.<pattern> (kl:shen.<pattern> V1399))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern>)) (let ((Parse_shen.<patterns> (kl:shen.<patterns> Parse_shen.<pattern>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (kl:shen.pair (car Parse_shen.<patterns>) (cons (kl:shen.hdtl Parse_shen.<pattern>) (kl:shen.hdtl Parse_shen.<patterns>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1399))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<patterns>))
(begin (register-function-arity (quote shen.<pattern>) 1) (define (kl:shen.<pattern> V1406) (let ((YaccParse (if (and (pair? (car V1406)) (pair? (car (car V1406)))) (if (and (pair? (car (kl:shen.pair (car (car V1406)) (car (cdr V1406))))) (eq? (quote _waspvm_at_p) (car (car (kl:shen.pair (car (car V1406)) (car (cdr V1406))))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> (kl:shen.pair (cdr (car (kl:shen.pair (car (car V1406)) (car (cdr V1406))))) (kl:shen.hdtl (kl:shen.pair (car (car V1406)) (car (cdr V1406)))))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (cdr (car V1406)) (car (cdr V1406)))) (cons (quote _waspvm_at_p) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V1406)) (pair? (car (car V1406)))) (if (and (pair? (car (kl:shen.pair (car (car V1406)) (car (cdr V1406))))) (eq? (quote cons) (car (car (kl:shen.pair (car (car V1406)) (car (cdr V1406))))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> (kl:shen.pair (cdr (car (kl:shen.pair (car (car V1406)) (car (cdr V1406))))) (kl:shen.hdtl (kl:shen.pair (car (car V1406)) (car (cdr V1406)))))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (cdr (car V1406)) (car (cdr V1406)))) (cons (quote cons) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V1406)) (pair? (car (car V1406)))) (if (and (pair? (car (kl:shen.pair (car (car V1406)) (car (cdr V1406))))) (eq? (quote _waspvm_at_v) (car (car (kl:shen.pair (car (car V1406)) (car (cdr V1406))))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> (kl:shen.pair (cdr (car (kl:shen.pair (car (car V1406)) (car (cdr V1406))))) (kl:shen.hdtl (kl:shen.pair (car (car V1406)) (car (cdr V1406)))))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (cdr (car V1406)) (car (cdr V1406)))) (cons (quote _waspvm_at_v) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V1406)) (pair? (car (car V1406)))) (if (and (pair? (car (kl:shen.pair (car (car V1406)) (car (cdr V1406))))) (eq? (quote _waspvm_at_s) (car (car (kl:shen.pair (car (car V1406)) (car (cdr V1406))))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> (kl:shen.pair (cdr (car (kl:shen.pair (car (car V1406)) (car (cdr V1406))))) (kl:shen.hdtl (kl:shen.pair (car (car V1406)) (car (cdr V1406)))))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (cdr (car V1406)) (car (cdr V1406)))) (cons (quote _waspvm_at_s) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V1406)) (pair? (car (car V1406)))) (if (and (pair? (car (kl:shen.pair (car (car V1406)) (car (cdr V1406))))) (eq? (quote vector) (car (car (kl:shen.pair (car (car V1406)) (car (cdr V1406))))))) (if (and (pair? (car (kl:shen.pair (cdr (car (kl:shen.pair (car (car V1406)) (car (cdr V1406))))) (kl:shen.hdtl (kl:shen.pair (car (car V1406)) (car (cdr V1406))))))) (kl:= 0 (car (car (kl:shen.pair (cdr (car (kl:shen.pair (car (car V1406)) (car (cdr V1406))))) (kl:shen.hdtl (kl:shen.pair (car (car V1406)) (car (cdr V1406))))))))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1406)) (car (cdr V1406)))) (cons (quote vector) (cons 0 (quote ())))) (kl:fail)) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (pair? (car V1406)) (let ((Parse_X (car (car V1406)))) (if (pair? Parse_X) (kl:shen.pair (car (kl:shen.pair (cdr (car V1406)) (kl:shen.hdtl V1406))) (kl:shen.constructor-error Parse_X)) (kl:fail))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<simple_pattern> (kl:shen.<simple_pattern> V1406))) (if (kl:not (kl:= (kl:fail) Parse_shen.<simple_pattern>)) (kl:shen.pair (car Parse_shen.<simple_pattern>) (kl:shen.hdtl Parse_shen.<simple_pattern>)) (kl:fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse))) (quote shen.<pattern>))
(begin (register-function-arity (quote shen.constructor-error) 1) (define (kl:shen.constructor-error V1408) (simple-error (kl:shen.app V1408 " is not a legitimate constructor\n" (quote shen.a)))) (quote shen.constructor-error))
(begin (register-function-arity (quote shen.<simple_pattern>) 1) (define (kl:shen.<simple_pattern> V1410) (let ((YaccParse (if (pair? (car V1410)) (let ((Parse_X (car (car V1410)))) (if (eq? Parse_X (quote _)) (kl:shen.pair (car (kl:shen.pair (cdr (car V1410)) (kl:shen.hdtl V1410))) (kl:gensym (quote Parse_Y))) (kl:fail))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (if (pair? (car V1410)) (let ((Parse_X (car (car V1410)))) (if (kl:not (kl:element? Parse_X (cons (quote ->) (cons (quote <-) (quote ()))))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1410)) (kl:shen.hdtl V1410))) Parse_X) (kl:fail))) (kl:fail)) YaccParse))) (quote shen.<simple_pattern>))
(begin (register-function-arity (quote shen.<pattern1>) 1) (define (kl:shen.<pattern1> V1412) (let ((Parse_shen.<pattern> (kl:shen.<pattern> V1412))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern>)) (kl:shen.pair (car Parse_shen.<pattern>) (kl:shen.hdtl Parse_shen.<pattern>)) (kl:fail)))) (quote shen.<pattern1>))
(begin (register-function-arity (quote shen.<pattern2>) 1) (define (kl:shen.<pattern2> V1414) (let ((Parse_shen.<pattern> (kl:shen.<pattern> V1414))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern>)) (kl:shen.pair (car Parse_shen.<pattern>) (kl:shen.hdtl Parse_shen.<pattern>)) (kl:fail)))) (quote shen.<pattern2>))
(begin (register-function-arity (quote shen.<action>) 1) (define (kl:shen.<action> V1416) (if (pair? (car V1416)) (let ((Parse_X (car (car V1416)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1416)) (kl:shen.hdtl V1416))) Parse_X)) (kl:fail))) (quote shen.<action>))
(begin (register-function-arity (quote shen.<guard>) 1) (define (kl:shen.<guard> V1418) (if (pair? (car V1418)) (let ((Parse_X (car (car V1418)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1418)) (kl:shen.hdtl V1418))) Parse_X)) (kl:fail))) (quote shen.<guard>))
(begin (register-function-arity (quote shen.compile_to_machine_code) 2) (define (kl:shen.compile_to_machine_code V1421 V1422) (let ((Lambda+ (kl:shen.compile_to_lambda+ V1421 V1422))) (let ((KL (kl:shen.compile_to_kl V1421 Lambda+))) (let ((Record (kl:shen.record-source V1421 KL))) KL)))) (quote shen.compile_to_machine_code))
(begin (register-function-arity (quote shen.record-source) 2) (define (kl:shen.record-source V1427 V1428) (cond ((assert-boolean (kl:value (quote shen.*installing-kl*))) (quote shen.skip)) (#t (kl:put V1427 (quote shen.source) V1428 (kl:value (quote *property-vector*)))))) (quote shen.record-source))
(begin (register-function-arity (quote shen.compile_to_lambda+) 2) (define (kl:shen.compile_to_lambda+ V1431 V1432) (let ((Arity (kl:shen.aritycheck V1431 V1432))) (let ((UpDateSymbolTable (kl:shen.update-symbol-table V1431 Arity))) (let ((Free (kl:for-each (lambda (Rule) (kl:shen.free_variable_check V1431 Rule)) V1432))) (let ((Variables (kl:shen.parameters Arity))) (let ((Strip (kl:map (lambda (X) (kl:shen.strip-protect X)) V1432))) (let ((Abstractions (kl:map (lambda (X) (kl:shen.abstract_rule X)) Strip))) (let ((Applications (kl:map (lambda (X) (kl:shen.application_build Variables X)) Abstractions))) (cons Variables (cons Applications (quote ()))))))))))) (quote shen.compile_to_lambda+))
(begin (register-function-arity (quote shen.update-symbol-table) 2) (define (kl:shen.update-symbol-table V1435 V1436) (cond ((kl:= 0 V1436) (quote shen.skip)) (#t (kl:put V1435 (quote shen.lambda-form) (kl:eval-kl (kl:shen.lambda-form V1435 V1436)) (kl:value (quote *property-vector*)))))) (quote shen.update-symbol-table))
(begin (register-function-arity (quote shen.free_variable_check) 2) (define (kl:shen.free_variable_check V1439 V1440) (cond ((and (pair? V1440) (and (pair? (cdr V1440)) (null? (cdr (cdr V1440))))) (let ((Bound (kl:shen.extract_vars (car V1440)))) (let ((Free (kl:shen.extract_free_vars Bound (car (cdr V1440))))) (kl:shen.free_variable_warnings V1439 Free)))) (#t (kl:shen.f_error (quote shen.free_variable_check))))) (quote shen.free_variable_check))
(begin (register-function-arity (quote shen.extract_vars) 1) (define (kl:shen.extract_vars V1442) (cond ((kl:variable? V1442) (cons V1442 (quote ()))) ((pair? V1442) (kl:union (kl:shen.extract_vars (car V1442)) (kl:shen.extract_vars (cdr V1442)))) (#t (quote ())))) (quote shen.extract_vars))
(begin (register-function-arity (quote shen.extract_free_vars) 2) (define (kl:shen.extract_free_vars V1454 V1455) (cond ((and (pair? V1455) (and (pair? (cdr V1455)) (and (null? (cdr (cdr V1455))) (eq? (car V1455) (quote protect))))) (quote ())) ((and (kl:variable? V1455) (kl:not (kl:element? V1455 V1454))) (cons V1455 (quote ()))) ((and (pair? V1455) (and (eq? (quote lambda) (car V1455)) (and (pair? (cdr V1455)) (and (pair? (cdr (cdr V1455))) (null? (cdr (cdr (cdr V1455)))))))) (kl:shen.extract_free_vars (cons (car (cdr V1455)) V1454) (car (cdr (cdr V1455))))) ((and (pair? V1455) (and (eq? (quote let) (car V1455)) (and (pair? (cdr V1455)) (and (pair? (cdr (cdr V1455))) (and (pair? (cdr (cdr (cdr V1455)))) (null? (cdr (cdr (cdr (cdr V1455)))))))))) (kl:union (kl:shen.extract_free_vars V1454 (car (cdr (cdr V1455)))) (kl:shen.extract_free_vars (cons (car (cdr V1455)) V1454) (car (cdr (cdr (cdr V1455))))))) ((pair? V1455) (kl:union (kl:shen.extract_free_vars V1454 (car V1455)) (kl:shen.extract_free_vars V1454 (cdr V1455)))) (#t (quote ())))) (quote shen.extract_free_vars))
(begin (register-function-arity (quote shen.free_variable_warnings) 2) (define (kl:shen.free_variable_warnings V1460 V1461) (cond ((null? V1461) (quote _)) (#t (simple-error (string-append "error: the following variables are free in " (kl:shen.app V1460 (string-append ": " (kl:shen.app (kl:shen.list_variables V1461) "" (quote shen.a))) (quote shen.a))))))) (quote shen.free_variable_warnings))
(begin (register-function-arity (quote shen.list_variables) 1) (define (kl:shen.list_variables V1463) (cond ((and (pair? V1463) (null? (cdr V1463))) (string-append (kl:str (car V1463)) ".")) ((pair? V1463) (string-append (kl:str (car V1463)) (string-append ", " (kl:shen.list_variables (cdr V1463))))) (#t (kl:shen.f_error (quote shen.list_variables))))) (quote shen.list_variables))
(begin (register-function-arity (quote shen.strip-protect) 1) (define (kl:shen.strip-protect V1465) (cond ((and (pair? V1465) (and (pair? (cdr V1465)) (and (null? (cdr (cdr V1465))) (eq? (car V1465) (quote protect))))) (kl:shen.strip-protect (car (cdr V1465)))) ((pair? V1465) (kl:map (lambda (Z) (kl:shen.strip-protect Z)) V1465)) (#t V1465))) (quote shen.strip-protect))
(begin (register-function-arity (quote shen.linearise) 1) (define (kl:shen.linearise V1467) (cond ((and (pair? V1467) (and (pair? (cdr V1467)) (null? (cdr (cdr V1467))))) (kl:shen.linearise_help (kl:shen.flatten (car V1467)) (car V1467) (car (cdr V1467)))) (#t (kl:shen.f_error (quote shen.linearise))))) (quote shen.linearise))
(begin (register-function-arity (quote shen.flatten) 1) (define (kl:shen.flatten V1469) (cond ((null? V1469) (quote ())) ((pair? V1469) (kl:append (kl:shen.flatten (car V1469)) (kl:shen.flatten (cdr V1469)))) (#t (cons V1469 (quote ()))))) (quote shen.flatten))
(begin (register-function-arity (quote shen.linearise_help) 3) (define (kl:shen.linearise_help V1473 V1474 V1475) (cond ((null? V1473) (cons V1474 (cons V1475 (quote ())))) ((pair? V1473) (if (and (kl:variable? (car V1473)) (kl:element? (car V1473) (cdr V1473))) (let ((Var (kl:gensym (car V1473)))) (let ((NewAction (cons (quote where) (cons (cons (quote =) (cons (car V1473) (cons Var (quote ())))) (cons V1475 (quote ())))))) (let ((NewPatts (kl:shen.linearise_X (car V1473) Var V1474))) (kl:shen.linearise_help (cdr V1473) NewPatts NewAction)))) (kl:shen.linearise_help (cdr V1473) V1474 V1475))) (#t (kl:shen.f_error (quote shen.linearise_help))))) (quote shen.linearise_help))
(begin (register-function-arity (quote shen.linearise_X) 3) (define (kl:shen.linearise_X V1488 V1489 V1490) (cond ((kl:= V1490 V1488) V1489) ((pair? V1490) (let ((L (kl:shen.linearise_X V1488 V1489 (car V1490)))) (if (kl:= L (car V1490)) (cons (car V1490) (kl:shen.linearise_X V1488 V1489 (cdr V1490))) (cons L (cdr V1490))))) (#t V1490))) (quote shen.linearise_X))
(begin (register-function-arity (quote shen.aritycheck) 2) (define (kl:shen.aritycheck V1493 V1494) (cond ((and (pair? V1494) (and (pair? (car V1494)) (and (pair? (cdr (car V1494))) (and (null? (cdr (cdr (car V1494)))) (null? (cdr V1494)))))) (begin (kl:shen.aritycheck-action (car (cdr (car V1494)))) (kl:shen.aritycheck-name V1493 (kl:arity V1493) (kl:length (car (car V1494)))))) ((and (pair? V1494) (and (pair? (car V1494)) (and (pair? (cdr (car V1494))) (and (null? (cdr (cdr (car V1494)))) (and (pair? (cdr V1494)) (and (pair? (car (cdr V1494))) (and (pair? (cdr (car (cdr V1494)))) (null? (cdr (cdr (car (cdr V1494)))))))))))) (if (kl:= (kl:length (car (car V1494))) (kl:length (car (car (cdr V1494))))) (begin (kl:shen.aritycheck-action (car (cdr (car V1494)))) (kl:shen.aritycheck V1493 (cdr V1494))) (simple-error (string-append "arity error in " (kl:shen.app V1493 "\n" (quote shen.a)))))) (#t (kl:shen.f_error (quote shen.aritycheck))))) (quote shen.aritycheck))
(begin (register-function-arity (quote shen.aritycheck-name) 3) (define (kl:shen.aritycheck-name V1507 V1508 V1509) (cond ((kl:= -1 V1508) V1509) ((kl:= V1509 V1508) V1509) (#t (begin (kl:shen.prhush (string-append "\nwarning: changing the arity of " (kl:shen.app V1507 " can cause errors.\n" (quote shen.a))) (kl:stoutput)) V1509)))) (quote shen.aritycheck-name))
(begin (register-function-arity (quote shen.aritycheck-action) 1) (define (kl:shen.aritycheck-action V1515) (cond ((pair? V1515) (begin (kl:shen.aah (car V1515) (cdr V1515)) (kl:for-each (lambda (Y) (kl:shen.aritycheck-action Y)) V1515))) (#t (quote shen.skip)))) (quote shen.aritycheck-action))
(begin (register-function-arity (quote shen.aah) 2) (define (kl:shen.aah V1518 V1519) (let ((Arity (kl:arity V1518))) (let ((Len (kl:length V1519))) (if (and (> Arity -1) (> Len Arity)) (kl:shen.prhush (string-append "warning: " (kl:shen.app V1518 (string-append " might not like " (kl:shen.app Len (string-append " argument" (kl:shen.app (if (> Len 1) "s" "") ".\n" (quote shen.a))) (quote shen.a))) (quote shen.a))) (kl:stoutput)) (quote shen.skip))))) (quote shen.aah))
(begin (register-function-arity (quote shen.abstract_rule) 1) (define (kl:shen.abstract_rule V1521) (cond ((and (pair? V1521) (and (pair? (cdr V1521)) (null? (cdr (cdr V1521))))) (kl:shen.abstraction_build (car V1521) (car (cdr V1521)))) (#t (kl:shen.f_error (quote shen.abstract_rule))))) (quote shen.abstract_rule))
(begin (register-function-arity (quote shen.abstraction_build) 2) (define (kl:shen.abstraction_build V1524 V1525) (cond ((null? V1524) V1525) ((pair? V1524) (cons (quote /.) (cons (car V1524) (cons (kl:shen.abstraction_build (cdr V1524) V1525) (quote ()))))) (#t (kl:shen.f_error (quote shen.abstraction_build))))) (quote shen.abstraction_build))
(begin (register-function-arity (quote shen.parameters) 1) (define (kl:shen.parameters V1527) (cond ((kl:= 0 V1527) (quote ())) (#t (cons (kl:gensym (quote V)) (kl:shen.parameters (- V1527 1)))))) (quote shen.parameters))
(begin (register-function-arity (quote shen.application_build) 2) (define (kl:shen.application_build V1530 V1531) (cond ((null? V1530) V1531) ((pair? V1530) (kl:shen.application_build (cdr V1530) (cons V1531 (cons (car V1530) (quote ()))))) (#t (kl:shen.f_error (quote shen.application_build))))) (quote shen.application_build))
(begin (register-function-arity (quote shen.compile_to_kl) 2) (define (kl:shen.compile_to_kl V1534 V1535) (cond ((and (pair? V1535) (and (pair? (cdr V1535)) (null? (cdr (cdr V1535))))) (let ((Arity (kl:shen.store-arity V1534 (kl:length (car V1535))))) (let ((Reduce (kl:map (lambda (X) (kl:shen.reduce X)) (car (cdr V1535))))) (let ((CondExpression (kl:shen.cond-expression V1534 (car V1535) Reduce))) (let ((TypeTable (if (assert-boolean (kl:value (quote shen.*optimise*))) (kl:shen.typextable (kl:shen.get-type V1534) (car V1535)) (quote shen.skip)))) (let ((TypedCondExpression (if (assert-boolean (kl:value (quote shen.*optimise*))) (kl:shen.assign-types (car V1535) TypeTable CondExpression) CondExpression))) (cons (quote defun) (cons V1534 (cons (car V1535) (cons TypedCondExpression (quote ()))))))))))) (#t (kl:shen.f_error (quote shen.compile_to_kl))))) (quote shen.compile_to_kl))
(begin (register-function-arity (quote shen.get-type) 1) (define (kl:shen.get-type V1541) (cond ((pair? V1541) (quote shen.skip)) (#t (let ((FType (kl:assoc V1541 (kl:value (quote shen.*signedfuncs*))))) (if (kl:empty? FType) (quote shen.skip) (cdr FType)))))) (quote shen.get-type))
(begin (register-function-arity (quote shen.typextable) 2) (define (kl:shen.typextable V1552 V1553) (cond ((and (pair? V1552) (and (pair? (cdr V1552)) (and (eq? (quote -->) (car (cdr V1552))) (and (pair? (cdr (cdr V1552))) (and (null? (cdr (cdr (cdr V1552)))) (pair? V1553)))))) (if (kl:variable? (car V1552)) (kl:shen.typextable (car (cdr (cdr V1552))) (cdr V1553)) (cons (cons (car V1553) (car V1552)) (kl:shen.typextable (car (cdr (cdr V1552))) (cdr V1553))))) (#t (quote ())))) (quote shen.typextable))
(begin (register-function-arity (quote shen.assign-types) 3) (define (kl:shen.assign-types V1557 V1558 V1559) (cond ((and (pair? V1559) (and (eq? (quote let) (car V1559)) (and (pair? (cdr V1559)) (and (pair? (cdr (cdr V1559))) (and (pair? (cdr (cdr (cdr V1559)))) (null? (cdr (cdr (cdr (cdr V1559)))))))))) (cons (quote let) (cons (car (cdr V1559)) (cons (kl:shen.assign-types V1557 V1558 (car (cdr (cdr V1559)))) (cons (kl:shen.assign-types (cons (car (cdr V1559)) V1557) V1558 (car (cdr (cdr (cdr V1559))))) (quote ())))))) ((and (pair? V1559) (and (eq? (quote lambda) (car V1559)) (and (pair? (cdr V1559)) (and (pair? (cdr (cdr V1559))) (null? (cdr (cdr (cdr V1559)))))))) (cons (quote lambda) (cons (car (cdr V1559)) (cons (kl:shen.assign-types (cons (car (cdr V1559)) V1557) V1558 (car (cdr (cdr V1559)))) (quote ()))))) ((and (pair? V1559) (eq? (quote cond) (car V1559))) (cons (quote cond) (kl:map (lambda (Y) (cons (kl:shen.assign-types V1557 V1558 (car Y)) (cons (kl:shen.assign-types V1557 V1558 (car (cdr Y))) (quote ())))) (cdr V1559)))) ((pair? V1559) (let ((NewTable (kl:shen.typextable (kl:shen.get-type (car V1559)) (cdr V1559)))) (cons (car V1559) (kl:map (lambda (Y) (kl:shen.assign-types V1557 (kl:append V1558 NewTable) Y)) (cdr V1559))))) (#t (let ((AtomType (kl:assoc V1559 V1558))) (if (pair? AtomType) (cons (quote type) (cons V1559 (cons (cdr AtomType) (quote ())))) (if (kl:element? V1559 V1557) V1559 (kl:shen.atom-type V1559))))))) (quote shen.assign-types))
(begin (register-function-arity (quote shen.atom-type) 1) (define (kl:shen.atom-type V1561) (if (string? V1561) (cons (quote type) (cons V1561 (cons (quote string) (quote ())))) (if (number? V1561) (cons (quote type) (cons V1561 (cons (quote number) (quote ())))) (if (kl:boolean? V1561) (cons (quote type) (cons V1561 (cons (quote boolean) (quote ())))) (if (kl:symbol? V1561) (cons (quote type) (cons V1561 (cons (quote symbol) (quote ())))) V1561))))) (quote shen.atom-type))
(begin (register-function-arity (quote shen.store-arity) 2) (define (kl:shen.store-arity V1566 V1567) (cond ((assert-boolean (kl:value (quote shen.*installing-kl*))) (quote shen.skip)) (#t (kl:put V1566 (quote arity) V1567 (kl:value (quote *property-vector*)))))) (quote shen.store-arity))
(begin (register-function-arity (quote shen.reduce) 1) (define (kl:shen.reduce V1569) (begin (kl:set (quote shen.*teststack*) (quote ())) (let ((Result (kl:shen.reduce_help V1569))) (cons (cons (quote :) (cons (quote shen.tests) (kl:reverse (kl:value (quote shen.*teststack*))))) (cons Result (quote ())))))) (quote shen.reduce))
(begin (register-function-arity (quote shen.reduce_help) 1) (define (kl:shen.reduce_help V1571) (cond ((and (pair? V1571) (and (pair? (car V1571)) (and (eq? (quote /.) (car (car V1571))) (and (pair? (cdr (car V1571))) (and (pair? (car (cdr (car V1571)))) (and (eq? (quote cons) (car (car (cdr (car V1571))))) (and (pair? (cdr (car (cdr (car V1571))))) (and (pair? (cdr (cdr (car (cdr (car V1571)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1571))))))) (and (pair? (cdr (cdr (car V1571)))) (and (null? (cdr (cdr (cdr (car V1571))))) (and (pair? (cdr V1571)) (null? (cdr (cdr V1571))))))))))))))) (begin (kl:shen.add_test (cons (quote cons?) (cdr V1571))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V1571))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V1571)))))) (cons (kl:shen.ebr (car (cdr V1571)) (car (cdr (car V1571))) (car (cdr (cdr (car V1571))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote hd) (cdr V1571)) (quote ()))) (cons (cons (quote tl) (cdr V1571)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V1571) (and (pair? (car V1571)) (and (eq? (quote /.) (car (car V1571))) (and (pair? (cdr (car V1571))) (and (pair? (car (cdr (car V1571)))) (and (eq? (quote _waspvm_at_p) (car (car (cdr (car V1571))))) (and (pair? (cdr (car (cdr (car V1571))))) (and (pair? (cdr (cdr (car (cdr (car V1571)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1571))))))) (and (pair? (cdr (cdr (car V1571)))) (and (null? (cdr (cdr (cdr (car V1571))))) (and (pair? (cdr V1571)) (null? (cdr (cdr V1571))))))))))))))) (begin (kl:shen.add_test (cons (quote tuple?) (cdr V1571))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V1571))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V1571)))))) (cons (kl:shen.ebr (car (cdr V1571)) (car (cdr (car V1571))) (car (cdr (cdr (car V1571))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote fst) (cdr V1571)) (quote ()))) (cons (cons (quote snd) (cdr V1571)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V1571) (and (pair? (car V1571)) (and (eq? (quote /.) (car (car V1571))) (and (pair? (cdr (car V1571))) (and (pair? (car (cdr (car V1571)))) (and (eq? (quote _waspvm_at_v) (car (car (cdr (car V1571))))) (and (pair? (cdr (car (cdr (car V1571))))) (and (pair? (cdr (cdr (car (cdr (car V1571)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1571))))))) (and (pair? (cdr (cdr (car V1571)))) (and (null? (cdr (cdr (cdr (car V1571))))) (and (pair? (cdr V1571)) (null? (cdr (cdr V1571))))))))))))))) (begin (kl:shen.add_test (cons (quote shen.+vector?) (cdr V1571))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V1571))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V1571)))))) (cons (kl:shen.ebr (car (cdr V1571)) (car (cdr (car V1571))) (car (cdr (cdr (car V1571))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote hdv) (cdr V1571)) (quote ()))) (cons (cons (quote tlv) (cdr V1571)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V1571) (and (pair? (car V1571)) (and (eq? (quote /.) (car (car V1571))) (and (pair? (cdr (car V1571))) (and (pair? (car (cdr (car V1571)))) (and (eq? (quote _waspvm_at_s) (car (car (cdr (car V1571))))) (and (pair? (cdr (car (cdr (car V1571))))) (and (pair? (cdr (cdr (car (cdr (car V1571)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1571))))))) (and (pair? (cdr (cdr (car V1571)))) (and (null? (cdr (cdr (cdr (car V1571))))) (and (pair? (cdr V1571)) (null? (cdr (cdr V1571))))))))))))))) (begin (kl:shen.add_test (cons (quote shen.+string?) (cdr V1571))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V1571))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V1571)))))) (cons (kl:shen.ebr (car (cdr V1571)) (car (cdr (car V1571))) (car (cdr (cdr (car V1571))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote pos) (cons (car (cdr V1571)) (cons 0 (quote ())))) (quote ()))) (cons (cons (quote tlstr) (cdr V1571)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V1571) (and (pair? (car V1571)) (and (eq? (quote /.) (car (car V1571))) (and (pair? (cdr (car V1571))) (and (pair? (cdr (cdr (car V1571)))) (and (null? (cdr (cdr (cdr (car V1571))))) (and (pair? (cdr V1571)) (and (null? (cdr (cdr V1571))) (kl:not (kl:variable? (car (cdr (car V1571))))))))))))) (begin (kl:shen.add_test (cons (quote =) (cons (car (cdr (car V1571))) (cdr V1571)))) (kl:shen.reduce_help (car (cdr (cdr (car V1571))))))) ((and (pair? V1571) (and (pair? (car V1571)) (and (eq? (quote /.) (car (car V1571))) (and (pair? (cdr (car V1571))) (and (pair? (cdr (cdr (car V1571)))) (and (null? (cdr (cdr (cdr (car V1571))))) (and (pair? (cdr V1571)) (null? (cdr (cdr V1571)))))))))) (kl:shen.reduce_help (kl:shen.ebr (car (cdr V1571)) (car (cdr (car V1571))) (car (cdr (cdr (car V1571))))))) ((and (pair? V1571) (and (eq? (quote where) (car V1571)) (and (pair? (cdr V1571)) (and (pair? (cdr (cdr V1571))) (null? (cdr (cdr (cdr V1571)))))))) (begin (kl:shen.add_test (car (cdr V1571))) (kl:shen.reduce_help (car (cdr (cdr V1571)))))) ((and (pair? V1571) (and (pair? (cdr V1571)) (null? (cdr (cdr V1571))))) (let ((Z (kl:shen.reduce_help (car V1571)))) (if (kl:= (car V1571) Z) V1571 (kl:shen.reduce_help (cons Z (cdr V1571)))))) (#t V1571))) (quote shen.reduce_help))
(begin (register-function-arity (quote shen.+string?) 1) (define (kl:shen.+string? V1573) (cond ((equal? "" V1573) #f) (#t (string? V1573)))) (quote shen.+string?))
(begin (register-function-arity (quote shen.+vector?) 1) (define (kl:shen.+vector? V1575) (and (vector? V1575) (> (vector-ref V1575 0) 0))) (quote shen.+vector?))
(begin (register-function-arity (quote shen.ebr) 3) (define (kl:shen.ebr V1589 V1590 V1591) (cond ((kl:= V1591 V1590) V1589) ((and (pair? V1591) (and (eq? (quote /.) (car V1591)) (and (pair? (cdr V1591)) (and (pair? (cdr (cdr V1591))) (and (null? (cdr (cdr (cdr V1591)))) (> (kl:occurrences V1590 (car (cdr V1591))) 0)))))) V1591) ((and (pair? V1591) (and (eq? (quote lambda) (car V1591)) (and (pair? (cdr V1591)) (and (pair? (cdr (cdr V1591))) (and (null? (cdr (cdr (cdr V1591)))) (> (kl:occurrences V1590 (car (cdr V1591))) 0)))))) V1591) ((and (pair? V1591) (and (eq? (quote let) (car V1591)) (and (pair? (cdr V1591)) (and (pair? (cdr (cdr V1591))) (and (pair? (cdr (cdr (cdr V1591)))) (and (null? (cdr (cdr (cdr (cdr V1591))))) (kl:= (car (cdr V1591)) V1590))))))) (cons (quote let) (cons (car (cdr V1591)) (cons (kl:shen.ebr V1589 (car (cdr V1591)) (car (cdr (cdr V1591)))) (cdr (cdr (cdr V1591))))))) ((pair? V1591) (cons (kl:shen.ebr V1589 V1590 (car V1591)) (kl:shen.ebr V1589 V1590 (cdr V1591)))) (#t V1591))) (quote shen.ebr))
(begin (register-function-arity (quote shen.add_test) 1) (define (kl:shen.add_test V1593) (kl:set (quote shen.*teststack*) (cons V1593 (kl:value (quote shen.*teststack*))))) (quote shen.add_test))
(begin (register-function-arity (quote shen.cond-expression) 3) (define (kl:shen.cond-expression V1597 V1598 V1599) (let ((Err (kl:shen.err-condition V1597))) (let ((Cases (kl:shen.case-form V1599 Err))) (let ((EncodeChoices (kl:shen.encode-choices Cases V1597))) (kl:shen.cond-form EncodeChoices))))) (quote shen.cond-expression))
(begin (register-function-arity (quote shen.cond-form) 1) (define (kl:shen.cond-form V1603) (cond ((and (pair? V1603) (and (pair? (car V1603)) (and (kl:= #t (car (car V1603))) (and (pair? (cdr (car V1603))) (null? (cdr (cdr (car V1603)))))))) (car (cdr (car V1603)))) (#t (cons (quote cond) V1603)))) (quote shen.cond-form))
(begin (register-function-arity (quote shen.encode-choices) 2) (define (kl:shen.encode-choices V1608 V1609) (cond ((null? V1608) (quote ())) ((and (pair? V1608) (and (pair? (car V1608)) (and (kl:= #t (car (car V1608))) (and (pair? (cdr (car V1608))) (and (pair? (car (cdr (car V1608)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V1608))))) (and (pair? (cdr (car (cdr (car V1608))))) (and (null? (cdr (cdr (car (cdr (car V1608)))))) (and (null? (cdr (cdr (car V1608)))) (null? (cdr V1608))))))))))) (cons (cons #t (cons (cons (quote let) (cons (quote Result) (cons (car (cdr (car (cdr (car V1608))))) (cons (cons (quote if) (cons (cons (quote =) (cons (quote Result) (cons (cons (quote fail) (quote ())) (quote ())))) (cons (if (assert-boolean (kl:value (quote shen.*installing-kl*))) (cons (quote shen.sys-error) (cons V1609 (quote ()))) (cons (quote shen.f_error) (cons V1609 (quote ())))) (cons (quote Result) (quote ()))))) (quote ()))))) (quote ()))) (quote ()))) ((and (pair? V1608) (and (pair? (car V1608)) (and (kl:= #t (car (car V1608))) (and (pair? (cdr (car V1608))) (and (pair? (car (cdr (car V1608)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V1608))))) (and (pair? (cdr (car (cdr (car V1608))))) (and (null? (cdr (cdr (car (cdr (car V1608)))))) (null? (cdr (cdr (car V1608)))))))))))) (cons (cons #t (cons (cons (quote let) (cons (quote Result) (cons (car (cdr (car (cdr (car V1608))))) (cons (cons (quote if) (cons (cons (quote =) (cons (quote Result) (cons (cons (quote fail) (quote ())) (quote ())))) (cons (kl:shen.cond-form (kl:shen.encode-choices (cdr V1608) V1609)) (cons (quote Result) (quote ()))))) (quote ()))))) (quote ()))) (quote ()))) ((and (pair? V1608) (and (pair? (car V1608)) (and (pair? (cdr (car V1608))) (and (pair? (car (cdr (car V1608)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V1608))))) (and (pair? (cdr (car (cdr (car V1608))))) (and (null? (cdr (cdr (car (cdr (car V1608)))))) (null? (cdr (cdr (car V1608))))))))))) (cons (cons #t (cons (cons (quote let) (cons (quote Freeze) (cons (cons (quote freeze) (cons (kl:shen.cond-form (kl:shen.encode-choices (cdr V1608) V1609)) (quote ()))) (cons (cons (quote if) (cons (car (car V1608)) (cons (cons (quote let) (cons (quote Result) (cons (car (cdr (car (cdr (car V1608))))) (cons (cons (quote if) (cons (cons (quote =) (cons (quote Result) (cons (cons (quote fail) (quote ())) (quote ())))) (cons (cons (quote thaw) (cons (quote Freeze) (quote ()))) (cons (quote Result) (quote ()))))) (quote ()))))) (cons (cons (quote thaw) (cons (quote Freeze) (quote ()))) (quote ()))))) (quote ()))))) (quote ()))) (quote ()))) ((and (pair? V1608) (and (pair? (car V1608)) (and (pair? (cdr (car V1608))) (null? (cdr (cdr (car V1608))))))) (cons (car V1608) (kl:shen.encode-choices (cdr V1608) V1609))) (#t (kl:shen.f_error (quote shen.encode-choices))))) (quote shen.encode-choices))
(begin (register-function-arity (quote shen.case-form) 2) (define (kl:shen.case-form V1616 V1617) (cond ((null? V1616) (cons V1617 (quote ()))) ((and (pair? V1616) (and (pair? (car V1616)) (and (pair? (car (car V1616))) (and (eq? (quote :) (car (car (car V1616)))) (and (pair? (cdr (car (car V1616)))) (and (eq? (quote shen.tests) (car (cdr (car (car V1616))))) (and (null? (cdr (cdr (car (car V1616))))) (and (pair? (cdr (car V1616))) (and (pair? (car (cdr (car V1616)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V1616))))) (and (pair? (cdr (car (cdr (car V1616))))) (and (null? (cdr (cdr (car (cdr (car V1616)))))) (null? (cdr (cdr (car V1616)))))))))))))))) (cons (cons #t (cdr (car V1616))) (kl:shen.case-form (cdr V1616) V1617))) ((and (pair? V1616) (and (pair? (car V1616)) (and (pair? (car (car V1616))) (and (eq? (quote :) (car (car (car V1616)))) (and (pair? (cdr (car (car V1616)))) (and (eq? (quote shen.tests) (car (cdr (car (car V1616))))) (and (null? (cdr (cdr (car (car V1616))))) (and (pair? (cdr (car V1616))) (null? (cdr (cdr (car V1616)))))))))))) (cons (cons #t (cdr (car V1616))) (quote ()))) ((and (pair? V1616) (and (pair? (car V1616)) (and (pair? (car (car V1616))) (and (eq? (quote :) (car (car (car V1616)))) (and (pair? (cdr (car (car V1616)))) (and (eq? (quote shen.tests) (car (cdr (car (car V1616))))) (and (pair? (cdr (car V1616))) (null? (cdr (cdr (car V1616))))))))))) (cons (cons (kl:shen.embed-and (cdr (cdr (car (car V1616))))) (cdr (car V1616))) (kl:shen.case-form (cdr V1616) V1617))) (#t (kl:shen.f_error (quote shen.case-form))))) (quote shen.case-form))
(begin (register-function-arity (quote shen.embed-and) 1) (define (kl:shen.embed-and V1619) (cond ((and (pair? V1619) (null? (cdr V1619))) (car V1619)) ((pair? V1619) (cons (quote and) (cons (car V1619) (cons (kl:shen.embed-and (cdr V1619)) (quote ()))))) (#t (kl:shen.f_error (quote shen.embed-and))))) (quote shen.embed-and))
(begin (register-function-arity (quote shen.err-condition) 1) (define (kl:shen.err-condition V1621) (cons #t (cons (cons (quote shen.f_error) (cons V1621 (quote ()))) (quote ())))) (quote shen.err-condition))
(begin (register-function-arity (quote shen.sys-error) 1) (define (kl:shen.sys-error V1623) (simple-error (string-append "system function " (kl:shen.app V1623 ": unexpected argument\n" (quote shen.a))))) (quote shen.sys-error))
