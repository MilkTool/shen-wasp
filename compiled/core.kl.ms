"Copyright (c) 2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of Mark Tarver may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
(begin (register-function-arity (quote shen->kl) 2) (define (kl:shen->kl V1193 V1194) (kl:compile (lambda (X) (kl:shen.<define> X)) (cons V1193 V1194) (lambda (X) (kl:shen-syntax-error V1193 X)))) (quote shen->kl))
(begin (register-function-arity (quote shen-syntax-error) 2) (define (kl:shen-syntax-error V1201 V1202) (cond ((pair? V1202) (simple-error (string-append "syntax error in " (kl:shen.app V1201 (string-append " here:\n\n " (kl:shen.app (kl:shen.next-50 50 (car V1202)) "\n" (quote shen.a))) (quote shen.a))))) (#t (simple-error (string-append "syntax error in " (kl:shen.app V1201 "\n" (quote shen.a))))))) (quote shen-syntax-error))
(begin (register-function-arity (quote shen.<define>) 1) (define (kl:shen.<define> V1204) (let ((YaccParse (let ((Parse_shen.<name> (kl:shen.<name> V1204))) (if (kl:not (kl:= (kl:fail) Parse_shen.<name>)) (let ((Parse_shen.<signature> (kl:shen.<signature> Parse_shen.<name>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature>)) (let ((Parse_shen.<rules> (kl:shen.<rules> Parse_shen.<signature>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rules>)) (kl:shen.pair (car Parse_shen.<rules>) (kl:shen.compile_to_machine_code (kl:shen.hdtl Parse_shen.<name>) (kl:shen.hdtl Parse_shen.<rules>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<name> (kl:shen.<name> V1204))) (if (kl:not (kl:= (kl:fail) Parse_shen.<name>)) (let ((Parse_shen.<rules> (kl:shen.<rules> Parse_shen.<name>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rules>)) (kl:shen.pair (car Parse_shen.<rules>) (kl:shen.compile_to_machine_code (kl:shen.hdtl Parse_shen.<name>) (kl:shen.hdtl Parse_shen.<rules>))) (kl:fail))) (kl:fail))) YaccParse))) (quote shen.<define>))
(begin (register-function-arity (quote shen.<name>) 1) (define (kl:shen.<name> V1206) (if (pair? (car V1206)) (let ((Parse_X (car (car V1206)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1206)) (kl:shen.hdtl V1206))) (if (and (kl:symbol? Parse_X) (kl:not (kl:shen.sysfunc? Parse_X))) Parse_X (simple-error (kl:shen.app Parse_X " is not a legitimate function name.\n" (quote shen.a)))))) (kl:fail))) (quote shen.<name>))
(begin (register-function-arity (quote shen.sysfunc?) 1) (define (kl:shen.sysfunc? V1208) (kl:element? V1208 (kl:get (kl:intern "shen") (quote shen.external-symbols) (kl:value (quote *property-vector*))))) (quote shen.sysfunc?))
(begin (register-function-arity (quote shen.<signature>) 1) (define (kl:shen.<signature> V1210) (if (and (pair? (car V1210)) (eq? (quote {) (car (car V1210)))) (let ((Parse_shen.<signature-help> (kl:shen.<signature-help> (kl:shen.pair (cdr (car V1210)) (kl:shen.hdtl V1210))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature-help>)) (if (and (pair? (car Parse_shen.<signature-help>)) (eq? (quote }) (car (car Parse_shen.<signature-help>)))) (kl:shen.pair (car (kl:shen.pair (cdr (car Parse_shen.<signature-help>)) (kl:shen.hdtl Parse_shen.<signature-help>))) (kl:shen.demodulate (kl:shen.curry-type (kl:shen.hdtl Parse_shen.<signature-help>)))) (kl:fail)) (kl:fail))) (kl:fail))) (quote shen.<signature>))
(begin (register-function-arity (quote shen.curry-type) 1) (define (kl:shen.curry-type V1212) (cond ((and (pair? V1212) (and (pair? (cdr V1212)) (and (eq? (quote -->) (car (cdr V1212))) (and (pair? (cdr (cdr V1212))) (and (pair? (cdr (cdr (cdr V1212)))) (eq? (quote -->) (car (cdr (cdr (cdr V1212)))))))))) (kl:shen.curry-type (cons (car V1212) (cons (quote -->) (cons (cdr (cdr V1212)) (quote ())))))) ((and (pair? V1212) (and (pair? (cdr V1212)) (and (eq? (quote *) (car (cdr V1212))) (and (pair? (cdr (cdr V1212))) (and (pair? (cdr (cdr (cdr V1212)))) (eq? (quote *) (car (cdr (cdr (cdr V1212)))))))))) (kl:shen.curry-type (cons (car V1212) (cons (quote *) (cons (cdr (cdr V1212)) (quote ())))))) ((pair? V1212) (kl:map (lambda (Z) (kl:shen.curry-type Z)) V1212)) (#t V1212))) (quote shen.curry-type))
(begin (register-function-arity (quote shen.<signature-help>) 1) (define (kl:shen.<signature-help> V1214) (let ((YaccParse (if (pair? (car V1214)) (let ((Parse_X (car (car V1214)))) (let ((Parse_shen.<signature-help> (kl:shen.<signature-help> (kl:shen.pair (cdr (car V1214)) (kl:shen.hdtl V1214))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature-help>)) (if (kl:not (kl:element? Parse_X (cons (quote {) (cons (quote }) (quote ()))))) (kl:shen.pair (car Parse_shen.<signature-help>) (cons Parse_X (kl:shen.hdtl Parse_shen.<signature-help>))) (kl:fail)) (kl:fail)))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1214))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<signature-help>))
(begin (register-function-arity (quote shen.<rules>) 1) (define (kl:shen.<rules> V1216) (let ((YaccParse (let ((Parse_shen.<rule> (kl:shen.<rule> V1216))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (let ((Parse_shen.<rules> (kl:shen.<rules> Parse_shen.<rule>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rules>)) (kl:shen.pair (car Parse_shen.<rules>) (cons (kl:shen.linearise (kl:shen.hdtl Parse_shen.<rule>)) (kl:shen.hdtl Parse_shen.<rules>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<rule> (kl:shen.<rule> V1216))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (kl:shen.pair (car Parse_shen.<rule>) (cons (kl:shen.linearise (kl:shen.hdtl Parse_shen.<rule>)) (quote ()))) (kl:fail))) YaccParse))) (quote shen.<rules>))
(begin (register-function-arity (quote shen.<rule>) 1) (define (kl:shen.<rule> V1218) (let ((YaccParse (let ((Parse_shen.<patterns> (kl:shen.<patterns> V1218))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote ->) (car (car Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> (kl:shen.pair (cdr (car Parse_shen.<patterns>)) (kl:shen.hdtl Parse_shen.<patterns>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (if (and (pair? (car Parse_shen.<action>)) (eq? (quote where) (car (car Parse_shen.<action>)))) (let ((Parse_shen.<guard> (kl:shen.<guard> (kl:shen.pair (cdr (car Parse_shen.<action>)) (kl:shen.hdtl Parse_shen.<action>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<guard>)) (kl:shen.pair (car Parse_shen.<guard>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (cons (quote where) (cons (kl:shen.hdtl Parse_shen.<guard>) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ())))) (quote ())))) (kl:fail))) (kl:fail)) (kl:fail))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<patterns> (kl:shen.<patterns> V1218))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote ->) (car (car Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> (kl:shen.pair (cdr (car Parse_shen.<patterns>)) (kl:shen.hdtl Parse_shen.<patterns>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (kl:shen.pair (car Parse_shen.<action>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ())))) (kl:fail))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<patterns> (kl:shen.<patterns> V1218))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote <-) (car (car Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> (kl:shen.pair (cdr (car Parse_shen.<patterns>)) (kl:shen.hdtl Parse_shen.<patterns>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (if (and (pair? (car Parse_shen.<action>)) (eq? (quote where) (car (car Parse_shen.<action>)))) (let ((Parse_shen.<guard> (kl:shen.<guard> (kl:shen.pair (cdr (car Parse_shen.<action>)) (kl:shen.hdtl Parse_shen.<action>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<guard>)) (kl:shen.pair (car Parse_shen.<guard>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (cons (quote where) (cons (kl:shen.hdtl Parse_shen.<guard>) (cons (cons (quote shen.choicepoint!) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ()))) (quote ())))) (quote ())))) (kl:fail))) (kl:fail)) (kl:fail))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<patterns> (kl:shen.<patterns> V1218))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote <-) (car (car Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> (kl:shen.pair (cdr (car Parse_shen.<patterns>)) (kl:shen.hdtl Parse_shen.<patterns>))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (kl:shen.pair (car Parse_shen.<action>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (cons (quote shen.choicepoint!) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ()))) (quote ())))) (kl:fail))) (kl:fail)) (kl:fail))) YaccParse)) YaccParse)) YaccParse))) (quote shen.<rule>))
(begin (register-function-arity (quote shen.fail_if) 2) (define (kl:shen.fail_if V1221 V1222) (if (assert-boolean (V1221 V1222)) (kl:fail) V1222)) (quote shen.fail_if))
(begin (register-function-arity (quote shen.succeeds?) 1) (define (kl:shen.succeeds? V1228) (cond ((kl:= V1228 (kl:fail)) #f) (#t #t))) (quote shen.succeeds?))
(begin (register-function-arity (quote shen.<patterns>) 1) (define (kl:shen.<patterns> V1230) (let ((YaccParse (let ((Parse_shen.<pattern> (kl:shen.<pattern> V1230))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern>)) (let ((Parse_shen.<patterns> (kl:shen.<patterns> Parse_shen.<pattern>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (kl:shen.pair (car Parse_shen.<patterns>) (cons (kl:shen.hdtl Parse_shen.<pattern>) (kl:shen.hdtl Parse_shen.<patterns>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1230))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (quote shen.<patterns>))
(begin (register-function-arity (quote shen.<pattern>) 1) (define (kl:shen.<pattern> V1237) (let ((YaccParse (if (and (pair? (car V1237)) (pair? (car (car V1237)))) (if (and (pair? (car (kl:shen.pair (car (car V1237)) (car (cdr V1237))))) (eq? (quote _waspvm_at_p) (car (car (kl:shen.pair (car (car V1237)) (car (cdr V1237))))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> (kl:shen.pair (cdr (car (kl:shen.pair (car (car V1237)) (car (cdr V1237))))) (kl:shen.hdtl (kl:shen.pair (car (car V1237)) (car (cdr V1237)))))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (cdr (car V1237)) (car (cdr V1237)))) (cons (quote _waspvm_at_p) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V1237)) (pair? (car (car V1237)))) (if (and (pair? (car (kl:shen.pair (car (car V1237)) (car (cdr V1237))))) (eq? (quote cons) (car (car (kl:shen.pair (car (car V1237)) (car (cdr V1237))))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> (kl:shen.pair (cdr (car (kl:shen.pair (car (car V1237)) (car (cdr V1237))))) (kl:shen.hdtl (kl:shen.pair (car (car V1237)) (car (cdr V1237)))))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (cdr (car V1237)) (car (cdr V1237)))) (cons (quote cons) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V1237)) (pair? (car (car V1237)))) (if (and (pair? (car (kl:shen.pair (car (car V1237)) (car (cdr V1237))))) (eq? (quote _waspvm_at_v) (car (car (kl:shen.pair (car (car V1237)) (car (cdr V1237))))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> (kl:shen.pair (cdr (car (kl:shen.pair (car (car V1237)) (car (cdr V1237))))) (kl:shen.hdtl (kl:shen.pair (car (car V1237)) (car (cdr V1237)))))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (cdr (car V1237)) (car (cdr V1237)))) (cons (quote _waspvm_at_v) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V1237)) (pair? (car (car V1237)))) (if (and (pair? (car (kl:shen.pair (car (car V1237)) (car (cdr V1237))))) (eq? (quote _waspvm_at_s) (car (car (kl:shen.pair (car (car V1237)) (car (cdr V1237))))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> (kl:shen.pair (cdr (car (kl:shen.pair (car (car V1237)) (car (cdr V1237))))) (kl:shen.hdtl (kl:shen.pair (car (car V1237)) (car (cdr V1237)))))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (cdr (car V1237)) (car (cdr V1237)))) (cons (quote _waspvm_at_s) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V1237)) (pair? (car (car V1237)))) (if (and (pair? (car (kl:shen.pair (car (car V1237)) (car (cdr V1237))))) (eq? (quote vector) (car (car (kl:shen.pair (car (car V1237)) (car (cdr V1237))))))) (if (and (pair? (car (kl:shen.pair (cdr (car (kl:shen.pair (car (car V1237)) (car (cdr V1237))))) (kl:shen.hdtl (kl:shen.pair (car (car V1237)) (car (cdr V1237))))))) (kl:= 0 (car (car (kl:shen.pair (cdr (car (kl:shen.pair (car (car V1237)) (car (cdr V1237))))) (kl:shen.hdtl (kl:shen.pair (car (car V1237)) (car (cdr V1237))))))))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1237)) (car (cdr V1237)))) (cons (quote vector) (cons 0 (quote ())))) (kl:fail)) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (pair? (car V1237)) (let ((Parse_X (car (car V1237)))) (if (pair? Parse_X) (kl:shen.pair (car (kl:shen.pair (cdr (car V1237)) (kl:shen.hdtl V1237))) (kl:shen.constructor-error Parse_X)) (kl:fail))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<simple_pattern> (kl:shen.<simple_pattern> V1237))) (if (kl:not (kl:= (kl:fail) Parse_shen.<simple_pattern>)) (kl:shen.pair (car Parse_shen.<simple_pattern>) (kl:shen.hdtl Parse_shen.<simple_pattern>)) (kl:fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse))) (quote shen.<pattern>))
(begin (register-function-arity (quote shen.constructor-error) 1) (define (kl:shen.constructor-error V1239) (simple-error (kl:shen.app V1239 " is not a legitimate constructor\n" (quote shen.a)))) (quote shen.constructor-error))
(begin (register-function-arity (quote shen.<simple_pattern>) 1) (define (kl:shen.<simple_pattern> V1241) (let ((YaccParse (if (pair? (car V1241)) (let ((Parse_X (car (car V1241)))) (if (eq? Parse_X (quote _)) (kl:shen.pair (car (kl:shen.pair (cdr (car V1241)) (kl:shen.hdtl V1241))) (kl:gensym (quote Parse_Y))) (kl:fail))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (if (pair? (car V1241)) (let ((Parse_X (car (car V1241)))) (if (kl:not (kl:element? Parse_X (cons (quote ->) (cons (quote <-) (quote ()))))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1241)) (kl:shen.hdtl V1241))) Parse_X) (kl:fail))) (kl:fail)) YaccParse))) (quote shen.<simple_pattern>))
(begin (register-function-arity (quote shen.<pattern1>) 1) (define (kl:shen.<pattern1> V1243) (let ((Parse_shen.<pattern> (kl:shen.<pattern> V1243))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern>)) (kl:shen.pair (car Parse_shen.<pattern>) (kl:shen.hdtl Parse_shen.<pattern>)) (kl:fail)))) (quote shen.<pattern1>))
(begin (register-function-arity (quote shen.<pattern2>) 1) (define (kl:shen.<pattern2> V1245) (let ((Parse_shen.<pattern> (kl:shen.<pattern> V1245))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern>)) (kl:shen.pair (car Parse_shen.<pattern>) (kl:shen.hdtl Parse_shen.<pattern>)) (kl:fail)))) (quote shen.<pattern2>))
(begin (register-function-arity (quote shen.<action>) 1) (define (kl:shen.<action> V1247) (if (pair? (car V1247)) (let ((Parse_X (car (car V1247)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1247)) (kl:shen.hdtl V1247))) Parse_X)) (kl:fail))) (quote shen.<action>))
(begin (register-function-arity (quote shen.<guard>) 1) (define (kl:shen.<guard> V1249) (if (pair? (car V1249)) (let ((Parse_X (car (car V1249)))) (kl:shen.pair (car (kl:shen.pair (cdr (car V1249)) (kl:shen.hdtl V1249))) Parse_X)) (kl:fail))) (quote shen.<guard>))
(begin (register-function-arity (quote shen.compile_to_machine_code) 2) (define (kl:shen.compile_to_machine_code V1252 V1253) (let ((Lambda+ (kl:shen.compile_to_lambda+ V1252 V1253))) (let ((KL (kl:shen.compile_to_kl V1252 Lambda+))) (let ((Record (kl:shen.record-source V1252 KL))) KL)))) (quote shen.compile_to_machine_code))
(begin (register-function-arity (quote shen.record-source) 2) (define (kl:shen.record-source V1258 V1259) (cond ((assert-boolean (kl:value (quote shen.*installing-kl*))) (quote shen.skip)) (#t (kl:put V1258 (quote shen.source) V1259 (kl:value (quote *property-vector*)))))) (quote shen.record-source))
(begin (register-function-arity (quote shen.compile_to_lambda+) 2) (define (kl:shen.compile_to_lambda+ V1262 V1263) (let ((Arity (kl:shen.aritycheck V1262 V1263))) (let ((UpDateSymbolTable (kl:shen.update-symbol-table V1262 Arity))) (let ((Free (kl:for-each (lambda (Rule) (kl:shen.free_variable_check V1262 Rule)) V1263))) (let ((Variables (kl:shen.parameters Arity))) (let ((Strip (kl:map (lambda (X) (kl:shen.strip-protect X)) V1263))) (let ((Abstractions (kl:map (lambda (X) (kl:shen.abstract_rule X)) Strip))) (let ((Applications (kl:map (lambda (X) (kl:shen.application_build Variables X)) Abstractions))) (cons Variables (cons Applications (quote ()))))))))))) (quote shen.compile_to_lambda+))
(begin (register-function-arity (quote shen.update-symbol-table) 2) (define (kl:shen.update-symbol-table V1266 V1267) (cond ((kl:= 0 V1267) (quote shen.skip)) (#t (kl:put V1266 (quote shen.lambda-form) (kl:eval-kl (kl:shen.lambda-form V1266 V1267)) (kl:value (quote *property-vector*)))))) (quote shen.update-symbol-table))
(begin (register-function-arity (quote shen.free_variable_check) 2) (define (kl:shen.free_variable_check V1270 V1271) (cond ((and (pair? V1271) (and (pair? (cdr V1271)) (null? (cdr (cdr V1271))))) (let ((Bound (kl:shen.extract_vars (car V1271)))) (let ((Free (kl:shen.extract_free_vars Bound (car (cdr V1271))))) (kl:shen.free_variable_warnings V1270 Free)))) (#t (kl:shen.f_error (quote shen.free_variable_check))))) (quote shen.free_variable_check))
(begin (register-function-arity (quote shen.extract_vars) 1) (define (kl:shen.extract_vars V1273) (cond ((kl:variable? V1273) (cons V1273 (quote ()))) ((pair? V1273) (kl:union (kl:shen.extract_vars (car V1273)) (kl:shen.extract_vars (cdr V1273)))) (#t (quote ())))) (quote shen.extract_vars))
(begin (register-function-arity (quote shen.extract_free_vars) 2) (define (kl:shen.extract_free_vars V1285 V1286) (cond ((and (pair? V1286) (and (pair? (cdr V1286)) (and (null? (cdr (cdr V1286))) (eq? (car V1286) (quote protect))))) (quote ())) ((and (kl:variable? V1286) (kl:not (kl:element? V1286 V1285))) (cons V1286 (quote ()))) ((and (pair? V1286) (and (eq? (quote lambda) (car V1286)) (and (pair? (cdr V1286)) (and (pair? (cdr (cdr V1286))) (null? (cdr (cdr (cdr V1286)))))))) (kl:shen.extract_free_vars (cons (car (cdr V1286)) V1285) (car (cdr (cdr V1286))))) ((and (pair? V1286) (and (eq? (quote let) (car V1286)) (and (pair? (cdr V1286)) (and (pair? (cdr (cdr V1286))) (and (pair? (cdr (cdr (cdr V1286)))) (null? (cdr (cdr (cdr (cdr V1286)))))))))) (kl:union (kl:shen.extract_free_vars V1285 (car (cdr (cdr V1286)))) (kl:shen.extract_free_vars (cons (car (cdr V1286)) V1285) (car (cdr (cdr (cdr V1286))))))) ((pair? V1286) (kl:union (kl:shen.extract_free_vars V1285 (car V1286)) (kl:shen.extract_free_vars V1285 (cdr V1286)))) (#t (quote ())))) (quote shen.extract_free_vars))
(begin (register-function-arity (quote shen.free_variable_warnings) 2) (define (kl:shen.free_variable_warnings V1291 V1292) (cond ((null? V1292) (quote _)) (#t (simple-error (string-append "error: the following variables are free in " (kl:shen.app V1291 (string-append ": " (kl:shen.app (kl:shen.list_variables V1292) "" (quote shen.a))) (quote shen.a))))))) (quote shen.free_variable_warnings))
(begin (register-function-arity (quote shen.list_variables) 1) (define (kl:shen.list_variables V1294) (cond ((and (pair? V1294) (null? (cdr V1294))) (string-append (kl:str (car V1294)) ".")) ((pair? V1294) (string-append (kl:str (car V1294)) (string-append ", " (kl:shen.list_variables (cdr V1294))))) (#t (kl:shen.f_error (quote shen.list_variables))))) (quote shen.list_variables))
(begin (register-function-arity (quote shen.strip-protect) 1) (define (kl:shen.strip-protect V1296) (cond ((and (pair? V1296) (and (pair? (cdr V1296)) (and (null? (cdr (cdr V1296))) (eq? (car V1296) (quote protect))))) (kl:shen.strip-protect (car (cdr V1296)))) ((pair? V1296) (kl:map (lambda (Z) (kl:shen.strip-protect Z)) V1296)) (#t V1296))) (quote shen.strip-protect))
(begin (register-function-arity (quote shen.linearise) 1) (define (kl:shen.linearise V1298) (cond ((and (pair? V1298) (and (pair? (cdr V1298)) (null? (cdr (cdr V1298))))) (kl:shen.linearise_help (kl:shen.flatten (car V1298)) (car V1298) (car (cdr V1298)))) (#t (kl:shen.f_error (quote shen.linearise))))) (quote shen.linearise))
(begin (register-function-arity (quote shen.flatten) 1) (define (kl:shen.flatten V1300) (cond ((null? V1300) (quote ())) ((pair? V1300) (kl:append (kl:shen.flatten (car V1300)) (kl:shen.flatten (cdr V1300)))) (#t (cons V1300 (quote ()))))) (quote shen.flatten))
(begin (register-function-arity (quote shen.linearise_help) 3) (define (kl:shen.linearise_help V1304 V1305 V1306) (cond ((null? V1304) (cons V1305 (cons V1306 (quote ())))) ((pair? V1304) (if (and (kl:variable? (car V1304)) (kl:element? (car V1304) (cdr V1304))) (let ((Var (kl:gensym (car V1304)))) (let ((NewAction (cons (quote where) (cons (cons (quote =) (cons (car V1304) (cons Var (quote ())))) (cons V1306 (quote ())))))) (let ((NewPatts (kl:shen.linearise_X (car V1304) Var V1305))) (kl:shen.linearise_help (cdr V1304) NewPatts NewAction)))) (kl:shen.linearise_help (cdr V1304) V1305 V1306))) (#t (kl:shen.f_error (quote shen.linearise_help))))) (quote shen.linearise_help))
(begin (register-function-arity (quote shen.linearise_X) 3) (define (kl:shen.linearise_X V1319 V1320 V1321) (cond ((kl:= V1321 V1319) V1320) ((pair? V1321) (let ((L (kl:shen.linearise_X V1319 V1320 (car V1321)))) (if (kl:= L (car V1321)) (cons (car V1321) (kl:shen.linearise_X V1319 V1320 (cdr V1321))) (cons L (cdr V1321))))) (#t V1321))) (quote shen.linearise_X))
(begin (register-function-arity (quote shen.aritycheck) 2) (define (kl:shen.aritycheck V1324 V1325) (cond ((and (pair? V1325) (and (pair? (car V1325)) (and (pair? (cdr (car V1325))) (and (null? (cdr (cdr (car V1325)))) (null? (cdr V1325)))))) (begin (kl:shen.aritycheck-action (car (cdr (car V1325)))) (kl:shen.aritycheck-name V1324 (kl:arity V1324) (kl:length (car (car V1325)))))) ((and (pair? V1325) (and (pair? (car V1325)) (and (pair? (cdr (car V1325))) (and (null? (cdr (cdr (car V1325)))) (and (pair? (cdr V1325)) (and (pair? (car (cdr V1325))) (and (pair? (cdr (car (cdr V1325)))) (null? (cdr (cdr (car (cdr V1325)))))))))))) (if (kl:= (kl:length (car (car V1325))) (kl:length (car (car (cdr V1325))))) (begin (kl:shen.aritycheck-action (car (cdr (car V1325)))) (kl:shen.aritycheck V1324 (cdr V1325))) (simple-error (string-append "arity error in " (kl:shen.app V1324 "\n" (quote shen.a)))))) (#t (kl:shen.f_error (quote shen.aritycheck))))) (quote shen.aritycheck))
(begin (register-function-arity (quote shen.aritycheck-name) 3) (define (kl:shen.aritycheck-name V1338 V1339 V1340) (cond ((kl:= -1 V1339) V1340) ((kl:= V1340 V1339) V1340) (#t (begin (kl:shen.prhush (string-append "\nwarning: changing the arity of " (kl:shen.app V1338 " can cause errors.\n" (quote shen.a))) (kl:stoutput)) V1340)))) (quote shen.aritycheck-name))
(begin (register-function-arity (quote shen.aritycheck-action) 1) (define (kl:shen.aritycheck-action V1346) (cond ((pair? V1346) (begin (kl:shen.aah (car V1346) (cdr V1346)) (kl:for-each (lambda (Y) (kl:shen.aritycheck-action Y)) V1346))) (#t (quote shen.skip)))) (quote shen.aritycheck-action))
(begin (register-function-arity (quote shen.aah) 2) (define (kl:shen.aah V1349 V1350) (let ((Arity (kl:arity V1349))) (let ((Len (kl:length V1350))) (if (and (> Arity -1) (> Len Arity)) (kl:shen.prhush (string-append "warning: " (kl:shen.app V1349 (string-append " might not like " (kl:shen.app Len (string-append " argument" (kl:shen.app (if (> Len 1) "s" "") ".\n" (quote shen.a))) (quote shen.a))) (quote shen.a))) (kl:stoutput)) (quote shen.skip))))) (quote shen.aah))
(begin (register-function-arity (quote shen.abstract_rule) 1) (define (kl:shen.abstract_rule V1352) (cond ((and (pair? V1352) (and (pair? (cdr V1352)) (null? (cdr (cdr V1352))))) (kl:shen.abstraction_build (car V1352) (car (cdr V1352)))) (#t (kl:shen.f_error (quote shen.abstract_rule))))) (quote shen.abstract_rule))
(begin (register-function-arity (quote shen.abstraction_build) 2) (define (kl:shen.abstraction_build V1355 V1356) (cond ((null? V1355) V1356) ((pair? V1355) (cons (quote /.) (cons (car V1355) (cons (kl:shen.abstraction_build (cdr V1355) V1356) (quote ()))))) (#t (kl:shen.f_error (quote shen.abstraction_build))))) (quote shen.abstraction_build))
(begin (register-function-arity (quote shen.parameters) 1) (define (kl:shen.parameters V1358) (cond ((kl:= 0 V1358) (quote ())) (#t (cons (kl:gensym (quote V)) (kl:shen.parameters (- V1358 1)))))) (quote shen.parameters))
(begin (register-function-arity (quote shen.application_build) 2) (define (kl:shen.application_build V1361 V1362) (cond ((null? V1361) V1362) ((pair? V1361) (kl:shen.application_build (cdr V1361) (cons V1362 (cons (car V1361) (quote ()))))) (#t (kl:shen.f_error (quote shen.application_build))))) (quote shen.application_build))
(begin (register-function-arity (quote shen.compile_to_kl) 2) (define (kl:shen.compile_to_kl V1365 V1366) (cond ((and (pair? V1366) (and (pair? (cdr V1366)) (null? (cdr (cdr V1366))))) (let ((Arity (kl:shen.store-arity V1365 (kl:length (car V1366))))) (let ((Reduce (kl:map (lambda (X) (kl:shen.reduce X)) (car (cdr V1366))))) (let ((CondExpression (kl:shen.cond-expression V1365 (car V1366) Reduce))) (let ((TypeTable (if (assert-boolean (kl:value (quote shen.*optimise*))) (kl:shen.typextable (kl:shen.get-type V1365) (car V1366)) (quote shen.skip)))) (let ((TypedCondExpression (if (assert-boolean (kl:value (quote shen.*optimise*))) (kl:shen.assign-types (car V1366) TypeTable CondExpression) CondExpression))) (cons (quote defun) (cons V1365 (cons (car V1366) (cons TypedCondExpression (quote ()))))))))))) (#t (kl:shen.f_error (quote shen.compile_to_kl))))) (quote shen.compile_to_kl))
(begin (register-function-arity (quote shen.get-type) 1) (define (kl:shen.get-type V1372) (cond ((pair? V1372) (quote shen.skip)) (#t (let ((FType (kl:assoc V1372 (kl:value (quote shen.*signedfuncs*))))) (if (kl:empty? FType) (quote shen.skip) (cdr FType)))))) (quote shen.get-type))
(begin (register-function-arity (quote shen.typextable) 2) (define (kl:shen.typextable V1383 V1384) (cond ((and (pair? V1383) (and (pair? (cdr V1383)) (and (eq? (quote -->) (car (cdr V1383))) (and (pair? (cdr (cdr V1383))) (and (null? (cdr (cdr (cdr V1383)))) (pair? V1384)))))) (if (kl:variable? (car V1383)) (kl:shen.typextable (car (cdr (cdr V1383))) (cdr V1384)) (cons (cons (car V1384) (car V1383)) (kl:shen.typextable (car (cdr (cdr V1383))) (cdr V1384))))) (#t (quote ())))) (quote shen.typextable))
(begin (register-function-arity (quote shen.assign-types) 3) (define (kl:shen.assign-types V1388 V1389 V1390) (cond ((and (pair? V1390) (and (eq? (quote let) (car V1390)) (and (pair? (cdr V1390)) (and (pair? (cdr (cdr V1390))) (and (pair? (cdr (cdr (cdr V1390)))) (null? (cdr (cdr (cdr (cdr V1390)))))))))) (cons (quote let) (cons (car (cdr V1390)) (cons (kl:shen.assign-types V1388 V1389 (car (cdr (cdr V1390)))) (cons (kl:shen.assign-types (cons (car (cdr V1390)) V1388) V1389 (car (cdr (cdr (cdr V1390))))) (quote ())))))) ((and (pair? V1390) (and (eq? (quote lambda) (car V1390)) (and (pair? (cdr V1390)) (and (pair? (cdr (cdr V1390))) (null? (cdr (cdr (cdr V1390)))))))) (cons (quote lambda) (cons (car (cdr V1390)) (cons (kl:shen.assign-types (cons (car (cdr V1390)) V1388) V1389 (car (cdr (cdr V1390)))) (quote ()))))) ((and (pair? V1390) (eq? (quote cond) (car V1390))) (cons (quote cond) (kl:map (lambda (Y) (cons (kl:shen.assign-types V1388 V1389 (car Y)) (cons (kl:shen.assign-types V1388 V1389 (car (cdr Y))) (quote ())))) (cdr V1390)))) ((pair? V1390) (let ((NewTable (kl:shen.typextable (kl:shen.get-type (car V1390)) (cdr V1390)))) (cons (car V1390) (kl:map (lambda (Y) (kl:shen.assign-types V1388 (kl:append V1389 NewTable) Y)) (cdr V1390))))) (#t (let ((AtomType (kl:assoc V1390 V1389))) (if (pair? AtomType) (cons (quote type) (cons V1390 (cons (cdr AtomType) (quote ())))) (if (kl:element? V1390 V1388) V1390 (kl:shen.atom-type V1390))))))) (quote shen.assign-types))
(begin (register-function-arity (quote shen.atom-type) 1) (define (kl:shen.atom-type V1392) (if (string? V1392) (cons (quote type) (cons V1392 (cons (quote string) (quote ())))) (if (number? V1392) (cons (quote type) (cons V1392 (cons (quote number) (quote ())))) (if (kl:boolean? V1392) (cons (quote type) (cons V1392 (cons (quote boolean) (quote ())))) (if (kl:symbol? V1392) (cons (quote type) (cons V1392 (cons (quote symbol) (quote ())))) V1392))))) (quote shen.atom-type))
(begin (register-function-arity (quote shen.store-arity) 2) (define (kl:shen.store-arity V1397 V1398) (cond ((assert-boolean (kl:value (quote shen.*installing-kl*))) (quote shen.skip)) (#t (kl:put V1397 (quote arity) V1398 (kl:value (quote *property-vector*)))))) (quote shen.store-arity))
(begin (register-function-arity (quote shen.reduce) 1) (define (kl:shen.reduce V1400) (begin (kl:set (quote shen.*teststack*) (quote ())) (let ((Result (kl:shen.reduce_help V1400))) (cons (cons (quote :) (cons (quote shen.tests) (kl:reverse (kl:value (quote shen.*teststack*))))) (cons Result (quote ())))))) (quote shen.reduce))
(begin (register-function-arity (quote shen.reduce_help) 1) (define (kl:shen.reduce_help V1402) (cond ((and (pair? V1402) (and (pair? (car V1402)) (and (eq? (quote /.) (car (car V1402))) (and (pair? (cdr (car V1402))) (and (pair? (car (cdr (car V1402)))) (and (eq? (quote cons) (car (car (cdr (car V1402))))) (and (pair? (cdr (car (cdr (car V1402))))) (and (pair? (cdr (cdr (car (cdr (car V1402)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1402))))))) (and (pair? (cdr (cdr (car V1402)))) (and (null? (cdr (cdr (cdr (car V1402))))) (and (pair? (cdr V1402)) (null? (cdr (cdr V1402))))))))))))))) (begin (kl:shen.add_test (cons (quote cons?) (cdr V1402))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V1402))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V1402)))))) (cons (kl:shen.ebr (car (cdr V1402)) (car (cdr (car V1402))) (car (cdr (cdr (car V1402))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote hd) (cdr V1402)) (quote ()))) (cons (cons (quote tl) (cdr V1402)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V1402) (and (pair? (car V1402)) (and (eq? (quote /.) (car (car V1402))) (and (pair? (cdr (car V1402))) (and (pair? (car (cdr (car V1402)))) (and (eq? (quote _waspvm_at_p) (car (car (cdr (car V1402))))) (and (pair? (cdr (car (cdr (car V1402))))) (and (pair? (cdr (cdr (car (cdr (car V1402)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1402))))))) (and (pair? (cdr (cdr (car V1402)))) (and (null? (cdr (cdr (cdr (car V1402))))) (and (pair? (cdr V1402)) (null? (cdr (cdr V1402))))))))))))))) (begin (kl:shen.add_test (cons (quote tuple?) (cdr V1402))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V1402))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V1402)))))) (cons (kl:shen.ebr (car (cdr V1402)) (car (cdr (car V1402))) (car (cdr (cdr (car V1402))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote fst) (cdr V1402)) (quote ()))) (cons (cons (quote snd) (cdr V1402)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V1402) (and (pair? (car V1402)) (and (eq? (quote /.) (car (car V1402))) (and (pair? (cdr (car V1402))) (and (pair? (car (cdr (car V1402)))) (and (eq? (quote _waspvm_at_v) (car (car (cdr (car V1402))))) (and (pair? (cdr (car (cdr (car V1402))))) (and (pair? (cdr (cdr (car (cdr (car V1402)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1402))))))) (and (pair? (cdr (cdr (car V1402)))) (and (null? (cdr (cdr (cdr (car V1402))))) (and (pair? (cdr V1402)) (null? (cdr (cdr V1402))))))))))))))) (begin (kl:shen.add_test (cons (quote shen.+vector?) (cdr V1402))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V1402))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V1402)))))) (cons (kl:shen.ebr (car (cdr V1402)) (car (cdr (car V1402))) (car (cdr (cdr (car V1402))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote hdv) (cdr V1402)) (quote ()))) (cons (cons (quote tlv) (cdr V1402)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V1402) (and (pair? (car V1402)) (and (eq? (quote /.) (car (car V1402))) (and (pair? (cdr (car V1402))) (and (pair? (car (cdr (car V1402)))) (and (eq? (quote _waspvm_at_s) (car (car (cdr (car V1402))))) (and (pair? (cdr (car (cdr (car V1402))))) (and (pair? (cdr (cdr (car (cdr (car V1402)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1402))))))) (and (pair? (cdr (cdr (car V1402)))) (and (null? (cdr (cdr (cdr (car V1402))))) (and (pair? (cdr V1402)) (null? (cdr (cdr V1402))))))))))))))) (begin (kl:shen.add_test (cons (quote shen.+string?) (cdr V1402))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V1402))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V1402)))))) (cons (kl:shen.ebr (car (cdr V1402)) (car (cdr (car V1402))) (car (cdr (cdr (car V1402))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote pos) (cons (car (cdr V1402)) (cons 0 (quote ())))) (quote ()))) (cons (cons (quote tlstr) (cdr V1402)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V1402) (and (pair? (car V1402)) (and (eq? (quote /.) (car (car V1402))) (and (pair? (cdr (car V1402))) (and (pair? (cdr (cdr (car V1402)))) (and (null? (cdr (cdr (cdr (car V1402))))) (and (pair? (cdr V1402)) (and (null? (cdr (cdr V1402))) (kl:not (kl:variable? (car (cdr (car V1402))))))))))))) (begin (kl:shen.add_test (cons (quote =) (cons (car (cdr (car V1402))) (cdr V1402)))) (kl:shen.reduce_help (car (cdr (cdr (car V1402))))))) ((and (pair? V1402) (and (pair? (car V1402)) (and (eq? (quote /.) (car (car V1402))) (and (pair? (cdr (car V1402))) (and (pair? (cdr (cdr (car V1402)))) (and (null? (cdr (cdr (cdr (car V1402))))) (and (pair? (cdr V1402)) (null? (cdr (cdr V1402)))))))))) (kl:shen.reduce_help (kl:shen.ebr (car (cdr V1402)) (car (cdr (car V1402))) (car (cdr (cdr (car V1402))))))) ((and (pair? V1402) (and (eq? (quote where) (car V1402)) (and (pair? (cdr V1402)) (and (pair? (cdr (cdr V1402))) (null? (cdr (cdr (cdr V1402)))))))) (begin (kl:shen.add_test (car (cdr V1402))) (kl:shen.reduce_help (car (cdr (cdr V1402)))))) ((and (pair? V1402) (and (pair? (cdr V1402)) (null? (cdr (cdr V1402))))) (let ((Z (kl:shen.reduce_help (car V1402)))) (if (kl:= (car V1402) Z) V1402 (kl:shen.reduce_help (cons Z (cdr V1402)))))) (#t V1402))) (quote shen.reduce_help))
(begin (register-function-arity (quote shen.+string?) 1) (define (kl:shen.+string? V1404) (cond ((equal? "" V1404) #f) (#t (string? V1404)))) (quote shen.+string?))
(begin (register-function-arity (quote shen.+vector?) 1) (define (kl:shen.+vector? V1406) (and (vector? V1406) (> (vector-ref V1406 0) 0))) (quote shen.+vector?))
(begin (register-function-arity (quote shen.ebr) 3) (define (kl:shen.ebr V1420 V1421 V1422) (cond ((kl:= V1422 V1421) V1420) ((and (pair? V1422) (and (eq? (quote /.) (car V1422)) (and (pair? (cdr V1422)) (and (pair? (cdr (cdr V1422))) (and (null? (cdr (cdr (cdr V1422)))) (> (kl:occurrences V1421 (car (cdr V1422))) 0)))))) V1422) ((and (pair? V1422) (and (eq? (quote lambda) (car V1422)) (and (pair? (cdr V1422)) (and (pair? (cdr (cdr V1422))) (and (null? (cdr (cdr (cdr V1422)))) (> (kl:occurrences V1421 (car (cdr V1422))) 0)))))) V1422) ((and (pair? V1422) (and (eq? (quote let) (car V1422)) (and (pair? (cdr V1422)) (and (pair? (cdr (cdr V1422))) (and (pair? (cdr (cdr (cdr V1422)))) (and (null? (cdr (cdr (cdr (cdr V1422))))) (kl:= (car (cdr V1422)) V1421))))))) (cons (quote let) (cons (car (cdr V1422)) (cons (kl:shen.ebr V1420 (car (cdr V1422)) (car (cdr (cdr V1422)))) (cdr (cdr (cdr V1422))))))) ((pair? V1422) (cons (kl:shen.ebr V1420 V1421 (car V1422)) (kl:shen.ebr V1420 V1421 (cdr V1422)))) (#t V1422))) (quote shen.ebr))
(begin (register-function-arity (quote shen.add_test) 1) (define (kl:shen.add_test V1424) (kl:set (quote shen.*teststack*) (cons V1424 (kl:value (quote shen.*teststack*))))) (quote shen.add_test))
(begin (register-function-arity (quote shen.cond-expression) 3) (define (kl:shen.cond-expression V1428 V1429 V1430) (let ((Err (kl:shen.err-condition V1428))) (let ((Cases (kl:shen.case-form V1430 Err))) (let ((EncodeChoices (kl:shen.encode-choices Cases V1428))) (kl:shen.cond-form EncodeChoices))))) (quote shen.cond-expression))
(begin (register-function-arity (quote shen.cond-form) 1) (define (kl:shen.cond-form V1434) (cond ((and (pair? V1434) (and (pair? (car V1434)) (and (kl:= #t (car (car V1434))) (and (pair? (cdr (car V1434))) (null? (cdr (cdr (car V1434)))))))) (car (cdr (car V1434)))) (#t (cons (quote cond) V1434)))) (quote shen.cond-form))
(begin (register-function-arity (quote shen.encode-choices) 2) (define (kl:shen.encode-choices V1439 V1440) (cond ((null? V1439) (quote ())) ((and (pair? V1439) (and (pair? (car V1439)) (and (kl:= #t (car (car V1439))) (and (pair? (cdr (car V1439))) (and (pair? (car (cdr (car V1439)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V1439))))) (and (pair? (cdr (car (cdr (car V1439))))) (and (null? (cdr (cdr (car (cdr (car V1439)))))) (and (null? (cdr (cdr (car V1439)))) (null? (cdr V1439))))))))))) (cons (cons #t (cons (cons (quote let) (cons (quote Result) (cons (car (cdr (car (cdr (car V1439))))) (cons (cons (quote if) (cons (cons (quote =) (cons (quote Result) (cons (cons (quote fail) (quote ())) (quote ())))) (cons (if (assert-boolean (kl:value (quote shen.*installing-kl*))) (cons (quote shen.sys-error) (cons V1440 (quote ()))) (cons (quote shen.f_error) (cons V1440 (quote ())))) (cons (quote Result) (quote ()))))) (quote ()))))) (quote ()))) (quote ()))) ((and (pair? V1439) (and (pair? (car V1439)) (and (kl:= #t (car (car V1439))) (and (pair? (cdr (car V1439))) (and (pair? (car (cdr (car V1439)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V1439))))) (and (pair? (cdr (car (cdr (car V1439))))) (and (null? (cdr (cdr (car (cdr (car V1439)))))) (null? (cdr (cdr (car V1439)))))))))))) (cons (cons #t (cons (cons (quote let) (cons (quote Result) (cons (car (cdr (car (cdr (car V1439))))) (cons (cons (quote if) (cons (cons (quote =) (cons (quote Result) (cons (cons (quote fail) (quote ())) (quote ())))) (cons (kl:shen.cond-form (kl:shen.encode-choices (cdr V1439) V1440)) (cons (quote Result) (quote ()))))) (quote ()))))) (quote ()))) (quote ()))) ((and (pair? V1439) (and (pair? (car V1439)) (and (pair? (cdr (car V1439))) (and (pair? (car (cdr (car V1439)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V1439))))) (and (pair? (cdr (car (cdr (car V1439))))) (and (null? (cdr (cdr (car (cdr (car V1439)))))) (null? (cdr (cdr (car V1439))))))))))) (cons (cons #t (cons (cons (quote let) (cons (quote Freeze) (cons (cons (quote freeze) (cons (kl:shen.cond-form (kl:shen.encode-choices (cdr V1439) V1440)) (quote ()))) (cons (cons (quote if) (cons (car (car V1439)) (cons (cons (quote let) (cons (quote Result) (cons (car (cdr (car (cdr (car V1439))))) (cons (cons (quote if) (cons (cons (quote =) (cons (quote Result) (cons (cons (quote fail) (quote ())) (quote ())))) (cons (cons (quote thaw) (cons (quote Freeze) (quote ()))) (cons (quote Result) (quote ()))))) (quote ()))))) (cons (cons (quote thaw) (cons (quote Freeze) (quote ()))) (quote ()))))) (quote ()))))) (quote ()))) (quote ()))) ((and (pair? V1439) (and (pair? (car V1439)) (and (pair? (cdr (car V1439))) (null? (cdr (cdr (car V1439))))))) (cons (car V1439) (kl:shen.encode-choices (cdr V1439) V1440))) (#t (kl:shen.f_error (quote shen.encode-choices))))) (quote shen.encode-choices))
(begin (register-function-arity (quote shen.case-form) 2) (define (kl:shen.case-form V1447 V1448) (cond ((null? V1447) (cons V1448 (quote ()))) ((and (pair? V1447) (and (pair? (car V1447)) (and (pair? (car (car V1447))) (and (eq? (quote :) (car (car (car V1447)))) (and (pair? (cdr (car (car V1447)))) (and (eq? (quote shen.tests) (car (cdr (car (car V1447))))) (and (null? (cdr (cdr (car (car V1447))))) (and (pair? (cdr (car V1447))) (and (pair? (car (cdr (car V1447)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V1447))))) (and (pair? (cdr (car (cdr (car V1447))))) (and (null? (cdr (cdr (car (cdr (car V1447)))))) (null? (cdr (cdr (car V1447)))))))))))))))) (cons (cons #t (cdr (car V1447))) (kl:shen.case-form (cdr V1447) V1448))) ((and (pair? V1447) (and (pair? (car V1447)) (and (pair? (car (car V1447))) (and (eq? (quote :) (car (car (car V1447)))) (and (pair? (cdr (car (car V1447)))) (and (eq? (quote shen.tests) (car (cdr (car (car V1447))))) (and (null? (cdr (cdr (car (car V1447))))) (and (pair? (cdr (car V1447))) (null? (cdr (cdr (car V1447)))))))))))) (cons (cons #t (cdr (car V1447))) (quote ()))) ((and (pair? V1447) (and (pair? (car V1447)) (and (pair? (car (car V1447))) (and (eq? (quote :) (car (car (car V1447)))) (and (pair? (cdr (car (car V1447)))) (and (eq? (quote shen.tests) (car (cdr (car (car V1447))))) (and (pair? (cdr (car V1447))) (null? (cdr (cdr (car V1447))))))))))) (cons (cons (kl:shen.embed-and (cdr (cdr (car (car V1447))))) (cdr (car V1447))) (kl:shen.case-form (cdr V1447) V1448))) (#t (kl:shen.f_error (quote shen.case-form))))) (quote shen.case-form))
(begin (register-function-arity (quote shen.embed-and) 1) (define (kl:shen.embed-and V1450) (cond ((and (pair? V1450) (null? (cdr V1450))) (car V1450)) ((pair? V1450) (cons (quote and) (cons (car V1450) (cons (kl:shen.embed-and (cdr V1450)) (quote ()))))) (#t (kl:shen.f_error (quote shen.embed-and))))) (quote shen.embed-and))
(begin (register-function-arity (quote shen.err-condition) 1) (define (kl:shen.err-condition V1452) (cons #t (cons (cons (quote shen.f_error) (cons V1452 (quote ()))) (quote ())))) (quote shen.err-condition))
(begin (register-function-arity (quote shen.sys-error) 1) (define (kl:shen.sys-error V1454) (simple-error (string-append "system function " (kl:shen.app V1454 ": unexpected argument\n" (quote shen.a))))) (quote shen.sys-error))
